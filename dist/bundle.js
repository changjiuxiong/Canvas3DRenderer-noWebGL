!function(t){var c={};function n(r){if(c[r])return c[r].exports;var g=c[r]={i:r,l:!1,exports:{}};return t[r].call(g.exports,g,g.exports,n),g.l=!0,g.exports}n.m=t,n.c=c,n.d=function(t,c,r){n.o(t,c)||Object.defineProperty(t,c,{enumerable:!0,get:r})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,c){if(1&c&&(t=n(t)),8&c)return t;if(4&c&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&c&&"string"!=typeof t)for(var g in t)n.d(r,g,function(c){return t[c]}.bind(null,g));return r},n.n=function(t){var c=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(c,"a",c),c},n.o=function(t,c){return Object.prototype.hasOwnProperty.call(t,c)},n.p="",n(n.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\nvar Curves_namespaceObject = {};\n__webpack_require__.r(Curves_namespaceObject);\n__webpack_require__.d(Curves_namespaceObject, \"ArcCurve\", function() { return ArcCurve; });\n__webpack_require__.d(Curves_namespaceObject, \"CatmullRomCurve3\", function() { return CatmullRomCurve3; });\n__webpack_require__.d(Curves_namespaceObject, \"CubicBezierCurve\", function() { return CubicBezierCurve; });\n__webpack_require__.d(Curves_namespaceObject, \"CubicBezierCurve3\", function() { return CubicBezierCurve3; });\n__webpack_require__.d(Curves_namespaceObject, \"EllipseCurve\", function() { return EllipseCurve; });\n__webpack_require__.d(Curves_namespaceObject, \"LineCurve\", function() { return LineCurve; });\n__webpack_require__.d(Curves_namespaceObject, \"LineCurve3\", function() { return LineCurve3; });\n__webpack_require__.d(Curves_namespaceObject, \"QuadraticBezierCurve\", function() { return QuadraticBezierCurve; });\n__webpack_require__.d(Curves_namespaceObject, \"QuadraticBezierCurve3\", function() { return QuadraticBezierCurve3; });\n__webpack_require__.d(Curves_namespaceObject, \"SplineCurve\", function() { return SplineCurve; });\n\n// CONCATENATED MODULE: ./src/math/Math.js\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nvar _Math = {\r\n\r\n\tDEG2RAD: Math.PI / 180,\r\n\tRAD2DEG: 180 / Math.PI,\r\n\r\n\tgenerateUUID: ( function () {\r\n\r\n\t\t// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\r\n\r\n\t\tvar lut = [];\r\n\r\n\t\tfor ( var i = 0; i < 256; i ++ ) {\r\n\r\n\t\t\tlut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );\r\n\r\n\t\t}\r\n\r\n\t\treturn function generateUUID() {\r\n\r\n\t\t\tvar d0 = Math.random() * 0xffffffff | 0;\r\n\t\t\tvar d1 = Math.random() * 0xffffffff | 0;\r\n\t\t\tvar d2 = Math.random() * 0xffffffff | 0;\r\n\t\t\tvar d3 = Math.random() * 0xffffffff | 0;\r\n\t\t\tvar uuid = lut[ d0 & 0xff ] + lut[ d0 >> 8 & 0xff ] + lut[ d0 >> 16 & 0xff ] + lut[ d0 >> 24 & 0xff ] + '-' +\r\n\t\t\t\tlut[ d1 & 0xff ] + lut[ d1 >> 8 & 0xff ] + '-' + lut[ d1 >> 16 & 0x0f | 0x40 ] + lut[ d1 >> 24 & 0xff ] + '-' +\r\n\t\t\t\tlut[ d2 & 0x3f | 0x80 ] + lut[ d2 >> 8 & 0xff ] + '-' + lut[ d2 >> 16 & 0xff ] + lut[ d2 >> 24 & 0xff ] +\r\n\t\t\t\tlut[ d3 & 0xff ] + lut[ d3 >> 8 & 0xff ] + lut[ d3 >> 16 & 0xff ] + lut[ d3 >> 24 & 0xff ];\r\n\r\n\t\t\t// .toUpperCase() here flattens concatenated strings to save heap memory space.\r\n\t\t\treturn uuid.toUpperCase();\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n\tclamp: function ( value, min, max ) {\r\n\r\n\t\treturn Math.max( min, Math.min( max, value ) );\r\n\r\n\t},\r\n\r\n\t// compute euclidian modulo of m % n\r\n\t// https://en.wikipedia.org/wiki/Modulo_operation\r\n\r\n\teuclideanModulo: function ( n, m ) {\r\n\r\n\t\treturn ( ( n % m ) + m ) % m;\r\n\r\n\t},\r\n\r\n\t// Linear mapping from range <a1, a2> to range <b1, b2>\r\n\r\n\tmapLinear: function ( x, a1, a2, b1, b2 ) {\r\n\r\n\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\r\n\r\n\t},\r\n\r\n\t// https://en.wikipedia.org/wiki/Linear_interpolation\r\n\r\n\tlerp: function ( x, y, t ) {\r\n\r\n\t\treturn ( 1 - t ) * x + t * y;\r\n\r\n\t},\r\n\r\n\t// http://en.wikipedia.org/wiki/Smoothstep\r\n\r\n\tsmoothstep: function ( x, min, max ) {\r\n\r\n\t\tif ( x <= min ) return 0;\r\n\t\tif ( x >= max ) return 1;\r\n\r\n\t\tx = ( x - min ) / ( max - min );\r\n\r\n\t\treturn x * x * ( 3 - 2 * x );\r\n\r\n\t},\r\n\r\n\tsmootherstep: function ( x, min, max ) {\r\n\r\n\t\tif ( x <= min ) return 0;\r\n\t\tif ( x >= max ) return 1;\r\n\r\n\t\tx = ( x - min ) / ( max - min );\r\n\r\n\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\r\n\r\n\t},\r\n\r\n\t// Random integer from <low, high> interval\r\n\r\n\trandInt: function ( low, high ) {\r\n\r\n\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\r\n\r\n\t},\r\n\r\n\t// Random float from <low, high> interval\r\n\r\n\trandFloat: function ( low, high ) {\r\n\r\n\t\treturn low + Math.random() * ( high - low );\r\n\r\n\t},\r\n\r\n\t// Random float from <-range/2, range/2> interval\r\n\r\n\trandFloatSpread: function ( range ) {\r\n\r\n\t\treturn range * ( 0.5 - Math.random() );\r\n\r\n\t},\r\n\r\n\tdegToRad: function ( degrees ) {\r\n\r\n\t\treturn degrees * _Math.DEG2RAD;\r\n\r\n\t},\r\n\r\n\tradToDeg: function ( radians ) {\r\n\r\n\t\treturn radians * _Math.RAD2DEG;\r\n\r\n\t},\r\n\r\n\tisPowerOfTwo: function ( value ) {\r\n\r\n\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\r\n\r\n\t},\r\n\r\n\tceilPowerOfTwo: function ( value ) {\r\n\r\n\t\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\r\n\r\n\t},\r\n\r\n\tfloorPowerOfTwo: function ( value ) {\r\n\r\n\t\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\r\n\r\n\t}\r\n\r\n};\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/math/Matrix4.js\n\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author jordi_ros / http://plattsoft.com\r\n * @author D1plo1d / http://github.com/D1plo1d\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author timknip / http://www.floorplanner.com/\r\n * @author bhouston / http://clara.io\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nfunction Matrix4() {\r\n\r\n\tthis.elements = [\r\n\r\n\t\t1, 0, 0, 0,\r\n\t\t0, 1, 0, 0,\r\n\t\t0, 0, 1, 0,\r\n\t\t0, 0, 0, 1\r\n\r\n\t];\r\n\r\n\tif ( arguments.length > 0 ) {\r\n\r\n\t\tconsole.error( 'COOL.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\r\n\r\n\t}\r\n\r\n}\r\n\r\nObject.assign( Matrix4.prototype, {\r\n\r\n\tisMatrix4: true,\r\n\r\n\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\r\n\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\r\n\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\r\n\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n    setIdentity :function() {\r\n        var e = this.elements;\r\n        e[0] = 1;   e[4] = 0;   e[8]  = 0;   e[12] = 0;\r\n        e[1] = 0;   e[5] = 1;   e[9]  = 0;   e[13] = 0;\r\n        e[2] = 0;   e[6] = 0;   e[10] = 1;   e[14] = 0;\r\n        e[3] = 0;   e[7] = 0;   e[11] = 0;   e[15] = 1;\r\n        return this;\r\n    },\r\n\r\n    multiplyVector3 :function(pos) {\r\n        var e = this.elements;\r\n        var p = pos.elements;\r\n        var v = new Vector3();\r\n        var result = v.elements;\r\n\r\n        result[0] = p[0] * e[0] + p[1] * e[4] + p[2] * e[ 8] + e[11];\r\n        result[1] = p[0] * e[1] + p[1] * e[5] + p[2] * e[ 9] + e[12];\r\n        result[2] = p[0] * e[2] + p[1] * e[6] + p[2] * e[10] + e[13];\r\n\r\n        return v;\r\n    },\r\n\r\n    multiplyVector4 :function(pos) {\r\n        var e = this.elements;\r\n        var p = pos.elements;\r\n        var v = new Vector4();\r\n        var result = v.elements;\r\n\r\n        result[0] = p[0] * e[0] + p[1] * e[4] + p[2] * e[ 8] + p[3] * e[12];\r\n        result[1] = p[0] * e[1] + p[1] * e[5] + p[2] * e[ 9] + p[3] * e[13];\r\n        result[2] = p[0] * e[2] + p[1] * e[6] + p[2] * e[10] + p[3] * e[14];\r\n        result[3] = p[0] * e[3] + p[1] * e[7] + p[2] * e[11] + p[3] * e[15];\r\n\r\n        return v;\r\n    },\r\n\r\n    setInverseOf :function(other) {\r\n        var i, s, d, inv, det;\r\n\r\n        s = other.elements;\r\n        d = this.elements;\r\n        inv = new Float32Array(16);\r\n\r\n        inv[0]  =   s[5]*s[10]*s[15] - s[5] *s[11]*s[14] - s[9] *s[6]*s[15]\r\n            + s[9]*s[7] *s[14] + s[13]*s[6] *s[11] - s[13]*s[7]*s[10];\r\n        inv[4]  = - s[4]*s[10]*s[15] + s[4] *s[11]*s[14] + s[8] *s[6]*s[15]\r\n            - s[8]*s[7] *s[14] - s[12]*s[6] *s[11] + s[12]*s[7]*s[10];\r\n        inv[8]  =   s[4]*s[9] *s[15] - s[4] *s[11]*s[13] - s[8] *s[5]*s[15]\r\n            + s[8]*s[7] *s[13] + s[12]*s[5] *s[11] - s[12]*s[7]*s[9];\r\n        inv[12] = - s[4]*s[9] *s[14] + s[4] *s[10]*s[13] + s[8] *s[5]*s[14]\r\n            - s[8]*s[6] *s[13] - s[12]*s[5] *s[10] + s[12]*s[6]*s[9];\r\n\r\n        inv[1]  = - s[1]*s[10]*s[15] + s[1] *s[11]*s[14] + s[9] *s[2]*s[15]\r\n            - s[9]*s[3] *s[14] - s[13]*s[2] *s[11] + s[13]*s[3]*s[10];\r\n        inv[5]  =   s[0]*s[10]*s[15] - s[0] *s[11]*s[14] - s[8] *s[2]*s[15]\r\n            + s[8]*s[3] *s[14] + s[12]*s[2] *s[11] - s[12]*s[3]*s[10];\r\n        inv[9]  = - s[0]*s[9] *s[15] + s[0] *s[11]*s[13] + s[8] *s[1]*s[15]\r\n            - s[8]*s[3] *s[13] - s[12]*s[1] *s[11] + s[12]*s[3]*s[9];\r\n        inv[13] =   s[0]*s[9] *s[14] - s[0] *s[10]*s[13] - s[8] *s[1]*s[14]\r\n            + s[8]*s[2] *s[13] + s[12]*s[1] *s[10] - s[12]*s[2]*s[9];\r\n\r\n        inv[2]  =   s[1]*s[6]*s[15] - s[1] *s[7]*s[14] - s[5] *s[2]*s[15]\r\n            + s[5]*s[3]*s[14] + s[13]*s[2]*s[7]  - s[13]*s[3]*s[6];\r\n        inv[6]  = - s[0]*s[6]*s[15] + s[0] *s[7]*s[14] + s[4] *s[2]*s[15]\r\n            - s[4]*s[3]*s[14] - s[12]*s[2]*s[7]  + s[12]*s[3]*s[6];\r\n        inv[10] =   s[0]*s[5]*s[15] - s[0] *s[7]*s[13] - s[4] *s[1]*s[15]\r\n            + s[4]*s[3]*s[13] + s[12]*s[1]*s[7]  - s[12]*s[3]*s[5];\r\n        inv[14] = - s[0]*s[5]*s[14] + s[0] *s[6]*s[13] + s[4] *s[1]*s[14]\r\n            - s[4]*s[2]*s[13] - s[12]*s[1]*s[6]  + s[12]*s[2]*s[5];\r\n\r\n        inv[3]  = - s[1]*s[6]*s[11] + s[1]*s[7]*s[10] + s[5]*s[2]*s[11]\r\n            - s[5]*s[3]*s[10] - s[9]*s[2]*s[7]  + s[9]*s[3]*s[6];\r\n        inv[7]  =   s[0]*s[6]*s[11] - s[0]*s[7]*s[10] - s[4]*s[2]*s[11]\r\n            + s[4]*s[3]*s[10] + s[8]*s[2]*s[7]  - s[8]*s[3]*s[6];\r\n        inv[11] = - s[0]*s[5]*s[11] + s[0]*s[7]*s[9]  + s[4]*s[1]*s[11]\r\n            - s[4]*s[3]*s[9]  - s[8]*s[1]*s[7]  + s[8]*s[3]*s[5];\r\n        inv[15] =   s[0]*s[5]*s[10] - s[0]*s[6]*s[9]  - s[4]*s[1]*s[10]\r\n            + s[4]*s[2]*s[9]  + s[8]*s[1]*s[6]  - s[8]*s[2]*s[5];\r\n\r\n        det = s[0]*inv[0] + s[1]*inv[4] + s[2]*inv[8] + s[3]*inv[12];\r\n        if (det === 0) {\r\n            return this;\r\n        }\r\n\r\n        det = 1 / det;\r\n        for (i = 0; i < 16; i++) {\r\n            d[i] = inv[i] * det;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    invert :function() {\r\n        return this.setInverseOf(this);\r\n    },\r\n\r\n    ortho :function(left, right, bottom, top, near, far) {\r\n        return this.concat(new Matrix4().setOrtho(left, right, bottom, top, near, far));\r\n    },\r\n\r\n    setFrustum :function(left, right, bottom, top, near, far) {\r\n        var e, rw, rh, rd;\r\n\r\n        if (left === right || top === bottom || near === far) {\r\n            throw 'null frustum';\r\n        }\r\n        if (near <= 0) {\r\n            throw 'near <= 0';\r\n        }\r\n        if (far <= 0) {\r\n            throw 'far <= 0';\r\n        }\r\n\r\n        rw = 1 / (right - left);\r\n        rh = 1 / (top - bottom);\r\n        rd = 1 / (far - near);\r\n\r\n        e = this.elements;\r\n\r\n        e[ 0] = 2 * near * rw;\r\n        e[ 1] = 0;\r\n        e[ 2] = 0;\r\n        e[ 3] = 0;\r\n\r\n        e[ 4] = 0;\r\n        e[ 5] = 2 * near * rh;\r\n        e[ 6] = 0;\r\n        e[ 7] = 0;\r\n\r\n        e[ 8] = (right + left) * rw;\r\n        e[ 9] = (top + bottom) * rh;\r\n        e[10] = -(far + near) * rd;\r\n        e[11] = -1;\r\n\r\n        e[12] = 0;\r\n        e[13] = 0;\r\n        e[14] = -2 * near * far * rd;\r\n        e[15] = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    setOrtho :function(left, right, bottom, top, near, far) {\r\n        var e, rw, rh, rd;\r\n\r\n        if (left === right || bottom === top || near === far) {\r\n            throw 'null frustum';\r\n        }\r\n\r\n        rw = 1 / (right - left);\r\n        rh = 1 / (top - bottom);\r\n        rd = 1 / (far - near);\r\n\r\n        e = this.elements;\r\n\r\n        e[0]  = 2 * rw;\r\n        e[1]  = 0;\r\n        e[2]  = 0;\r\n        e[3]  = 0;\r\n\r\n        e[4]  = 0;\r\n        e[5]  = 2 * rh;\r\n        e[6]  = 0;\r\n        e[7]  = 0;\r\n\r\n        e[8]  = 0;\r\n        e[9]  = 0;\r\n        e[10] = -2 * rd;\r\n        e[11] = 0;\r\n\r\n        e[12] = -(right + left) * rw;\r\n        e[13] = -(top + bottom) * rh;\r\n        e[14] = -(far + near) * rd;\r\n        e[15] = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    concat :function(other) {\r\n        var i, e, a, b, ai0, ai1, ai2, ai3;\r\n\r\n        // Calculate e = a * b\r\n        e = this.elements;\r\n        a = this.elements;\r\n        b = other.elements;\r\n\r\n        // If e equals b, copy b to temporary matrix.\r\n        if (e === b) {\r\n            b = new Float32Array(16);\r\n            for (i = 0; i < 16; ++i) {\r\n                b[i] = e[i];\r\n            }\r\n        }\r\n\r\n        for (i = 0; i < 4; i++) {\r\n            ai0=a[i];  ai1=a[i+4];  ai2=a[i+8];  ai3=a[i+12];\r\n            e[i]    = ai0 * b[0]  + ai1 * b[1]  + ai2 * b[2]  + ai3 * b[3];\r\n            e[i+4]  = ai0 * b[4]  + ai1 * b[5]  + ai2 * b[6]  + ai3 * b[7];\r\n            e[i+8]  = ai0 * b[8]  + ai1 * b[9]  + ai2 * b[10] + ai3 * b[11];\r\n            e[i+12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    frustum :function(left, right, bottom, top, near, far) {\r\n        return this.concat(new Matrix4().setFrustum(left, right, bottom, top, near, far));\r\n    },\r\n\r\n    setPerspective :function(fovy, aspect, near, far) {\r\n        var e, rd, s, ct;\r\n\r\n        if (near === far || aspect === 0) {\r\n            throw 'null frustum';\r\n        }\r\n        if (near <= 0) {\r\n            throw 'near <= 0';\r\n        }\r\n        if (far <= 0) {\r\n            throw 'far <= 0';\r\n        }\r\n\r\n        fovy = Math.PI * fovy / 180 / 2;\r\n        s = Math.sin(fovy);\r\n        if (s === 0) {\r\n            throw 'null frustum';\r\n        }\r\n\r\n        rd = 1 / (far - near);\r\n        ct = Math.cos(fovy) / s;\r\n\r\n        e = this.elements;\r\n\r\n        e[0]  = ct / aspect;\r\n        e[1]  = 0;\r\n        e[2]  = 0;\r\n        e[3]  = 0;\r\n\r\n        e[4]  = 0;\r\n        e[5]  = ct;\r\n        e[6]  = 0;\r\n        e[7]  = 0;\r\n\r\n        e[8]  = 0;\r\n        e[9]  = 0;\r\n        e[10] = -(far + near) * rd;\r\n        e[11] = -1;\r\n\r\n        e[12] = 0;\r\n        e[13] = 0;\r\n        e[14] = -2 * near * far * rd;\r\n        e[15] = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    perspective :function(fovy, aspect, near, far) {\r\n        return this.concat(new Matrix4().setPerspective(fovy, aspect, near, far));\r\n    },\r\n\r\n    setScale :function(x, y, z) {\r\n        var e = this.elements;\r\n        e[0] = x;  e[4] = 0;  e[8]  = 0;  e[12] = 0;\r\n        e[1] = 0;  e[5] = y;  e[9]  = 0;  e[13] = 0;\r\n        e[2] = 0;  e[6] = 0;  e[10] = z;  e[14] = 0;\r\n        e[3] = 0;  e[7] = 0;  e[11] = 0;  e[15] = 1;\r\n        return this;\r\n    },\r\n\r\n    scale :function(x, y, z) {\r\n        var e = this.elements;\r\n        e[0] *= x;  e[4] *= y;  e[8]  *= z;\r\n        e[1] *= x;  e[5] *= y;  e[9]  *= z;\r\n        e[2] *= x;  e[6] *= y;  e[10] *= z;\r\n        e[3] *= x;  e[7] *= y;  e[11] *= z;\r\n        return this;\r\n    },\r\n\r\n\tidentity: function () {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0, 0,\r\n\t\t\t0, 1, 0, 0,\r\n\t\t\t0, 0, 1, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new Matrix4().fromArray( this.elements );\r\n\r\n\t},\r\n\r\n\tcopy: function ( m ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar me = m.elements;\r\n\r\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];\r\n\t\tte[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];\r\n\t\tte[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];\r\n\t\tte[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyPosition: function ( m ) {\r\n\r\n\t\tvar te = this.elements, me = m.elements;\r\n\r\n\t\tte[ 12 ] = me[ 12 ];\r\n\t\tte[ 13 ] = me[ 13 ];\r\n\t\tte[ 14 ] = me[ 14 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\textractBasis: function ( xAxis, yAxis, zAxis ) {\r\n\r\n\t\txAxis.setFromMatrixColumn( this, 0 );\r\n\t\tyAxis.setFromMatrixColumn( this, 1 );\r\n\t\tzAxis.setFromMatrixColumn( this, 2 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\r\n\r\n\t\tthis.set(\r\n\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\r\n\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\r\n\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\r\n\t\t\t0, 0, 0, 1\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\textractRotation: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function extractRotation( m ) {\r\n\r\n\t\t\t// this method does not support reflection matrices\r\n\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar me = m.elements;\r\n\r\n\t\t\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\r\n\t\t\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\r\n\t\t\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\r\n\r\n\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\r\n\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\r\n\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\r\n\t\t\tte[ 3 ] = 0;\r\n\r\n\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\r\n\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\r\n\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\r\n\t\t\tte[ 7 ] = 0;\r\n\r\n\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\r\n\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\r\n\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\r\n\t\t\tte[ 11 ] = 0;\r\n\r\n\t\t\tte[ 12 ] = 0;\r\n\t\t\tte[ 13 ] = 0;\r\n\t\t\tte[ 14 ] = 0;\r\n\t\t\tte[ 15 ] = 1;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmakeRotationFromEuler: function ( euler ) {\r\n\r\n\t\tif ( ! ( euler && euler.isEuler ) ) {\r\n\r\n\t\t\tconsole.error( 'COOL.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\r\n\t\t}\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar x = euler.x, y = euler.y, z = euler.z;\r\n\t\tvar a = Math.cos( x ), b = Math.sin( x );\r\n\t\tvar c = Math.cos( y ), d = Math.sin( y );\r\n\t\tvar e = Math.cos( z ), f = Math.sin( z );\r\n\r\n\t\tif ( euler.order === 'XYZ' ) {\r\n\r\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = - c * f;\r\n\t\t\tte[ 8 ] = d;\r\n\r\n\t\t\tte[ 1 ] = af + be * d;\r\n\t\t\tte[ 5 ] = ae - bf * d;\r\n\t\t\tte[ 9 ] = - b * c;\r\n\r\n\t\t\tte[ 2 ] = bf - ae * d;\r\n\t\t\tte[ 6 ] = be + af * d;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'YXZ' ) {\r\n\r\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n\t\t\tte[ 0 ] = ce + df * b;\r\n\t\t\tte[ 4 ] = de * b - cf;\r\n\t\t\tte[ 8 ] = a * d;\r\n\r\n\t\t\tte[ 1 ] = a * f;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = - b;\r\n\r\n\t\t\tte[ 2 ] = cf * b - de;\r\n\t\t\tte[ 6 ] = df + ce * b;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'ZXY' ) {\r\n\r\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n\t\t\tte[ 0 ] = ce - df * b;\r\n\t\t\tte[ 4 ] = - a * f;\r\n\t\t\tte[ 8 ] = de + cf * b;\r\n\r\n\t\t\tte[ 1 ] = cf + de * b;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = df - ce * b;\r\n\r\n\t\t\tte[ 2 ] = - a * d;\r\n\t\t\tte[ 6 ] = b;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'ZYX' ) {\r\n\r\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = be * d - af;\r\n\t\t\tte[ 8 ] = ae * d + bf;\r\n\r\n\t\t\tte[ 1 ] = c * f;\r\n\t\t\tte[ 5 ] = bf * d + ae;\r\n\t\t\tte[ 9 ] = af * d - be;\r\n\r\n\t\t\tte[ 2 ] = - d;\r\n\t\t\tte[ 6 ] = b * c;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'YZX' ) {\r\n\r\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = bd - ac * f;\r\n\t\t\tte[ 8 ] = bc * f + ad;\r\n\r\n\t\t\tte[ 1 ] = f;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = - b * e;\r\n\r\n\t\t\tte[ 2 ] = - d * e;\r\n\t\t\tte[ 6 ] = ad * f + bc;\r\n\t\t\tte[ 10 ] = ac - bd * f;\r\n\r\n\t\t} else if ( euler.order === 'XZY' ) {\r\n\r\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = - f;\r\n\t\t\tte[ 8 ] = d * e;\r\n\r\n\t\t\tte[ 1 ] = ac * f + bd;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = ad * f - bc;\r\n\r\n\t\t\tte[ 2 ] = bc * f - ad;\r\n\t\t\tte[ 6 ] = b * e;\r\n\t\t\tte[ 10 ] = bd * f + ac;\r\n\r\n\t\t}\r\n\r\n\t\t// bottom row\r\n\t\tte[ 3 ] = 0;\r\n\t\tte[ 7 ] = 0;\r\n\t\tte[ 11 ] = 0;\r\n\r\n\t\t// last column\r\n\t\tte[ 12 ] = 0;\r\n\t\tte[ 13 ] = 0;\r\n\t\tte[ 14 ] = 0;\r\n\t\tte[ 15 ] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationFromQuaternion: function () {\r\n\r\n\t\tvar zero = new Vector3( 0, 0, 0 );\r\n\t\tvar one = new Vector3( 1, 1, 1 );\r\n\r\n\t\treturn function makeRotationFromQuaternion( q ) {\r\n\r\n\t\t\treturn this.compose( zero, q, one );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlookAt: function () {\r\n\r\n\t\tvar x = new Vector3();\r\n\t\tvar y = new Vector3();\r\n\t\tvar z = new Vector3();\r\n\r\n\t\treturn function lookAt( eye, target, up ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tz.subVectors( eye, target );\r\n\r\n\t\t\tif ( z.lengthSq() === 0 ) {\r\n\r\n\t\t\t\t// eye and target are in the same position\r\n\r\n\t\t\t\tz.z = 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tz.normalize();\r\n\t\t\tx.crossVectors( up, z );\r\n\r\n\t\t\tif ( x.lengthSq() === 0 ) {\r\n\r\n\t\t\t\t// up and z are parallel\r\n\r\n\t\t\t\tif ( Math.abs( up.z ) === 1 ) {\r\n\r\n\t\t\t\t\tz.x += 0.0001;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tz.z += 0.0001;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tz.normalize();\r\n\t\t\t\tx.crossVectors( up, z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tx.normalize();\r\n\t\t\ty.crossVectors( z, x );\r\n\r\n\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\r\n\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\r\n\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmultiply: function ( m, n ) {\r\n\r\n\t\tif ( n !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\r\n\t\t\treturn this.multiplyMatrices( m, n );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.multiplyMatrices( this, m );\r\n\r\n\t},\r\n\r\n\tpremultiply: function ( m ) {\r\n\r\n\t\treturn this.multiplyMatrices( m, this );\r\n\r\n\t},\r\n\r\n\tmultiplyMatrices: function ( a, b ) {\r\n\r\n\t\tvar ae = a.elements;\r\n\t\tvar be = b.elements;\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\r\n\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\r\n\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\r\n\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\r\n\r\n\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\r\n\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\r\n\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\r\n\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\r\n\r\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\r\n\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\r\n\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\r\n\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\r\n\r\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\r\n\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\r\n\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\r\n\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\r\n\r\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\r\n\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\r\n\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\r\n\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\r\n\r\n\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\r\n\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\r\n\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\r\n\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\r\n\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\r\n\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\r\n\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyToBufferAttribute: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function applyToBufferAttribute( attribute ) {\r\n\r\n\t\t\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\r\n\r\n\t\t\t\tv1.x = attribute.getX( i );\r\n\t\t\t\tv1.y = attribute.getY( i );\r\n\t\t\t\tv1.z = attribute.getZ( i );\r\n\r\n\t\t\t\tv1.applyMatrix4( this );\r\n\r\n\t\t\t\tattribute.setXYZ( i, v1.x, v1.y, v1.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn attribute;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tdeterminant: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\r\n\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\r\n\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\r\n\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\r\n\r\n\t\t//TODO: make this more efficient\r\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\r\n\r\n\t\treturn (\r\n\t\t\tn41 * (\r\n\t\t\t\t+ n14 * n23 * n32\r\n\t\t\t\t - n13 * n24 * n32\r\n\t\t\t\t - n14 * n22 * n33\r\n\t\t\t\t + n12 * n24 * n33\r\n\t\t\t\t + n13 * n22 * n34\r\n\t\t\t\t - n12 * n23 * n34\r\n\t\t\t) +\r\n\t\t\tn42 * (\r\n\t\t\t\t+ n11 * n23 * n34\r\n\t\t\t\t - n11 * n24 * n33\r\n\t\t\t\t + n14 * n21 * n33\r\n\t\t\t\t - n13 * n21 * n34\r\n\t\t\t\t + n13 * n24 * n31\r\n\t\t\t\t - n14 * n23 * n31\r\n\t\t\t) +\r\n\t\t\tn43 * (\r\n\t\t\t\t+ n11 * n24 * n32\r\n\t\t\t\t - n11 * n22 * n34\r\n\t\t\t\t - n14 * n21 * n32\r\n\t\t\t\t + n12 * n21 * n34\r\n\t\t\t\t + n14 * n22 * n31\r\n\t\t\t\t - n12 * n24 * n31\r\n\t\t\t) +\r\n\t\t\tn44 * (\r\n\t\t\t\t- n13 * n22 * n31\r\n\t\t\t\t - n11 * n23 * n32\r\n\t\t\t\t + n11 * n22 * n33\r\n\t\t\t\t + n13 * n21 * n32\r\n\t\t\t\t - n12 * n21 * n33\r\n\t\t\t\t + n12 * n23 * n31\r\n\t\t\t)\r\n\r\n\t\t);\r\n\r\n\t},\r\n\r\n\ttranspose: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar tmp;\r\n\r\n\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\r\n\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\r\n\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\r\n\r\n\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\r\n\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\r\n\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetPosition: function ( v ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 12 ] = v.x;\r\n\t\tte[ 13 ] = v.y;\r\n\t\tte[ 14 ] = v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetInverse: function ( m, throwOnDegenerate ) {\r\n\r\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\r\n\t\tvar te = this.elements,\r\n\t\t\tme = m.elements,\r\n\r\n\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\r\n\t\t\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\r\n\t\t\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\r\n\t\t\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\r\n\r\n\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\r\n\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\r\n\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\r\n\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\r\n\r\n\t\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\r\n\r\n\t\tif ( det === 0 ) {\r\n\r\n\t\t\tvar msg = \"COOL.Matrix4: .getInverse() can't invert matrix, determinant is 0\";\r\n\r\n\t\t\tif ( throwOnDegenerate === true ) {\r\n\r\n\t\t\t\tthrow new Error( msg );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( msg );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.identity();\r\n\r\n\t\t}\r\n\r\n\t\tvar detInv = 1 / det;\r\n\r\n\t\tte[ 0 ] = t11 * detInv;\r\n\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\r\n\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\r\n\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\r\n\r\n\t\tte[ 4 ] = t12 * detInv;\r\n\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\r\n\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\r\n\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\r\n\r\n\t\tte[ 8 ] = t13 * detInv;\r\n\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\r\n\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\r\n\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\r\n\r\n\t\tte[ 12 ] = t14 * detInv;\r\n\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\r\n\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\r\n\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tscale: function ( v ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar x = v.x, y = v.y, z = v.z;\r\n\r\n\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\r\n\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\r\n\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\r\n\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n    setTranslate :function(x, y, z) {\r\n        var e = this.elements;\r\n        e[0] = 1;  e[4] = 0;  e[8]  = 0;  e[12] = x;\r\n        e[1] = 0;  e[5] = 1;  e[9]  = 0;  e[13] = y;\r\n        e[2] = 0;  e[6] = 0;  e[10] = 1;  e[14] = z;\r\n        e[3] = 0;  e[7] = 0;  e[11] = 0;  e[15] = 1;\r\n        return this;\r\n    },\r\n\r\n    translate :function(x, y, z) {\r\n        var e = this.elements;\r\n        e[12] += e[0] * x + e[4] * y + e[8]  * z;\r\n        e[13] += e[1] * x + e[5] * y + e[9]  * z;\r\n        e[14] += e[2] * x + e[6] * y + e[10] * z;\r\n        e[15] += e[3] * x + e[7] * y + e[11] * z;\r\n        return this;\r\n    },\r\n\r\n    setRotate :function(angle, x, y, z) {\r\n        var e, s, c, len, rlen, nc, xy, yz, zx, xs, ys, zs;\r\n\r\n        angle = Math.PI * angle / 180;\r\n        e = this.elements;\r\n\r\n        s = Math.sin(angle);\r\n        c = Math.cos(angle);\r\n\r\n        if (0 !== x && 0 === y && 0 === z) {\r\n            // Rotation around X axis\r\n            if (x < 0) {\r\n                s = -s;\r\n            }\r\n            e[0] = 1;  e[4] = 0;  e[ 8] = 0;  e[12] = 0;\r\n            e[1] = 0;  e[5] = c;  e[ 9] =-s;  e[13] = 0;\r\n            e[2] = 0;  e[6] = s;  e[10] = c;  e[14] = 0;\r\n            e[3] = 0;  e[7] = 0;  e[11] = 0;  e[15] = 1;\r\n        } else if (0 === x && 0 !== y && 0 === z) {\r\n            // Rotation around Y axis\r\n            if (y < 0) {\r\n                s = -s;\r\n            }\r\n            e[0] = c;  e[4] = 0;  e[ 8] = s;  e[12] = 0;\r\n            e[1] = 0;  e[5] = 1;  e[ 9] = 0;  e[13] = 0;\r\n            e[2] =-s;  e[6] = 0;  e[10] = c;  e[14] = 0;\r\n            e[3] = 0;  e[7] = 0;  e[11] = 0;  e[15] = 1;\r\n        } else if (0 === x && 0 === y && 0 !== z) {\r\n            // Rotation around Z axis\r\n            if (z < 0) {\r\n                s = -s;\r\n            }\r\n            e[0] = c;  e[4] =-s;  e[ 8] = 0;  e[12] = 0;\r\n            e[1] = s;  e[5] = c;  e[ 9] = 0;  e[13] = 0;\r\n            e[2] = 0;  e[6] = 0;  e[10] = 1;  e[14] = 0;\r\n            e[3] = 0;  e[7] = 0;  e[11] = 0;  e[15] = 1;\r\n        } else {\r\n            // Rotation around another axis\r\n            len = Math.sqrt(x*x + y*y + z*z);\r\n            if (len !== 1) {\r\n                rlen = 1 / len;\r\n                x *= rlen;\r\n                y *= rlen;\r\n                z *= rlen;\r\n            }\r\n            nc = 1 - c;\r\n            xy = x * y;\r\n            yz = y * z;\r\n            zx = z * x;\r\n            xs = x * s;\r\n            ys = y * s;\r\n            zs = z * s;\r\n\r\n            e[ 0] = x*x*nc +  c;\r\n            e[ 1] = xy *nc + zs;\r\n            e[ 2] = zx *nc - ys;\r\n            e[ 3] = 0;\r\n\r\n            e[ 4] = xy *nc - zs;\r\n            e[ 5] = y*y*nc +  c;\r\n            e[ 6] = yz *nc + xs;\r\n            e[ 7] = 0;\r\n\r\n            e[ 8] = zx *nc + ys;\r\n            e[ 9] = yz *nc - xs;\r\n            e[10] = z*z*nc +  c;\r\n            e[11] = 0;\r\n\r\n            e[12] = 0;\r\n            e[13] = 0;\r\n            e[14] = 0;\r\n            e[15] = 1;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    rotate :function(angle, x, y, z) {\r\n        return this.concat(new Matrix4().setRotate(angle, x, y, z));\r\n    },\r\n\r\n    setLookAt :function(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) {\r\n        var e, fx, fy, fz, rlf, sx, sy, sz, rls, ux, uy, uz;\r\n\r\n        fx = centerX - eyeX;\r\n        fy = centerY - eyeY;\r\n        fz = centerZ - eyeZ;\r\n\r\n        // Normalize f.\r\n        rlf = 1 / Math.sqrt(fx*fx + fy*fy + fz*fz);\r\n        fx *= rlf;\r\n        fy *= rlf;\r\n        fz *= rlf;\r\n\r\n        // Calculate cross product of f and up.\r\n        sx = fy * upZ - fz * upY;\r\n        sy = fz * upX - fx * upZ;\r\n        sz = fx * upY - fy * upX;\r\n\r\n        // Normalize s.\r\n        rls = 1 / Math.sqrt(sx*sx + sy*sy + sz*sz);\r\n        sx *= rls;\r\n        sy *= rls;\r\n        sz *= rls;\r\n\r\n        // Calculate cross product of s and f.\r\n        ux = sy * fz - sz * fy;\r\n        uy = sz * fx - sx * fz;\r\n        uz = sx * fy - sy * fx;\r\n\r\n        // Set to this.\r\n        e = this.elements;\r\n        e[0] = sx;\r\n        e[1] = ux;\r\n        e[2] = -fx;\r\n        e[3] = 0;\r\n\r\n        e[4] = sy;\r\n        e[5] = uy;\r\n        e[6] = -fy;\r\n        e[7] = 0;\r\n\r\n        e[8] = sz;\r\n        e[9] = uz;\r\n        e[10] = -fz;\r\n        e[11] = 0;\r\n\r\n        e[12] = 0;\r\n        e[13] = 0;\r\n        e[14] = 0;\r\n        e[15] = 1;\r\n\r\n        // Translate.\r\n        return this.translate(-eyeX, -eyeY, -eyeZ);\r\n    },\r\n\r\n    lookAt2 :function(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) {\r\n        return this.concat(new Matrix4().setLookAt(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ));\r\n    },\r\n\r\n\tgetMaxScaleOnAxis: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\r\n\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\r\n\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\r\n\r\n\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\r\n\r\n\t},\r\n\r\n\tmakeTranslation: function ( x, y, z ) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0, x,\r\n\t\t\t0, 1, 0, y,\r\n\t\t\t0, 0, 1, z,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationX: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0, 0,\r\n\t\t\t0, c, - s, 0,\r\n\t\t\t0, s, c, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationY: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t c, 0, s, 0,\r\n\t\t\t 0, 1, 0, 0,\r\n\t\t\t- s, 0, c, 0,\r\n\t\t\t 0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationZ: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tc, - s, 0, 0,\r\n\t\t\ts, c, 0, 0,\r\n\t\t\t0, 0, 1, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationAxis: function ( axis, angle ) {\r\n\r\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\r\n\r\n\t\tvar c = Math.cos( angle );\r\n\t\tvar s = Math.sin( angle );\r\n\t\tvar t = 1 - c;\r\n\t\tvar x = axis.x, y = axis.y, z = axis.z;\r\n\t\tvar tx = t * x, ty = t * y;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\r\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\r\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\t return this;\r\n\r\n\t},\r\n\r\n\tmakeScale: function ( x, y, z ) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tx, 0, 0, 0,\r\n\t\t\t0, y, 0, 0,\r\n\t\t\t0, 0, z, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeShear: function ( x, y, z ) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, y, z, 0,\r\n\t\t\tx, 1, z, 0,\r\n\t\t\tx, y, 1, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcompose: function ( position, quaternion, scale ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;\r\n\t\tvar x2 = x + x,\ty2 = y + y, z2 = z + z;\r\n\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\r\n\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\r\n\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\r\n\r\n\t\tvar sx = scale.x, sy = scale.y, sz = scale.z;\r\n\r\n\t        te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;\r\n\t        te[ 1 ] = ( xy + wz ) * sx;\r\n\t        te[ 2 ] = ( xz - wy ) * sx;\r\n\t        te[ 3 ] = 0;\r\n\r\n\t        te[ 4 ] = ( xy - wz ) * sy;\r\n\t        te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;\r\n\t        te[ 6 ] = ( yz + wx ) * sy;\r\n\t        te[ 7 ] = 0;\r\n\r\n\t        te[ 8 ] = ( xz + wy ) * sz;\r\n\t        te[ 9 ] = ( yz - wx ) * sz;\r\n\t        te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;\r\n\t        te[ 11 ] = 0;\r\n\r\n\t        te[ 12 ] = position.x;\r\n\t        te[ 13 ] = position.y;\r\n\t        te[ 14 ] = position.z;\r\n\t        te[ 15 ] = 1;\r\n\r\n\t        return this;\r\n\r\n\t},\r\n\r\n\tdecompose: function () {\r\n\r\n\t\tvar vector = new Vector3();\r\n\t\tvar matrix = new Matrix4();\r\n\r\n\t\treturn function decompose( position, quaternion, scale ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\r\n\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\r\n\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\r\n\r\n\t\t\t// if determine is negative, we need to invert one scale\r\n\t\t\tvar det = this.determinant();\r\n\t\t\tif ( det < 0 ) sx = - sx;\r\n\r\n\t\t\tposition.x = te[ 12 ];\r\n\t\t\tposition.y = te[ 13 ];\r\n\t\t\tposition.z = te[ 14 ];\r\n\r\n\t\t\t// scale the rotation part\r\n\t\t\tmatrix.copy( this );\r\n\r\n\t\t\tvar invSX = 1 / sx;\r\n\t\t\tvar invSY = 1 / sy;\r\n\t\t\tvar invSZ = 1 / sz;\r\n\r\n\t\t\tmatrix.elements[ 0 ] *= invSX;\r\n\t\t\tmatrix.elements[ 1 ] *= invSX;\r\n\t\t\tmatrix.elements[ 2 ] *= invSX;\r\n\r\n\t\t\tmatrix.elements[ 4 ] *= invSY;\r\n\t\t\tmatrix.elements[ 5 ] *= invSY;\r\n\t\t\tmatrix.elements[ 6 ] *= invSY;\r\n\r\n\t\t\tmatrix.elements[ 8 ] *= invSZ;\r\n\t\t\tmatrix.elements[ 9 ] *= invSZ;\r\n\t\t\tmatrix.elements[ 10 ] *= invSZ;\r\n\r\n\t\t\tquaternion.setFromRotationMatrix( matrix );\r\n\r\n\t\t\tscale.x = sx;\r\n\t\t\tscale.y = sy;\r\n\t\t\tscale.z = sz;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmakePerspective: function ( left, right, top, bottom, near, far ) {\r\n\r\n\t\tif ( far === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );\r\n\r\n\t\t}\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar x = 2 * near / ( right - left );\r\n\t\tvar y = 2 * near / ( top - bottom );\r\n\r\n\t\tvar a = ( right + left ) / ( right - left );\r\n\t\tvar b = ( top + bottom ) / ( top - bottom );\r\n\t\tvar c = - ( far + near ) / ( far - near );\r\n\t\tvar d = - 2 * far * near / ( far - near );\r\n\r\n\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\r\n\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\r\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\r\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar w = 1.0 / ( right - left );\r\n\t\tvar h = 1.0 / ( top - bottom );\r\n\t\tvar p = 1.0 / ( far - near );\r\n\r\n\t\tvar x = ( right + left ) * w;\r\n\t\tvar y = ( top + bottom ) * h;\r\n\t\tvar z = ( far + near ) * p;\r\n\r\n\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\r\n\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\r\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\r\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( matrix ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar me = matrix.elements;\r\n\r\n\t\tfor ( var i = 0; i < 16; i ++ ) {\r\n\r\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tfor ( var i = 0; i < 16; i ++ ) {\r\n\r\n\t\t\tthis.elements[ i ] = array[ i + offset ];\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tarray[ offset ] = te[ 0 ];\r\n\t\tarray[ offset + 1 ] = te[ 1 ];\r\n\t\tarray[ offset + 2 ] = te[ 2 ];\r\n\t\tarray[ offset + 3 ] = te[ 3 ];\r\n\r\n\t\tarray[ offset + 4 ] = te[ 4 ];\r\n\t\tarray[ offset + 5 ] = te[ 5 ];\r\n\t\tarray[ offset + 6 ] = te[ 6 ];\r\n\t\tarray[ offset + 7 ] = te[ 7 ];\r\n\r\n\t\tarray[ offset + 8 ] = te[ 8 ];\r\n\t\tarray[ offset + 9 ] = te[ 9 ];\r\n\t\tarray[ offset + 10 ] = te[ 10 ];\r\n\t\tarray[ offset + 11 ] = te[ 11 ];\r\n\r\n\t\tarray[ offset + 12 ] = te[ 12 ];\r\n\t\tarray[ offset + 13 ] = te[ 13 ];\r\n\t\tarray[ offset + 14 ] = te[ 14 ];\r\n\t\tarray[ offset + 15 ] = te[ 15 ];\r\n\r\n\t\treturn array;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/math/Quaternion.js\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\n\r\n\r\n\r\nfunction Quaternion( x, y, z, w ) {\r\n\r\n\tthis._x = x || 0;\r\n\tthis._y = y || 0;\r\n\tthis._z = z || 0;\r\n\tthis._w = ( w !== undefined ) ? w : 1;\r\n\r\n}\r\n\r\nObject.assign( Quaternion, {\r\n\r\n\tslerp: function ( qa, qb, qm, t ) {\r\n\r\n\t\treturn qm.copy( qa ).slerp( qb, t );\r\n\r\n\t},\r\n\r\n\tslerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\r\n\r\n\t\t// fuzz-free, array-based Quaternion SLERP operation\r\n\r\n\t\tvar x0 = src0[ srcOffset0 + 0 ],\r\n\t\t\ty0 = src0[ srcOffset0 + 1 ],\r\n\t\t\tz0 = src0[ srcOffset0 + 2 ],\r\n\t\t\tw0 = src0[ srcOffset0 + 3 ],\r\n\r\n\t\t\tx1 = src1[ srcOffset1 + 0 ],\r\n\t\t\ty1 = src1[ srcOffset1 + 1 ],\r\n\t\t\tz1 = src1[ srcOffset1 + 2 ],\r\n\t\t\tw1 = src1[ srcOffset1 + 3 ];\r\n\r\n\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\r\n\r\n\t\t\tvar s = 1 - t,\r\n\r\n\t\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\r\n\r\n\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\r\n\t\t\t\tsqrSin = 1 - cos * cos;\r\n\r\n\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\r\n\t\t\tif ( sqrSin > Number.EPSILON ) {\r\n\r\n\t\t\t\tvar sin = Math.sqrt( sqrSin ),\r\n\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\r\n\r\n\t\t\t\ts = Math.sin( s * len ) / sin;\r\n\t\t\t\tt = Math.sin( t * len ) / sin;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar tDir = t * dir;\r\n\r\n\t\t\tx0 = x0 * s + x1 * tDir;\r\n\t\t\ty0 = y0 * s + y1 * tDir;\r\n\t\t\tz0 = z0 * s + z1 * tDir;\r\n\t\t\tw0 = w0 * s + w1 * tDir;\r\n\r\n\t\t\t// Normalize in case we just did a lerp:\r\n\t\t\tif ( s === 1 - t ) {\r\n\r\n\t\t\t\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\r\n\r\n\t\t\t\tx0 *= f;\r\n\t\t\t\ty0 *= f;\r\n\t\t\t\tz0 *= f;\r\n\t\t\t\tw0 *= f;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tdst[ dstOffset ] = x0;\r\n\t\tdst[ dstOffset + 1 ] = y0;\r\n\t\tdst[ dstOffset + 2 ] = z0;\r\n\t\tdst[ dstOffset + 3 ] = w0;\r\n\r\n\t}\r\n\r\n} );\r\n\r\nObject.defineProperties( Quaternion.prototype, {\r\n\r\n\tx: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this._x;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tthis._x = value;\r\n\t\t\tthis.onChangeCallback();\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ty: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this._y;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tthis._y = value;\r\n\t\t\tthis.onChangeCallback();\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tz: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this._z;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tthis._z = value;\r\n\t\t\tthis.onChangeCallback();\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tw: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this._w;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tthis._w = value;\r\n\t\t\tthis.onChangeCallback();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\r\n\r\nObject.assign( Quaternion.prototype, {\r\n\r\n\tisQuaternion: true,\r\n\r\n\tset: function ( x, y, z, w ) {\r\n\r\n\t\tthis._x = x;\r\n\t\tthis._y = y;\r\n\t\tthis._z = z;\r\n\t\tthis._w = w;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\r\n\r\n\t},\r\n\r\n\tcopy: function ( quaternion ) {\r\n\r\n\t\tthis._x = quaternion.x;\r\n\t\tthis._y = quaternion.y;\r\n\t\tthis._z = quaternion.z;\r\n\t\tthis._w = quaternion.w;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromEuler: function ( euler, update ) {\r\n\r\n\t\tif ( ! ( euler && euler.isEuler ) ) {\r\n\r\n\t\t\tthrow new Error( 'COOL.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );\r\n\r\n\t\t}\r\n\r\n\t\tvar x = euler._x, y = euler._y, z = euler._z, order = euler.order;\r\n\r\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\r\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\r\n\t\t//\tcontent/SpinCalc.m\r\n\r\n\t\tvar cos = Math.cos;\r\n\t\tvar sin = Math.sin;\r\n\r\n\t\tvar c1 = cos( x / 2 );\r\n\t\tvar c2 = cos( y / 2 );\r\n\t\tvar c3 = cos( z / 2 );\r\n\r\n\t\tvar s1 = sin( x / 2 );\r\n\t\tvar s2 = sin( y / 2 );\r\n\t\tvar s3 = sin( z / 2 );\r\n\r\n\t\tif ( order === 'XYZ' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'YXZ' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'ZXY' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'ZYX' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'YZX' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'XZY' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t}\r\n\r\n\t\tif ( update !== false ) this.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromAxisAngle: function ( axis, angle ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\r\n\r\n\t\t// assumes axis is normalized\r\n\r\n\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\r\n\r\n\t\tthis._x = axis.x * s;\r\n\t\tthis._y = axis.y * s;\r\n\t\tthis._z = axis.z * s;\r\n\t\tthis._w = Math.cos( halfAngle );\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromRotationMatrix: function ( m ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tvar te = m.elements,\r\n\r\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\r\n\r\n\t\t\ttrace = m11 + m22 + m33,\r\n\t\t\ts;\r\n\r\n\t\tif ( trace > 0 ) {\r\n\r\n\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\r\n\r\n\t\t\tthis._w = 0.25 / s;\r\n\t\t\tthis._x = ( m32 - m23 ) * s;\r\n\t\t\tthis._y = ( m13 - m31 ) * s;\r\n\t\t\tthis._z = ( m21 - m12 ) * s;\r\n\r\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\r\n\r\n\t\t\tthis._w = ( m32 - m23 ) / s;\r\n\t\t\tthis._x = 0.25 * s;\r\n\t\t\tthis._y = ( m12 + m21 ) / s;\r\n\t\t\tthis._z = ( m13 + m31 ) / s;\r\n\r\n\t\t} else if ( m22 > m33 ) {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\r\n\r\n\t\t\tthis._w = ( m13 - m31 ) / s;\r\n\t\t\tthis._x = ( m12 + m21 ) / s;\r\n\t\t\tthis._y = 0.25 * s;\r\n\t\t\tthis._z = ( m23 + m32 ) / s;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\r\n\r\n\t\t\tthis._w = ( m21 - m12 ) / s;\r\n\t\t\tthis._x = ( m13 + m31 ) / s;\r\n\t\t\tthis._y = ( m23 + m32 ) / s;\r\n\t\t\tthis._z = 0.25 * s;\r\n\r\n\t\t}\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromUnitVectors: function () {\r\n\r\n\t\t// assumes direction vectors vFrom and vTo are normalized\r\n\r\n\t\tvar v1 = new Vector3();\r\n\t\tvar r;\r\n\r\n\t\tvar EPS = 0.000001;\r\n\r\n\t\treturn function setFromUnitVectors( vFrom, vTo ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new Vector3();\r\n\r\n\t\t\tr = vFrom.dot( vTo ) + 1;\r\n\r\n\t\t\tif ( r < EPS ) {\r\n\r\n\t\t\t\tr = 0;\r\n\r\n\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\r\n\r\n\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tv1.crossVectors( vFrom, vTo );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis._x = v1.x;\r\n\t\t\tthis._y = v1.y;\r\n\t\t\tthis._z = v1.z;\r\n\t\t\tthis._w = r;\r\n\r\n\t\t\treturn this.normalize();\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tangleTo: function ( q ) {\r\n\r\n\t\treturn 2 * Math.acos( Math.abs( _Math.clamp( this.dot( q ), - 1, 1 ) ) );\r\n\r\n\t},\r\n\r\n\trotateTowards: function ( q, step ) {\r\n\r\n\t\tvar angle = this.angleTo( q );\r\n\r\n\t\tif ( angle === 0 ) return this;\r\n\r\n\t\tvar t = Math.min( 1, step / angle );\r\n\r\n\t\tthis.slerp( q, t );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tinverse: function () {\r\n\r\n\t\t// quaternion is assumed to have unit length\r\n\r\n\t\treturn this.conjugate();\r\n\r\n\t},\r\n\r\n\tconjugate: function () {\r\n\r\n\t\tthis._x *= - 1;\r\n\t\tthis._y *= - 1;\r\n\t\tthis._z *= - 1;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\tvar l = this.length();\r\n\r\n\t\tif ( l === 0 ) {\r\n\r\n\t\t\tthis._x = 0;\r\n\t\t\tthis._y = 0;\r\n\t\t\tthis._z = 0;\r\n\t\t\tthis._w = 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tl = 1 / l;\r\n\r\n\t\t\tthis._x = this._x * l;\r\n\t\t\tthis._y = this._y * l;\r\n\t\t\tthis._z = this._z * l;\r\n\t\t\tthis._w = this._w * l;\r\n\r\n\t\t}\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( q, p ) {\r\n\r\n\t\tif ( p !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\r\n\t\t\treturn this.multiplyQuaternions( q, p );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.multiplyQuaternions( this, q );\r\n\r\n\t},\r\n\r\n\tpremultiply: function ( q ) {\r\n\r\n\t\treturn this.multiplyQuaternions( q, this );\r\n\r\n\t},\r\n\r\n\tmultiplyQuaternions: function ( a, b ) {\r\n\r\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\r\n\r\n\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\r\n\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\r\n\r\n\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\r\n\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\r\n\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\r\n\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tslerp: function ( qb, t ) {\r\n\r\n\t\tif ( t === 0 ) return this;\r\n\t\tif ( t === 1 ) return this.copy( qb );\r\n\r\n\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\r\n\r\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\r\n\r\n\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\r\n\r\n\t\tif ( cosHalfTheta < 0 ) {\r\n\r\n\t\t\tthis._w = - qb._w;\r\n\t\t\tthis._x = - qb._x;\r\n\t\t\tthis._y = - qb._y;\r\n\t\t\tthis._z = - qb._z;\r\n\r\n\t\t\tcosHalfTheta = - cosHalfTheta;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.copy( qb );\r\n\r\n\t\t}\r\n\r\n\t\tif ( cosHalfTheta >= 1.0 ) {\r\n\r\n\t\t\tthis._w = w;\r\n\t\t\tthis._x = x;\r\n\t\t\tthis._y = y;\r\n\t\t\tthis._z = z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tvar sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\r\n\r\n\t\tif ( sqrSinHalfTheta <= Number.EPSILON ) {\r\n\r\n\t\t\tvar s = 1 - t;\r\n\t\t\tthis._w = s * w + t * this._w;\r\n\t\t\tthis._x = s * x + t * this._x;\r\n\t\t\tthis._y = s * y + t * this._y;\r\n\t\t\tthis._z = s * z + t * this._z;\r\n\r\n\t\t\treturn this.normalize();\r\n\r\n\t\t}\r\n\r\n\t\tvar sinHalfTheta = Math.sqrt( sqrSinHalfTheta );\r\n\t\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\r\n\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\r\n\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\r\n\r\n\t\tthis._w = ( w * ratioA + this._w * ratioB );\r\n\t\tthis._x = ( x * ratioA + this._x * ratioB );\r\n\t\tthis._y = ( y * ratioA + this._y * ratioB );\r\n\t\tthis._z = ( z * ratioA + this._z * ratioB );\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( quaternion ) {\r\n\r\n\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis._x = array[ offset ];\r\n\t\tthis._y = array[ offset + 1 ];\r\n\t\tthis._z = array[ offset + 2 ];\r\n\t\tthis._w = array[ offset + 3 ];\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this._x;\r\n\t\tarray[ offset + 1 ] = this._y;\r\n\t\tarray[ offset + 2 ] = this._z;\r\n\t\tarray[ offset + 3 ] = this._w;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tonChange: function ( callback ) {\r\n\r\n\t\tthis.onChangeCallback = callback;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tonChangeCallback: function () {}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/math/Vector3.js\n\r\n\r\n\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author kile / http://kile.stravaganza.org/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author egraether / http://egraether.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nfunction Vector3( x, y, z ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\tthis.z = z || 0;\r\n\r\n}\r\n\r\nObject.assign( Vector3.prototype, {\r\n\r\n\tisVector3: true,\r\n\r\n\tset: function ( x, y, z ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetScalar: function ( scalar ) {\r\n\r\n\t\tthis.x = scalar;\r\n\t\tthis.y = scalar;\r\n\t\tthis.z = scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetZ: function ( z ) {\r\n\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tcase 2: this.z = value; break;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tcase 2: return this.z;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.x, this.y, this.z );\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\t\tthis.z = v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\t\tthis.z += v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\t\tthis.z += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\t\tthis.z = a.z + b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScaledVector: function ( v, s ) {\r\n\r\n\t\tthis.x += v.x * s;\r\n\t\tthis.y += v.y * s;\r\n\t\tthis.z += v.z * s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\t\tthis.z -= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubScalar: function ( s ) {\r\n\r\n\t\tthis.x -= s;\r\n\t\tthis.y -= s;\r\n\t\tthis.z -= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n    scaleVectors :function(v1,scale){\r\n        return new Vector3(v1.x*scale, v1.y*scale, v1.z*scale );\r\n    },\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\t\tthis.z = a.z - b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\r\n\t\t\treturn this.multiplyVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x *= v.x;\r\n\t\tthis.y *= v.y;\r\n\t\tthis.z *= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( scalar ) {\r\n\r\n\t\tthis.x *= scalar;\r\n\t\tthis.y *= scalar;\r\n\t\tthis.z *= scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x * b.x;\r\n\t\tthis.y = a.y * b.y;\r\n\t\tthis.z = a.z * b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyEuler: function () {\r\n\r\n\t\tvar quaternion = new Quaternion();\r\n\r\n\t\treturn function applyEuler( euler ) {\r\n\r\n\t\t\tif ( ! ( euler && euler.isEuler ) ) {\r\n\r\n\t\t\t\tconsole.error( 'COOL.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.applyQuaternion( quaternion.setFromEuler( euler ) );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyAxisAngle: function () {\r\n\r\n\t\tvar quaternion = new Quaternion();\r\n\r\n\t\treturn function applyAxisAngle( axis, angle ) {\r\n\r\n\t\t\treturn this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyMatrix3: function ( m ) {\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\r\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\r\n\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( m ) {\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\tvar e = m.elements;\r\n\r\n\t\tvar w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );\r\n\r\n\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;\r\n\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;\r\n\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyQuaternion: function ( q ) {\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\tvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;\r\n\r\n\t\t// calculate quat * vector\r\n\r\n\t\tvar ix = qw * x + qy * z - qz * y;\r\n\t\tvar iy = qw * y + qz * x - qx * z;\r\n\t\tvar iz = qw * z + qx * y - qy * x;\r\n\t\tvar iw = - qx * x - qy * y - qz * z;\r\n\r\n\t\t// calculate result * inverse quat\r\n\r\n\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\r\n\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\r\n\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tproject: function ( camera ) {\r\n\r\n\t\treturn this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );\r\n\r\n\t},\r\n\r\n\tunproject: function () {\r\n\r\n\t\tvar matrix = new Matrix4();\r\n\r\n\t\treturn function unproject( camera ) {\r\n\r\n\t\t\treturn this.applyMatrix4( matrix.getInverse( camera.projectionMatrix ) ).applyMatrix4( camera.matrixWorld );\r\n            // return this.applyMatrix4( matrix.getInverse( camera.VPmatrix ) ); \r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttransformDirection: function ( m ) {\r\n\r\n\t\t// input: COOL.Matrix4 affine matrix\r\n\t\t// vector interpreted as a direction\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\r\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\r\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\r\n\r\n\t\treturn this.normalize();\r\n\r\n\t},\r\n\r\n\tdivide: function ( v ) {\r\n\r\n\t\tthis.x /= v.x;\r\n\t\tthis.y /= v.y;\r\n\t\tthis.z /= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( scalar ) {\r\n\r\n\t\treturn this.multiplyScalar( 1 / scalar );\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tthis.x = Math.min( this.x, v.x );\r\n\t\tthis.y = Math.min( this.y, v.y );\r\n\t\tthis.z = Math.min( this.z, v.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tthis.x = Math.max( this.x, v.x );\r\n\t\tthis.y = Math.max( this.y, v.y );\r\n\t\tthis.z = Math.max( this.z, v.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// assumes min < max, componentwise\r\n\r\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclampScalar: function () {\r\n\r\n\t\tvar min = new Vector3();\r\n\t\tvar max = new Vector3();\r\n\r\n\t\treturn function clampScalar( minVal, maxVal ) {\r\n\r\n\t\t\tmin.set( minVal, minVal, minVal );\r\n\t\t\tmax.set( maxVal, maxVal, maxVal );\r\n\r\n\t\t\treturn this.clamp( min, max );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclampLength: function ( min, max ) {\r\n\r\n\t\tvar length = this.length();\r\n\r\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\r\n\r\n\t},\r\n\r\n\tfloor: function () {\r\n\r\n\t\tthis.x = Math.floor( this.x );\r\n\t\tthis.y = Math.floor( this.y );\r\n\t\tthis.z = Math.floor( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tceil: function () {\r\n\r\n\t\tthis.x = Math.ceil( this.x );\r\n\t\tthis.y = Math.ceil( this.y );\r\n\t\tthis.z = Math.ceil( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tround: function () {\r\n\r\n\t\tthis.x = Math.round( this.x );\r\n\t\tthis.y = Math.round( this.y );\r\n\t\tthis.z = Math.round( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\troundToZero: function () {\r\n\r\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.x = - this.x;\r\n\t\tthis.y = - this.y;\r\n\t\tthis.z = - this.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\r\n\r\n\t},\r\n\r\n\t// TODO lengthSquared?\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\r\n\r\n\t},\r\n\r\n\tmanhattanLength: function () {\r\n\r\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() || 1 );\r\n\r\n\t},\r\n\r\n\tsetLength: function ( length ) {\r\n\r\n\t\treturn this.normalize().multiplyScalar( length );\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerpVectors: function ( v1, v2, alpha ) {\r\n\r\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n\t},\r\n\r\n\tcross: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\r\n\t\t\treturn this.crossVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.crossVectors( this, v );\r\n\r\n\t},\r\n\r\n\tcrossVectors: function ( a, b ) {\r\n\r\n\t\tvar ax = a.x, ay = a.y, az = a.z;\r\n\t\tvar bx = b.x, by = b.y, bz = b.z;\r\n\r\n\t\tthis.x = ay * bz - az * by;\r\n\t\tthis.y = az * bx - ax * bz;\r\n\t\tthis.z = ax * by - ay * bx;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tprojectOnVector: function ( vector ) {\r\n\r\n\t\tvar scalar = vector.dot( this ) / vector.lengthSq();\r\n\r\n\t\treturn this.copy( vector ).multiplyScalar( scalar );\r\n\r\n\t},\r\n\r\n\tprojectOnPlane: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function projectOnPlane( planeNormal ) {\r\n\r\n\t\t\tv1.copy( this ).projectOnVector( planeNormal );\r\n\r\n\t\t\treturn this.sub( v1 );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\treflect: function () {\r\n\r\n\t\t// reflect incident vector off plane orthogonal to normal\r\n\t\t// normal is assumed to have unit length\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function reflect( normal ) {\r\n\r\n\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tangleTo: function ( v ) {\r\n\r\n\t\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\r\n\r\n\t\t// clamp, to handle numerical problems\r\n\r\n\t\treturn Math.acos( _Math.clamp( theta, - 1, 1 ) );\r\n\r\n\t},\r\n\r\n\tdistanceTo: function ( v ) {\r\n\r\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n\t},\r\n\r\n\tdistanceToSquared: function ( v ) {\r\n\r\n\t\tvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\r\n\r\n\t\treturn dx * dx + dy * dy + dz * dz;\r\n\r\n\t},\r\n\r\n\tmanhattanDistanceTo: function ( v ) {\r\n\r\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\r\n\r\n\t},\r\n\r\n\tsetFromSpherical: function ( s ) {\r\n\r\n\t\treturn this.setFromSphericalCoords( s.radius, s.phi, s.theta );\r\n\r\n\t},\r\n\r\n\tsetFromSphericalCoords: function ( radius, phi, theta ) {\r\n\r\n\t\tvar sinPhiRadius = Math.sin( phi ) * radius;\r\n\r\n\t\tthis.x = sinPhiRadius * Math.sin( theta );\r\n\t\tthis.y = Math.cos( phi ) * radius;\r\n\t\tthis.z = sinPhiRadius * Math.cos( theta );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCylindrical: function ( c ) {\r\n\r\n\t\treturn this.setFromCylindricalCoords( c.radius, c.theta, c.y );\r\n\r\n\t},\r\n\r\n\tsetFromCylindricalCoords: function ( radius, theta, y ) {\r\n\r\n\t\tthis.x = radius * Math.sin( theta );\r\n\t\tthis.y = y;\r\n\t\tthis.z = radius * Math.cos( theta );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrixPosition: function ( m ) {\r\n\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 12 ];\r\n\t\tthis.y = e[ 13 ];\r\n\t\tthis.z = e[ 14 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrixScale: function ( m ) {\r\n\r\n\t\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\r\n\t\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\r\n\t\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\r\n\r\n\t\tthis.x = sx;\r\n\t\tthis.y = sy;\r\n\t\tthis.z = sz;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrixColumn: function ( m, index ) {\r\n\r\n\t\treturn this.fromArray( m.elements, index * 4 );\r\n\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\r\n\r\n\t},\r\n\r\n    rotateByVector :function(vec1, vec2, angle) {\r\n        var v1 = vec1.toArray();\r\n        var v2 = vec2.toArray();\r\n        angle = - angle;\r\n        var pos = [];\r\n        pos[0] = v1[0] * Math.cos(angle) + (v2[1] * v1[2] - v2[2] * v1[1]) * Math.sin(angle) + v2[0] * (v2[0] * v1[0] + v2[1] * v1[1] + v2[2] * v1[2]) * (1 - Math.cos(angle));\r\n        pos[1] = v1[1] * Math.cos(angle) + (v2[2] * v1[0] - v2[0] * v1[2]) * Math.sin(angle) + v2[1] * (v2[0] * v1[0] + v2[1] * v1[1] + v2[2] * v1[2]) * (1 - Math.cos(angle));\r\n        pos[2] = v1[2] * Math.cos(angle) + (v2[0] * v1[1] - v2[1] * v1[0]) * Math.sin(angle) + v2[2] * (v2[0] * v1[0] + v2[1] * v1[1] + v2[2] * v1[2]) * (1 - Math.cos(angle));\r\n        return new Vector3().fromArray(pos);\r\n    },\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.x = array[ offset ];\r\n\t\tthis.y = array[ offset + 1 ];\r\n\t\tthis.z = array[ offset + 2 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this.x;\r\n\t\tarray[ offset + 1 ] = this.y;\r\n\t\tarray[ offset + 2 ] = this.z;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tfromBufferAttribute: function ( attribute, index, offset ) {\r\n\r\n\t\tif ( offset !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Vector3: offset has been removed from .fromBufferAttribute().' );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x = attribute.getX( index );\r\n\t\tthis.y = attribute.getY( index );\r\n\t\tthis.z = attribute.getZ( index );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/math/Box3.js\n\r\n\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nfunction Box3( min, max ) {\r\n\r\n\tthis.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );\r\n\tthis.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );\r\n\r\n}\r\n\r\nObject.assign( Box3.prototype, {\r\n\r\n\tisBox3: true,\r\n\r\n\tset: function ( min, max ) {\r\n\r\n\t\tthis.min.copy( min );\r\n\t\tthis.max.copy( max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromArray: function ( array ) {\r\n\r\n\t\tvar minX = + Infinity;\r\n\t\tvar minY = + Infinity;\r\n\t\tvar minZ = + Infinity;\r\n\r\n\t\tvar maxX = - Infinity;\r\n\t\tvar maxY = - Infinity;\r\n\t\tvar maxZ = - Infinity;\r\n\r\n\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\r\n\r\n\t\t\tvar x = array[ i ];\r\n\t\t\tvar y = array[ i + 1 ];\r\n\t\t\tvar z = array[ i + 2 ];\r\n\r\n\t\t\tif ( x < minX ) minX = x;\r\n\t\t\tif ( y < minY ) minY = y;\r\n\t\t\tif ( z < minZ ) minZ = z;\r\n\r\n\t\t\tif ( x > maxX ) maxX = x;\r\n\t\t\tif ( y > maxY ) maxY = y;\r\n\t\t\tif ( z > maxZ ) maxZ = z;\r\n\r\n\t\t}\r\n\r\n\t\tthis.min.set( minX, minY, minZ );\r\n\t\tthis.max.set( maxX, maxY, maxZ );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromBufferAttribute: function ( attribute ) {\r\n\r\n\t\tvar minX = + Infinity;\r\n\t\tvar minY = + Infinity;\r\n\t\tvar minZ = + Infinity;\r\n\r\n\t\tvar maxX = - Infinity;\r\n\t\tvar maxY = - Infinity;\r\n\t\tvar maxZ = - Infinity;\r\n\r\n\t\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\r\n\r\n\t\t\tvar x = attribute.getX( i );\r\n\t\t\tvar y = attribute.getY( i );\r\n\t\t\tvar z = attribute.getZ( i );\r\n\r\n\t\t\tif ( x < minX ) minX = x;\r\n\t\t\tif ( y < minY ) minY = y;\r\n\t\t\tif ( z < minZ ) minZ = z;\r\n\r\n\t\t\tif ( x > maxX ) maxX = x;\r\n\t\t\tif ( y > maxY ) maxY = y;\r\n\t\t\tif ( z > maxZ ) maxZ = z;\r\n\r\n\t\t}\r\n\r\n\t\tthis.min.set( minX, minY, minZ );\r\n\t\tthis.max.set( maxX, maxY, maxZ );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function ( points ) {\r\n\r\n\t\tthis.makeEmpty();\r\n\r\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.expandByPoint( points[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCenterAndSize: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function setFromCenterAndSize( center, size ) {\r\n\r\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\r\n\t\t\tthis.min.copy( center ).sub( halfSize );\r\n\t\t\tthis.max.copy( center ).add( halfSize );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetFromObject: function ( object ) {\r\n\r\n\t\tthis.makeEmpty();\r\n\r\n\t\treturn this.expandByObject( object );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( box ) {\r\n\r\n\t\tthis.min.copy( box.min );\r\n\t\tthis.max.copy( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeEmpty: function () {\r\n\r\n\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\r\n\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tisEmpty: function () {\r\n\r\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\r\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\r\n\r\n\t},\r\n\r\n\tgetCenter: function ( target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Box3: .getCenter() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\r\n\t},\r\n\r\n\tgetSize: function ( target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Box3: .getSize() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );\r\n\r\n\t},\r\n\r\n\texpandByPoint: function ( point ) {\r\n\r\n\t\tthis.min.min( point );\r\n\t\tthis.max.max( point );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByVector: function ( vector ) {\r\n\r\n\t\tthis.min.sub( vector );\r\n\t\tthis.max.add( vector );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByScalar: function ( scalar ) {\r\n\r\n\t\tthis.min.addScalar( - scalar );\r\n\t\tthis.max.addScalar( scalar );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByObject: function () {\r\n\r\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\r\n\t\t// accounting for both the object's, and children's, world transforms\r\n\r\n\t\tvar scope, i, l;\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\tfunction traverse( node ) {\r\n\r\n\t\t\tvar geometry = node.geometry;\r\n\r\n\t\t\tif ( geometry !== undefined ) {\r\n\r\n\t\t\t\tif ( geometry.isGeometry ) {\r\n\r\n\t\t\t\t\tvar vertices = geometry.vertices;\r\n\r\n\t\t\t\t\tfor ( i = 0, l = vertices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\tv1.copy( vertices[ i ] );\r\n\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\r\n\r\n\t\t\t\t\t\tscope.expandByPoint( v1 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( geometry.isBufferGeometry ) {\r\n\r\n\t\t\t\t\tvar attribute = geometry.attributes.position;\r\n\r\n\t\t\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\t\t\tfor ( i = 0, l = attribute.count; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tv1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );\r\n\r\n\t\t\t\t\t\t\tscope.expandByPoint( v1 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn function expandByObject( object ) {\r\n\r\n\t\t\tscope = this;\r\n\r\n\t\t\tobject.updateMatrixWorld( true );\r\n\r\n\t\t\tobject.traverse( traverse );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\treturn point.x < this.min.x || point.x > this.max.x ||\r\n\t\t\tpoint.y < this.min.y || point.y > this.max.y ||\r\n\t\t\tpoint.z < this.min.z || point.z > this.max.z ? false : true;\r\n\r\n\t},\r\n\r\n\tcontainsBox: function ( box ) {\r\n\r\n\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\r\n\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y &&\r\n\t\t\tthis.min.z <= box.min.z && box.max.z <= this.max.z;\r\n\r\n\t},\r\n\r\n\tgetParameter: function ( point, target ) {\r\n\r\n\t\t// This can potentially have a divide by zero if the box\r\n\t\t// has a size dimension of 0.\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Box3: .getParameter() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\treturn target.set(\r\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\r\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\r\n\t\t);\r\n\r\n\t},\r\n\r\n\tintersectsBox: function ( box ) {\r\n\r\n\t\t// using 6 splitting planes to rule out intersections.\r\n\t\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\r\n\t\t\tbox.max.y < this.min.y || box.min.y > this.max.y ||\r\n\t\t\tbox.max.z < this.min.z || box.min.z > this.max.z ? false : true;\r\n\r\n\t},\r\n\r\n\tintersectsSphere: ( function () {\r\n\r\n\t\tvar closestPoint = new Vector3();\r\n\r\n\t\treturn function intersectsSphere( sphere ) {\r\n\r\n\t\t\t// Find the point on the AABB closest to the sphere center.\r\n\t\t\tthis.clampPoint( sphere.center, closestPoint );\r\n\r\n\t\t\t// If that point is inside the sphere, the AABB and sphere intersect.\r\n\t\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n\tintersectsPlane: function ( plane ) {\r\n\r\n\t\t// We compute the minimum and maximum dot product values. If those values\r\n\t\t// are on the same side (back or front) of the plane, then there is no intersection.\r\n\r\n\t\tvar min, max;\r\n\r\n\t\tif ( plane.normal.x > 0 ) {\r\n\r\n\t\t\tmin = plane.normal.x * this.min.x;\r\n\t\t\tmax = plane.normal.x * this.max.x;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmin = plane.normal.x * this.max.x;\r\n\t\t\tmax = plane.normal.x * this.min.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( plane.normal.y > 0 ) {\r\n\r\n\t\t\tmin += plane.normal.y * this.min.y;\r\n\t\t\tmax += plane.normal.y * this.max.y;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmin += plane.normal.y * this.max.y;\r\n\t\t\tmax += plane.normal.y * this.min.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( plane.normal.z > 0 ) {\r\n\r\n\t\t\tmin += plane.normal.z * this.min.z;\r\n\t\t\tmax += plane.normal.z * this.max.z;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmin += plane.normal.z * this.max.z;\r\n\t\t\tmax += plane.normal.z * this.min.z;\r\n\r\n\t\t}\r\n\r\n\t\treturn ( min <= - plane.constant && max >= - plane.constant );\r\n\r\n\t},\r\n\r\n\tintersectsTriangle: ( function () {\r\n\r\n\t\t// triangle centered vertices\r\n\t\tvar v0 = new Vector3();\r\n\t\tvar v1 = new Vector3();\r\n\t\tvar v2 = new Vector3();\r\n\r\n\t\t// triangle edge vectors\r\n\t\tvar f0 = new Vector3();\r\n\t\tvar f1 = new Vector3();\r\n\t\tvar f2 = new Vector3();\r\n\r\n\t\tvar testAxis = new Vector3();\r\n\r\n\t\tvar center = new Vector3();\r\n\t\tvar extents = new Vector3();\r\n\r\n\t\tvar triangleNormal = new Vector3();\r\n\r\n\t\tfunction satForAxes( axes ) {\r\n\r\n\t\t\tvar i, j;\r\n\r\n\t\t\tfor ( i = 0, j = axes.length - 3; i <= j; i += 3 ) {\r\n\r\n\t\t\t\ttestAxis.fromArray( axes, i );\r\n\t\t\t\t// project the aabb onto the seperating axis\r\n\t\t\t\tvar r = extents.x * Math.abs( testAxis.x ) + extents.y * Math.abs( testAxis.y ) + extents.z * Math.abs( testAxis.z );\r\n\t\t\t\t// project all 3 vertices of the triangle onto the seperating axis\r\n\t\t\t\tvar p0 = v0.dot( testAxis );\r\n\t\t\t\tvar p1 = v1.dot( testAxis );\r\n\t\t\t\tvar p2 = v2.dot( testAxis );\r\n\t\t\t\t// actual test, basically see if either of the most extreme of the triangle points intersects r\r\n\t\t\t\tif ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\r\n\r\n\t\t\t\t\t// points of the projected triangle are outside the projected half-length of the aabb\r\n\t\t\t\t\t// the axis is seperating and we can exit\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn function intersectsTriangle( triangle ) {\r\n\r\n\t\t\tif ( this.isEmpty() ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// compute box center and extents\r\n\t\t\tthis.getCenter( center );\r\n\t\t\textents.subVectors( this.max, center );\r\n\r\n\t\t\t// translate triangle to aabb origin\r\n\t\t\tv0.subVectors( triangle.a, center );\r\n\t\t\tv1.subVectors( triangle.b, center );\r\n\t\t\tv2.subVectors( triangle.c, center );\r\n\r\n\t\t\t// compute edge vectors for triangle\r\n\t\t\tf0.subVectors( v1, v0 );\r\n\t\t\tf1.subVectors( v2, v1 );\r\n\t\t\tf2.subVectors( v0, v2 );\r\n\r\n\t\t\t// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\r\n\t\t\t// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\r\n\t\t\t// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\r\n\t\t\tvar axes = [\r\n\t\t\t\t0, - f0.z, f0.y, 0, - f1.z, f1.y, 0, - f2.z, f2.y,\r\n\t\t\t\tf0.z, 0, - f0.x, f1.z, 0, - f1.x, f2.z, 0, - f2.x,\r\n\t\t\t\t- f0.y, f0.x, 0, - f1.y, f1.x, 0, - f2.y, f2.x, 0\r\n\t\t\t];\r\n\t\t\tif ( ! satForAxes( axes ) ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// test 3 face normals from the aabb\r\n\t\t\taxes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];\r\n\t\t\tif ( ! satForAxes( axes ) ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// finally testing the face normal of the triangle\r\n\t\t\t// use already existing triangle edge vectors here\r\n\t\t\ttriangleNormal.crossVectors( f0, f1 );\r\n\t\t\taxes = [ triangleNormal.x, triangleNormal.y, triangleNormal.z ];\r\n\t\t\treturn satForAxes( axes );\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n\tclampPoint: function ( point, target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Box3: .clampPoint() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\treturn target.copy( point ).clamp( this.min, this.max );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function distanceToPoint( point ) {\r\n\r\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n\t\t\treturn clampedPoint.sub( point ).length();\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetBoundingSphere: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function getBoundingSphere( target ) {\r\n\r\n\t\t\tif ( target === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'COOL.Box3: .getBoundingSphere() target is now required' );\r\n\t\t\t\ttarget = new Sphere();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.getCenter( target.center );\r\n\r\n\t\t\ttarget.radius = this.getSize( v1 ).length() * 0.5;\r\n\r\n\t\t\treturn target;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersect: function ( box ) {\r\n\r\n\t\tthis.min.max( box.min );\r\n\t\tthis.max.min( box.max );\r\n\r\n\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\r\n\t\tif ( this.isEmpty() ) this.makeEmpty();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tunion: function ( box ) {\r\n\r\n\t\tthis.min.min( box.min );\r\n\t\tthis.max.max( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function () {\r\n\r\n\t\tvar points = [\r\n\t\t\tnew Vector3(),\r\n\t\t\tnew Vector3(),\r\n\t\t\tnew Vector3(),\r\n\t\t\tnew Vector3(),\r\n\t\t\tnew Vector3(),\r\n\t\t\tnew Vector3(),\r\n\t\t\tnew Vector3(),\r\n\t\t\tnew Vector3()\r\n\t\t];\r\n\r\n\t\treturn function applyMatrix4( matrix ) {\r\n\r\n\t\t\t// transform of empty box is an empty box.\r\n\t\t\tif ( this.isEmpty() ) return this;\r\n\r\n\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\r\n\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\r\n\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\r\n\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\r\n\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\r\n\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\r\n\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\r\n\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\r\n\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111\r\n\r\n\t\t\tthis.setFromPoints( points );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.min.add( offset );\r\n\t\tthis.max.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( box ) {\r\n\r\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/math/Sphere.js\n\r\n\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nfunction Sphere( center, radius ) {\r\n\r\n\tthis.center = ( center !== undefined ) ? center : new Vector3();\r\n\tthis.radius = ( radius !== undefined ) ? radius : 0;\r\n\r\n}\r\n\r\nObject.assign( Sphere.prototype, {\r\n\r\n\tset: function ( center, radius ) {\r\n\r\n\t\tthis.center.copy( center );\r\n\t\tthis.radius = radius;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function () {\r\n\r\n\t\tvar box = new Box3();\r\n\r\n\t\treturn function setFromPoints( points, optionalCenter ) {\r\n\r\n\t\t\tvar center = this.center;\r\n\r\n\t\t\tif ( optionalCenter !== undefined ) {\r\n\r\n\t\t\t\tcenter.copy( optionalCenter );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbox.setFromPoints( points ).getCenter( center );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar maxRadiusSq = 0;\r\n\r\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( sphere ) {\r\n\r\n\t\tthis.center.copy( sphere.center );\r\n\t\tthis.radius = sphere.radius;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tempty: function () {\r\n\r\n\t\treturn ( this.radius <= 0 );\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function ( point ) {\r\n\r\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\r\n\r\n\t},\r\n\r\n\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\tvar radiusSum = this.radius + sphere.radius;\r\n\r\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\r\n\r\n\t},\r\n\r\n\tintersectsBox: function ( box ) {\r\n\r\n\t\treturn box.intersectsSphere( this );\r\n\r\n\t},\r\n\r\n\tintersectsPlane: function ( plane ) {\r\n\r\n\t\treturn Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;\r\n\r\n\t},\r\n\r\n\tclampPoint: function ( point, target ) {\r\n\r\n\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Sphere: .clampPoint() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\ttarget.copy( point );\r\n\r\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\r\n\r\n\t\t\ttarget.sub( this.center ).normalize();\r\n\t\t\ttarget.multiplyScalar( this.radius ).add( this.center );\r\n\r\n\t\t}\r\n\r\n\t\treturn target;\r\n\r\n\t},\r\n\r\n\tgetBoundingBox: function ( target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Sphere: .getBoundingBox() target is now required' );\r\n\t\t\ttarget = new Box3();\r\n\r\n\t\t}\r\n\r\n\t\ttarget.set( this.center, this.center );\r\n\t\ttarget.expandByScalar( this.radius );\r\n\r\n\t\treturn target;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( matrix ) {\r\n\r\n\t\tthis.center.applyMatrix4( matrix );\r\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.center.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( sphere ) {\r\n\r\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/core/Geometry.js\n\r\n\r\n\r\n\r\nclass Geometry_Geometry {\r\n    constructor(param) {\r\n        param = param || {};\r\n\r\n        // Create a cube\r\n        //    v6----- v5\r\n        //   /|      /|\r\n        //  v1------v0|\r\n        //  | |     | |\r\n        //  | |v7---|-|v4\r\n        //  |/      |/\r\n        //  v2------v3\r\n\r\n        this.uv = param.uv || new Float32Array([   // Vertex coordinates\r\n\r\n            1,1, 0,1, 0,0, 1,0,  // v0-v1-v2-v3 front\r\n            0,1, 0,0, 1,0, 1,1,  // v0-v3-v4-v5 right\r\n            1,0, 1,1, 0,1, 0,0,  // v0-v5-v6-v1 up\r\n            1,1, 0,1, 0,0, 1,0,  // v1-v6-v7-v2 left\r\n            0,1, 1,1, 1,0, 0,0,  // v7-v4-v3-v2 down\r\n            1,0, 0,0, 0,1, 1,1   // v4-v7-v6-v5 back\r\n\r\n        ]);\r\n\r\n        this.vertices = param.vertices || new Float32Array([   // Vertex coordinates\r\n            0.5, 0.5, 0.5,  -0.5, 0.5, 0.5,  -0.5,-0.5, 0.5,   0.5,-0.5, 0.5,  // v0-v1-v2-v3 front\r\n            0.5, 0.5, 0.5,   0.5,-0.5, 0.5,   0.5,-0.5,-0.5,   0.5, 0.5,-0.5,  // v0-v3-v4-v5 right\r\n            0.5, 0.5, 0.5,   0.5, 0.5,-0.5,  -0.5, 0.5,-0.5,  -0.5, 0.5, 0.5,  // v0-v5-v6-v1 up\r\n            -0.5, 0.5, 0.5,  -0.5, 0.5,-0.5,  -0.5,-0.5,-0.5,  -0.5,-0.5, 0.5,  // v1-v6-v7-v2 left\r\n            -0.5,-0.5,-0.5,   0.5,-0.5,-0.5,   0.5,-0.5, 0.5,  -0.5,-0.5, 0.5,  // v7-v4-v3-v2 down\r\n            0.5,-0.5,-0.5,  -0.5,-0.5,-0.5,  -0.5, 0.5,-0.5,   0.5, 0.5,-0.5   // v4-v7-v6-v5 back\r\n        ]);\r\n\r\n        this.normal = param.normal || this.vertices;\r\n\r\n        if(param.indices){\r\n            this.indices = new Uint16Array(param.indices);\r\n        }else{\r\n            var indicesArray = [];\r\n            for(var i=0; i<param.vertices.length/3; i++){\r\n                indicesArray.push(i);\r\n            }\r\n            this.indices = new Uint16Array(indicesArray);\r\n        }\r\n\r\n\r\n        this.morphAttributes = param.morphAttributes;\r\n\r\n        this.boundingSphere = new Sphere();\r\n        this.boundingBox = new Box3();\r\n        this.computeBoundingBox();\r\n\r\n        // this.updateNormal();\r\n\r\n        this.updataBuffer();\r\n\r\n    }\r\n\r\n    updataBuffer(){\r\n        var buffer = [];\r\n        var uv = this.uv;\r\n        var vertices = this.vertices;\r\n        var normal = this.normal;\r\n        for(var i=0; i<vertices.length; i+=3){\r\n            buffer.push(vertices[i+0]);\r\n            buffer.push(vertices[i+1]);\r\n            buffer.push(vertices[i+2]);\r\n\r\n            buffer.push(normal[i+0]);\r\n            buffer.push(normal[i+1]);\r\n            buffer.push(normal[i+2]);\r\n\r\n            buffer.push(uv[i/3*2+0]);\r\n            buffer.push(uv[i/3*2+1]);\r\n        }\r\n\r\n        this.buffer = new Float32Array(buffer);\r\n    }\r\n\r\n    updateNormal(){\r\n        var normal = [];\r\n        var vertices = this.vertices;\r\n        for(var i=0; i<vertices.length; i+=3*4){\r\n            var line1 = new Vector3().subVectors(\r\n                new Vector3(vertices[i+0], vertices[i+1], vertices[i+2]),\r\n                new Vector3(vertices[i+3], vertices[i+4], vertices[i+5])\r\n            );\r\n            var line2 = new Vector3().subVectors(\r\n                new Vector3(vertices[i+3], vertices[i+4], vertices[i+5]),\r\n                new Vector3(vertices[i+6], vertices[i+7], vertices[i+8]),\r\n            );\r\n            var cur_normal = new Vector3().crossVectors(\r\n                line1,\r\n                line2\r\n            ).toArray();\r\n            for(var j=0 ;j<4; j++){\r\n                normal.push(cur_normal[0], cur_normal[1], cur_normal[2]);\r\n            }\r\n        }\r\n        this.normal = new Float32Array(normal);\r\n\r\n    }\r\n\r\n    computeBoundingBox () {\r\n        var verticesV3 = [];\r\n        for(var i=0; i<this.vertices.length; i+=3){\r\n            verticesV3.push(new Vector3(this.vertices[i], this.vertices[i+1], this.vertices[i+2]))\r\n        }\r\n        this.boundingBox.setFromPoints(verticesV3);\r\n    }\r\n\r\n    clone(){\r\n        var geometry = new Geometry_Geometry({\r\n            vertices: this.vertices.slice(0),\r\n            indices: this.indices.slice(0)\r\n        });\r\n\r\n        return geometry;\r\n    }\r\n}\r\n\r\n/* harmony default export */ var core_Geometry = (Geometry_Geometry);\r\n\n// CONCATENATED MODULE: ./src/core/BoxGeometry.js\n\r\n\r\n\r\n\r\nclass BoxGeometry_BoxGeometry {\r\n    constructor(param) {\r\n        param = param || {};\r\n\r\n        this.uv = param.uv || new Float32Array([   // Vertex coordinates\r\n\r\n            1,1, 0,1, 0,0, 1,0,  // v0-v1-v2-v3 front\r\n            0,1, 0,0, 1,0, 1,1,  // v0-v3-v4-v5 right\r\n            1,0, 1,1, 0,1, 0,0,  // v0-v5-v6-v1 up\r\n            1,1, 0,1, 0,0, 1,0,  // v1-v6-v7-v2 left\r\n            0,1, 1,1, 1,0, 0,0,  // v7-v4-v3-v2 down\r\n            1,0, 0,0, 0,1, 1,1   // v4-v7-v6-v5 back\r\n\r\n        ]);\r\n\r\n        this.vertices = param.indices || new Float32Array([   // Vertex coordinates\r\n            0.5, 0.5, 0.5,  -0.5, 0.5, 0.5,  -0.5,-0.5, 0.5,   0.5,-0.5, 0.5,  // v0-v1-v2-v3 front\r\n            0.5, 0.5, 0.5,   0.5,-0.5, 0.5,   0.5,-0.5,-0.5,   0.5, 0.5,-0.5,  // v0-v3-v4-v5 right\r\n            0.5, 0.5, 0.5,   0.5, 0.5,-0.5,  -0.5, 0.5,-0.5,  -0.5, 0.5, 0.5,  // v0-v5-v6-v1 up\r\n            -0.5, 0.5, 0.5,  -0.5, 0.5,-0.5,  -0.5,-0.5,-0.5,  -0.5,-0.5, 0.5,  // v1-v6-v7-v2 left\r\n            -0.5,-0.5,-0.5,   0.5,-0.5,-0.5,   0.5,-0.5, 0.5,  -0.5,-0.5, 0.5,  // v7-v4-v3-v2 down\r\n            0.5,-0.5,-0.5,  -0.5,-0.5,-0.5,  -0.5, 0.5,-0.5,   0.5, 0.5,-0.5   // v4-v7-v6-v5 back\r\n        ]);\r\n\r\n        this.normal = param.normal || this.vertices;\r\n\r\n        this.indices = param.indices || new Uint16Array([       // Indices of the vertices\r\n            0, 1, 2,   0, 2, 3,    // front\r\n            4, 5, 6,   4, 6, 7,    // right\r\n            8, 9,10,   8,10,11,    // up\r\n            12,13,14,  12,14,15,    // left\r\n            16,17,18,  16,18,19,    // down\r\n            20,21,22,  20,22,23     // back\r\n        ]);\r\n\r\n        this.boundingSphere = new Sphere();\r\n        this.boundingBox = new Box3();\r\n        this.computeBoundingBox();\r\n        // this.computeBoundingSphere();\r\n\r\n        this.updateNormal();\r\n\r\n        this.updataBuffer();\r\n\r\n    }\r\n\r\n    updataBuffer(){\r\n        var buffer = [];\r\n        var uv = this.uv;\r\n        var vertices = this.vertices;\r\n        var normal = this.normal;\r\n        for(var i=0; i<vertices.length; i+=3){\r\n            buffer.push(vertices[i+0]);\r\n            buffer.push(vertices[i+1]);\r\n            buffer.push(vertices[i+2]);\r\n\r\n            buffer.push(normal[i+0]);\r\n            buffer.push(normal[i+1]);\r\n            buffer.push(normal[i+2]);\r\n\r\n            buffer.push(uv[i/3*2+0]);\r\n            buffer.push(uv[i/3*2+1]);\r\n        }\r\n\r\n        this.buffer = new Float32Array(buffer);\r\n    }\r\n\r\n    updateNormal(){\r\n        var normal = [];\r\n        var vertices = this.vertices;\r\n        for(var i=0; i<vertices.length; i+=3*4){\r\n            var line1 = new Vector3().subVectors(\r\n                new Vector3(vertices[i+0], vertices[i+1], vertices[i+2]),\r\n                new Vector3(vertices[i+3], vertices[i+4], vertices[i+5])\r\n            );\r\n            var line2 = new Vector3().subVectors(\r\n                new Vector3(vertices[i+3], vertices[i+4], vertices[i+5]),\r\n                new Vector3(vertices[i+6], vertices[i+7], vertices[i+8]),\r\n            );\r\n            var cur_normal = new Vector3().crossVectors(\r\n                line1,\r\n                line2\r\n            ).toArray();\r\n            for(var j=0 ;j<4; j++){\r\n                normal.push(cur_normal[0], cur_normal[1], cur_normal[2]);\r\n            }\r\n        }\r\n        this.normal = new Float32Array(normal);\r\n\r\n    }\r\n\r\n    computeBoundingSphere(){\r\n\r\n        // if ( this.boundingSphere === null ) {\r\n        //     this.boundingSphere = new Sphere();\r\n        // }\r\n        // this.boundingSphere.setFromPoints( this.vertices );\r\n    }\r\n\r\n    computeBoundingBox () {\r\n        var verticesV3 = [];\r\n        for(var i=0; i<this.vertices.length; i+=3){\r\n            verticesV3.push(new Vector3(this.vertices[i], this.vertices[i+1], this.vertices[i+2]))\r\n        }\r\n        this.boundingBox.setFromPoints(verticesV3);\r\n    }\r\n\r\n    clone(){\r\n        var geometry = new BoxGeometry_BoxGeometry({\r\n            vertices: this.vertices.slice(0),\r\n            indices: this.indices.slice(0)\r\n        });\r\n\r\n        return geometry;\r\n    }\r\n}\r\n\r\n/* harmony default export */ var core_BoxGeometry = (BoxGeometry_BoxGeometry);\r\n\n// CONCATENATED MODULE: ./src/material/Material.js\n\r\nclass Material {\r\n    constructor(param) {\r\n        param = param || {};\r\n        this.type = 'Material';\r\n        this.map = param.map;\r\n        this.envMap = param.envMap;\r\n        this.color = param.color || [1,1,1,1];\r\n        this.opacity = this.color[3];\r\n        if(this.color[3] && this.color[3]<1){\r\n            this.transparent = true;\r\n        }else {\r\n            this.transparent = false;\r\n        }\r\n        this.metalness = param.metalness == undefined ? 0.5 : param.metalness;\r\n\r\n        this.wireframe = param.wireframe == undefined ? false : param.wireframe;\r\n\r\n        var VSHADER_SOURCE =\r\n\r\n            'precision highp int;\\n' +\r\n            'precision highp float;\\n' +\r\n            'attribute vec4 a_Position;\\n' +\r\n            'uniform mat4 u_MvMatrix;\\n' +\r\n            'uniform mat4 u_PMatrix;\\n' +\r\n\r\n            '#ifdef USE_Shadow\\n' +\r\n            'uniform mat4 u_PMatrixFromLight;\\n' +\r\n            'varying vec4 v_PositionFromLight;\\n' +\r\n            '#endif\\n' +\r\n\r\n            'attribute vec2 a_TexCoord;\\n' +\r\n            'varying vec2 v_TexCoord;\\n' +\r\n            'attribute vec3 a_Normal;\\n' +\r\n            'varying vec3 v_Normal;\\n' +\r\n\r\n            '#ifdef USE_SColor\\n' +\r\n            'varying vec3 v_PositionV3;\\n' +\r\n            '#else\\n' +\r\n            '   #ifdef USE_envMap\\n' +\r\n            '   varying vec3 v_PositionV3;\\n' +\r\n            '   #endif\\n' +\r\n            '#endif\\n' +\r\n\r\n            'void main() {\\n' +\r\n            '  vec4 positionV4 = u_PMatrix * u_MvMatrix * a_Position;\\n' +\r\n            '  gl_Position = positionV4;\\n' +\r\n            '  v_TexCoord = a_TexCoord;\\n' +\r\n            '  v_Normal = mat3(u_MvMatrix) * a_Normal;\\n' +\r\n            // '  v_Normal = (u_MvMatrix * vec4(a_Normal, 0.0)).xyz;\\n' +\r\n            // '  v_Normal = a_Normal;\\n' +\r\n\r\n            '#ifdef USE_Shadow\\n' +\r\n            '  v_PositionFromLight = u_PMatrixFromLight * u_MvMatrix * a_Position;\\n' +\r\n            '#endif\\n' +\r\n\r\n            '#ifdef USE_SColor\\n' +\r\n            '  vec4 positionV4Rel = u_MvMatrix * a_Position;\\n' +\r\n            '  v_PositionV3 = positionV4Rel.xyz / positionV4Rel.w;\\n' +\r\n            '#else\\n' +\r\n            '   #ifdef USE_envMap\\n' +\r\n            '   vec4 positionV4Rel = u_MvMatrix * a_Position;\\n' +\r\n            '   v_PositionV3 = positionV4Rel.xyz / positionV4Rel.w;\\n' +\r\n            '   #endif\\n' +\r\n            '#endif\\n' +\r\n\r\n            '}\\n';\r\n\r\n        var FSHADER_SOURCE =\r\n            'precision highp int;\\n' +\r\n            'precision highp float;\\n' +\r\n            'uniform vec4 u_Color;\\n' +\r\n            'varying vec2 v_TexCoord;\\n' +\r\n            'varying vec3 v_Normal;\\n' +\r\n\r\n            'uniform float u_Metalness;\\n' +\r\n\r\n            '#ifdef USE_Map\\n' +\r\n            'uniform sampler2D u_Sampler;\\n' +\r\n            '#endif\\n' +\r\n\r\n            '#ifdef USE_envMap\\n' +\r\n            'uniform samplerCube u_envMap;\\n' +\r\n            '#endif\\n' +\r\n\r\n            '#ifdef USE_AmbientLight\\n' +\r\n            'uniform vec3 u_AmbientLight_Color;\\n' +\r\n            '#endif\\n' +\r\n\r\n            '#ifdef USE_DirectionalLight\\n' +\r\n            'uniform vec3 u_DirectionalLight_Direction;\\n' +\r\n            'uniform vec3 u_DirectionalLight_Color;\\n' +\r\n            '#endif\\n' +\r\n\r\n            '#ifdef USE_SColor\\n' +\r\n            'uniform vec3 u_Camera_Position;\\n' +\r\n            'varying vec3 v_PositionV3;\\n' +\r\n            '#else\\n' +\r\n            '   #ifdef USE_envMap\\n' +\r\n            '   uniform vec3 u_Camera_Position;\\n' +\r\n            '   varying vec3 v_PositionV3;\\n' +\r\n            '   #endif\\n' +\r\n            '#endif\\n' +\r\n\r\n            '#ifdef USE_Shadow\\n' +\r\n            'uniform sampler2D u_ShadowMap;\\n' +\r\n            'varying vec4 v_PositionFromLight;\\n' +\r\n\r\n            'float unpackDepth(const in vec4 rgbaDepth) {\\n' +\r\n            '  const vec4 bitShift = vec4(1.0, 1.0/256.0, 1.0/(256.0*256.0), 1.0/(256.0*256.0*256.0));\\n' +\r\n            '  float depth = dot(rgbaDepth, bitShift);\\n' + // Use dot() since the calculations is same\r\n            '  return depth;\\n' +\r\n            '}\\n' +\r\n\r\n            '#endif\\n' +\r\n\r\n            'void main() {\\n' +\r\n            '  vec4 color = u_Color;\\n' +\r\n            '  vec3 v_Normal0 = normalize(v_Normal);\\n' +\r\n\r\n            '#ifdef USE_Map\\n' +\r\n            '  color = texture2D(u_Sampler, v_TexCoord);\\n' +\r\n            '#endif\\n' +\r\n\r\n            '  vec3 colorV3 = color.rgb;\\n' +\r\n            '  float useLight = 0.0;\\n' +\r\n            '  vec3 finalColorV3 = colorV3.rgb;\\n' +\r\n\r\n            '#ifdef USE_AmbientLight\\n' +\r\n            '  vec3 A_color = colorV3 * u_AmbientLight_Color * 0.5;\\n' +\r\n            '  finalColorV3 = A_color;\\n' +\r\n            '  useLight = 1.0;\\n' +\r\n            '#endif\\n' +\r\n\r\n            '#ifdef USE_DirectionalLight\\n' +\r\n            '  float D_weight = max(dot(u_DirectionalLight_Direction, v_Normal0), 0.0);\\n' +\r\n            '  vec3 D_color = colorV3 * u_DirectionalLight_Color * D_weight * (1.0 - u_Metalness);\\n' +\r\n\r\n            '  if(useLight>0.5){\\n' +\r\n            '    finalColorV3 = finalColorV3 + D_color;\\n' +\r\n            '  }else{\\n' +\r\n            '    finalColorV3 = D_color;\\n' +\r\n            '  }\\n' +\r\n            '  useLight = 1.0;\\n' +\r\n            '#endif\\n' +\r\n\r\n            '#ifdef USE_SColor\\n' +\r\n            '  vec3 r = normalize( reflect(-u_DirectionalLight_Direction, v_Normal0) );\\n' +\r\n            '  vec3 v = normalize( u_Camera_Position - v_PositionV3 );\\n' +\r\n            '  float rdotv = max( dot(r ,v), 0.0 );\\n' +\r\n            '  float S_weight = pow( rdotv, 100.0 );\\n' +\r\n            '  vec3 S_color = colorV3 * u_DirectionalLight_Color * S_weight * u_Metalness;\\n' +\r\n\r\n            '  if(useLight>0.5){\\n' +\r\n            '    finalColorV3 = finalColorV3 + S_color;\\n' +\r\n            '  }else{\\n' +\r\n            '    finalColorV3 = S_color;\\n' +\r\n            '  }\\n' +\r\n            '  useLight = 1.0;\\n' +\r\n            '#endif\\n' +\r\n\r\n            '  color = vec4(finalColorV3, color.a);\\n' +\r\n\r\n            '#ifdef USE_envMap\\n' +\r\n            // '   vec3 v1 = normalize( u_Camera_Position - v_PositionV3 );\\n' +\r\n            // '   vec3 r1 = normalize( reflect(v1, v_Normal0) );\\n' +\r\n            '   vec3 v1 = u_Camera_Position - v_PositionV3;\\n' +\r\n            '   vec3 r1 = reflect(-v1, v_Normal0);\\n' +\r\n\r\n            '   vec4 envMapColor = textureCube(u_envMap, r1);\\n' +\r\n            // '   vec3 ref = v1 - 2.0 * dot(v_Normal0, v1) * v_Normal0;\\n'+\r\n            // '   vec4 envMapColor = textureCube(u_envMap, ref);\\n' +\r\n            '   color = vec4(envMapColor.rgb, color.a);\\n' +\r\n            '#endif\\n' +\r\n\r\n\r\n            '#ifdef USE_Shadow\\n' +\r\n            '  vec3 shadowCoord = (v_PositionFromLight.xyz/v_PositionFromLight.w)/2.0 + 0.5;\\n' +\r\n            '  vec4 rgbaDepth = texture2D(u_ShadowMap, shadowCoord.xy);\\n' +\r\n            '  float depth = unpackDepth(rgbaDepth);\\n' +\r\n            '  float visibility = (shadowCoord.z > depth + 0.0015) ? 0.7 : 1.0;\\n' +\r\n            '  color = vec4(color.rgb * visibility, color.a);\\n' +\r\n            '#endif\\n' +\r\n\r\n            '  gl_FragColor = color;\\n' +\r\n\r\n            '}\\n';\r\n\r\n        this.vshaderSource = VSHADER_SOURCE;\r\n        this.fshaderSource = FSHADER_SOURCE;\r\n    }\r\n\r\n    setOpacity(opacity){\r\n        this.opacity = opacity;\r\n        this.color[3] = opacity;\r\n        this.transparent = opacity<1;\r\n    }\r\n\r\n    clone(){\r\n\r\n        var material = new Material({\r\n            map: this.map,\r\n            color: this.color.slice(0)\r\n        });\r\n\r\n        return material;\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ var material_Material = (Material);\r\n\n// CONCATENATED MODULE: ./src/math/Euler.js\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nfunction Euler( x, y, z, order ) {\r\n\r\n\tthis._x = x || 0;\r\n\tthis._y = y || 0;\r\n\tthis._z = z || 0;\r\n\tthis._order = order || Euler.DefaultOrder;\r\n\r\n}\r\n\r\nEuler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\r\n\r\nEuler.DefaultOrder = 'XYZ';\r\n\r\nObject.defineProperties( Euler.prototype, {\r\n\r\n\tx: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this._x;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tthis._x = value;\r\n\t\t\tthis.onChangeCallback();\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ty: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this._y;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tthis._y = value;\r\n\t\t\tthis.onChangeCallback();\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tz: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this._z;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tthis._z = value;\r\n\t\t\tthis.onChangeCallback();\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\torder: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this._order;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tthis._order = value;\r\n\t\t\tthis.onChangeCallback();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\r\n\r\nObject.assign( Euler.prototype, {\r\n\r\n\tisEuler: true,\r\n\r\n\tset: function ( x, y, z, order ) {\r\n\r\n\t\tthis._x = x;\r\n\t\tthis._y = y;\r\n\t\tthis._z = z;\r\n\t\tthis._order = order || this._order;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\r\n\r\n\t},\r\n\r\n\tcopy: function ( euler ) {\r\n\r\n\t\tthis._x = euler._x;\r\n\t\tthis._y = euler._y;\r\n\t\tthis._z = euler._z;\r\n\t\tthis._order = euler._order;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromRotationMatrix: function ( m, order, update ) {\r\n\r\n\t\tvar clamp = _Math.clamp;\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tvar te = m.elements;\r\n\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\r\n\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\r\n\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\r\n\t\torder = order || this._order;\r\n\r\n\t\tif ( order === 'XYZ' ) {\r\n\r\n\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\r\n\t\t\t\tthis._z = Math.atan2( - m12, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\r\n\t\t\t\tthis._z = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'YXZ' ) {\r\n\r\n\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\r\n\t\t\t\tthis._z = Math.atan2( m21, m22 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\r\n\t\t\t\tthis._z = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'ZXY' ) {\r\n\r\n\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._y = Math.atan2( - m31, m33 );\r\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._y = 0;\r\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'ZYX' ) {\r\n\r\n\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( m32, m33 );\r\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = 0;\r\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'YZX' ) {\r\n\r\n\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( - m23, m22 );\r\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = 0;\r\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'XZY' ) {\r\n\r\n\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\r\n\t\t\t\tthis._y = Math.atan2( m13, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\r\n\t\t\t\tthis._y = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( 'COOL.Euler: .setFromRotationMatrix() given unsupported order: ' + order );\r\n\r\n\t\t}\r\n\r\n\t\tthis._order = order;\r\n\r\n\t\tif ( update !== false ) this.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromQuaternion: function () {\r\n\r\n\t\tvar matrix = new Matrix4();\r\n\r\n\t\treturn function setFromQuaternion( q, order, update ) {\r\n\r\n\t\t\tmatrix.makeRotationFromQuaternion( q );\r\n\r\n\t\t\treturn this.setFromRotationMatrix( matrix, order, update );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetFromVector3: function ( v, order ) {\r\n\r\n\t\treturn this.set( v.x, v.y, v.z, order || this._order );\r\n\r\n\t},\r\n\r\n\treorder: function () {\r\n\r\n\t\t// WARNING: this discards revolution information -bhouston\r\n\r\n\t\tvar q = new Quaternion();\r\n\r\n\t\treturn function reorder( newOrder ) {\r\n\r\n\t\t\tq.setFromEuler( this );\r\n\r\n\t\t\treturn this.setFromQuaternion( q, newOrder );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tequals: function ( euler ) {\r\n\r\n\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array ) {\r\n\r\n\t\tthis._x = array[ 0 ];\r\n\t\tthis._y = array[ 1 ];\r\n\t\tthis._z = array[ 2 ];\r\n\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this._x;\r\n\t\tarray[ offset + 1 ] = this._y;\r\n\t\tarray[ offset + 2 ] = this._z;\r\n\t\tarray[ offset + 3 ] = this._order;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\ttoVector3: function ( optionalResult ) {\r\n\r\n\t\tif ( optionalResult ) {\r\n\r\n\t\t\treturn optionalResult.set( this._x, this._y, this._z );\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn new Vector3( this._x, this._y, this._z );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tonChange: function ( callback ) {\r\n\r\n\t\tthis.onChangeCallback = callback;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tonChangeCallback: function () {}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/math/Vector2.js\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author egraether / http://egraether.com/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\nfunction Vector2( x, y ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\r\n}\r\n\r\nObject.defineProperties( Vector2.prototype, {\r\n\r\n\t\"width\": {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this.x;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tthis.x = value;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t\"height\": {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this.y;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tthis.y = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\r\n\r\nObject.assign( Vector2.prototype, {\r\n\r\n\tisVector2: true,\r\n\r\n\tset: function ( x, y ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetScalar: function ( scalar ) {\r\n\r\n\t\tthis.x = scalar;\r\n\t\tthis.y = scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.x, this.y );\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScaledVector: function ( v, s ) {\r\n\r\n\t\tthis.x += v.x * s;\r\n\t\tthis.y += v.y * s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubScalar: function ( s ) {\r\n\r\n\t\tthis.x -= s;\r\n\t\tthis.y -= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( v ) {\r\n\r\n\t\tthis.x *= v.x;\r\n\t\tthis.y *= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( scalar ) {\r\n\r\n\t\tthis.x *= scalar;\r\n\t\tthis.y *= scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivide: function ( v ) {\r\n\r\n\t\tthis.x /= v.x;\r\n\t\tthis.y /= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( scalar ) {\r\n\r\n\t\treturn this.multiplyScalar( 1 / scalar );\r\n\r\n\t},\r\n\r\n\tapplyMatrix3: function ( m ) {\r\n\r\n\t\tvar x = this.x, y = this.y;\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];\r\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tthis.x = Math.min( this.x, v.x );\r\n\t\tthis.y = Math.min( this.y, v.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tthis.x = Math.max( this.x, v.x );\r\n\t\tthis.y = Math.max( this.y, v.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// assumes min < max, componentwise\r\n\r\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclampScalar: function () {\r\n\r\n\t\tvar min = new Vector2();\r\n\t\tvar max = new Vector2();\r\n\r\n\t\treturn function clampScalar( minVal, maxVal ) {\r\n\r\n\t\t\tmin.set( minVal, minVal );\r\n\t\t\tmax.set( maxVal, maxVal );\r\n\r\n\t\t\treturn this.clamp( min, max );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclampLength: function ( min, max ) {\r\n\r\n\t\tvar length = this.length();\r\n\r\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\r\n\r\n\t},\r\n\r\n\tfloor: function () {\r\n\r\n\t\tthis.x = Math.floor( this.x );\r\n\t\tthis.y = Math.floor( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tceil: function () {\r\n\r\n\t\tthis.x = Math.ceil( this.x );\r\n\t\tthis.y = Math.ceil( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tround: function () {\r\n\r\n\t\tthis.x = Math.round( this.x );\r\n\t\tthis.y = Math.round( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\troundToZero: function () {\r\n\r\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.x = - this.x;\r\n\t\tthis.y = - this.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y;\r\n\r\n\t},\r\n\r\n\tcross: function ( v ) {\r\n\r\n\t\treturn this.x * v.y - this.y * v.x;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\r\n\r\n\t},\r\n\r\n\tmanhattanLength: function () {\r\n\r\n\t\treturn Math.abs( this.x ) + Math.abs( this.y );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() || 1 );\r\n\r\n\t},\r\n\r\n\tangle: function () {\r\n\r\n\t\t// computes the angle in radians with respect to the positive x-axis\r\n\r\n\t\tvar angle = Math.atan2( this.y, this.x );\r\n\r\n\t\tif ( angle < 0 ) angle += 2 * Math.PI;\r\n\r\n\t\treturn angle;\r\n\r\n\t},\r\n\r\n\tdistanceTo: function ( v ) {\r\n\r\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n\t},\r\n\r\n\tdistanceToSquared: function ( v ) {\r\n\r\n\t\tvar dx = this.x - v.x, dy = this.y - v.y;\r\n\t\treturn dx * dx + dy * dy;\r\n\r\n\t},\r\n\r\n\tmanhattanDistanceTo: function ( v ) {\r\n\r\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\r\n\r\n\t},\r\n\r\n\tsetLength: function ( length ) {\r\n\r\n\t\treturn this.normalize().multiplyScalar( length );\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerpVectors: function ( v1, v2, alpha ) {\r\n\r\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.x = array[ offset ];\r\n\t\tthis.y = array[ offset + 1 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this.x;\r\n\t\tarray[ offset + 1 ] = this.y;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tfromBufferAttribute: function ( attribute, index, offset ) {\r\n\r\n\t\tif ( offset !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Vector2: offset has been removed from .fromBufferAttribute().' );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x = attribute.getX( index );\r\n\t\tthis.y = attribute.getY( index );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trotateAround: function ( center, angle ) {\r\n\r\n\t\tvar c = Math.cos( angle ), s = Math.sin( angle );\r\n\r\n\t\tvar x = this.x - center.x;\r\n\t\tvar y = this.y - center.y;\r\n\r\n\t\tthis.x = x * c - y * s + center.x;\r\n\t\tthis.y = x * s + y * c + center.y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/math/Ray.js\n\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nfunction Ray( origin, direction ) {\r\n\r\n\tthis.origin = ( origin !== undefined ) ? origin : new Vector3();\r\n\tthis.direction = ( direction !== undefined ) ? direction : new Vector3();\r\n\r\n}\r\n\r\nObject.assign( Ray.prototype, {\r\n\r\n\tset: function ( origin, direction ) {\r\n\r\n\t\tthis.origin.copy( origin );\r\n\t\tthis.direction.copy( direction );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( ray ) {\r\n\r\n\t\tthis.origin.copy( ray.origin );\r\n\t\tthis.direction.copy( ray.direction );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tat: function ( t, target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Ray: .at() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\treturn target.copy( this.direction ).multiplyScalar( t ).add( this.origin );\r\n\r\n\t},\r\n\r\n\tlookAt: function ( v ) {\r\n\r\n\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trecast: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function recast( t ) {\r\n\r\n\t\t\tthis.origin.copy( this.at( t, v1 ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclosestPointToPoint: function ( point, target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Ray: .closestPointToPoint() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\ttarget.subVectors( point, this.origin );\r\n\r\n\t\tvar directionDistance = target.dot( this.direction );\r\n\r\n\t\tif ( directionDistance < 0 ) {\r\n\r\n\t\t\treturn target.copy( this.origin );\r\n\r\n\t\t}\r\n\r\n\t\treturn target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function ( point ) {\r\n\r\n\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\r\n\r\n\t},\r\n\r\n\tdistanceSqToPoint: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function distanceSqToPoint( point ) {\r\n\r\n\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\r\n\r\n\t\t\t// point behind the ray\r\n\r\n\t\t\tif ( directionDistance < 0 ) {\r\n\r\n\t\t\t\treturn this.origin.distanceToSquared( point );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\r\n\t\t\treturn v1.distanceToSquared( point );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tdistanceSqToSegment: function () {\r\n\r\n\t\tvar segCenter = new Vector3();\r\n\t\tvar segDir = new Vector3();\r\n\t\tvar diff = new Vector3();\r\n\r\n\t\treturn function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\r\n\r\n\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\r\n\t\t\t// It returns the min distance between the ray and the segment\r\n\t\t\t// defined by v0 and v1\r\n\t\t\t// It can also set two optional targets :\r\n\t\t\t// - The closest point on the ray\r\n\t\t\t// - The closest point on the segment\r\n\r\n\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\r\n\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\r\n\t\t\tdiff.copy( this.origin ).sub( segCenter );\r\n\r\n\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\r\n\t\t\tvar a01 = - this.direction.dot( segDir );\r\n\t\t\tvar b0 = diff.dot( this.direction );\r\n\t\t\tvar b1 = - diff.dot( segDir );\r\n\t\t\tvar c = diff.lengthSq();\r\n\t\t\tvar det = Math.abs( 1 - a01 * a01 );\r\n\t\t\tvar s0, s1, sqrDist, extDet;\r\n\r\n\t\t\tif ( det > 0 ) {\r\n\r\n\t\t\t\t// The ray and segment are not parallel.\r\n\r\n\t\t\t\ts0 = a01 * b1 - b0;\r\n\t\t\t\ts1 = a01 * b0 - b1;\r\n\t\t\t\textDet = segExtent * det;\r\n\r\n\t\t\t\tif ( s0 >= 0 ) {\r\n\r\n\t\t\t\t\tif ( s1 >= - extDet ) {\r\n\r\n\t\t\t\t\t\tif ( s1 <= extDet ) {\r\n\r\n\t\t\t\t\t\t\t// region 0\r\n\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\r\n\r\n\t\t\t\t\t\t\tvar invDet = 1 / det;\r\n\t\t\t\t\t\t\ts0 *= invDet;\r\n\t\t\t\t\t\t\ts1 *= invDet;\r\n\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t// region 1\r\n\r\n\t\t\t\t\t\t\ts1 = segExtent;\r\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// region 5\r\n\r\n\t\t\t\t\t\ts1 = - segExtent;\r\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( s1 <= - extDet ) {\r\n\r\n\t\t\t\t\t\t// region 4\r\n\r\n\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\r\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t} else if ( s1 <= extDet ) {\r\n\r\n\t\t\t\t\t\t// region 3\r\n\r\n\t\t\t\t\t\ts0 = 0;\r\n\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// region 2\r\n\r\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\r\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Ray and segment are parallel.\r\n\r\n\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\r\n\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( optionalPointOnRay ) {\r\n\r\n\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( optionalPointOnSegment ) {\r\n\r\n\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn sqrDist;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersectSphere: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function intersectSphere( sphere, target ) {\r\n\r\n\t\t\tv1.subVectors( sphere.center, this.origin );\r\n\t\t\tvar tca = v1.dot( this.direction );\r\n\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\r\n\t\t\tvar radius2 = sphere.radius * sphere.radius;\r\n\r\n\t\t\tif ( d2 > radius2 ) return null;\r\n\r\n\t\t\tvar thc = Math.sqrt( radius2 - d2 );\r\n\r\n\t\t\t// t0 = first intersect point - entrance on front of sphere\r\n\t\t\tvar t0 = tca - thc;\r\n\r\n\t\t\t// t1 = second intersect point - exit point on back of sphere\r\n\t\t\tvar t1 = tca + thc;\r\n\r\n\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\r\n\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\r\n\r\n\t\t\t// test to see if t0 is behind the ray:\r\n\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\r\n\t\t\t// in order to always return an intersect point that is in front of the ray.\r\n\t\t\tif ( t0 < 0 ) return this.at( t1, target );\r\n\r\n\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\r\n\t\t\treturn this.at( t0, target );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\treturn this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );\r\n\r\n\t},\r\n\r\n\tdistanceToPlane: function ( plane ) {\r\n\r\n\t\tvar denominator = plane.normal.dot( this.direction );\r\n\r\n\t\tif ( denominator === 0 ) {\r\n\r\n\t\t\t// line is coplanar, return origin\r\n\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\r\n\r\n\t\t\t\treturn 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\r\n\r\n\t\t// Return if the ray never intersects the plane\r\n\r\n\t\treturn t >= 0 ? t : null;\r\n\r\n\t},\r\n\r\n\tintersectPlane: function ( plane, target ) {\r\n\r\n\t\tvar t = this.distanceToPlane( plane );\r\n\r\n\t\tif ( t === null ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\treturn this.at( t, target );\r\n\r\n\t},\r\n\r\n\tintersectsPlane: function ( plane ) {\r\n\r\n\t\t// check if the ray lies on the plane first\r\n\r\n\t\tvar distToPoint = plane.distanceToPoint( this.origin );\r\n\r\n\t\tif ( distToPoint === 0 ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\tvar denominator = plane.normal.dot( this.direction );\r\n\r\n\t\tif ( denominator * distToPoint < 0 ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\t// ray origin is behind the plane (and is pointing behind it)\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tintersectBox: function ( box, target ) {\r\n\r\n\t\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\r\n\r\n\t\tvar invdirx = 1 / this.direction.x,\r\n\t\t\tinvdiry = 1 / this.direction.y,\r\n\t\t\tinvdirz = 1 / this.direction.z;\r\n\r\n\t\tvar origin = this.origin;\r\n\r\n\t\tif ( invdirx >= 0 ) {\r\n\r\n\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\r\n\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\r\n\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\r\n\r\n\t\t}\r\n\r\n\t\tif ( invdiry >= 0 ) {\r\n\r\n\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\r\n\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\r\n\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\r\n\r\n\t\t// These lines also handle the case where tmin or tmax is NaN\r\n\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\r\n\r\n\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\r\n\r\n\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\r\n\r\n\t\tif ( invdirz >= 0 ) {\r\n\r\n\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\r\n\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\r\n\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\r\n\r\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\r\n\r\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\r\n\r\n\t\t//return point closest to the ray (positive side)\r\n\r\n\t\tif ( tmax < 0 ) return null;\r\n\r\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, target );\r\n\r\n\t},\r\n\r\n\tintersectsBox: ( function () {\r\n\r\n\t\tvar v = new Vector3();\r\n\r\n\t\treturn function intersectsBox( box ) {\r\n\r\n\t\t\treturn this.intersectBox( box, v ) !== null;\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n\tintersectTriangle: function () {\r\n\r\n\t\t// Compute the offset origin, edges, and normal.\r\n\t\tvar diff = new Vector3();\r\n\t\tvar edge1 = new Vector3();\r\n\t\tvar edge2 = new Vector3();\r\n\t\tvar normal = new Vector3();\r\n\r\n\t\treturn function intersectTriangle( a, b, c, backfaceCulling, target ) {\r\n\r\n\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\r\n\r\n\t\t\tedge1.subVectors( b, a );\r\n\t\t\tedge2.subVectors( c, a );\r\n\t\t\tnormal.crossVectors( edge1, edge2 );\r\n\r\n\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\r\n\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\r\n\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\r\n\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\r\n\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\r\n\t\t\tvar DdN = this.direction.dot( normal );\r\n\t\t\tvar sign;\r\n\r\n\t\t\tif ( DdN > 0 ) {\r\n\r\n\t\t\t\tif ( backfaceCulling ) return null;\r\n\t\t\t\tsign = 1;\r\n\r\n\t\t\t} else if ( DdN < 0 ) {\r\n\r\n\t\t\t\tsign = - 1;\r\n\t\t\t\tDdN = - DdN;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdiff.subVectors( this.origin, a );\r\n\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\r\n\r\n\t\t\t// b1 < 0, no intersection\r\n\t\t\tif ( DdQxE2 < 0 ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\r\n\r\n\t\t\t// b2 < 0, no intersection\r\n\t\t\tif ( DdE1xQ < 0 ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// b1+b2 > 1, no intersection\r\n\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Line intersects triangle, check if ray does.\r\n\t\t\tvar QdN = - sign * diff.dot( normal );\r\n\r\n\t\t\t// t < 0, no intersection\r\n\t\t\tif ( QdN < 0 ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Ray intersects triangle.\r\n\t\t\treturn this.at( QdN / DdN, target );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyMatrix4: function ( matrix4 ) {\r\n\r\n\t\tthis.origin.applyMatrix4( matrix4 );\r\n\t\tthis.direction.transformDirection( matrix4 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( ray ) {\r\n\r\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/math/Triangle.js\n\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nfunction Triangle( a, b, c ) {\r\n\r\n\tthis.a = ( a !== undefined ) ? a : new Vector3();\r\n\tthis.b = ( b !== undefined ) ? b : new Vector3();\r\n\tthis.c = ( c !== undefined ) ? c : new Vector3();\r\n\r\n}\r\n\r\nObject.assign( Triangle, {\r\n\r\n\tgetNormal: function () {\r\n\r\n\t\tvar v0 = new Vector3();\r\n\r\n\t\treturn function getNormal( a, b, c, target ) {\r\n\r\n\t\t\tif ( target === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'COOL.Triangle: .getNormal() target is now required' );\r\n\t\t\t\ttarget = new Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttarget.subVectors( c, b );\r\n\t\t\tv0.subVectors( a, b );\r\n\t\t\ttarget.cross( v0 );\r\n\r\n\t\t\tvar targetLengthSq = target.lengthSq();\r\n\t\t\tif ( targetLengthSq > 0 ) {\r\n\r\n\t\t\t\treturn target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn target.set( 0, 0, 0 );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\t// static/instance method to calculate barycentric coordinates\r\n\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\r\n\tgetBarycoord: function () {\r\n\r\n\t\tvar v0 = new Vector3();\r\n\t\tvar v1 = new Vector3();\r\n\t\tvar v2 = new Vector3();\r\n\r\n\t\treturn function getBarycoord( point, a, b, c, target ) {\r\n\r\n\t\t\tv0.subVectors( c, a );\r\n\t\t\tv1.subVectors( b, a );\r\n\t\t\tv2.subVectors( point, a );\r\n\r\n\t\t\tvar dot00 = v0.dot( v0 );\r\n\t\t\tvar dot01 = v0.dot( v1 );\r\n\t\t\tvar dot02 = v0.dot( v2 );\r\n\t\t\tvar dot11 = v1.dot( v1 );\r\n\t\t\tvar dot12 = v1.dot( v2 );\r\n\r\n\t\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\r\n\r\n\t\t\tif ( target === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'COOL.Triangle: .getBarycoord() target is now required' );\r\n\t\t\t\ttarget = new Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// collinear or singular triangle\r\n\t\t\tif ( denom === 0 ) {\r\n\r\n\t\t\t\t// arbitrary location outside of triangle?\r\n\t\t\t\t// not sure if this is the best idea, maybe should be returning undefined\r\n\t\t\t\treturn target.set( - 2, - 1, - 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar invDenom = 1 / denom;\r\n\t\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\r\n\t\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\r\n\r\n\t\t\t// barycentric coordinates must always sum to 1\r\n\t\t\treturn target.set( 1 - u - v, v, u );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcontainsPoint: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function containsPoint( point, a, b, c ) {\r\n\r\n\t\t\tTriangle.getBarycoord( point, a, b, c, v1 );\r\n\r\n\t\t\treturn ( v1.x >= 0 ) && ( v1.y >= 0 ) && ( ( v1.x + v1.y ) <= 1 );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetUV: function () {\r\n\r\n\t\tvar barycoord = new Vector3();\r\n\r\n\t\treturn function getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {\r\n\r\n\t\t\tthis.getBarycoord( point, p1, p2, p3, barycoord );\r\n\r\n\t\t\ttarget.set( 0, 0 );\r\n\t\t\ttarget.addScaledVector( uv1, barycoord.x );\r\n\t\t\ttarget.addScaledVector( uv2, barycoord.y );\r\n\t\t\ttarget.addScaledVector( uv3, barycoord.z );\r\n\r\n\t\t\treturn target;\r\n\r\n\t\t};\r\n\r\n\t}()\r\n\r\n} );\r\n\r\nObject.assign( Triangle.prototype, {\r\n\r\n\tset: function ( a, b, c ) {\r\n\r\n\t\tthis.a.copy( a );\r\n\t\tthis.b.copy( b );\r\n\t\tthis.c.copy( c );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\r\n\r\n\t\tthis.a.copy( points[ i0 ] );\r\n\t\tthis.b.copy( points[ i1 ] );\r\n\t\tthis.c.copy( points[ i2 ] );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( triangle ) {\r\n\r\n\t\tthis.a.copy( triangle.a );\r\n\t\tthis.b.copy( triangle.b );\r\n\t\tthis.c.copy( triangle.c );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetArea: function () {\r\n\r\n\t\tvar v0 = new Vector3();\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function getArea() {\r\n\r\n\t\t\tv0.subVectors( this.c, this.b );\r\n\t\t\tv1.subVectors( this.a, this.b );\r\n\r\n\t\t\treturn v0.cross( v1 ).length() * 0.5;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetMidpoint: function ( target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Triangle: .getMidpoint() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\treturn target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\r\n\r\n\t},\r\n\r\n\tgetNormal: function ( target ) {\r\n\r\n\t\treturn Triangle.getNormal( this.a, this.b, this.c, target );\r\n\r\n\t},\r\n\r\n\tgetPlane: function ( target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Triangle: .getPlane() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\treturn target.setFromCoplanarPoints( this.a, this.b, this.c );\r\n\r\n\t},\r\n\r\n\tgetBarycoord: function ( point, target ) {\r\n\r\n\t\treturn Triangle.getBarycoord( point, this.a, this.b, this.c, target );\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\r\n\r\n\t},\r\n\r\n\tgetUV: function ( point, uv1, uv2, uv3, result ) {\r\n\r\n\t\treturn Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, result );\r\n\r\n\t},\r\n\r\n\tintersectsBox: function ( box ) {\r\n\r\n\t\treturn box.intersectsTriangle( this );\r\n\r\n\t},\r\n\r\n\tclosestPointToPoint: function () {\r\n\r\n\t\tvar vab = new Vector3();\r\n\t\tvar vac = new Vector3();\r\n\t\tvar vbc = new Vector3();\r\n\t\tvar vap = new Vector3();\r\n\t\tvar vbp = new Vector3();\r\n\t\tvar vcp = new Vector3();\r\n\r\n\t\treturn function closestPointToPoint( p, target ) {\r\n\r\n\t\t\tif ( target === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'COOL.Triangle: .closestPointToPoint() target is now required' );\r\n\t\t\t\ttarget = new Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar a = this.a, b = this.b, c = this.c;\r\n\t\t\tvar v, w;\r\n\r\n\t\t\t// algorithm thanks to Real-Time Collision Detection by Christer Ericson,\r\n\t\t\t// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,\r\n\t\t\t// under the accompanying license; see chapter 5.1.5 for detailed explanation.\r\n\t\t\t// basically, we're distinguishing which of the voronoi regions of the triangle\r\n\t\t\t// the point lies in with the minimum amount of redundant computation.\r\n\r\n\t\t\tvab.subVectors( b, a );\r\n\t\t\tvac.subVectors( c, a );\r\n\t\t\tvap.subVectors( p, a );\r\n\t\t\tvar d1 = vab.dot( vap );\r\n\t\t\tvar d2 = vac.dot( vap );\r\n\t\t\tif ( d1 <= 0 && d2 <= 0 ) {\r\n\r\n\t\t\t\t// vertex region of A; barycentric coords (1, 0, 0)\r\n\t\t\t\treturn target.copy( a );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvbp.subVectors( p, b );\r\n\t\t\tvar d3 = vab.dot( vbp );\r\n\t\t\tvar d4 = vac.dot( vbp );\r\n\t\t\tif ( d3 >= 0 && d4 <= d3 ) {\r\n\r\n\t\t\t\t// vertex region of B; barycentric coords (0, 1, 0)\r\n\t\t\t\treturn target.copy( b );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar vc = d1 * d4 - d3 * d2;\r\n\t\t\tif ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {\r\n\r\n\t\t\t\tv = d1 / ( d1 - d3 );\r\n\t\t\t\t// edge region of AB; barycentric coords (1-v, v, 0)\r\n\t\t\t\treturn target.copy( a ).addScaledVector( vab, v );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvcp.subVectors( p, c );\r\n\t\t\tvar d5 = vab.dot( vcp );\r\n\t\t\tvar d6 = vac.dot( vcp );\r\n\t\t\tif ( d6 >= 0 && d5 <= d6 ) {\r\n\r\n\t\t\t\t// vertex region of C; barycentric coords (0, 0, 1)\r\n\t\t\t\treturn target.copy( c );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar vb = d5 * d2 - d1 * d6;\r\n\t\t\tif ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {\r\n\r\n\t\t\t\tw = d2 / ( d2 - d6 );\r\n\t\t\t\t// edge region of AC; barycentric coords (1-w, 0, w)\r\n\t\t\t\treturn target.copy( a ).addScaledVector( vac, w );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar va = d3 * d6 - d5 * d4;\r\n\t\t\tif ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {\r\n\r\n\t\t\t\tvbc.subVectors( c, b );\r\n\t\t\t\tw = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );\r\n\t\t\t\t// edge region of BC; barycentric coords (0, 1-w, w)\r\n\t\t\t\treturn target.copy( b ).addScaledVector( vbc, w ); // edge region of BC\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// face region\r\n\t\t\tvar denom = 1 / ( va + vb + vc );\r\n\t\t\t// u = va * denom\r\n\t\t\tv = vb * denom;\r\n\t\t\tw = vc * denom;\r\n\t\t\treturn target.copy( a ).addScaledVector( vab, v ).addScaledVector( vac, w );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tequals: function ( triangle ) {\r\n\r\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/math/Color.js\n\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nvar ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\r\n\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\r\n\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\r\n\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\r\n\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\r\n\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\r\n\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\r\n\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\r\n\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\r\n\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\r\n\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\r\n\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\r\n\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\r\n\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\r\n\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\r\n\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\r\n\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\r\n\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\r\n\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\r\n\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\r\n\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\r\n\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\r\n\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\r\n\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\r\n\r\nfunction Color( r, g, b ) {\r\n\r\n\tif ( g === undefined && b === undefined ) {\r\n\r\n\t\t// r is COOL.Color, hex or string\r\n\t\treturn this.set( r );\r\n\r\n\t}\r\n\r\n\treturn this.setRGB( r, g, b );\r\n\r\n}\r\n\r\nObject.assign( Color.prototype, {\r\n\r\n\tisColor: true,\r\n\r\n\tr: 1, g: 1, b: 1,\r\n\r\n\tset: function ( value ) {\r\n\r\n\t\tif ( value && value.isColor ) {\r\n\r\n\t\t\tthis.copy( value );\r\n\r\n\t\t} else if ( typeof value === 'number' ) {\r\n\r\n\t\t\tthis.setHex( value );\r\n\r\n\t\t} else if ( typeof value === 'string' ) {\r\n\r\n\t\t\tthis.setStyle( value );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetScalar: function ( scalar ) {\r\n\r\n\t\tthis.r = scalar;\r\n\t\tthis.g = scalar;\r\n\t\tthis.b = scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetHex: function ( hex ) {\r\n\r\n\t\thex = Math.floor( hex );\r\n\r\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\r\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\r\n\t\tthis.b = ( hex & 255 ) / 255;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetRGB: function ( r, g, b ) {\r\n\r\n\t\tthis.r = r;\r\n\t\tthis.g = g;\r\n\t\tthis.b = b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetHSL: function () {\r\n\r\n\t\tfunction hue2rgb( p, q, t ) {\r\n\r\n\t\t\tif ( t < 0 ) t += 1;\r\n\t\t\tif ( t > 1 ) t -= 1;\r\n\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\r\n\t\t\tif ( t < 1 / 2 ) return q;\r\n\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\r\n\t\t\treturn p;\r\n\r\n\t\t}\r\n\r\n\t\treturn function setHSL( h, s, l ) {\r\n\r\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\t\t\th = _Math.euclideanModulo( h, 1 );\r\n\t\t\ts = _Math.clamp( s, 0, 1 );\r\n\t\t\tl = _Math.clamp( l, 0, 1 );\r\n\r\n\t\t\tif ( s === 0 ) {\r\n\r\n\t\t\t\tthis.r = this.g = this.b = l;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\r\n\t\t\t\tvar q = ( 2 * l ) - p;\r\n\r\n\t\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\r\n\t\t\t\tthis.g = hue2rgb( q, p, h );\r\n\t\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetStyle: function ( style ) {\r\n\r\n\t\tfunction handleAlpha( string ) {\r\n\r\n\t\t\tif ( string === undefined ) return;\r\n\r\n\t\t\tif ( parseFloat( string ) < 1 ) {\r\n\r\n\t\t\t\tconsole.warn( 'COOL.Color: Alpha component of ' + style + ' will be ignored.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\tvar m;\r\n\r\n\t\tif ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\r\n\r\n\t\t\t// rgb / hsl\r\n\r\n\t\t\tvar color;\r\n\t\t\tvar name = m[ 1 ];\r\n\t\t\tvar components = m[ 2 ];\r\n\r\n\t\t\tswitch ( name ) {\r\n\r\n\t\t\t\tcase 'rgb':\r\n\t\t\t\tcase 'rgba':\r\n\r\n\t\t\t\t\tif ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\r\n\r\n\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\r\n\t\t\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\r\n\t\t\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\r\n\t\t\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\r\n\r\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\r\n\r\n\t\t\t\t\t\treturn this;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\r\n\r\n\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\r\n\t\t\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\r\n\t\t\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\r\n\t\t\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\r\n\r\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\r\n\r\n\t\t\t\t\t\treturn this;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'hsl':\r\n\t\t\t\tcase 'hsla':\r\n\r\n\t\t\t\t\tif ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\r\n\r\n\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\r\n\t\t\t\t\t\tvar h = parseFloat( color[ 1 ] ) / 360;\r\n\t\t\t\t\t\tvar s = parseInt( color[ 2 ], 10 ) / 100;\r\n\t\t\t\t\t\tvar l = parseInt( color[ 3 ], 10 ) / 100;\r\n\r\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\r\n\r\n\t\t\t\t\t\treturn this.setHSL( h, s, l );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\r\n\r\n\t\t\t// hex color\r\n\r\n\t\t\tvar hex = m[ 1 ];\r\n\t\t\tvar size = hex.length;\r\n\r\n\t\t\tif ( size === 3 ) {\r\n\r\n\t\t\t\t// #ff0\r\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\r\n\t\t\t\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\r\n\t\t\t\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\r\n\r\n\t\t\t\treturn this;\r\n\r\n\t\t\t} else if ( size === 6 ) {\r\n\r\n\t\t\t\t// #ff0000\r\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\r\n\t\t\t\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\r\n\t\t\t\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\r\n\r\n\t\t\t\treturn this;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( style && style.length > 0 ) {\r\n\r\n\t\t\t// color keywords\r\n\t\t\tvar hex = ColorKeywords[ style ];\r\n\r\n\t\t\tif ( hex !== undefined ) {\r\n\r\n\t\t\t\t// red\r\n\t\t\t\tthis.setHex( hex );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// unknown color\r\n\t\t\t\tconsole.warn( 'COOL.Color: Unknown color ' + style );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.r, this.g, this.b );\r\n\r\n\t},\r\n\r\n\tcopy: function ( color ) {\r\n\r\n\t\tthis.r = color.r;\r\n\t\tthis.g = color.g;\r\n\t\tthis.b = color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyGammaToLinear: function ( color, gammaFactor ) {\r\n\r\n\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\r\n\r\n\t\tthis.r = Math.pow( color.r, gammaFactor );\r\n\t\tthis.g = Math.pow( color.g, gammaFactor );\r\n\t\tthis.b = Math.pow( color.b, gammaFactor );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyLinearToGamma: function ( color, gammaFactor ) {\r\n\r\n\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\r\n\r\n\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\r\n\r\n\t\tthis.r = Math.pow( color.r, safeInverse );\r\n\t\tthis.g = Math.pow( color.g, safeInverse );\r\n\t\tthis.b = Math.pow( color.b, safeInverse );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconvertGammaToLinear: function ( gammaFactor ) {\r\n\r\n\t\tthis.copyGammaToLinear( this, gammaFactor );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconvertLinearToGamma: function ( gammaFactor ) {\r\n\r\n\t\tthis.copyLinearToGamma( this, gammaFactor );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopySRGBToLinear: function () {\r\n\r\n\t\tfunction SRGBToLinear( c ) {\r\n\r\n\t\t\treturn ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\r\n\r\n\t\t}\r\n\r\n\t\treturn function copySRGBToLinear( color ) {\r\n\r\n\t\t\tthis.r = SRGBToLinear( color.r );\r\n\t\t\tthis.g = SRGBToLinear( color.g );\r\n\t\t\tthis.b = SRGBToLinear( color.b );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcopyLinearToSRGB: function () {\r\n\r\n\t\tfunction LinearToSRGB( c ) {\r\n\r\n\t\t\treturn ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;\r\n\r\n\t\t}\r\n\r\n\t\treturn function copyLinearToSRGB( color ) {\r\n\r\n\t\t\tthis.r = LinearToSRGB( color.r );\r\n\t\t\tthis.g = LinearToSRGB( color.g );\r\n\t\t\tthis.b = LinearToSRGB( color.b );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tconvertSRGBToLinear: function () {\r\n\r\n\t\tthis.copySRGBToLinear( this );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconvertLinearToSRGB: function () {\r\n\r\n\t\tthis.copyLinearToSRGB( this );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetHex: function () {\r\n\r\n\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\r\n\r\n\t},\r\n\r\n\tgetHexString: function () {\r\n\r\n\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\r\n\r\n\t},\r\n\r\n\tgetHSL: function ( target ) {\r\n\r\n\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Color: .getHSL() target is now required' );\r\n\t\t\ttarget = { h: 0, s: 0, l: 0 };\r\n\r\n\t\t}\r\n\r\n\t\tvar r = this.r, g = this.g, b = this.b;\r\n\r\n\t\tvar max = Math.max( r, g, b );\r\n\t\tvar min = Math.min( r, g, b );\r\n\r\n\t\tvar hue, saturation;\r\n\t\tvar lightness = ( min + max ) / 2.0;\r\n\r\n\t\tif ( min === max ) {\r\n\r\n\t\t\thue = 0;\r\n\t\t\tsaturation = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar delta = max - min;\r\n\r\n\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\r\n\r\n\t\t\tswitch ( max ) {\r\n\r\n\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\r\n\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\r\n\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\r\n\r\n\t\t\t}\r\n\r\n\t\t\thue /= 6;\r\n\r\n\t\t}\r\n\r\n\t\ttarget.h = hue;\r\n\t\ttarget.s = saturation;\r\n\t\ttarget.l = lightness;\r\n\r\n\t\treturn target;\r\n\r\n\t},\r\n\r\n\tgetStyle: function () {\r\n\r\n\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\r\n\r\n\t},\r\n\r\n\toffsetHSL: function () {\r\n\r\n\t\tvar hsl = {};\r\n\r\n\t\treturn function ( h, s, l ) {\r\n\r\n\t\t\tthis.getHSL( hsl );\r\n\r\n\t\t\thsl.h += h; hsl.s += s; hsl.l += l;\r\n\r\n\t\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tadd: function ( color ) {\r\n\r\n\t\tthis.r += color.r;\r\n\t\tthis.g += color.g;\r\n\t\tthis.b += color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddColors: function ( color1, color2 ) {\r\n\r\n\t\tthis.r = color1.r + color2.r;\r\n\t\tthis.g = color1.g + color2.g;\r\n\t\tthis.b = color1.b + color2.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.r += s;\r\n\t\tthis.g += s;\r\n\t\tthis.b += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( color ) {\r\n\r\n\t\tthis.r = Math.max( 0, this.r - color.r );\r\n\t\tthis.g = Math.max( 0, this.g - color.g );\r\n\t\tthis.b = Math.max( 0, this.b - color.b );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( color ) {\r\n\r\n\t\tthis.r *= color.r;\r\n\t\tthis.g *= color.g;\r\n\t\tthis.b *= color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tthis.r *= s;\r\n\t\tthis.g *= s;\r\n\t\tthis.b *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerp: function ( color, alpha ) {\r\n\r\n\t\tthis.r += ( color.r - this.r ) * alpha;\r\n\t\tthis.g += ( color.g - this.g ) * alpha;\r\n\t\tthis.b += ( color.b - this.b ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerpHSL: function () {\r\n\r\n\t\tvar hslA = { h: 0, s: 0, l: 0 };\r\n\t\tvar hslB = { h: 0, s: 0, l: 0 };\r\n\r\n\t\treturn function lerpHSL( color, alpha ) {\r\n\r\n\t\t\tthis.getHSL( hslA );\r\n\t\t\tcolor.getHSL( hslB );\r\n\r\n\t\t\tvar h = _Math.lerp( hslA.h, hslB.h, alpha );\r\n\t\t\tvar s = _Math.lerp( hslA.s, hslB.s, alpha );\r\n\t\t\tvar l = _Math.lerp( hslA.l, hslB.l, alpha );\r\n\r\n\t\t\tthis.setHSL( h, s, l );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tequals: function ( c ) {\r\n\r\n\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.r = array[ offset ];\r\n\t\tthis.g = array[ offset + 1 ];\r\n\t\tthis.b = array[ offset + 2 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this.r;\r\n\t\tarray[ offset + 1 ] = this.g;\r\n\t\tarray[ offset + 2 ] = this.b;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\treturn this.getHex();\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/core/Face3.js\n\r\n\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nfunction Face3( a, b, c, normal, color, materialIndex ) {\r\n\r\n\tthis.a = a;\r\n\tthis.b = b;\r\n\tthis.c = c;\r\n\r\n\tthis.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();\r\n\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\r\n\r\n\tthis.color = ( color && color.isColor ) ? color : new Color();\r\n\tthis.vertexColors = Array.isArray( color ) ? color : [];\r\n\r\n\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\r\n\r\n}\r\n\r\nObject.assign( Face3.prototype, {\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.a = source.a;\r\n\t\tthis.b = source.b;\r\n\t\tthis.c = source.c;\r\n\r\n\t\tthis.normal.copy( source.normal );\r\n\t\tthis.color.copy( source.color );\r\n\r\n\t\tthis.materialIndex = source.materialIndex;\r\n\r\n\t\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/core/Mesh.js\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass Mesh_Mesh {\r\n    constructor(param) {\r\n        this.type = 'Mesh';\r\n        param = param || {};\r\n        this.geometry = param.geometry;\r\n        this.material = param.material || new material_Material();\r\n\r\n        this.position = param.position || [0,0,0];\r\n        this.rotation = param.rotation || new Euler();\r\n        this.scale = param.scale || [1,1,1];\r\n\r\n        this.quaternion = new Quaternion().setFromEuler( this.rotation, false );\r\n\r\n        this.children = [];\r\n        this.parent = null;\r\n\r\n        this.matrix = new Matrix4();\r\n        this.matrixWorld = new Matrix4();\r\n        this.updateMatrix();\r\n\r\n    }\r\n\r\n    setPosition(position){\r\n        this.position = position;\r\n        this.updateMatrix();\r\n    }\r\n\r\n    setRotation(rotationArray){\r\n        this.rotation = new Euler().fromArray(rotationArray);\r\n        var quaternion = new Quaternion().setFromEuler( this.rotation, false );\r\n        this.setQuaternion(quaternion);\r\n    }\r\n\r\n    setQuaternion(quaternion){\r\n\r\n        this.quaternion = quaternion;\r\n        this.rotation.setFromQuaternion( quaternion, undefined, false );\r\n        this.updateMatrix();\r\n    }\r\n\r\n    setScale(scaleArray){\r\n        this.scale = scaleArray;\r\n        this.updateMatrix();\r\n    }\r\n\r\n    updateMatrix(){\r\n        this.matrix.compose( new Vector3().fromArray(this.position), this.quaternion, new Vector3().fromArray(this.scale) );\r\n        this.updateMatrixWorld ();\r\n    }\r\n\r\n    setMatrix(matrix){\r\n        this.matrix = matrix;\r\n        this.updateMatrixWorld ();\r\n    }\r\n\r\n    updateMatrixWorld () {\r\n\r\n        // this.updateMatrix();\r\n\r\n        if ( this.parent === null ) {\r\n\r\n            this.matrixWorld = this.matrix.clone();\r\n\r\n        } else {\r\n\r\n            this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n        }\r\n\r\n        this.updateChildrenMatrixWorld();\r\n\r\n    }\r\n\r\n    getWorldPosition() {\r\n\r\n        var target = new Vector3();\r\n\r\n        // this.updateMatrixWorld();\r\n\r\n        return target.setFromMatrixPosition( this.matrixWorld );\r\n\r\n    }\r\n\r\n    updateChildrenMatrixWorld(){\r\n\r\n        for(var i in this.children){\r\n            this.children[i].updateMatrixWorld();\r\n        }\r\n\r\n    }\r\n\r\n    clone(){\r\n        var mesh = new Mesh_Mesh({\r\n            geometry: this.geometry.clone(),\r\n            material: this.material.clone(),\r\n            position: this.position.slice(0),\r\n            rotation: this.rotation.clone(),\r\n            scale: this.scale.slice(0)\r\n        });\r\n\r\n        return mesh;\r\n    }\r\n\r\n    add(mesh){\r\n        this.children.push(mesh);\r\n        mesh.parent = this;\r\n        mesh.updateMatrix();\r\n    }\r\n\r\n    rotateOnAxis (axis, angle) {\r\n\r\n        var q1 = new Quaternion();\r\n        q1.setFromAxisAngle( axis, angle );\r\n        var quaternion = this.quaternion.multiply( q1 );\r\n        this.setQuaternion(quaternion);\r\n\r\n    }\r\n\r\n    rotateX (angle) {\r\n\r\n        this.rotateOnAxis( new Vector3(1,0,0), angle );\r\n\r\n    }\r\n\r\n    rotateY (angle) {\r\n\r\n        this.rotateOnAxis( new Vector3(0,1,0), angle );\r\n\r\n    }\r\n\r\n    rotateZ (angle) {\r\n\r\n        this.rotateOnAxis( new Vector3(0,0,1), angle );\r\n\r\n    }\r\n\r\n\r\n\r\n    raycast( raycaster, intersects ) {\r\n\r\n        var that = this;\r\n\r\n        var inverseMatrix = new Matrix4();\r\n        var ray = new Ray();\r\n        var sphere = new Sphere();\r\n\r\n        var vA = new Vector3();\r\n        var vB = new Vector3();\r\n        var vC = new Vector3();\r\n\r\n        var tempA = new Vector3();\r\n        var tempB = new Vector3();\r\n        var tempC = new Vector3();\r\n\r\n        var uvA = new Vector2();\r\n        var uvB = new Vector2();\r\n        var uvC = new Vector2();\r\n\r\n        var intersectionPoint = new Vector3();\r\n        var intersectionPointWorld = new Vector3();\r\n\r\n        function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {\r\n\r\n            var intersect;\r\n\r\n            if ( material.side === BackSide ) {\r\n\r\n                intersect = ray.intersectTriangle( pC, pB, pA, true, point );\r\n\r\n            } else {\r\n\r\n                intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );\r\n\r\n            }\r\n\r\n            if ( intersect === null ) return null;\r\n\r\n            intersectionPointWorld.copy( point );\r\n            intersectionPointWorld.applyMatrix4( object.matrixWorld );\r\n\r\n            var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\r\n\r\n            if ( distance < raycaster.near || distance > raycaster.far ) return null;\r\n\r\n            return {\r\n                distance: distance,\r\n                point: intersectionPointWorld.clone(),\r\n                object: object\r\n            };\r\n\r\n        }\r\n\r\n        function checkBufferGeometryIntersection( object, material, raycaster, ray, position, uv, a, b, c ) {\r\n\r\n            vA.fromBufferAttribute( position, a );\r\n            vB.fromBufferAttribute( position, b );\r\n            vC.fromBufferAttribute( position, c );\r\n\r\n            var intersection = checkIntersection( object, material, raycaster, ray, vA, vB, vC, intersectionPoint );\r\n\r\n            if ( intersection ) {\r\n\r\n                if ( uv ) {\r\n\r\n                    uvA.fromBufferAttribute( uv, a );\r\n                    uvB.fromBufferAttribute( uv, b );\r\n                    uvC.fromBufferAttribute( uv, c );\r\n\r\n                    intersection.uv = Triangle.getUV( intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2() );\r\n\r\n                }\r\n\r\n                var face = new Face3( a, b, c );\r\n                Triangle.getNormal( vA, vB, vC, face.normal );\r\n\r\n                intersection.face = face;\r\n\r\n            }\r\n\r\n            return intersection;\r\n\r\n        }\r\n\r\n        var geometry = this.geometry;\r\n        var material = this.material;\r\n        var matrixWorld = this.matrixWorld;\r\n\r\n        if ( material === undefined ) return;\r\n\r\n        // Checking boundingSphere distance to ray\r\n\r\n        if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n        sphere.copy( geometry.boundingSphere );\r\n        sphere.applyMatrix4( matrixWorld );\r\n\r\n        var box3 = new Box3().copy(geometry.boundingBox);\r\n        box3.applyMatrix4( matrixWorld );\r\n\r\n        // raycaster.ray.intersectsSphere( sphere ) ||\r\n        if ( raycaster.ray.intersectsBox( box3 ) ) {\r\n            var worldPosition = new Vector3().setFromMatrixPosition( this.matrixWorld );\r\n            that.distance = raycaster.ray.origin.distanceTo( worldPosition );\r\n            intersects.push(that);\r\n        }\r\n\r\n        //\r\n        // inverseMatrix.getInverse( matrixWorld );\r\n        // ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n        //\r\n        // // Check boundingBox before continuing\r\n        //\r\n        // if ( geometry.boundingBox !== null ) {\r\n        //\r\n        //     if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\r\n        //\r\n        // }\r\n        //\r\n        // var intersection;\r\n        //\r\n        // if ( geometry.isBufferGeometry ) {\r\n        //\r\n        //     var a, b, c;\r\n        //     var index = geometry.index;\r\n        //     var position = geometry.attributes.position;\r\n        //     var uv = geometry.attributes.uv;\r\n        //     var groups = geometry.groups;\r\n        //     var drawRange = geometry.drawRange;\r\n        //     var i, j, il, jl;\r\n        //     var group, groupMaterial;\r\n        //     var start, end;\r\n        //\r\n        //     if ( index !== null ) {\r\n        //\r\n        //         // indexed buffer geometry\r\n        //\r\n        //         if ( Array.isArray( material ) ) {\r\n        //\r\n        //             for ( i = 0, il = groups.length; i < il; i ++ ) {\r\n        //\r\n        //                 group = groups[ i ];\r\n        //                 groupMaterial = material[ group.materialIndex ];\r\n        //\r\n        //                 start = Math.max( group.start, drawRange.start );\r\n        //                 end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\r\n        //\r\n        //                 for ( j = start, jl = end; j < jl; j += 3 ) {\r\n        //\r\n        //                     a = index.getX( j );\r\n        //                     b = index.getX( j + 1 );\r\n        //                     c = index.getX( j + 2 );\r\n        //\r\n        //                     intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, ray, position, uv, a, b, c );\r\n        //\r\n        //                     if ( intersection ) {\r\n        //\r\n        //                         intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics\r\n        //                         intersects.push( intersection );\r\n        //\r\n        //                     }\r\n        //\r\n        //                 }\r\n        //\r\n        //             }\r\n        //\r\n        //         } else {\r\n        //\r\n        //             start = Math.max( 0, drawRange.start );\r\n        //             end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\r\n        //\r\n        //             for ( i = start, il = end; i < il; i += 3 ) {\r\n        //\r\n        //                 a = index.getX( i );\r\n        //                 b = index.getX( i + 1 );\r\n        //                 c = index.getX( i + 2 );\r\n        //\r\n        //                 intersection = checkBufferGeometryIntersection( this, material, raycaster, ray, position, uv, a, b, c );\r\n        //\r\n        //                 if ( intersection ) {\r\n        //\r\n        //                     intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics\r\n        //                     intersects.push( intersection );\r\n        //\r\n        //                 }\r\n        //\r\n        //             }\r\n        //\r\n        //         }\r\n        //\r\n        //     } else if ( position !== undefined ) {\r\n        //\r\n        //         // non-indexed buffer geometry\r\n        //\r\n        //         if ( Array.isArray( material ) ) {\r\n        //\r\n        //             for ( i = 0, il = groups.length; i < il; i ++ ) {\r\n        //\r\n        //                 group = groups[ i ];\r\n        //                 groupMaterial = material[ group.materialIndex ];\r\n        //\r\n        //                 start = Math.max( group.start, drawRange.start );\r\n        //                 end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\r\n        //\r\n        //                 for ( j = start, jl = end; j < jl; j += 3 ) {\r\n        //\r\n        //                     a = j;\r\n        //                     b = j + 1;\r\n        //                     c = j + 2;\r\n        //\r\n        //                     intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, ray, position, uv, a, b, c );\r\n        //\r\n        //                     if ( intersection ) {\r\n        //\r\n        //                         intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics\r\n        //                         intersects.push( intersection );\r\n        //\r\n        //                     }\r\n        //\r\n        //                 }\r\n        //\r\n        //             }\r\n        //\r\n        //         } else {\r\n        //\r\n        //             start = Math.max( 0, drawRange.start );\r\n        //             end = Math.min( position.count, ( drawRange.start + drawRange.count ) );\r\n        //\r\n        //             for ( i = start, il = end; i < il; i += 3 ) {\r\n        //\r\n        //                 a = i;\r\n        //                 b = i + 1;\r\n        //                 c = i + 2;\r\n        //\r\n        //                 intersection = checkBufferGeometryIntersection( this, material, raycaster, ray, position, uv, a, b, c );\r\n        //\r\n        //                 if ( intersection ) {\r\n        //\r\n        //                     intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics\r\n        //                     intersects.push( intersection );\r\n        //\r\n        //                 }\r\n        //\r\n        //             }\r\n        //\r\n        //         }\r\n        //\r\n        //     }\r\n        //\r\n        // } else if ( geometry.isGeometry ) {\r\n        //\r\n        //     var fvA, fvB, fvC;\r\n        //     var isMultiMaterial = Array.isArray( material );\r\n        //\r\n        //     var vertices = geometry.vertices;\r\n        //     var faces = geometry.faces;\r\n        //     var uvs;\r\n        //\r\n        //     var faceVertexUvs = geometry.faceVertexUvs[ 0 ];\r\n        //     if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\r\n        //\r\n        //     for ( var f = 0, fl = faces.length; f < fl; f ++ ) {\r\n        //\r\n        //         var face = faces[ f ];\r\n        //         var faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;\r\n        //\r\n        //         if ( faceMaterial === undefined ) continue;\r\n        //\r\n        //         fvA = vertices[ face.a ];\r\n        //         fvB = vertices[ face.b ];\r\n        //         fvC = vertices[ face.c ];\r\n        //\r\n        //         if ( faceMaterial.morphTargets === true ) {\r\n        //\r\n        //             var morphTargets = geometry.morphTargets;\r\n        //             var morphInfluences = this.morphTargetInfluences;\r\n        //\r\n        //             vA.set( 0, 0, 0 );\r\n        //             vB.set( 0, 0, 0 );\r\n        //             vC.set( 0, 0, 0 );\r\n        //\r\n        //             for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\r\n        //\r\n        //                 var influence = morphInfluences[ t ];\r\n        //\r\n        //                 if ( influence === 0 ) continue;\r\n        //\r\n        //                 var targets = morphTargets[ t ].vertices;\r\n        //\r\n        //                 vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\r\n        //                 vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\r\n        //                 vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\r\n        //\r\n        //             }\r\n        //\r\n        //             vA.add( fvA );\r\n        //             vB.add( fvB );\r\n        //             vC.add( fvC );\r\n        //\r\n        //             fvA = vA;\r\n        //             fvB = vB;\r\n        //             fvC = vC;\r\n        //\r\n        //         }\r\n        //\r\n        //         intersection = checkIntersection( this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\r\n        //\r\n        //         if ( intersection ) {\r\n        //\r\n        //             if ( uvs && uvs[ f ] ) {\r\n        //\r\n        //                 var uvs_f = uvs[ f ];\r\n        //                 uvA.copy( uvs_f[ 0 ] );\r\n        //                 uvB.copy( uvs_f[ 1 ] );\r\n        //                 uvC.copy( uvs_f[ 2 ] );\r\n        //\r\n        //                 intersection.uv = Triangle.getUV( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC, new Vector2() );\r\n        //\r\n        //             }\r\n        //\r\n        //             intersection.face = face;\r\n        //             intersection.faceIndex = f;\r\n        //             intersects.push( intersection );\r\n        //\r\n        //         }\r\n        //\r\n        //     }\r\n        //\r\n        // }\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n/* harmony default export */ var core_Mesh = (Mesh_Mesh);\r\n\n// CONCATENATED MODULE: ./src/camera/Camera.js\n\r\n\r\n\r\n\r\n\r\nclass Camera_Camera {\r\n    constructor(fov, aspect, near, far) {\r\n        this.fov = fov;\r\n        this.aspect = aspect;\r\n        this.near = near;\r\n        this.far = far;\r\n\r\n        this.position = [0, 0, 10];\r\n        this.target = [0,0,0];\r\n        this.up = [0,1,0];\r\n\r\n        this.VPmatrix = new Matrix4();\r\n\r\n        this.direction = [0,0,-1];\r\n        this.right = [1,0,0];\r\n\r\n        this.scale = [1,1,1];\r\n        this.quaternion = new Quaternion();\r\n        this.matrix = new Matrix4();\r\n        this.matrixWorld = this.matrix;\r\n        this.projectionMatrix = new Matrix4();\r\n\r\n        this.updateAll();\r\n    }\r\n\r\n    updateAll(){\r\n        this.updateOption();\r\n        this.updateMatrix();\r\n        this.updateVPMatrix();\r\n    }\r\n\r\n    updateMatrix(){\r\n        var quaternionD = new Quaternion().setFromUnitVectors(new Vector3(0,0,-1), new Vector3().fromArray(this.direction));\r\n        var right2 = new Vector3(1,0,0).applyQuaternion(quaternionD);\r\n        var quaternionR = new Quaternion().setFromUnitVectors(right2, new Vector3().fromArray(this.right));\r\n        var quaternion = new Quaternion().multiplyQuaternions(quaternionR, quaternionD);\r\n        this.quaternion = quaternion;\r\n\r\n        this.matrix.compose( new Vector3().fromArray(this.position), this.quaternion, new Vector3().fromArray(this.scale) );\r\n        this.projectionMatrix = new Matrix4().setPerspective(this.fov, this.aspect, this.near, this.far);\r\n        // this.updateMatrixWorld ();\r\n    }\r\n\r\n    updateOption(){\r\n        var targetV3 = new Vector3().fromArray(this.target);\r\n        var positionV3 = new Vector3().fromArray(this.position);\r\n        var upV3 = new Vector3().fromArray(this.up);\r\n\r\n        var directionV3 = new Vector3().subVectors(targetV3, positionV3).normalize();\r\n        this.direction = directionV3.toArray();\r\n\r\n        var rightV3 = new Vector3().crossVectors(directionV3, upV3).normalize();\r\n        this.right = rightV3.toArray();\r\n\r\n        // this.up = new Vector3().crossVectors(rightV3, directionV3).normalize().toArray();\r\n    }\r\n\r\n    setPosition(position){\r\n        this.position = position;\r\n        this.updateAll();\r\n    }\r\n\r\n    setTarget(target){\r\n        this.target = target;\r\n        this.updateAll();\r\n    }\r\n\r\n    setUp(up){\r\n        this.up = new Vector3().fromArray(up).normalize().toArray();\r\n        this.updateAll();\r\n    }\r\n\r\n\r\n\r\n    updateVPMatrix(){\r\n        this.VPmatrix = new Matrix4().setPerspective(this.fov, this.aspect, this.near, this.far);\r\n        var Vmatrix = new Matrix4().getInverse(this.matrix);\r\n        this.VPmatrix.concat(Vmatrix);\r\n        //\r\n        // this.VPmatrix.lookAt2(this.position[0],this.position[1],this.position[2], this.target[0],this.target[1],this.target[2], this.up[0],this.up[1],this.up[2]);\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ var camera_Camera = (Camera_Camera);\r\n\r\n\n// CONCATENATED MODULE: ./src/util/webgl-utils.js\n/*\r\n * Copyright 2010, Google Inc.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are\r\n * met:\r\n *\r\n *     * Redistributions of source code must retain the above copyright\r\n * notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above\r\n * copyright notice, this list of conditions and the following disclaimer\r\n * in the documentation and/or other materials provided with the\r\n * distribution.\r\n *     * Neither the name of Google Inc. nor the names of its\r\n * contributors may be used to endorse or promote products derived from\r\n * this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n\r\n/**\r\n * @fileoverview This file contains functions every webgl program will need\r\n * a version of one way or another.\r\n *\r\n * Instead of setting up a context manually it is recommended to\r\n * use. This will check for success or failure. On failure it\r\n * will attempt to present an approriate message to the user.\r\n *\r\n *       gl = WebGLUtils.setupWebGL(canvas);\r\n *\r\n * For animated WebGL apps use of setTimeout or setInterval are\r\n * discouraged. It is recommended you structure your rendering\r\n * loop like this.\r\n *\r\n *       function render() {\r\n *         window.requestAnimationFrame(render, canvas);\r\n *\r\n *         // do rendering\r\n *         ...\r\n *       }\r\n *       render();\r\n *\r\n * This will call your rendering function up to the refresh rate\r\n * of your display but will stop rendering if your app is not\r\n * visible.\r\n */\r\n\r\nvar WebGLUtils = function() {\r\n\r\n/**\r\n * Creates the HTLM for a failure message\r\n * @param {string} canvasContainerId id of container of th\r\n *        canvas.\r\n * @return {string} The html.\r\n */\r\nvar makeFailHTML = function(msg) {\r\n  return '' +\r\n        '<div style=\"margin: auto; width:500px;z-index:10000;margin-top:20em;text-align:center;\">' + msg + '</div>';\r\n  return '' +\r\n    '<table style=\"background-color: #8CE; width: 100%; height: 100%;\"><tr>' +\r\n    '<td align=\"center\">' +\r\n    '<div style=\"display: table-cell; vertical-align: middle;\">' +\r\n    '<div style=\"\">' + msg + '</div>' +\r\n    '</div>' +\r\n    '</td></tr></table>';\r\n};\r\n\r\n/**\r\n * Mesasge for getting a webgl browser\r\n * @type {string}\r\n */\r\nvar GET_A_WEBGL_BROWSER = '' +\r\n  'This page requires a browser that supports WebGL.<br/>' +\r\n  '<a href=\"http://get.webgl.org\">Click here to upgrade your browser.</a>';\r\n\r\n/**\r\n * Mesasge for need better hardware\r\n * @type {string}\r\n */\r\nvar OTHER_PROBLEM = '' +\r\n  \"It doesn't appear your computer can support WebGL.<br/>\" +\r\n  '<a href=\"http://get.webgl.org\">Click here for more information.</a>';\r\n\r\n/**\r\n * Creates a webgl context. If creation fails it will\r\n * change the contents of the container of the <canvas>\r\n * tag to an error message with the correct links for WebGL.\r\n * @param {Element} canvas. The canvas element to create a\r\n *     context from.\r\n * @param {WebGLContextCreationAttirbutes} opt_attribs Any\r\n *     creation attributes you want to pass in.\r\n * @param {function:(msg)} opt_onError An function to call\r\n *     if there is an error during creation.\r\n * @return {WebGLRenderingContext} The created context.\r\n */\r\nvar setupWebGL = function(canvas, opt_attribs, opt_onError) {\r\n  function handleCreationError(msg) {\r\n      var container = document.getElementsByTagName(\"body\")[0];\r\n    //var container = canvas.parentNode;\r\n    if (container) {\r\n      var str = window.WebGLRenderingContext ?\r\n           OTHER_PROBLEM :\r\n           GET_A_WEBGL_BROWSER;\r\n      if (msg) {\r\n        str += \"<br/><br/>Status: \" + msg;\r\n      }\r\n      container.innerHTML = makeFailHTML(str);\r\n    }\r\n  };\r\n\r\n  opt_onError = opt_onError || handleCreationError;\r\n\r\n  if (canvas.addEventListener) {\r\n    canvas.addEventListener(\"webglcontextcreationerror\", function(event) {\r\n          opt_onError(event.statusMessage);\r\n        }, false);\r\n  }\r\n  var context = create3DContext(canvas, opt_attribs);\r\n  if (!context) {\r\n    if (!window.WebGLRenderingContext) {\r\n      opt_onError(\"\");\r\n    } else {\r\n      opt_onError(\"\");\r\n    }\r\n  }\r\n\r\n  return context;\r\n};\r\n\r\n/**\r\n * Creates a webgl context.\r\n * @param {!Canvas} canvas The canvas tag to get context\r\n *     from. If one is not passed in one will be created.\r\n * @return {!WebGLContext} The created context.\r\n */\r\nvar create3DContext = function(canvas, opt_attribs) {\r\n  var names = [\"webgl\", \"experimental-webgl\", \"webkit-3d\", \"moz-webgl\"];\r\n  var context = null;\r\n  for (var ii = 0; ii < names.length; ++ii) {\r\n    try {\r\n      context = canvas.getContext(names[ii], opt_attribs);\r\n    } catch(e) {}\r\n    if (context) {\r\n      break;\r\n    }\r\n  }\r\n  return context;\r\n}\r\n\r\nreturn {\r\n  create3DContext: create3DContext,\r\n  setupWebGL: setupWebGL\r\n};\r\n}();\r\n\r\n/**\r\n * Provides requestAnimationFrame in a cross browser\r\n * way.\r\n */\r\nif (!window.requestAnimationFrame) {\r\n  window.requestAnimationFrame = (function() {\r\n    return window.requestAnimationFrame ||\r\n           window.webkitRequestAnimationFrame ||\r\n           window.mozRequestAnimationFrame ||\r\n           window.oRequestAnimationFrame ||\r\n           window.msRequestAnimationFrame ||\r\n           function(/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {\r\n             window.setTimeout(callback, 1000/60);\r\n           };\r\n  })();\r\n}\r\n\r\n/** * ERRATA: 'cancelRequestAnimationFrame' renamed to 'cancelAnimationFrame' to reflect an update to the W3C Animation-Timing Spec. \r\n * \r\n * Cancels an animation frame request. \r\n * Checks for cross-browser support, falls back to clearTimeout. \r\n * @param {number}  Animation frame request. */\r\nif (!window.cancelAnimationFrame) {\r\n  window.cancelAnimationFrame = (window.cancelRequestAnimationFrame ||\r\n                                 window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame ||\r\n                                 window.mozCancelAnimationFrame || window.mozCancelRequestAnimationFrame ||\r\n                                 window.msCancelAnimationFrame || window.msCancelRequestAnimationFrame ||\r\n                                 window.oCancelAnimationFrame || window.oCancelRequestAnimationFrame ||\r\n                                 window.clearTimeout);\r\n}\r\n\r\n/* harmony default export */ var webgl_utils = (WebGLUtils);\n// CONCATENATED MODULE: ./src/util/webgl-debug.js\n//Copyright (c) 2009 The Chromium Authors. All rights reserved.\r\n//Use of this source code is governed by a BSD-style license that can be\r\n//found in the LICENSE file.\r\n\r\n// Various functions for helping debug WebGL apps.\r\n\r\nvar WebGLDebugUtils = function() {\r\n\r\n/**\r\n * Wrapped logging function.\r\n * @param {string} msg Message to log.\r\n */\r\nvar log = function(msg) {\r\n  if (window.console && window.console.log) {\r\n    window.console.log(msg);\r\n  }\r\n};\r\n\r\n/**\r\n * Which arguements are enums.\r\n * @type {!Object.<number, string>}\r\n */\r\nvar glValidEnumContexts = {\r\n\r\n  // Generic setters and getters\r\n\r\n  'enable': { 0:true },\r\n  'disable': { 0:true },\r\n  'getParameter': { 0:true },\r\n\r\n  // Rendering\r\n\r\n  'drawArrays': { 0:true },\r\n  'drawElements': { 0:true, 2:true },\r\n\r\n  // Shaders\r\n\r\n  'createShader': { 0:true },\r\n  'getShaderParameter': { 1:true },\r\n  'getProgramParameter': { 1:true },\r\n\r\n  // Vertex attributes\r\n\r\n  'getVertexAttrib': { 1:true },\r\n  'vertexAttribPointer': { 2:true },\r\n\r\n  // Textures\r\n\r\n  'bindTexture': { 0:true },\r\n  'activeTexture': { 0:true },\r\n  'getTexParameter': { 0:true, 1:true },\r\n  'texParameterf': { 0:true, 1:true },\r\n  'texParameteri': { 0:true, 1:true, 2:true },\r\n  'texImage2D': { 0:true, 2:true, 6:true, 7:true },\r\n  'texSubImage2D': { 0:true, 6:true, 7:true },\r\n  'copyTexImage2D': { 0:true, 2:true },\r\n  'copyTexSubImage2D': { 0:true },\r\n  'generateMipmap': { 0:true },\r\n\r\n  // Buffer objects\r\n\r\n  'bindBuffer': { 0:true },\r\n  'bufferData': { 0:true, 2:true },\r\n  'bufferSubData': { 0:true },\r\n  'getBufferParameter': { 0:true, 1:true },\r\n\r\n  // Renderbuffers and framebuffers\r\n\r\n  'pixelStorei': { 0:true, 1:true },\r\n  'readPixels': { 4:true, 5:true },\r\n  'bindRenderbuffer': { 0:true },\r\n  'bindFramebuffer': { 0:true },\r\n  'checkFramebufferStatus': { 0:true },\r\n  'framebufferRenderbuffer': { 0:true, 1:true, 2:true },\r\n  'framebufferTexture2D': { 0:true, 1:true, 2:true },\r\n  'getFramebufferAttachmentParameter': { 0:true, 1:true, 2:true },\r\n  'getRenderbufferParameter': { 0:true, 1:true },\r\n  'renderbufferStorage': { 0:true, 1:true },\r\n\r\n  // Frame buffer operations (clear, blend, depth test, stencil)\r\n\r\n  'clear': { 0:true },\r\n  'depthFunc': { 0:true },\r\n  'blendFunc': { 0:true, 1:true },\r\n  'blendFuncSeparate': { 0:true, 1:true, 2:true, 3:true },\r\n  'blendEquation': { 0:true },\r\n  'blendEquationSeparate': { 0:true, 1:true },\r\n  'stencilFunc': { 0:true },\r\n  'stencilFuncSeparate': { 0:true, 1:true },\r\n  'stencilMaskSeparate': { 0:true },\r\n  'stencilOp': { 0:true, 1:true, 2:true },\r\n  'stencilOpSeparate': { 0:true, 1:true, 2:true, 3:true },\r\n\r\n  // Culling\r\n\r\n  'cullFace': { 0:true },\r\n  'frontFace': { 0:true },\r\n};\r\n\r\n/**\r\n * Map of numbers to names.\r\n * @type {Object}\r\n */\r\nvar glEnums = null;\r\n\r\n/**\r\n * Initializes this module. Safe to call more than once.\r\n * @param {!WebGLRenderingContext} ctx A WebGL context. If\r\n *    you have more than one context it doesn't matter which one\r\n *    you pass in, it is only used to pull out constants.\r\n */\r\nfunction init(ctx) {\r\n  if (glEnums == null) {\r\n    glEnums = { };\r\n    for (var propertyName in ctx) {\r\n      if (typeof ctx[propertyName] == 'number') {\r\n        glEnums[ctx[propertyName]] = propertyName;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Checks the utils have been initialized.\r\n */\r\nfunction checkInit() {\r\n  if (glEnums == null) {\r\n    throw 'WebGLDebugUtils.init(ctx) not called';\r\n  }\r\n}\r\n\r\n/**\r\n * Returns true or false if value matches any WebGL enum\r\n * @param {*} value Value to check if it might be an enum.\r\n * @return {boolean} True if value matches one of the WebGL defined enums\r\n */\r\nfunction mightBeEnum(value) {\r\n  checkInit();\r\n  return (glEnums[value] !== undefined);\r\n}\r\n\r\n/**\r\n * Gets an string version of an WebGL enum.\r\n *\r\n * Example:\r\n *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());\r\n *\r\n * @param {number} value Value to return an enum for\r\n * @return {string} The string version of the enum.\r\n */\r\nfunction glEnumToString(value) {\r\n  checkInit();\r\n  var name = glEnums[value];\r\n  return (name !== undefined) ? name :\r\n      (\"*UNKNOWN WebGL ENUM (0x\" + value.toString(16) + \")\");\r\n}\r\n\r\n/**\r\n * Returns the string version of a WebGL argument.\r\n * Attempts to convert enum arguments to strings.\r\n * @param {string} functionName the name of the WebGL function.\r\n * @param {number} argumentIndx the index of the argument.\r\n * @param {*} value The value of the argument.\r\n * @return {string} The value as a string.\r\n */\r\nfunction glFunctionArgToString(functionName, argumentIndex, value) {\r\n  var funcInfo = glValidEnumContexts[functionName];\r\n  if (funcInfo !== undefined) {\r\n    if (funcInfo[argumentIndex]) {\r\n      return glEnumToString(value);\r\n    }\r\n  }\r\n  return value.toString();\r\n}\r\n\r\n/**\r\n * Given a WebGL context returns a wrapped context that calls\r\n * gl.getError after every command and calls a function if the\r\n * result is not gl.NO_ERROR.\r\n *\r\n * @param {!WebGLRenderingContext} ctx The webgl context to\r\n *        wrap.\r\n * @param {!function(err, funcName, args): void} opt_onErrorFunc\r\n *        The function to call when gl.getError returns an\r\n *        error. If not specified the default function calls\r\n *        console.log with a message.\r\n */\r\nfunction makeDebugContext(ctx, opt_onErrorFunc) {\r\n  init(ctx);\r\n  opt_onErrorFunc = opt_onErrorFunc || function(err, functionName, args) {\r\n        // apparently we can't do args.join(\",\");\r\n        var argStr = \"\";\r\n        for (var ii = 0; ii < args.length; ++ii) {\r\n          argStr += ((ii == 0) ? '' : ', ') +\r\n              glFunctionArgToString(functionName, ii, args[ii]);\r\n        }\r\n        log(\"WebGL error \"+ glEnumToString(err) + \" in \"+ functionName +\r\n            \"(\" + argStr + \")\");\r\n      };\r\n\r\n  // Holds booleans for each GL error so after we get the error ourselves\r\n  // we can still return it to the client app.\r\n  var glErrorShadow = { };\r\n\r\n  // Makes a function that calls a WebGL function and then calls getError.\r\n  function makeErrorWrapper(ctx, functionName) {\r\n    return function() {\r\n      var result = ctx[functionName].apply(ctx, arguments);\r\n      var err = ctx.getError();\r\n      if (err != 0) {\r\n        glErrorShadow[err] = true;\r\n        opt_onErrorFunc(err, functionName, arguments);\r\n      }\r\n      return result;\r\n    };\r\n  }\r\n\r\n  // Make a an object that has a copy of every property of the WebGL context\r\n  // but wraps all functions.\r\n  var wrapper = {};\r\n  for (var propertyName in ctx) {\r\n    if (typeof ctx[propertyName] == 'function') {\r\n       wrapper[propertyName] = makeErrorWrapper(ctx, propertyName);\r\n     } else {\r\n       wrapper[propertyName] = ctx[propertyName];\r\n     }\r\n  }\r\n\r\n  // Override the getError function with one that returns our saved results.\r\n  wrapper.getError = function() {\r\n    for (var err in glErrorShadow) {\r\n      if (glErrorShadow[err]) {\r\n        glErrorShadow[err] = false;\r\n        return err;\r\n      }\r\n    }\r\n    return ctx.NO_ERROR;\r\n  };\r\n\r\n  return wrapper;\r\n}\r\n\r\nfunction resetToInitialState(ctx) {\r\n  var numAttribs = ctx.getParameter(ctx.MAX_VERTEX_ATTRIBS);\r\n  var tmp = ctx.createBuffer();\r\n  ctx.bindBuffer(ctx.ARRAY_BUFFER, tmp);\r\n  for (var ii = 0; ii < numAttribs; ++ii) {\r\n    ctx.disableVertexAttribArray(ii);\r\n    ctx.vertexAttribPointer(ii, 4, ctx.FLOAT, false, 0, 0);\r\n    ctx.vertexAttrib1f(ii, 0);\r\n  }\r\n  ctx.deleteBuffer(tmp);\r\n\r\n  var numTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);\r\n  for (var ii = 0; ii < numTextureUnits; ++ii) {\r\n    ctx.activeTexture(ctx.TEXTURE0 + ii);\r\n    ctx.bindTexture(ctx.TEXTURE_CUBE_MAP, null);\r\n    ctx.bindTexture(ctx.TEXTURE_2D, null);\r\n  }\r\n\r\n  ctx.activeTexture(ctx.TEXTURE0);\r\n  ctx.useProgram(null);\r\n  ctx.bindBuffer(ctx.ARRAY_BUFFER, null);\r\n  ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, null);\r\n  ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);\r\n  ctx.bindRenderbuffer(ctx.RENDERBUFFER, null);\r\n  ctx.disable(ctx.BLEND);\r\n  ctx.disable(ctx.CULL_FACE);\r\n  ctx.disable(ctx.DEPTH_TEST);\r\n  ctx.disable(ctx.DITHER);\r\n  ctx.disable(ctx.SCISSOR_TEST);\r\n  ctx.blendColor(0, 0, 0, 0);\r\n  ctx.blendEquation(ctx.FUNC_ADD);\r\n  ctx.blendFunc(ctx.ONE, ctx.ZERO);\r\n  ctx.clearColor(0, 0, 0, 0);\r\n  ctx.clearDepth(1);\r\n  ctx.clearStencil(-1);\r\n  ctx.colorMask(true, true, true, true);\r\n  ctx.cullFace(ctx.BACK);\r\n  ctx.depthFunc(ctx.LESS);\r\n  ctx.depthMask(true);\r\n  ctx.depthRange(0, 1);\r\n  ctx.frontFace(ctx.CCW);\r\n  ctx.hint(ctx.GENERATE_MIPMAP_HINT, ctx.DONT_CARE);\r\n  ctx.lineWidth(1);\r\n  ctx.pixelStorei(ctx.PACK_ALIGNMENT, 4);\r\n  ctx.pixelStorei(ctx.UNPACK_ALIGNMENT, 4);\r\n  ctx.pixelStorei(ctx.UNPACK_FLIP_Y_WEBGL, false);\r\n  ctx.pixelStorei(ctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\r\n  // TODO: Delete this IF.\r\n  if (ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL) {\r\n    ctx.pixelStorei(ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL, ctx.BROWSER_DEFAULT_WEBGL);\r\n  }\r\n  ctx.polygonOffset(0, 0);\r\n  ctx.sampleCoverage(1, false);\r\n  ctx.scissor(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n  ctx.stencilFunc(ctx.ALWAYS, 0, 0xFFFFFFFF);\r\n  ctx.stencilMask(0xFFFFFFFF);\r\n  ctx.stencilOp(ctx.KEEP, ctx.KEEP, ctx.KEEP);\r\n  ctx.viewport(0, 0, ctx.canvas.clientWidth, ctx.canvas.clientHeight);\r\n  ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT | ctx.STENCIL_BUFFER_BIT);\r\n\r\n  // TODO: This should NOT be needed but Firefox fails with 'hint'\r\n  while(ctx.getError());\r\n}\r\n\r\nfunction makeLostContextSimulatingContext(ctx) {\r\n  var wrapper_ = {};\r\n  var contextId_ = 1;\r\n  var contextLost_ = false;\r\n  var resourceId_ = 0;\r\n  var resourceDb_ = [];\r\n  var onLost_ = undefined;\r\n  var onRestored_ = undefined;\r\n  var nextOnRestored_ = undefined;\r\n\r\n  // Holds booleans for each GL error so can simulate errors.\r\n  var glErrorShadow_ = { };\r\n\r\n  function isWebGLObject(obj) {\r\n    //return false;\r\n    return (obj instanceof WebGLBuffer ||\r\n            obj instanceof WebGLFramebuffer ||\r\n            obj instanceof WebGLProgram ||\r\n            obj instanceof WebGLRenderbuffer ||\r\n            obj instanceof WebGLShader ||\r\n            obj instanceof WebGLTexture);\r\n  }\r\n\r\n  function checkResources(args) {\r\n    for (var ii = 0; ii < args.length; ++ii) {\r\n      var arg = args[ii];\r\n      if (isWebGLObject(arg)) {\r\n        return arg.__webglDebugContextLostId__ == contextId_;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  function clearErrors() {\r\n    var k = Object.keys(glErrorShadow_);\r\n    for (var ii = 0; ii < k.length; ++ii) {\r\n      delete glErrorShdow_[k];\r\n    }\r\n  }\r\n\r\n  // Makes a function that simulates WebGL when out of context.\r\n  function makeLostContextWrapper(ctx, functionName) {\r\n    var f = ctx[functionName];\r\n    return function() {\r\n      // Only call the functions if the context is not lost.\r\n      if (!contextLost_) {\r\n        if (!checkResources(arguments)) {\r\n          glErrorShadow_[ctx.INVALID_OPERATION] = true;\r\n          return;\r\n        }\r\n        var result = f.apply(ctx, arguments);\r\n        return result;\r\n      }\r\n    };\r\n  }\r\n\r\n  for (var propertyName in ctx) {\r\n    if (typeof ctx[propertyName] == 'function') {\r\n       wrapper_[propertyName] = makeLostContextWrapper(ctx, propertyName);\r\n     } else {\r\n       wrapper_[propertyName] = ctx[propertyName];\r\n     }\r\n  }\r\n\r\n  function makeWebGLContextEvent(statusMessage) {\r\n    return {statusMessage: statusMessage};\r\n  }\r\n\r\n  function freeResources() {\r\n    for (var ii = 0; ii < resourceDb_.length; ++ii) {\r\n      var resource = resourceDb_[ii];\r\n      if (resource instanceof WebGLBuffer) {\r\n        ctx.deleteBuffer(resource);\r\n      } else if (resource instanceof WebctxFramebuffer) {\r\n        ctx.deleteFramebuffer(resource);\r\n      } else if (resource instanceof WebctxProgram) {\r\n        ctx.deleteProgram(resource);\r\n      } else if (resource instanceof WebctxRenderbuffer) {\r\n        ctx.deleteRenderbuffer(resource);\r\n      } else if (resource instanceof WebctxShader) {\r\n        ctx.deleteShader(resource);\r\n      } else if (resource instanceof WebctxTexture) {\r\n        ctx.deleteTexture(resource);\r\n      }\r\n    }\r\n  }\r\n\r\n  wrapper_.loseContext = function() {\r\n    if (!contextLost_) {\r\n      contextLost_ = true;\r\n      ++contextId_;\r\n      while (ctx.getError());\r\n      clearErrors();\r\n      glErrorShadow_[ctx.CONTEXT_LOST_WEBGL] = true;\r\n      setTimeout(function() {\r\n          if (onLost_) {\r\n            onLost_(makeWebGLContextEvent(\"context lost\"));\r\n          }\r\n        }, 0);\r\n    }\r\n  };\r\n\r\n  wrapper_.restoreContext = function() {\r\n    if (contextLost_) {\r\n      if (onRestored_) {\r\n        setTimeout(function() {\r\n            freeResources();\r\n            resetToInitialState(ctx);\r\n            contextLost_ = false;\r\n            if (onRestored_) {\r\n              var callback = onRestored_;\r\n              onRestored_ = nextOnRestored_;\r\n              nextOnRestored_ = undefined;\r\n              callback(makeWebGLContextEvent(\"context restored\"));\r\n            }\r\n          }, 0);\r\n      } else {\r\n        throw \"You can not restore the context without a listener\"\r\n      }\r\n    }\r\n  };\r\n\r\n  // Wrap a few functions specially.\r\n  wrapper_.getError = function() {\r\n    if (!contextLost_) {\r\n      var err;\r\n      while (err = ctx.getError()) {\r\n        glErrorShadow_[err] = true;\r\n      }\r\n    }\r\n    for (var err in glErrorShadow_) {\r\n      if (glErrorShadow_[err]) {\r\n        delete glErrorShadow_[err];\r\n        return err;\r\n      }\r\n    }\r\n    return ctx.NO_ERROR;\r\n  };\r\n\r\n  var creationFunctions = [\r\n    \"createBuffer\",\r\n    \"createFramebuffer\",\r\n    \"createProgram\",\r\n    \"createRenderbuffer\",\r\n    \"createShader\",\r\n    \"createTexture\"\r\n  ];\r\n  for (var ii = 0; ii < creationFunctions.length; ++ii) {\r\n    var functionName = creationFunctions[ii];\r\n    wrapper_[functionName] = function(f) {\r\n      return function() {\r\n        if (contextLost_) {\r\n          return null;\r\n        }\r\n        var obj = f.apply(ctx, arguments);\r\n        obj.__webglDebugContextLostId__ = contextId_;\r\n        resourceDb_.push(obj);\r\n        return obj;\r\n      };\r\n    }(ctx[functionName]);\r\n  }\r\n\r\n  var functionsThatShouldReturnNull = [\r\n    \"getActiveAttrib\",\r\n    \"getActiveUniform\",\r\n    \"getBufferParameter\",\r\n    \"getContextAttributes\",\r\n    \"getAttachedShaders\",\r\n    \"getFramebufferAttachmentParameter\",\r\n    \"getParameter\",\r\n    \"getProgramParameter\",\r\n    \"getProgramInfoLog\",\r\n    \"getRenderbufferParameter\",\r\n    \"getShaderParameter\",\r\n    \"getShaderInfoLog\",\r\n    \"getShaderSource\",\r\n    \"getTexParameter\",\r\n    \"getUniform\",\r\n    \"getUniformLocation\",\r\n    \"getVertexAttrib\"\r\n  ];\r\n  for (var ii = 0; ii < functionsThatShouldReturnNull.length; ++ii) {\r\n    var functionName = functionsThatShouldReturnNull[ii];\r\n    wrapper_[functionName] = function(f) {\r\n      return function() {\r\n        if (contextLost_) {\r\n          return null;\r\n        }\r\n        return f.apply(ctx, arguments);\r\n      }\r\n    }(wrapper_[functionName]);\r\n  }\r\n\r\n  var isFunctions = [\r\n    \"isBuffer\",\r\n    \"isEnabled\",\r\n    \"isFramebuffer\",\r\n    \"isProgram\",\r\n    \"isRenderbuffer\",\r\n    \"isShader\",\r\n    \"isTexture\"\r\n  ];\r\n  for (var ii = 0; ii < isFunctions.length; ++ii) {\r\n    var functionName = isFunctions[ii];\r\n    wrapper_[functionName] = function(f) {\r\n      return function() {\r\n        if (contextLost_) {\r\n          return false;\r\n        }\r\n        return f.apply(ctx, arguments);\r\n      }\r\n    }(wrapper_[functionName]);\r\n  }\r\n\r\n  wrapper_.checkFramebufferStatus = function(f) {\r\n    return function() {\r\n      if (contextLost_) {\r\n        return ctx.FRAMEBUFFER_UNSUPPORTED;\r\n      }\r\n      return f.apply(ctx, arguments);\r\n    };\r\n  }(wrapper_.checkFramebufferStatus);\r\n\r\n  wrapper_.getAttribLocation = function(f) {\r\n    return function() {\r\n      if (contextLost_) {\r\n        return -1;\r\n      }\r\n      return f.apply(ctx, arguments);\r\n    };\r\n  }(wrapper_.getAttribLocation);\r\n\r\n  wrapper_.getVertexAttribOffset = function(f) {\r\n    return function() {\r\n      if (contextLost_) {\r\n        return 0;\r\n      }\r\n      return f.apply(ctx, arguments);\r\n    };\r\n  }(wrapper_.getVertexAttribOffset);\r\n\r\n  wrapper_.isContextLost = function() {\r\n    return contextLost_;\r\n  };\r\n\r\n  function wrapEvent(listener) {\r\n    if (typeof(listener) == \"function\") {\r\n      return listener;\r\n    } else {\r\n      return function(info) {\r\n        listener.handleEvent(info);\r\n      }\r\n    }\r\n  }\r\n\r\n  wrapper_.registerOnContextLostListener = function(listener) {\r\n    onLost_ = wrapEvent(listener);\r\n  };\r\n\r\n  wrapper_.registerOnContextRestoredListener = function(listener) {\r\n    if (contextLost_) {\r\n      nextOnRestored_ = wrapEvent(listener);\r\n    } else {\r\n      onRestored_ = wrapEvent(listener);\r\n    }\r\n  }\r\n\r\n  return wrapper_;\r\n}\r\n\r\nreturn {\r\n  /**\r\n   * Initializes this module. Safe to call more than once.\r\n   * @param {!WebGLRenderingContext} ctx A WebGL context. If\r\n   *    you have more than one context it doesn't matter which one\r\n   *    you pass in, it is only used to pull out constants.\r\n   */\r\n  'init': init,\r\n\r\n  /**\r\n   * Returns true or false if value matches any WebGL enum\r\n   * @param {*} value Value to check if it might be an enum.\r\n   * @return {boolean} True if value matches one of the WebGL defined enums\r\n   */\r\n  'mightBeEnum': mightBeEnum,\r\n\r\n  /**\r\n   * Gets an string version of an WebGL enum.\r\n   *\r\n   * Example:\r\n   *   WebGLDebugUtil.init(ctx);\r\n   *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());\r\n   *\r\n   * @param {number} value Value to return an enum for\r\n   * @return {string} The string version of the enum.\r\n   */\r\n  'glEnumToString': glEnumToString,\r\n\r\n  /**\r\n   * Converts the argument of a WebGL function to a string.\r\n   * Attempts to convert enum arguments to strings.\r\n   *\r\n   * Example:\r\n   *   WebGLDebugUtil.init(ctx);\r\n   *   var str = WebGLDebugUtil.glFunctionArgToString('bindTexture', 0, gl.TEXTURE_2D);\r\n   *\r\n   * would return 'TEXTURE_2D'\r\n   *\r\n   * @param {string} functionName the name of the WebGL function.\r\n   * @param {number} argumentIndx the index of the argument.\r\n   * @param {*} value The value of the argument.\r\n   * @return {string} The value as a string.\r\n   */\r\n  'glFunctionArgToString': glFunctionArgToString,\r\n\r\n  /**\r\n   * Given a WebGL context returns a wrapped context that calls\r\n   * gl.getError after every command and calls a function if the\r\n   * result is not NO_ERROR.\r\n   *\r\n   * You can supply your own function if you want. For example, if you'd like\r\n   * an exception thrown on any GL error you could do this\r\n   *\r\n   *    function throwOnGLError(err, funcName, args) {\r\n   *      throw WebGLDebugUtils.glEnumToString(err) + \" was caused by call to\" +\r\n   *            funcName;\r\n   *    };\r\n   *\r\n   *    ctx = WebGLDebugUtils.makeDebugContext(\r\n   *        canvas.getContext(\"webgl\"), throwOnGLError);\r\n   *\r\n   * @param {!WebGLRenderingContext} ctx The webgl context to wrap.\r\n   * @param {!function(err, funcName, args): void} opt_onErrorFunc The function\r\n   *     to call when gl.getError returns an error. If not specified the default\r\n   *     function calls console.log with a message.\r\n   */\r\n  'makeDebugContext': makeDebugContext,\r\n\r\n  /**\r\n   * Given a WebGL context returns a wrapped context that adds 4\r\n   * functions.\r\n   *\r\n   * ctx.loseContext:\r\n   *   simulates a lost context event.\r\n   *\r\n   * ctx.restoreContext:\r\n   *   simulates the context being restored.\r\n   *\r\n   * ctx.registerOnContextLostListener(listener):\r\n   *   lets you register a listener for context lost. Use instead\r\n   *   of addEventListener('webglcontextlostevent', listener);\r\n   *\r\n   * ctx.registerOnContextRestoredListener(listener):\r\n   *   lets you register a listener for context restored. Use\r\n   *   instead of addEventListener('webglcontextrestored',\r\n   *   listener);\r\n   *\r\n   * @param {!WebGLRenderingContext} ctx The webgl context to wrap.\r\n   */\r\n  'makeLostContextSimulatingContext': makeLostContextSimulatingContext,\r\n\r\n  /**\r\n   * Resets a context to the initial state.\r\n   * @param {!WebGLRenderingContext} ctx The webgl context to\r\n   *     reset.\r\n   */\r\n  'resetToInitialState': resetToInitialState\r\n};\r\n\r\n}();\r\n\r\n/* harmony default export */ var webgl_debug = (WebGLDebugUtils);\n// CONCATENATED MODULE: ./src/util/Util.js\n\r\n\r\n\r\nconst Util = {\r\n    initShaders: function(gl, vshader, fshader) {\r\n        var program = Util.createProgram(gl, vshader, fshader);\r\n        if (!program) {\r\n            console.log('Failed to create program');\r\n            return false;\r\n        }\r\n\r\n        gl.useProgram(program);\r\n        gl.program = program;\r\n\r\n        return true;\r\n    },\r\n\r\n    createProgram: function(gl, vshader, fshader) {\r\n        // Create shader object\r\n        var vertexShader = Util.loadShader(gl, gl.VERTEX_SHADER, vshader);\r\n        var fragmentShader = Util.loadShader(gl, gl.FRAGMENT_SHADER, fshader);\r\n        if (!vertexShader || !fragmentShader) {\r\n            return null;\r\n        }\r\n\r\n        // Create a program object\r\n        var program = gl.createProgram();\r\n        if (!program) {\r\n            return null;\r\n        }\r\n\r\n        // Attach the shader objects\r\n        gl.attachShader(program, vertexShader);\r\n        gl.attachShader(program, fragmentShader);\r\n\r\n        // Link the program object\r\n        gl.linkProgram(program);\r\n\r\n        // Check the result of linking\r\n        var linked = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n        if (!linked) {\r\n            var error = gl.getProgramInfoLog(program);\r\n            console.log('Failed to link program: ' + error);\r\n            gl.deleteProgram(program);\r\n            gl.deleteShader(fragmentShader);\r\n            gl.deleteShader(vertexShader);\r\n            return null;\r\n        }\r\n        return program;\r\n    },\r\n\r\n    loadShader: function(gl, type, source) {\r\n        // Create shader object\r\n        var shader = gl.createShader(type);\r\n        if (shader == null) {\r\n            console.log('unable to create shader');\r\n            return null;\r\n        }\r\n\r\n        // Set the shader program\r\n        gl.shaderSource(shader, source);\r\n\r\n        // Compile the shader\r\n        gl.compileShader(shader);\r\n\r\n        // Check the result of compilation\r\n        var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n        if (!compiled) {\r\n            var error = gl.getShaderInfoLog(shader);\r\n            console.log('Failed to compile shader: ' + error);\r\n            gl.deleteShader(shader);\r\n            return null;\r\n        }\r\n\r\n        return shader;\r\n    },\r\n\r\n    getWebGLContext: function(canvas, opt_debug) {\r\n        // Get the rendering context for WebGL\r\n        var gl = webgl_utils.setupWebGL(canvas);\r\n        if (!gl) return null;\r\n\r\n        // if opt_debug is explicitly false, create the context for debugging\r\n        if (arguments.length < 2 || opt_debug) {\r\n            gl = webgl_debug.makeDebugContext(gl);\r\n        }\r\n\r\n        return gl;\r\n    },\r\n\r\n    create3DContext : function(canvas, opt_attribs) {\r\n        var names = [\"webgl\", \"experimental-webgl\", \"webkit-3d\", \"moz-webgl\"];\r\n        var context = null;\r\n        for (var ii = 0; ii < names.length; ++ii) {\r\n            try {\r\n                context = canvas.getContext(names[ii], opt_attribs);\r\n            } catch(e) {}\r\n            if (context) {\r\n                break;\r\n            }\r\n        }\r\n        return context;\r\n    }\r\n}\r\n\r\n/* harmony default export */ var util_Util = (Util);\n// CONCATENATED MODULE: ./src/light/Light.js\n\r\nclass Light {\r\n    constructor(param) {\r\n        this.type = 'Light';\r\n\r\n        param = param || {};\r\n        this.color = param.color || [1,1,1];\r\n        this.intensity = param.intensity !== undefined ? param.intensity : 1;\r\n        this.castShadow = param.castShadow;\r\n    }\r\n}\r\n\r\n/* harmony default export */ var light_Light = (Light);\r\n\n// CONCATENATED MODULE: ./src/light/AmbientLight.js\n\r\n\r\nclass AmbientLight_AmbientLight extends light_Light{\r\n    constructor(param) {\r\n        super(param);\r\n        this.type = 'AmbientLight';\r\n    }\r\n}\r\n\r\n/* harmony default export */ var light_AmbientLight = (AmbientLight_AmbientLight);\r\n\n// CONCATENATED MODULE: ./src/light/DirectionalLight.js\n\r\n\r\n\r\nclass DirectionalLight_DirectionalLight extends light_Light{\r\n    constructor(param) {\r\n        super(param);\r\n        this.type = 'DirectionalLight';\r\n        this.direction = [1,1,1];\r\n        this.setDirection(param.direction || [1,1,1]);\r\n    }\r\n\r\n    setDirection(direction){\r\n        this.direction =  new Vector3().fromArray(direction).normalize().toArray();\r\n    }\r\n}\r\n\r\n/* harmony default export */ var light_DirectionalLight = (DirectionalLight_DirectionalLight);\r\n\n// CONCATENATED MODULE: ./src/composer/Composer.js\nclass Composer{\r\n    constructor(){\r\n        this.vertexShader = [\r\n            'precision highp int;',\r\n            'precision highp float;',\r\n            'attribute vec4 a_Position;',\r\n            'attribute vec2 a_TexCoord;',\r\n            \"varying vec2 vUv;\",\r\n\r\n            \"void main() {\",\r\n\r\n            \"vUv = a_TexCoord;\",\r\n            \"gl_Position = a_Position;\",\r\n            \"gl_Position.z = 0.0;\",\r\n\r\n            \"}\"\r\n\r\n        ].join( \"\\n\" );\r\n\r\n        this.fragmentShader = [\r\n\r\n            '#define lineWidth 2',\r\n            'precision highp int;',\r\n            'precision highp float;',\r\n            \"uniform sampler2D tDiffuse;\",\r\n\r\n            \"varying vec2 vUv;\",\r\n\r\n            \"float getGray(vec4 color){\",\r\n            \"\treturn (color.r + color.g + color.b)/3.0;\",\r\n            // \"\treturn color.r*0.299 + color.g*0.587 + color.b*0.114;\",\r\n            \"}\",\r\n\r\n            \"float getEdgeGray(vec2 uv){\",\r\n            \"\tfloat step = 1.0/600.0;\",\r\n            \"\tfloat gray = 0.0;\",\r\n\r\n            \"\tgray += -1.0 * getGray(texture2D( tDiffuse, vec2(uv.x-step, uv.y-step) ));\",\r\n            \"\tgray += -1.0 * getGray(texture2D( tDiffuse, vec2(uv.x, uv.y-step) ));\",\r\n            \"\tgray += -1.0 * getGray(texture2D( tDiffuse, vec2(uv.x+step, uv.y-step) ));\",\r\n\r\n            \"\tgray += -1.0 * getGray(texture2D( tDiffuse, vec2(uv.x-step, uv.y) ));\",\r\n            \"\tgray += 8.0 * getGray(texture2D( tDiffuse, vec2(uv.x, uv.y) ));\",\r\n            \"\tgray += -1.0 * getGray(texture2D( tDiffuse, vec2(uv.x+step, uv.y) ));\",\r\n\r\n            \"\tgray += -1.0 * getGray(texture2D( tDiffuse, vec2(uv.x-step, uv.y+step) ));\",\r\n            \"\tgray += -1.0 * getGray(texture2D( tDiffuse, vec2(uv.x, uv.y+step) ));\",\r\n            \"\tgray += -1.0 * getGray(texture2D( tDiffuse, vec2(uv.x+step, uv.y+step) ));\",\r\n\r\n            \"\treturn floor(gray+0.5);\",\r\n            \"}\",\r\n\r\n            \"float getFinalGray(vec2 uv){\",\r\n            \"\tfloat step = 1.0/600.0;\",\r\n            \"\tfor(int i=-lineWidth; i<lineWidth; i++){\",\r\n            \"\t    for(int j=-lineWidth; j<lineWidth; j++){\",\r\n            \"\t        if(getEdgeGray(vec2(uv.x+step*float(i), uv.y+step*float(j)))>0.5){\",\r\n            \"\t            return 1.0;\",\r\n            \"\t        }\",\r\n            \"\t    }\",\r\n            \"\t}\",\r\n            \"\treturn 0.0;\",\r\n            \"}\",\r\n\r\n            \"void main() {\",\r\n\r\n            \"vec4 texel = texture2D( tDiffuse, vUv );\",\r\n            \"float gray = getFinalGray(vUv);\",\r\n\r\n            \"vec4 finalColor = vec4(0,0,1,1) * gray;\",\r\n\r\n            \"gl_FragColor = finalColor;\",\r\n\r\n            \"}\"\r\n\r\n        ].join( \"\\n\" );\r\n\r\n    }\r\n}\r\n\r\n/* harmony default export */ var composer_Composer = (Composer);\r\n\n// CONCATENATED MODULE: ./src/composer/ComposerOthers.js\n\r\n\r\nclass ComposerOthers_ComposerOthers extends composer_Composer{\r\n    constructor(){\r\n        super();\r\n\r\n        this.vertexShader =\r\n            'precision highp int;\\n' +\r\n            'precision highp float;\\n' +\r\n            'attribute vec4 a_Position;\\n' +\r\n            'uniform mat4 u_MvMatrix;\\n' +\r\n            'uniform mat4 u_PMatrix;\\n' +\r\n            'void main() {\\n' +\r\n            '  gl_Position = u_PMatrix * u_MvMatrix * a_Position;\\n' +\r\n            '}\\n';\r\n\r\n        this.fragmentShader = 'precision highp int;\\n' +\r\n            'precision highp float;\\n' +\r\n            'void main() {\\n' +\r\n            '  gl_FragColor = vec4(0,0,0,0);\\n' +\r\n            '}\\n';\r\n\r\n    }\r\n}\r\n\r\n/* harmony default export */ var composer_ComposerOthers = (ComposerOthers_ComposerOthers);\r\n\n// CONCATENATED MODULE: ./src/composer/ComposerScheme.js\n\r\n\r\nclass ComposerScheme_ComposerScheme extends composer_Composer{\r\n    constructor(){\r\n        super();\r\n\r\n        this.vertexShader =\r\n            'precision highp int;\\n' +\r\n            'precision highp float;\\n' +\r\n            'attribute vec4 a_Position;\\n' +\r\n            'uniform mat4 u_MvMatrix;\\n' +\r\n            'uniform mat4 u_PMatrix;\\n' +\r\n            'void main() {\\n' +\r\n            '  gl_Position = u_PMatrix * u_MvMatrix * a_Position;\\n' +\r\n            '}\\n';\r\n\r\n        this.fragmentShader = 'precision highp int;\\n' +\r\n            'precision highp float;\\n' +\r\n            'void main() {\\n' +\r\n            '  gl_FragColor = vec4(1,1,1,1);\\n' +\r\n            '}\\n';\r\n\r\n    }\r\n}\r\n\r\n/* harmony default export */ var composer_ComposerScheme = (ComposerScheme_ComposerScheme);\r\n\n// CONCATENATED MODULE: ./src/core/Renderer.js\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// import md5 from 'js-md5';\r\n\r\nclass Renderer_Renderer {\r\n    constructor(param) {\r\n        var that = this;\r\n        param = param || {};\r\n        this.bufferList = [];\r\n\r\n        // this.programList = [];\r\n        this.programList = {};\r\n\r\n        this.curCameraPosition = null;\r\n        this.renderList = {\r\n            opacityList:[],\r\n            transparentList:[]\r\n        };\r\n\r\n        var canvas = document.getElementById('webgl');\r\n        var gl = this.gl = canvas.getContext('webgl');\r\n\r\n        //-----------------------\r\n        gl.enable(gl.CULL_FACE);\r\n        gl.enable(gl.DEPTH_TEST);\r\n        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\r\n        // gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\r\n        gl.clearColor(0.0, 0.0, 0.0, 1.0);\r\n\r\n    }\r\n\r\n    getProgramByVF(v, f){\r\n        var that = this;\r\n        var gl = that.gl;\r\n\r\n        var vertexShader = this.vshader = util_Util.loadShader(gl, gl.VERTEX_SHADER, v);\r\n        var fragmentShader = this.fshader = util_Util.loadShader(gl, gl.FRAGMENT_SHADER, f);\r\n        if (!vertexShader || !fragmentShader) {\r\n            return null;\r\n        }\r\n\r\n        var program = gl.createProgram();\r\n        if (!program) {\r\n            return null;\r\n        }\r\n\r\n        gl.attachShader(program, vertexShader);\r\n        gl.attachShader(program, fragmentShader);\r\n\r\n        gl.linkProgram(program);\r\n        var linked = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n        if (!linked) {\r\n            var error = gl.getProgramInfoLog(program);\r\n            console.log('Failed to link program: ' + error);\r\n            gl.deleteProgram(program);\r\n            gl.deleteShader(fragmentShader);\r\n            gl.deleteShader(vertexShader);\r\n            return null;\r\n        }\r\n\r\n        return program;\r\n    }\r\n\r\n    setProgram(v, f){\r\n        var that = this;\r\n        var gl = that.gl;\r\n\r\n        // if (!Util.initShaders(gl, v, f)) {\r\n        //     console.log('Failed to intialize shaders.');\r\n        //     return;\r\n        // }\r\n\r\n        var md5vf = (v+f);\r\n        var prog = that.programList[md5vf];\r\n        if(prog){\r\n            gl.useProgram(prog);\r\n            gl.program = prog;\r\n            return;\r\n        }\r\n\r\n        var program = that.getProgramByVF(v,f);\r\n\r\n        that.programList[md5vf] = program;\r\n\r\n        gl.useProgram(program);\r\n        gl.program = program;\r\n    }\r\n\r\n    getCameraLight(directionalLight){\r\n        var cameraLight = new COOL.OrthoCamera(-100, 100, -100, 100, 0, 300);\r\n        // var cameraLight = new COOL.Camera(30,1,1,10);\r\n        var caPos = directionalLight.direction;\r\n        caPos = caPos.map(function (item) {\r\n            return item * 100;\r\n        });\r\n        cameraLight.setPosition(caPos);\r\n        cameraLight.setTarget([0,0,0]);\r\n\r\n        return cameraLight;\r\n    }\r\n\r\n    render(scene, camera){\r\n        var that = this;\r\n        that.curCameraPosition = camera.position;\r\n\r\n        var renderList = that.sortRenderList(scene);\r\n\r\n        var gl = that.gl;\r\n        gl.enable(gl.DEPTH_TEST);\r\n\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n        if(that.useSkyBox){\r\n            this.renderSkyBox(camera);\r\n        }\r\n\r\n        var ambientLight = null;\r\n        var directionalLight = null;\r\n\r\n        for(var i in scene.lights){\r\n            if(scene.lights[i].type == 'DirectionalLight'){\r\n                directionalLight = scene.lights[i];\r\n            }else if(scene.lights[i].type == 'AmbientLight'){\r\n                ambientLight = scene.lights[i];\r\n            }\r\n        }\r\n\r\n        ambientLight = ambientLight || new light_AmbientLight({intensity:0});\r\n        directionalLight = directionalLight || new light_DirectionalLight({intensity:0});\r\n\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n        gl.viewport(0, 0, 600, 600);\r\n        gl.enable (gl.BLEND);\r\n        // gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n        for(var i in renderList){\r\n            this.renderOneMesh(renderList[i], camera, ambientLight, directionalLight);\r\n        }\r\n\r\n    }\r\n\r\n    renderOneMesh(mesh, camera, ambientLight, directionalLight){\r\n        var that = this;\r\n\r\n        var mesh = mesh || new core_Mesh();\r\n        var geometry = mesh.geometry;\r\n        var material = mesh.material;\r\n        var map = material.map;\r\n        var envMap = material.envMap;\r\n        var color = material.color;\r\n\r\n        var v = material.vshaderSource;\r\n        var f = material.fshaderSource;\r\n\r\n        var vDef = '';\r\n        var fDef = '';\r\n        if(material.type == 'MeshLambertMaterial'){\r\n            fDef += '#define USE_AmbientLight\\n';\r\n            fDef += '#define USE_DirectionalLight\\n';\r\n\r\n        }else if(material.type == 'MeshStandardMaterial'){\r\n\r\n            fDef += '#define USE_AmbientLight\\n';\r\n\r\n            vDef += '#define USE_SColor\\n';\r\n\r\n            fDef += '#define USE_DirectionalLight\\n';\r\n            fDef += '#define USE_SColor\\n';\r\n\r\n\r\n        }\r\n\r\n        if(map && map.image && map.image.width  && map.image.height){\r\n            fDef += '#define USE_Map\\n';\r\n        }\r\n\r\n        if(envMap && envMap.imgReady){\r\n            vDef += '#define USE_envMap\\n';\r\n            fDef += '#define USE_envMap\\n';\r\n        }\r\n\r\n        if(that.useShadow){\r\n            vDef += '#define USE_Shadow\\n';\r\n            fDef += '#define USE_Shadow\\n';\r\n        }\r\n\r\n        v = vDef + v;\r\n        f = fDef + f;\r\n\r\n        this.setProgram(v,f);\r\n\r\n        var gl = that.gl;\r\n\r\n        var bufferMesh = gl.createBuffer();\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, bufferMesh);\r\n        gl.bufferData(gl.ARRAY_BUFFER, geometry.buffer, gl.STATIC_DRAW);\r\n        var bufferFSIZE = geometry.buffer.BYTES_PER_ELEMENT;\r\n\r\n        var a_Position = gl.getAttribLocation(gl.program, 'a_Position');\r\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, bufferFSIZE * 8, bufferFSIZE * 0);\r\n        gl.enableVertexAttribArray(a_Position);\r\n\r\n        var a_Normal = gl.getAttribLocation(gl.program, 'a_Normal');\r\n        gl.vertexAttribPointer(a_Normal, 3, gl.FLOAT, false, bufferFSIZE * 8, bufferFSIZE * 3);\r\n        gl.enableVertexAttribArray(a_Normal);\r\n\r\n        var a_TexCoord = gl.getAttribLocation(gl.program, 'a_TexCoord');\r\n        gl.vertexAttribPointer(a_TexCoord, 2, gl.FLOAT, false, bufferFSIZE * 8, bufferFSIZE * 6);\r\n        gl.enableVertexAttribArray(a_TexCoord);\r\n\r\n\r\n        var indexBuffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, geometry.indices, gl.STATIC_DRAW);\r\n\r\n        var u_Color = gl.getUniformLocation(gl.program, 'u_Color');\r\n        gl.uniform4f(u_Color, color[0], color[1], color[2], color[3]);\r\n\r\n        var u_Metalness = gl.getUniformLocation(gl.program, 'u_Metalness');\r\n        gl.uniform1f(u_Metalness, material.metalness);\r\n\r\n        if(f.indexOf('#define USE_SColor')!=-1 || f.indexOf('#define USE_envMap')!=-1){\r\n            var u_Camera_Position = gl.getUniformLocation(gl.program, 'u_Camera_Position');\r\n            gl.uniform3f(u_Camera_Position, camera.position[0], camera.position[1], camera.position[2]);\r\n        }\r\n\r\n        if(f.indexOf('#define USE_AmbientLight')!=-1){\r\n            var u_AmbientLight_Color = gl.getUniformLocation(gl.program, 'u_AmbientLight_Color');\r\n            var ambientLightColor = ambientLight.color;\r\n            ambientLightColor = ambientLightColor.map(function (item) {\r\n                return ambientLight.intensity * item;\r\n            });\r\n            gl.uniform3f(u_AmbientLight_Color, ambientLightColor[0], ambientLightColor[1], ambientLightColor[2]);\r\n        }\r\n\r\n        if(f.indexOf('#define USE_DirectionalLight')!=-1){\r\n            var u_DirectionalLight_Direction = gl.getUniformLocation(gl.program, 'u_DirectionalLight_Direction');\r\n            var directionalLight_Direction = directionalLight.direction;\r\n            gl.uniform3f(u_DirectionalLight_Direction, directionalLight_Direction[0], directionalLight_Direction[1], directionalLight_Direction[2]);\r\n\r\n            var u_DirectionalLight_Color = gl.getUniformLocation(gl.program, 'u_DirectionalLight_Color');\r\n            var directionalLight_Color = directionalLight.color;\r\n            directionalLight_Color = directionalLight_Color.map(function (item) {\r\n                return directionalLight.intensity * item;\r\n            });\r\n            gl.uniform3f(u_DirectionalLight_Color, directionalLight_Color[0], directionalLight_Color[1], directionalLight_Color[2]);\r\n        }\r\n\r\n\r\n        var u_MvMatrix = gl.getUniformLocation(gl.program, 'u_MvMatrix');\r\n        var mvMatrix = mesh.matrixWorld;\r\n        gl.uniformMatrix4fv(u_MvMatrix, false, mvMatrix.elements);\r\n\r\n        var u_PMatrix = gl.getUniformLocation(gl.program, 'u_PMatrix');\r\n        var PMatrix = camera.VPmatrix;\r\n        gl.uniformMatrix4fv(u_PMatrix, false, PMatrix.elements);\r\n\r\n        if(v.indexOf('#define USE_Shadow')!=-1){\r\n            var ca = that.getCameraLight(directionalLight);\r\n            var u_PMatrixFromLight = gl.getUniformLocation(gl.program, 'u_PMatrixFromLight');\r\n            gl.uniformMatrix4fv(u_PMatrixFromLight, false, ca.VPmatrix.elements);\r\n\r\n            gl.activeTexture(gl.TEXTURE0);\r\n            gl.bindTexture(gl.TEXTURE_2D, that.shadow_fbo.texture);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, COOL.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, COOL.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, COOL.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, COOL.CLAMP_TO_EDGE);\r\n            var u_ShadowMap = gl.getUniformLocation(gl.program, 'u_ShadowMap');\r\n            gl.uniform1i(u_ShadowMap, 0);\r\n        }\r\n\r\n\r\n\r\n\r\n        if(f.indexOf('#define USE_Map')!=-1){\r\n\r\n            var texture = that.texture = gl.createTexture();   // Create a texture object\r\n            // gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1); // Flip the image's y axis\r\n\r\n            gl.activeTexture(gl.TEXTURE1); //bindTexture\r\n            gl.bindTexture(gl.TEXTURE_2D, texture);\r\n\r\n            var u_Sampler = gl.getUniformLocation(gl.program, 'u_Sampler');\r\n            gl.uniform1i(u_Sampler, 1);\r\n\r\n            // Set the texture parameters\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, map.magFilter);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, map.minFilter);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, map.wrapS);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, map.wrapT);\r\n\r\n            // Set the texture image\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, map.image);\r\n        }\r\n\r\n        if(f.indexOf('#define USE_envMap')!=-1){\r\n\r\n            var texture = that.env_texture = gl.createTexture();\r\n            gl.activeTexture(gl.TEXTURE7);\r\n            gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);\r\n\r\n            var images = envMap.images;\r\n            var faceInfos = [\r\n                {\r\n                    target: gl.TEXTURE_CUBE_MAP_POSITIVE_X,\r\n                    image:images[0],\r\n                },\r\n                {\r\n                    target: gl.TEXTURE_CUBE_MAP_NEGATIVE_X,\r\n                    image:images[1],\r\n                },\r\n                {\r\n                    target: gl.TEXTURE_CUBE_MAP_POSITIVE_Y,\r\n                    image:images[2],\r\n                },\r\n                {\r\n                    target: gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,\r\n                    image:images[3],\r\n                },\r\n                {\r\n                    target: gl.TEXTURE_CUBE_MAP_POSITIVE_Z,\r\n                    image:images[4],\r\n                },\r\n                {\r\n                    target: gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,\r\n                    image:images[5],\r\n                },\r\n            ];\r\n\r\n            faceInfos.forEach((faceInfo) => {\r\n                const {target, image} = faceInfo;\r\n\r\n                const level = 0;\r\n                const internalFormat = gl.RGBA;\r\n                const format = gl.RGBA;\r\n                const type = gl.UNSIGNED_BYTE;\r\n\r\n                gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);\r\n                gl.texImage2D(target, level, internalFormat, format, type, image);\r\n\r\n            });\r\n\r\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, envMap.magFilter);\r\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, envMap.minFilter);\r\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, envMap.wrapS);\r\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, envMap.wrapT);\r\n\r\n            var u_envMap = gl.getUniformLocation(gl.program, \"u_envMap\");\r\n            gl.uniform1i(u_envMap, 7);\r\n\r\n\r\n        }\r\n\r\n        var model = material.wireframe ? gl.LINE_STRIP : gl.TRIANGLES;\r\n        gl.drawElements(model, geometry.indices.length, gl.UNSIGNED_SHORT, 0);\r\n\r\n        if(that.texture){\r\n            gl.deleteTexture(that.texture);\r\n            that.texture = null;\r\n        }\r\n        if(that.env_texture){\r\n            gl.deleteTexture(that.env_texture);\r\n            that.env_texture = null;\r\n        }\r\n\r\n        // gl.deleteBuffer(bufferMesh);\r\n        that.addBuffer(bufferMesh);\r\n        gl.deleteBuffer(indexBuffer);\r\n\r\n        gl.deleteShader(that.vshader);\r\n        gl.deleteShader(that.fshader);\r\n        // gl.deleteProgram(gl.program);\r\n\r\n    }\r\n\r\n    addBuffer(buffer){\r\n        //buffer\r\n        this.bufferList.push(buffer);\r\n        if(this.bufferList.length > 1){\r\n            var bb = this.bufferList.shift();\r\n            this.gl.deleteBuffer(bb);\r\n        }\r\n    }\r\n\r\n    getAllObjList(obj, allObjList){\r\n        var that = this;\r\n        for(var i in obj.children){\r\n            if(obj.children[i].geometry){\r\n                allObjList.push(obj.children[i]);\r\n            }\r\n            that.getAllObjList(obj.children[i],allObjList);\r\n        }\r\n        return allObjList;\r\n    }\r\n\r\n    sortRenderList(scene){\r\n        var that = this;\r\n\r\n        var allObjList = that.getAllObjList(scene ,[]);\r\n\r\n        for(var i in allObjList){\r\n            var pa = allObjList[i].getWorldPosition();\r\n            var pc = new Vector3().fromArray(that.curCameraPosition);\r\n            var da = pc.distanceTo(pa);\r\n            allObjList[i].distanceToCamera = da;\r\n        }\r\n        var allObjSortedList = allObjList.sort(that.sortFun);\r\n        // var opacityList = [];\r\n        // var transparentList = [];\r\n        //\r\n        // for(var i in allObjSortedList){\r\n        //     if(allObjSortedList[i].material.transparent){\r\n        //         transparentList.push(allObjSortedList[i]);\r\n        //     }else {\r\n        //         opacityList.push(allObjSortedList[i]);\r\n        //     }\r\n        // }\r\n        //\r\n        // that.renderList = {\r\n        //     opacityList: opacityList,\r\n        //     transparentList: transparentList\r\n        // };\r\n\r\n        return allObjSortedList;\r\n    }\r\n\r\n    sortFun(a, b){\r\n        return b.distanceToCamera - a.distanceToCamera;\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ var core_Renderer = (Renderer_Renderer);\r\n\n// CONCATENATED MODULE: ./src/camera/CameraController.js\n\r\n\r\n\r\nclass CameraController_CameraController {\r\n    constructor(camera) {\r\n        this.camera = camera;\r\n\r\n        this.mouse0State = 'up';\r\n        this.mouse1State = 'up';\r\n        this.mouse2State = 'up';\r\n\r\n        this.x = -1;\r\n        this.y = -1;\r\n\r\n        this.minTilt = 0.1;\r\n        this.maxTilt = 3.04;\r\n    }\r\n\r\n    update(){\r\n        var that = this;\r\n\r\n        window.addEventListener('mousedown',function (e) {\r\n            // console.log(e.button+' down '+e.clientX+','+e.clientY);\r\n            var dom =  window.document.getElementsByTagName('canvas')[0];\r\n            if(!dom){\r\n                return;\r\n            }\r\n            var rect = dom.getBoundingClientRect();\r\n            if(e.clientX < rect.left || e.clientX > rect.right || e.clientY < rect.top || e.clientY > rect.bottom){\r\n                return;\r\n            }\r\n            if(e.button == 0){\r\n                that.mouse0State = 'down';\r\n            }else if(e.button == 1){\r\n                that.mouse1State = 'down';\r\n            }else if(e.button == 2){\r\n                that.mouse2State = 'down';\r\n            }\r\n        });\r\n\r\n        window.addEventListener('mouseup',function (e) {\r\n            // console.log(e.button+' up '+e.clientX+','+e.clientY);\r\n            if(e.button == 0){\r\n                that.mouse0State = 'up';\r\n            }else if(e.button == 1){\r\n                that.mouse1State = 'up';\r\n            }else if(e.button == 2){\r\n                that.mouse2State = 'up';\r\n            }\r\n        });\r\n\r\n        window.addEventListener('mousemove',function (e) {\r\n            // console.log(e.button+' move '+e.clientX+','+e.clientY);\r\n\r\n            var camera = that.camera;\r\n            if(that.mouse0State == 'down'){\r\n                var deltaX = e.clientX - that.x;\r\n                var deltaY = e.clientY - that.y;\r\n\r\n                // var angle = Math.sqrt(deltaX*deltaX + deltaY*deltaY)/80;\r\n                //\r\n                // var upV3 = new Vector3(camera.up);\r\n                // var rightV3 = new Vector3(camera.right);\r\n                //\r\n                // var axisV3 = new Vector3().addVectors( new Vector3().scaleVectors(upV3,deltaX) , new Vector3().scaleVectors(rightV3,deltaY)).normalize();\r\n                //\r\n                // var oldPositionV3 = new Vector3(camera.position);\r\n                // var newPositionV3 = new Vector3().rotateByVector(oldPositionV3, axisV3, angle);\r\n                // var newPosition = newPositionV3.toArray();\r\n                //\r\n                // camera.setPosition(newPosition);\r\n\r\n                var axisYV3 = new Vector3(0,1,0);\r\n                var angleY = deltaX/200;\r\n                var oldPositionV3 = new Vector3().fromArray(camera.position);\r\n                var newPositionV3 = new Vector3().rotateByVector(oldPositionV3, axisYV3, angleY);\r\n                var newPosition = newPositionV3.toArray();\r\n                camera.setPosition(newPosition);\r\n\r\n\r\n                var angleX = deltaY/200;\r\n                var tilt = that.getTilt();\r\n                var endTilt = tilt - angleX;\r\n\r\n                if(endTilt<that.maxTilt && endTilt>that.minTilt){\r\n\r\n                    var axisXV3 = new Vector3(camera.right[0], camera.right[1], camera.right[2]);\r\n                    oldPositionV3 = new Vector3().fromArray(camera.position);\r\n                    newPositionV3 = new Vector3().rotateByVector(oldPositionV3, axisXV3, angleX);\r\n                    newPosition = newPositionV3.toArray();\r\n                    camera.setPosition(newPosition);\r\n                }\r\n\r\n            }\r\n\r\n            if(that.mouse2State == 'down'){\r\n                var deltaX = e.clientX - that.x;\r\n                var deltaY = e.clientY - that.y;\r\n\r\n                var tempUp = new Vector3().crossVectors(new Vector3().fromArray(camera.right), new Vector3().fromArray(camera.direction));\r\n                var axisYV3 = tempUp;\r\n\r\n                var oldTargetV3 = new Vector3().fromArray(camera.target);\r\n                var newTargetV3 = new Vector3().addVectors(oldTargetV3, new Vector3().scaleVectors(axisYV3, deltaY/30));\r\n                var newTargetV3 = newTargetV3.toArray();\r\n                camera.setTarget(newTargetV3);\r\n\r\n                var oldPositionV3 = new Vector3().fromArray(camera.position);\r\n                var newPositionV3 = new Vector3().addVectors(oldPositionV3, new Vector3().scaleVectors(axisYV3, deltaY/30));\r\n                var newPosition = newPositionV3.toArray();\r\n                camera.setPosition(newPosition);\r\n\r\n                var axisXV3 = new Vector3().fromArray(camera.right);\r\n\r\n                oldTargetV3 = new Vector3().fromArray(camera.target);\r\n                newTargetV3 = new Vector3().addVectors(oldTargetV3, new Vector3().scaleVectors(axisXV3, -deltaX/30));\r\n                newTargetV3 = newTargetV3.toArray();\r\n                camera.setTarget(newTargetV3);\r\n\r\n                oldPositionV3 = new Vector3().fromArray(camera.position);\r\n                var newPositionV3 = new Vector3().addVectors(oldPositionV3, new Vector3().scaleVectors(axisXV3, -deltaX/30));\r\n                newPosition = newPositionV3.toArray();\r\n                camera.setPosition(newPosition);\r\n\r\n            }\r\n\r\n            that.x = e.clientX;\r\n            that.y = e.clientY;\r\n        });\r\n\r\n        window.addEventListener('mousewheel',function (e) {\r\n            // console.log(e.button+' wheel '+e.wheelDelta);\r\n\r\n            var camera = that.camera;\r\n\r\n            var delta = e.wheelDelta;\r\n\r\n            if(delta == 0 || typeof(delta) != 'number'){\r\n                return;\r\n            }\r\n            delta = Math.abs(delta)/delta;\r\n\r\n            var directionV3 = new Vector3().fromArray(camera.direction);\r\n\r\n            var oldPositionV3 = new Vector3().fromArray(camera.position);\r\n            var dis = oldPositionV3.lengthSq();\r\n            dis = Math.sqrt(dis);\r\n            var newPositionV3 = new Vector3().addVectors(oldPositionV3, new Vector3().scaleVectors(directionV3, dis/10*delta));\r\n            var newPosition = newPositionV3.toArray();\r\n\r\n            camera.setPosition(newPosition);\r\n\r\n        });\r\n    }\r\n\r\n    getTilt(){\r\n        var camera = this.camera;\r\n        var dir = camera.direction;\r\n        var axixY = new Vector3(0,-1,0);\r\n        var dirV3 = new Vector3().fromArray(dir);\r\n\r\n        var tilt = axixY.angleTo(dirV3);\r\n        return tilt;\r\n\r\n    }\r\n}\r\n\r\n/* harmony default export */ var camera_CameraController = (CameraController_CameraController);\r\n\n// CONCATENATED MODULE: ./src/core/Scene.js\n\r\n\r\n\r\nclass Scene {\r\n    constructor(param) {\r\n        param = param || {};\r\n        this.children = [];\r\n        this.lights = [];\r\n    }\r\n\r\n    add(obj){\r\n        if(obj.type == 'Mesh'){\r\n            this.children.push(obj);\r\n        }else{\r\n            this.lights.push(obj);\r\n        }\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\n/* harmony default export */ var core_Scene = (Scene);\n// CONCATENATED MODULE: ./src/material/Texture.js\n\r\nclass Texture {\r\n    constructor(param) {\r\n        param = param || {};\r\n        this.image = param.image || new Image();\r\n        this.wrapS = param.wrapS || COOL.REPEAT;\r\n        this.wrapT = param.wrapT || COOL.REPEAT;\r\n        this.magFilter = param.magFilter || COOL.NEAREST;\r\n        this.minFilter = param.minFilter || COOL.NEAREST;\r\n    }\r\n\r\n    clone(){\r\n\r\n        var image = new Image();\r\n        image.src = this.image.src;\r\n\r\n        var texture = new Texture({\r\n            image: image,\r\n            wrapS: this.wrapS,\r\n            wrapT: this.wrapT,\r\n            magFilter: this.magFilter,\r\n            minFilter: this.minFilter\r\n        });\r\n\r\n        return texture;\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ var material_Texture = (Texture);\r\n\n// CONCATENATED MODULE: ./src/material/MeshBasicMaterial.js\n\r\n\r\nclass MeshBasicMaterial_MeshBasicMaterial extends material_Material{\r\n    constructor(param) {\r\n        super(param);\r\n        this.type = 'MeshBasicMaterial';\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ var material_MeshBasicMaterial = (MeshBasicMaterial_MeshBasicMaterial);\r\n\n// CONCATENATED MODULE: ./src/material/MeshLambertMaterial.js\n\r\n\r\nclass MeshLambertMaterial_MeshLambertMaterial extends material_Material{\r\n    constructor(param) {\r\n        super(param);\r\n        this.type = 'MeshLambertMaterial';\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ var material_MeshLambertMaterial = (MeshLambertMaterial_MeshLambertMaterial);\r\n\n// CONCATENATED MODULE: ./src/material/MeshStandardMaterial.js\n\r\n\r\nclass MeshStandardMaterial_MeshStandardMaterial extends material_Material{\r\n    constructor(param) {\r\n        super(param);\r\n        this.type = 'MeshStandardMaterial';\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ var material_MeshStandardMaterial = (MeshStandardMaterial_MeshStandardMaterial);\r\n\n// CONCATENATED MODULE: ./src/core/SphereGeometry.js\n\r\n\r\n\r\n\r\nclass SphereGeometry_SphereGeometry {\r\n    constructor( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\r\n\r\n        radius = radius || 1;\r\n\r\n        widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\r\n        heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\r\n\r\n        phiStart = phiStart !== undefined ? phiStart : 0;\r\n        phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\r\n\r\n        thetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\r\n\r\n        var thetaEnd = thetaStart + thetaLength;\r\n\r\n        var ix, iy;\r\n\r\n        var index = 0;\r\n        var grid = [];\r\n\r\n        var vertex = new Vector3();\r\n        var normal = new Vector3();\r\n\r\n        // buffers\r\n\r\n        var indices = [];\r\n        var vertices = [];\r\n        var normals = [];\r\n        var uvs = [];\r\n\r\n        // generate vertices, normals and uvs\r\n\r\n        for ( iy = 0; iy <= heightSegments; iy ++ ) {\r\n\r\n            var verticesRow = [];\r\n\r\n            var v = iy / heightSegments;\r\n\r\n            for ( ix = 0; ix <= widthSegments; ix ++ ) {\r\n\r\n                var u = ix / widthSegments;\r\n\r\n                // vertex\r\n\r\n                vertex = new Vector3(\r\n                    - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength ),\r\n                    radius * Math.cos( thetaStart + v * thetaLength ),\r\n                    radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength )\r\n                );\r\n\r\n                vertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n                // normal\r\n\r\n                normal = vertex.clone().normalize();\r\n                normals.push( normal.x, normal.y, normal.z );\r\n\r\n                // uv\r\n\r\n                uvs.push( u, 1 - v );\r\n\r\n                verticesRow.push( index ++ );\r\n\r\n            }\r\n\r\n            grid.push( verticesRow );\r\n\r\n        }\r\n\r\n        // indices\r\n\r\n        for ( iy = 0; iy < heightSegments; iy ++ ) {\r\n\r\n            for ( ix = 0; ix < widthSegments; ix ++ ) {\r\n\r\n                var a = grid[ iy ][ ix + 1 ];\r\n                var b = grid[ iy ][ ix ];\r\n                var c = grid[ iy + 1 ][ ix ];\r\n                var d = grid[ iy + 1 ][ ix + 1 ];\r\n\r\n                if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );\r\n                if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );\r\n\r\n            }\r\n\r\n        }\r\n\r\n        this.vertices = new Float32Array(vertices);\r\n        this.normal = new Float32Array(normals);\r\n        this.uv = new Float32Array(uvs);\r\n\r\n        this.indices = new Uint16Array(indices);\r\n\r\n        var buffer = [];\r\n        var vertices = this.vertices;\r\n        var normal = this.normal;\r\n        var uv = this.uv;\r\n        for(var i=0; i<vertices.length; i+=3){\r\n            buffer.push(vertices[i+0]);\r\n            buffer.push(vertices[i+1]);\r\n            buffer.push(vertices[i+2]);\r\n\r\n            buffer.push(normal[i+0]);\r\n            buffer.push(normal[i+1]);\r\n            buffer.push(normal[i+2]);\r\n\r\n            buffer.push(uv[i/3*2+0]);\r\n            buffer.push(uv[i/3*2+1]);\r\n        }\r\n\r\n        this.buffer = new Float32Array(buffer);\r\n\r\n        this.boundingSphere = new Sphere();\r\n        this.boundingBox = new Box3();\r\n        this.computeBoundingBox();\r\n\r\n    }\r\n\r\n    computeBoundingBox () {\r\n        var verticesV3 = [];\r\n        for(var i=0; i<this.vertices.length; i+=3){\r\n            verticesV3.push(new Vector3(this.vertices[i], this.vertices[i+1], this.vertices[i+2]))\r\n        }\r\n        this.boundingBox.setFromPoints(verticesV3);\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ var core_SphereGeometry = (SphereGeometry_SphereGeometry);\r\n\n// CONCATENATED MODULE: ./src/core/GLTFLoader2.js\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass GLTFLoader2_GLTFLoader{\r\n    constructor(){\r\n        this.gltfObj = null;\r\n        this.urlBase = null;\r\n\r\n        this.arrayBuffers = [];\r\n        this.arrayBufferCount = 0;\r\n        this.dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\r\n    }\r\n\r\n    load(url, onLoadSuccess){\r\n        this.gltfObj = null;\r\n        this.urlBase = null;\r\n\r\n        this.arrayBuffers = [];\r\n        this.arrayBufferCount = 0;\r\n\r\n        var that = this;\r\n        var urlArray = url.split('/');\r\n        var jsonName = urlArray[urlArray.length-1];\r\n        that.urlBase = url.split(jsonName)[0];\r\n\r\n        var request = new XMLHttpRequest();\r\n        request.open(\"get\", url);\r\n        request.onload = function () {\r\n            if (request.status == 200) {\r\n                var gltfObj = JSON.parse(request.responseText);\r\n                that.gltfObj = gltfObj;\r\n                console.log(gltfObj);\r\n\r\n                that.arrayBufferCount = gltfObj.buffers.length;\r\n                var loadBufferCount = 0;\r\n\r\n                for(var i in gltfObj.buffers){\r\n\r\n                    var buffer = gltfObj.buffers[i];\r\n\r\n                    var dataUriRegexResult = buffer.uri.match( that.dataUriRegex );\r\n                    if(dataUriRegexResult){\r\n\r\n                        var buffer = that.base64ToArrayBuffer(dataUriRegexResult);\r\n                        if(buffer){\r\n                            that.arrayBuffers[i] = buffer;\r\n                            loadBufferCount ++;\r\n\r\n                            if(loadBufferCount = that.arrayBufferCount){\r\n\r\n                                var sceneObj = gltfObj.scenes[0];\r\n                                var scene = new core_Scene();\r\n                                for(var nodeindex in sceneObj.nodes){\r\n                                    var nodesIndex = sceneObj.nodes[nodeindex];\r\n                                    var nodesObj = gltfObj.nodes[nodesIndex];\r\n                                    var cur_mesh = that.nodeToMesh(nodesObj);\r\n                                    scene.add(cur_mesh);\r\n                                }\r\n                                onLoadSuccess(scene);\r\n\r\n                            }\r\n\r\n                        }\r\n\r\n                    }else{\r\n\r\n                        var bufferDataUri = that.urlBase + buffer.uri;\r\n\r\n                        var xhr = new XMLHttpRequest();\r\n                        xhr.open( 'GET', bufferDataUri, true );\r\n                        xhr.addEventListener( 'load', function ( event ) {\r\n\r\n                            var buffer = this.response;\r\n                            that.arrayBuffers[i] = buffer;\r\n                            loadBufferCount ++;\r\n\r\n                            if(loadBufferCount = that.arrayBufferCount){\r\n\r\n                                var sceneObj = gltfObj.scenes[0];\r\n                                var scene = new core_Scene();\r\n                                for(var nodeindex in sceneObj.nodes){\r\n                                    var nodesIndex = sceneObj.nodes[nodeindex];\r\n                                    var nodesObj = gltfObj.nodes[nodesIndex];\r\n                                    var cur_mesh = that.nodeToMesh(nodesObj);\r\n                                    scene.add(cur_mesh);\r\n                                }\r\n                                onLoadSuccess(scene);\r\n\r\n                            }\r\n\r\n\r\n                        }, false );\r\n                        xhr.responseType = 'arraybuffer';\r\n                        xhr.send( null );\r\n\r\n                    }\r\n\r\n\r\n                }\r\n\r\n\r\n            }\r\n        };\r\n        request.send(null);\r\n\r\n    }\r\n\r\n    nodeToMesh(node){\r\n        var that = this;\r\n\r\n        var meshIndex = node.mesh;\r\n        var mesh = null;\r\n\r\n        if(meshIndex != undefined){\r\n            var meshObj = that.gltfObj.meshes[meshIndex];\r\n            var geometryAndMaterial = that.meshToGeometry(meshObj);\r\n            mesh = new core_Mesh({\r\n                geometry:geometryAndMaterial[0],\r\n                material:geometryAndMaterial[1]\r\n            });\r\n        }else{\r\n            mesh = new core_Mesh();\r\n        }\r\n\r\n        var scale = node.scale;\r\n        if(scale){\r\n            mesh.setScale(scale);\r\n        }\r\n\r\n        var rotation = node.rotation;\r\n        if(rotation){\r\n            var quaternion = new Quaternion().fromArray(rotation);\r\n            mesh.setQuaternion(quaternion);\r\n        }\r\n\r\n        var translation = node.translation;\r\n        if(translation){\r\n            mesh.setPosition(translation);\r\n        }\r\n\r\n        var matrix = node.matrix;\r\n        if(matrix){\r\n            mesh.setMatrix(new Matrix4().fromArray(matrix));\r\n        }\r\n\r\n        for(var i in node.children){\r\n            var nodeChild = that.gltfObj.nodes[node.children[i]];\r\n            var meshChild = that.nodeToMesh(nodeChild);\r\n            mesh.add(meshChild);\r\n        }\r\n\r\n        return mesh;\r\n    }\r\n\r\n    meshToGeometry(mesh){\r\n        var that = this;\r\n\r\n        var primitive0 = mesh.primitives[0];\r\n        var attributes = primitive0.attributes;\r\n\r\n        var positionAccessorIndex = attributes.POSITION;\r\n        var positionAccessor = that.gltfObj.accessors[positionAccessorIndex];\r\n        var positionBufferViewIndex = positionAccessor.bufferView;\r\n        var positionBufferView = that.gltfObj.bufferViews[positionBufferViewIndex];\r\n        var positionData = that.getDataByBufferView(positionBufferView,positionAccessor);\r\n\r\n        var normalAccessorIndex = attributes.NORMAL;\r\n        var normalAccessor = that.gltfObj.accessors[normalAccessorIndex];\r\n        var normalBufferViewIndex = normalAccessor.bufferView;\r\n        var normalBufferView = that.gltfObj.bufferViews[normalBufferViewIndex];\r\n        var normalData = that.getDataByBufferView(normalBufferView,normalAccessor);\r\n\r\n        //TEXCOORD_0\r\n        var uv0AccessorIndex = attributes.TEXCOORD_0;\r\n        var uv0Accessor = that.gltfObj.accessors[uv0AccessorIndex];\r\n        var uv0BufferViewIndex = uv0Accessor.bufferView;\r\n        var uv0BufferView = that.gltfObj.bufferViews[uv0BufferViewIndex];\r\n        var uv0Data = that.getDataByBufferView(uv0BufferView,uv0Accessor);\r\n\r\n        var indicesData = null;\r\n        var indicesAccessorIndex = primitive0.indices;\r\n\r\n        if(indicesAccessorIndex != undefined){\r\n            var indicesAccessor = that.gltfObj.accessors[indicesAccessorIndex];\r\n            var indicesBufferViewIndex = indicesAccessor.bufferView;\r\n            var indicesBufferView = that.gltfObj.bufferViews[indicesBufferViewIndex];\r\n            indicesData = that.getDataByBufferView(indicesBufferView,indicesAccessor);\r\n        }\r\n\r\n        var materialIndex = primitive0.material;\r\n        var materialObj = that.gltfObj.materials[materialIndex];\r\n\r\n        if(materialObj.pbrMetallicRoughness.baseColorTexture){\r\n            var baseColorTextureIndex = materialObj.pbrMetallicRoughness.baseColorTexture.index;\r\n            var textureObj = that.gltfObj.textures[baseColorTextureIndex];\r\n            var imageIndex = textureObj.source;\r\n            var imageObj = that.gltfObj.images[imageIndex];\r\n            var imageUri = imageObj.uri;\r\n\r\n            var dataUriRegexResult = imageObj.uri.match( that.dataUriRegex );\r\n            if(!dataUriRegexResult){\r\n                imageUri = that.urlBase + imageObj.uri;\r\n            }\r\n\r\n            var samplerIndex = textureObj.sampler;\r\n            var sampler = that.gltfObj.samplers[samplerIndex];\r\n\r\n            var image = new Image();\r\n            image.crossOrigin = \"anonymous\";\r\n            image.src= imageUri;\r\n\r\n            var texture = new COOL.Texture({\r\n                image:image,\r\n                //9729 9986\r\n                // magFilter: sampler.magFilter,\r\n                // minFilter: sampler.minFilter,\r\n                wrapS: sampler.wrapS,\r\n                wrapT: sampler.wrapT,\r\n            });\r\n        }\r\n\r\n\r\n        var material = new COOL.MeshLambertMaterial({map:texture});\r\n\r\n        return [\r\n            new core_Geometry({\r\n                vertices: positionData,\r\n                indices: indicesData,\r\n                normal:normalData,\r\n                uv:uv0Data\r\n            }),\r\n            material\r\n        ];\r\n    }\r\n\r\n    getDataByBufferView(bufferView, accessor){\r\n        var that = this;\r\n        var bufferIndex = bufferView.buffer;\r\n\r\n        var byteLength = bufferView.byteLength || 0;\r\n        var byteOffset = bufferView.byteOffset || 0;\r\n\r\n        var buffer = that.gltfObj.buffers[bufferIndex];\r\n        var bufferDataUri = that.urlBase + buffer.uri;\r\n\r\n        var arrayBuffer = that.arrayBuffers[bufferIndex];\r\n\r\n        var cur_buffer = arrayBuffer.slice( byteOffset, byteOffset + byteLength );\r\n\r\n        var array = null;\r\n        var itemSize = null;\r\n\r\n        var accessorByteOffset = accessor.byteOffset || 0;\r\n\r\n        if(accessor.type == 'SCALAR'){\r\n            itemSize = 1;\r\n        }else if(accessor.type == 'VEC2'){\r\n            itemSize = 2;\r\n        }else if(accessor.type == 'VEC3'){\r\n            itemSize = 3;\r\n        }else if(accessor.type == 'VEC4'){\r\n            itemSize = 4;\r\n        }else{\r\n            console.warn('accessor.type undefined');\r\n        }\r\n\r\n        if(accessor.componentType == 5126){\r\n            array = new Float32Array( cur_buffer, accessorByteOffset, accessor.count * itemSize );\r\n        }else if(accessor.componentType == 5123){\r\n            array = new Uint16Array( cur_buffer, accessorByteOffset, accessor.count * itemSize );\r\n        }else if(accessor.componentType == 5120){\r\n            array = new Int8Array( cur_buffer, accessorByteOffset, accessor.count * itemSize );\r\n        }else if(accessor.componentType == 5121){\r\n            array = new Uint8Array( cur_buffer, accessorByteOffset, accessor.count * itemSize );\r\n        }else if(accessor.componentType == 5122){\r\n            array = new Int16Array( cur_buffer, accessorByteOffset, accessor.count * itemSize );\r\n        }else if(accessor.componentType == 5125){\r\n            array = new Uint32Array( cur_buffer, accessorByteOffset, accessor.count * itemSize );\r\n        }else{\r\n            console.warn('accessor.componentType undefined');\r\n        }\r\n\r\n        return array;\r\n\r\n\r\n    }\r\n\r\n    base64ToArrayBuffer(dataUriRegexResult){\r\n\r\n        var data = dataUriRegexResult[ 3 ];\r\n        data = decodeURIComponent( data );\r\n        data = atob( data );\r\n\r\n        try {\r\n\r\n            var view = new Uint8Array( data.length );\r\n            for ( var i = 0; i < data.length; i ++ ) {\r\n                view[ i ] = data.charCodeAt( i );\r\n            }\r\n\r\n            var arrayBuffer = view.buffer;\r\n            return arrayBuffer;\r\n\r\n        } catch ( error ) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ var GLTFLoader2 = (GLTFLoader2_GLTFLoader);\r\n\n// CONCATENATED MODULE: ./src/camera/OrthoCamera.js\n\r\n\r\n\r\n\r\nclass OrthoCamera_OrthoCamera {\r\n    constructor(left, right, bottom, top, near, far) {\r\n        this.left = left;\r\n        this._right = right;\r\n        this.bottom = bottom;\r\n        this.top = top;\r\n        this.near = near;\r\n        this.far = far;\r\n\r\n        this.position = [0, 0, 10];\r\n        this.target = [0,0,0];\r\n        this.up = [0,1,0];\r\n\r\n        this.VPmatrix = new Matrix4();\r\n\r\n        this.direction = [0,0,-1];\r\n        this.right = [1,0,0];\r\n\r\n        this.updateAll();\r\n    }\r\n\r\n    updateAll(){\r\n        this.updateOption();\r\n        this.updateVPMatrix();\r\n    }\r\n\r\n    updateOption(){\r\n        var targetV3 = new Vector3().fromArray(this.target);\r\n        var positionV3 = new Vector3().fromArray(this.position);\r\n        var upV3 = new Vector3().fromArray(this.up);\r\n\r\n        var directionV3 = new Vector3().subVectors(targetV3, positionV3).normalize();\r\n        this.direction = directionV3.toArray();\r\n\r\n        var rightV3 = new Vector3().crossVectors(directionV3, upV3).normalize();\r\n        this.right = rightV3.toArray();\r\n\r\n        // this.up = new Vector3().crossVectors(rightV3, directionV3).normalize().toArray();\r\n    }\r\n\r\n    setPosition(position){\r\n        this.position = position;\r\n        this.updateAll();\r\n    }\r\n\r\n    setTarget(target){\r\n        this.target = target;\r\n        this.updateAll();\r\n    }\r\n\r\n    setUp(up){\r\n        this.up = new Vector3().fromArray(up).normalize().toArray();\r\n        this.updateAll();\r\n    }\r\n\r\n\r\n\r\n    updateVPMatrix(){\r\n        this.VPmatrix = new Matrix4().setOrtho(this.left, this._right, this.bottom, this.top, this.near, this.far);\r\n        this.VPmatrix.lookAt2(this.position[0],this.position[1],this.position[2], this.target[0],this.target[1],this.target[2], this.up[0],this.up[1],this.up[2]);\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ var camera_OrthoCamera = (OrthoCamera_OrthoCamera);\r\n\r\n\n// CONCATENATED MODULE: ./src/animation/Animation.js\n\r\n\r\nclass Animation_Animation {\r\n    constructor(mesh){\r\n        this.mesh = mesh || new core_Mesh();\r\n        this.time = new Date().getTime();\r\n        this.index = 0;\r\n        this.frameCount = this.mesh.geometry.morphAttributes.position.length;\r\n    }\r\n\r\n    play(){\r\n        this.time = new Date().getTime();\r\n        this.index = 0;\r\n        this.animationLoop();\r\n    }\r\n\r\n    animationLoop(){\r\n        var that = this;\r\n        var curTime = new Date().getTime();\r\n        var curIndex = Math.floor((curTime - this.time)/1000*20)%this.frameCount;\r\n        if(curIndex != this.index){\r\n            this.mesh.geometry.vertices = this.mesh.geometry.morphAttributes.position[curIndex].array;\r\n            this.mesh.geometry.updataBuffer();\r\n            this.index = curIndex;\r\n        }\r\n        requestAnimationFrame(function () {\r\n            that.animationLoop();\r\n        });\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ var animation_Animation = (Animation_Animation);\r\n\n// CONCATENATED MODULE: ./src/core/Raycaster.js\n\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author bhouston / http://clara.io/\r\n * @author stephomi / http://stephaneginier.com/\r\n */\r\n\r\nfunction Raycaster( origin, direction, near, far ) {\r\n\r\n\tthis.ray = new Ray( origin, direction );\r\n\t// direction is assumed to be normalized (for accurate distance calculations)\r\n\r\n\tthis.near = near || 0;\r\n\tthis.far = far || Infinity;\r\n\r\n\tthis.params = {\r\n\t\tMesh: {},\r\n\t\tLine: {},\r\n\t\tLOD: {},\r\n\t\tPoints: { threshold: 1 },\r\n\t\tSprite: {}\r\n\t};\r\n\r\n\tObject.defineProperties( this.params, {\r\n\t\tPointCloud: {\r\n\t\t\tget: function () {\r\n\r\n\t\t\t\tconsole.warn( 'COOL.Raycaster: params.PointCloud has been renamed to params.Points.' );\r\n\t\t\t\treturn this.Points;\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\r\n}\r\n\r\nfunction ascSort( a, b ) {\r\n\r\n\treturn a.distance - b.distance;\r\n\r\n}\r\n\r\nfunction intersectObject( object, raycaster, intersects, recursive ) {\r\n\r\n\tif ( object.visible === false) return;\r\n\r\n\tif(object.geometry){\r\n        object.raycast( raycaster, intersects );\r\n\t}\r\n\r\n\tif ( recursive === true ) {\r\n\r\n\t\tvar children = object.children;\r\n\r\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nObject.assign( Raycaster.prototype, {\r\n\r\n\tlinePrecision: 1,\r\n\r\n\tset: function ( origin, direction ) {\r\n\r\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\r\n\r\n\t\tthis.ray.set( origin, direction );\r\n\r\n\t},\r\n\r\n\tsetFromCamera: function ( coords, camera ) {\r\n\r\n\t\tif ( true ) {\r\n\r\n\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\r\n\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\r\n\r\n\t\t}\r\n\t\t// else if ( ( camera && camera.isOrthographicCamera ) ) {\r\n\t\t//\r\n\t\t// \tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\r\n\t\t// \tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\r\n\t\t//\r\n\t\t// } else {\r\n\t\t//\r\n\t\t// \tconsole.error( 'COOL.Raycaster: Unsupported camera type.' );\r\n\t\t//\r\n\t\t// }\r\n\r\n\t},\r\n\r\n\tintersectObject: function ( object, recursive, optionalTarget ) {\r\n\r\n\t\tvar intersects = optionalTarget || [];\r\n\r\n\t\tintersectObject( object, this, intersects, recursive );\r\n\r\n\t\tintersects.sort( ascSort );\r\n\r\n\t\treturn intersects;\r\n\r\n\t},\r\n\r\n\tintersectObjects: function ( objects, recursive, optionalTarget ) {\r\n\r\n\t\tvar intersects = optionalTarget || [];\r\n\r\n\t\tif ( Array.isArray( objects ) === false ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Raycaster.intersectObjects: objects is not an Array.' );\r\n\t\t\treturn intersects;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\r\n\r\n\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\r\n\r\n\t\t}\r\n\r\n\t\tintersects.sort( ascSort );\r\n\r\n\t\treturn intersects;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/loader/EventDispatcher.js\n/**\r\n * https://github.com/mrdoob/eventdispatcher.js/\r\n */\r\n\r\nfunction EventDispatcher() {}\r\n\r\nObject.assign( EventDispatcher.prototype, {\r\n\r\n\taddEventListener: function ( type, listener ) {\r\n\r\n\t\tif ( this._listeners === undefined ) this._listeners = {};\r\n\r\n\t\tvar listeners = this._listeners;\r\n\r\n\t\tif ( listeners[ type ] === undefined ) {\r\n\r\n\t\t\tlisteners[ type ] = [];\r\n\r\n\t\t}\r\n\r\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\r\n\r\n\t\t\tlisteners[ type ].push( listener );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\thasEventListener: function ( type, listener ) {\r\n\r\n\t\tif ( this._listeners === undefined ) return false;\r\n\r\n\t\tvar listeners = this._listeners;\r\n\r\n\t\treturn listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\r\n\r\n\t},\r\n\r\n\tremoveEventListener: function ( type, listener ) {\r\n\r\n\t\tif ( this._listeners === undefined ) return;\r\n\r\n\t\tvar listeners = this._listeners;\r\n\t\tvar listenerArray = listeners[ type ];\r\n\r\n\t\tif ( listenerArray !== undefined ) {\r\n\r\n\t\t\tvar index = listenerArray.indexOf( listener );\r\n\r\n\t\t\tif ( index !== - 1 ) {\r\n\r\n\t\t\t\tlistenerArray.splice( index, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tdispatchEvent: function ( event ) {\r\n\r\n\t\tif ( this._listeners === undefined ) return;\r\n\r\n\t\tvar listeners = this._listeners;\r\n\t\tvar listenerArray = listeners[ event.type ];\r\n\r\n\t\tif ( listenerArray !== undefined ) {\r\n\r\n\t\t\tevent.target = this;\r\n\r\n\t\t\tvar array = listenerArray.slice( 0 );\r\n\r\n\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tarray[ i ].call( this, event );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/loader/Face3.js\n\r\n\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nfunction Face3_Face3( a, b, c, normal, color, materialIndex ) {\r\n\r\n\tthis.a = a;\r\n\tthis.b = b;\r\n\tthis.c = c;\r\n\r\n\tthis.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();\r\n\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\r\n\r\n\tthis.color = ( color && color.isColor ) ? color : new Color();\r\n\tthis.vertexColors = Array.isArray( color ) ? color : [];\r\n\r\n\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\r\n\r\n}\r\n\r\nObject.assign( Face3_Face3.prototype, {\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.a = source.a;\r\n\t\tthis.b = source.b;\r\n\t\tthis.c = source.c;\r\n\r\n\t\tthis.normal.copy( source.normal );\r\n\t\tthis.color.copy( source.color );\r\n\r\n\t\tthis.materialIndex = source.materialIndex;\r\n\r\n\t\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/math/Matrix3.js\n\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://clara.io\r\n * @author tschw\r\n */\r\n\r\nfunction Matrix3() {\r\n\r\n\tthis.elements = [\r\n\r\n\t\t1, 0, 0,\r\n\t\t0, 1, 0,\r\n\t\t0, 0, 1\r\n\r\n\t];\r\n\r\n\tif ( arguments.length > 0 ) {\r\n\r\n\t\tconsole.error( 'COOL.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\r\n\r\n\t}\r\n\r\n}\r\n\r\nObject.assign( Matrix3.prototype, {\r\n\r\n\tisMatrix3: true,\r\n\r\n\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\r\n\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\r\n\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tidentity: function () {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0,\r\n\t\t\t0, 1, 0,\r\n\t\t\t0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().fromArray( this.elements );\r\n\r\n\t},\r\n\r\n\tcopy: function ( m ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar me = m.elements;\r\n\r\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];\r\n\t\tte[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];\r\n\t\tte[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrix4: function ( m ) {\r\n\r\n\t\tvar me = m.elements;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tme[ 0 ], me[ 4 ], me[ 8 ],\r\n\t\t\tme[ 1 ], me[ 5 ], me[ 9 ],\r\n\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyToBufferAttribute: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function applyToBufferAttribute( attribute ) {\r\n\r\n\t\t\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\r\n\r\n\t\t\t\tv1.x = attribute.getX( i );\r\n\t\t\t\tv1.y = attribute.getY( i );\r\n\t\t\t\tv1.z = attribute.getZ( i );\r\n\r\n\t\t\t\tv1.applyMatrix3( this );\r\n\r\n\t\t\t\tattribute.setXYZ( i, v1.x, v1.y, v1.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn attribute;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmultiply: function ( m ) {\r\n\r\n\t\treturn this.multiplyMatrices( this, m );\r\n\r\n\t},\r\n\r\n\tpremultiply: function ( m ) {\r\n\r\n\t\treturn this.multiplyMatrices( m, this );\r\n\r\n\t},\r\n\r\n\tmultiplyMatrices: function ( a, b ) {\r\n\r\n\t\tvar ae = a.elements;\r\n\t\tvar be = b.elements;\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];\r\n\t\tvar a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];\r\n\t\tvar a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];\r\n\r\n\t\tvar b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];\r\n\t\tvar b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];\r\n\t\tvar b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];\r\n\r\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;\r\n\t\tte[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;\r\n\t\tte[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;\r\n\r\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;\r\n\t\tte[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;\r\n\t\tte[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;\r\n\r\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;\r\n\t\tte[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;\r\n\t\tte[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\r\n\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\r\n\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdeterminant: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\r\n\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\r\n\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\r\n\r\n\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\r\n\r\n\t},\r\n\r\n\tgetInverse: function ( matrix, throwOnDegenerate ) {\r\n\r\n\t\tif ( matrix && matrix.isMatrix4 ) {\r\n\r\n\t\t\tconsole.error( \"COOL.Matrix3: .getInverse() no longer takes a Matrix4 argument.\" );\r\n\r\n\t\t}\r\n\r\n\t\tvar me = matrix.elements,\r\n\t\t\tte = this.elements,\r\n\r\n\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\r\n\t\t\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\r\n\t\t\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\r\n\r\n\t\t\tt11 = n33 * n22 - n32 * n23,\r\n\t\t\tt12 = n32 * n13 - n33 * n12,\r\n\t\t\tt13 = n23 * n12 - n22 * n13,\r\n\r\n\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\r\n\r\n\t\tif ( det === 0 ) {\r\n\r\n\t\t\tvar msg = \"COOL.Matrix3: .getInverse() can't invert matrix, determinant is 0\";\r\n\r\n\t\t\tif ( throwOnDegenerate === true ) {\r\n\r\n\t\t\t\tthrow new Error( msg );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( msg );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.identity();\r\n\r\n\t\t}\r\n\r\n\t\tvar detInv = 1 / det;\r\n\r\n\t\tte[ 0 ] = t11 * detInv;\r\n\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\r\n\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\r\n\r\n\t\tte[ 3 ] = t12 * detInv;\r\n\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\r\n\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\r\n\r\n\t\tte[ 6 ] = t13 * detInv;\r\n\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\r\n\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranspose: function () {\r\n\r\n\t\tvar tmp, m = this.elements;\r\n\r\n\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\r\n\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\r\n\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetNormalMatrix: function ( matrix4 ) {\r\n\r\n\t\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\r\n\r\n\t},\r\n\r\n\ttransposeIntoArray: function ( r ) {\r\n\r\n\t\tvar m = this.elements;\r\n\r\n\t\tr[ 0 ] = m[ 0 ];\r\n\t\tr[ 1 ] = m[ 3 ];\r\n\t\tr[ 2 ] = m[ 6 ];\r\n\t\tr[ 3 ] = m[ 1 ];\r\n\t\tr[ 4 ] = m[ 4 ];\r\n\t\tr[ 5 ] = m[ 7 ];\r\n\t\tr[ 6 ] = m[ 2 ];\r\n\t\tr[ 7 ] = m[ 5 ];\r\n\t\tr[ 8 ] = m[ 8 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {\r\n\r\n\t\tvar c = Math.cos( rotation );\r\n\t\tvar s = Math.sin( rotation );\r\n\r\n\t\tthis.set(\r\n\t\t\tsx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,\r\n\t\t\t- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,\r\n\t\t\t0, 0, 1\r\n\t\t);\r\n\r\n\t},\r\n\r\n\tscale: function ( sx, sy ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;\r\n\t\tte[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trotate: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta );\r\n\t\tvar s = Math.sin( theta );\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];\r\n\t\tvar a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];\r\n\r\n\t\tte[ 0 ] = c * a11 + s * a21;\r\n\t\tte[ 3 ] = c * a12 + s * a22;\r\n\t\tte[ 6 ] = c * a13 + s * a23;\r\n\r\n\t\tte[ 1 ] = - s * a11 + c * a21;\r\n\t\tte[ 4 ] = - s * a12 + c * a22;\r\n\t\tte[ 7 ] = - s * a13 + c * a23;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranslate: function ( tx, ty ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];\r\n\t\tte[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( matrix ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar me = matrix.elements;\r\n\r\n\t\tfor ( var i = 0; i < 9; i ++ ) {\r\n\r\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tfor ( var i = 0; i < 9; i ++ ) {\r\n\r\n\t\t\tthis.elements[ i ] = array[ i + offset ];\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tarray[ offset ] = te[ 0 ];\r\n\t\tarray[ offset + 1 ] = te[ 1 ];\r\n\t\tarray[ offset + 2 ] = te[ 2 ];\r\n\r\n\t\tarray[ offset + 3 ] = te[ 3 ];\r\n\t\tarray[ offset + 4 ] = te[ 4 ];\r\n\t\tarray[ offset + 5 ] = te[ 5 ];\r\n\r\n\t\tarray[ offset + 6 ] = te[ 6 ];\r\n\t\tarray[ offset + 7 ] = te[ 7 ];\r\n\t\tarray[ offset + 8 ] = te[ 8 ];\r\n\r\n\t\treturn array;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/loader/Layers.js\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nfunction Layers() {\r\n\r\n\tthis.mask = 1 | 0;\r\n\r\n}\r\n\r\nObject.assign( Layers.prototype, {\r\n\r\n\tset: function ( channel ) {\r\n\r\n\t\tthis.mask = 1 << channel | 0;\r\n\r\n\t},\r\n\r\n\tenable: function ( channel ) {\r\n\r\n\t\tthis.mask |= 1 << channel | 0;\r\n\r\n\t},\r\n\r\n\ttoggle: function ( channel ) {\r\n\r\n\t\tthis.mask ^= 1 << channel | 0;\r\n\r\n\t},\r\n\r\n\tdisable: function ( channel ) {\r\n\r\n\t\tthis.mask &= ~ ( 1 << channel | 0 );\r\n\r\n\t},\r\n\r\n\ttest: function ( layers ) {\r\n\r\n\t\treturn ( this.mask & layers.mask ) !== 0;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/loader/Object3D.js\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author elephantatwork / www.elephantatwork.ch\r\n */\r\n\r\nvar object3DId = 0;\r\n\r\nfunction Object3D() {\r\n\r\n\tObject.defineProperty( this, 'id', { value: object3DId ++ } );\r\n\r\n\tthis.uuid = _Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'Object3D';\r\n\r\n\tthis.parent = null;\r\n\tthis.children = [];\r\n\r\n\tthis.up = Object3D.DefaultUp.clone();\r\n\r\n\tvar position = new Vector3();\r\n\tvar rotation = new Euler();\r\n\tvar quaternion = new Quaternion();\r\n\tvar scale = new Vector3( 1, 1, 1 );\r\n\r\n\tfunction onRotationChange() {\r\n\r\n\t\tquaternion.setFromEuler( rotation, false );\r\n\r\n\t}\r\n\r\n\tfunction onQuaternionChange() {\r\n\r\n\t\trotation.setFromQuaternion( quaternion, undefined, false );\r\n\r\n\t}\r\n\r\n\trotation.onChange( onRotationChange );\r\n\tquaternion.onChange( onQuaternionChange );\r\n\r\n\tObject.defineProperties( this, {\r\n\t\tposition: {\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: position\r\n\t\t},\r\n\t\trotation: {\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: rotation\r\n\t\t},\r\n\t\tquaternion: {\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: quaternion\r\n\t\t},\r\n\t\tscale: {\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: scale\r\n\t\t},\r\n\t\tmodelViewMatrix: {\r\n\t\t\tvalue: new Matrix4()\r\n\t\t},\r\n\t\tnormalMatrix: {\r\n\t\t\tvalue: new Matrix3()\r\n\t\t}\r\n\t} );\r\n\r\n\tthis.matrix = new Matrix4();\r\n\tthis.matrixWorld = new Matrix4();\r\n\r\n\tthis.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\r\n\tthis.matrixWorldNeedsUpdate = false;\r\n\r\n\tthis.layers = new Layers();\r\n\tthis.visible = true;\r\n\r\n\tthis.castShadow = false;\r\n\tthis.receiveShadow = false;\r\n\r\n\tthis.frustumCulled = true;\r\n\tthis.renderOrder = 0;\r\n\r\n\tthis.userData = {};\r\n\r\n}\r\n\r\nObject3D.DefaultUp = new Vector3( 0, 1, 0 );\r\nObject3D.DefaultMatrixAutoUpdate = true;\r\n\r\nObject3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\r\n\r\n\tconstructor: Object3D,\r\n\r\n\tisObject3D: true,\r\n\r\n\tonBeforeRender: function () {},\r\n\tonAfterRender: function () {},\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\r\n\r\n\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\r\n\r\n\t},\r\n\r\n\tapplyQuaternion: function ( q ) {\r\n\r\n\t\tthis.quaternion.premultiply( q );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetRotationFromAxisAngle: function ( axis, angle ) {\r\n\r\n\t\t// assumes axis is normalized\r\n\r\n\t\tthis.quaternion.setFromAxisAngle( axis, angle );\r\n\r\n\t},\r\n\r\n\tsetRotationFromEuler: function ( euler ) {\r\n\r\n\t\tthis.quaternion.setFromEuler( euler, true );\r\n\r\n\t},\r\n\r\n\tsetRotationFromMatrix: function ( m ) {\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tthis.quaternion.setFromRotationMatrix( m );\r\n\r\n\t},\r\n\r\n\tsetRotationFromQuaternion: function ( q ) {\r\n\r\n\t\t// assumes q is normalized\r\n\r\n\t\tthis.quaternion.copy( q );\r\n\r\n\t},\r\n\r\n\trotateOnAxis: function () {\r\n\r\n\t\t// rotate object on axis in object space\r\n\t\t// axis is assumed to be normalized\r\n\r\n\t\tvar q1 = new Quaternion();\r\n\r\n\t\treturn function rotateOnAxis( axis, angle ) {\r\n\r\n\t\t\tq1.setFromAxisAngle( axis, angle );\r\n\r\n\t\t\tthis.quaternion.multiply( q1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateOnWorldAxis: function () {\r\n\r\n\t\t// rotate object on axis in world space\r\n\t\t// axis is assumed to be normalized\r\n\t\t// method assumes no rotated parent\r\n\r\n\t\tvar q1 = new Quaternion();\r\n\r\n\t\treturn function rotateOnWorldAxis( axis, angle ) {\r\n\r\n\t\t\tq1.setFromAxisAngle( axis, angle );\r\n\r\n\t\t\tthis.quaternion.premultiply( q1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateX: function () {\r\n\r\n\t\tvar v1 = new Vector3( 1, 0, 0 );\r\n\r\n\t\treturn function rotateX( angle ) {\r\n\r\n\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateY: function () {\r\n\r\n\t\tvar v1 = new Vector3( 0, 1, 0 );\r\n\r\n\t\treturn function rotateY( angle ) {\r\n\r\n\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateZ: function () {\r\n\r\n\t\tvar v1 = new Vector3( 0, 0, 1 );\r\n\r\n\t\treturn function rotateZ( angle ) {\r\n\r\n\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateOnAxis: function () {\r\n\r\n\t\t// translate object by distance along axis in object space\r\n\t\t// axis is assumed to be normalized\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function translateOnAxis( axis, distance ) {\r\n\r\n\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\r\n\r\n\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateX: function () {\r\n\r\n\t\tvar v1 = new Vector3( 1, 0, 0 );\r\n\r\n\t\treturn function translateX( distance ) {\r\n\r\n\t\t\treturn this.translateOnAxis( v1, distance );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateY: function () {\r\n\r\n\t\tvar v1 = new Vector3( 0, 1, 0 );\r\n\r\n\t\treturn function translateY( distance ) {\r\n\r\n\t\t\treturn this.translateOnAxis( v1, distance );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateZ: function () {\r\n\r\n\t\tvar v1 = new Vector3( 0, 0, 1 );\r\n\r\n\t\treturn function translateZ( distance ) {\r\n\r\n\t\t\treturn this.translateOnAxis( v1, distance );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlocalToWorld: function ( vector ) {\r\n\r\n\t\treturn vector.applyMatrix4( this.matrixWorld );\r\n\r\n\t},\r\n\r\n\tworldToLocal: function () {\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function worldToLocal( vector ) {\r\n\r\n\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlookAt: function () {\r\n\r\n\t\t// This method does not support objects having non-uniformly-scaled parent(s)\r\n\r\n\t\tvar q1 = new Quaternion();\r\n\t\tvar m1 = new Matrix4();\r\n\t\tvar target = new Vector3();\r\n\t\tvar position = new Vector3();\r\n\r\n\t\treturn function lookAt( x, y, z ) {\r\n\r\n\t\t\tif ( x.isVector3 ) {\r\n\r\n\t\t\t\ttarget.copy( x );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttarget.set( x, y, z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar parent = this.parent;\r\n\r\n\t\t\tthis.updateWorldMatrix( true, false );\r\n\r\n\t\t\tposition.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t\t\tif ( this.isCamera || this.isLight ) {\r\n\r\n\t\t\t\tm1.lookAt( position, target, this.up );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tm1.lookAt( target, position, this.up );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\r\n\r\n\t\t\tif ( parent ) {\r\n\r\n\t\t\t\tm1.extractRotation( parent.matrixWorld );\r\n\t\t\t\tq1.setFromRotationMatrix( m1 );\r\n\t\t\t\tthis.quaternion.premultiply( q1.inverse() );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tadd: function ( object ) {\r\n\r\n\t\tif ( arguments.length > 1 ) {\r\n\r\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\r\n\r\n\t\t\t\tthis.add( arguments[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tif ( object === this ) {\r\n\r\n\t\t\tconsole.error( \"COOL.Object3D.add: object can't be added as a child of itself.\", object );\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ( object && object.isObject3D ) ) {\r\n\r\n\t\t\tif ( object.parent !== null ) {\r\n\r\n\t\t\t\tobject.parent.remove( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject.parent = this;\r\n\t\t\tobject.dispatchEvent( { type: 'added' } );\r\n\r\n\t\t\tthis.children.push( object );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.error( \"COOL.Object3D.add: object not an instance of COOL.Object3D.\", object );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tremove: function ( object ) {\r\n\r\n\t\tif ( arguments.length > 1 ) {\r\n\r\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\r\n\r\n\t\t\t\tthis.remove( arguments[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tvar index = this.children.indexOf( object );\r\n\r\n\t\tif ( index !== - 1 ) {\r\n\r\n\t\t\tobject.parent = null;\r\n\r\n\t\t\tobject.dispatchEvent( { type: 'removed' } );\r\n\r\n\t\t\tthis.children.splice( index, 1 );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetObjectById: function ( id ) {\r\n\r\n\t\treturn this.getObjectByProperty( 'id', id );\r\n\r\n\t},\r\n\r\n\tgetObjectByName: function ( name ) {\r\n\r\n\t\treturn this.getObjectByProperty( 'name', name );\r\n\r\n\t},\r\n\r\n\tgetObjectByProperty: function ( name, value ) {\r\n\r\n\t\tif ( this[ name ] === value ) return this;\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar child = this.children[ i ];\r\n\t\t\tvar object = child.getObjectByProperty( name, value );\r\n\r\n\t\t\tif ( object !== undefined ) {\r\n\r\n\t\t\t\treturn object;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn undefined;\r\n\r\n\t},\r\n\r\n\tgetWorldPosition: function ( target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Object3D: .getWorldPosition() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\treturn target.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t},\r\n\r\n\tgetWorldQuaternion: function () {\r\n\r\n\t\tvar position = new Vector3();\r\n\t\tvar scale = new Vector3();\r\n\r\n\t\treturn function getWorldQuaternion( target ) {\r\n\r\n\t\t\tif ( target === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'COOL.Object3D: .getWorldQuaternion() target is now required' );\r\n\t\t\t\ttarget = new Quaternion();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\t\tthis.matrixWorld.decompose( position, target, scale );\r\n\r\n\t\t\treturn target;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetWorldScale: function () {\r\n\r\n\t\tvar position = new Vector3();\r\n\t\tvar quaternion = new Quaternion();\r\n\r\n\t\treturn function getWorldScale( target ) {\r\n\r\n\t\t\tif ( target === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'COOL.Object3D: .getWorldScale() target is now required' );\r\n\t\t\t\ttarget = new Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\t\tthis.matrixWorld.decompose( position, quaternion, target );\r\n\r\n\t\t\treturn target;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetWorldDirection: function ( target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Object3D: .getWorldDirection() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\tvar e = this.matrixWorld.elements;\r\n\r\n\t\treturn target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();\r\n\r\n\t},\r\n\r\n\traycast: function () {},\r\n\r\n\ttraverse: function ( callback ) {\r\n\r\n\t\tcallback( this );\r\n\r\n\t\tvar children = this.children;\r\n\r\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tchildren[ i ].traverse( callback );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttraverseVisible: function ( callback ) {\r\n\r\n\t\tif ( this.visible === false ) return;\r\n\r\n\t\tcallback( this );\r\n\r\n\t\tvar children = this.children;\r\n\r\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tchildren[ i ].traverseVisible( callback );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttraverseAncestors: function ( callback ) {\r\n\r\n\t\tvar parent = this.parent;\r\n\r\n\t\tif ( parent !== null ) {\r\n\r\n\t\t\tcallback( parent );\r\n\r\n\t\t\tparent.traverseAncestors( callback );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tupdateMatrix: function () {\r\n\r\n\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\r\n\r\n\t\tthis.matrixWorldNeedsUpdate = true;\r\n\r\n\t},\r\n\r\n\tupdateMatrixWorld: function ( force ) {\r\n\r\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\r\n\r\n\t\tif ( this.matrixWorldNeedsUpdate || force ) {\r\n\r\n\t\t\tif ( this.parent === null ) {\r\n\r\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.matrixWorldNeedsUpdate = false;\r\n\r\n\t\t\tforce = true;\r\n\r\n\t\t}\r\n\r\n\t\t// update children\r\n\r\n\t\tvar children = this.children;\r\n\r\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tchildren[ i ].updateMatrixWorld( force );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tupdateWorldMatrix: function ( updateParents, updateChildren ) {\r\n\r\n\t\tvar parent = this.parent;\r\n\r\n\t\tif ( updateParents === true && parent !== null ) {\r\n\r\n\t\t\tparent.updateWorldMatrix( true, false );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\r\n\r\n\t\tif ( this.parent === null ) {\r\n\r\n\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n\t\t}\r\n\r\n\t\t// update children\r\n\r\n\t\tif ( updateChildren === true ) {\r\n\r\n\t\t\tvar children = this.children;\r\n\r\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tchildren[ i ].updateWorldMatrix( false, true );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttoJSON: function ( meta ) {\r\n\r\n\t\t// meta is a string when called from JSON.stringify\r\n\t\tvar isRootObject = ( meta === undefined || typeof meta === 'string' );\r\n\r\n\t\tvar output = {};\r\n\r\n\t\t// meta is a hash used to collect geometries, materials.\r\n\t\t// not providing it implies that this is the root object\r\n\t\t// being serialized.\r\n\t\tif ( isRootObject ) {\r\n\r\n\t\t\t// initialize meta obj\r\n\t\t\tmeta = {\r\n\t\t\t\tgeometries: {},\r\n\t\t\t\tmaterials: {},\r\n\t\t\t\ttextures: {},\r\n\t\t\t\timages: {},\r\n\t\t\t\tshapes: {}\r\n\t\t\t};\r\n\r\n\t\t\toutput.metadata = {\r\n\t\t\t\tversion: 4.5,\r\n\t\t\t\ttype: 'Object',\r\n\t\t\t\tgenerator: 'Object3D.toJSON'\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\t// standard Object3D serialization\r\n\r\n\t\tvar object = {};\r\n\r\n\t\tobject.uuid = this.uuid;\r\n\t\tobject.type = this.type;\r\n\r\n\t\tif ( this.name !== '' ) object.name = this.name;\r\n\t\tif ( this.castShadow === true ) object.castShadow = true;\r\n\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\r\n\t\tif ( this.visible === false ) object.visible = false;\r\n\t\tif ( this.frustumCulled === false ) object.frustumCulled = false;\r\n\t\tif ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;\r\n\t\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\r\n\r\n\t\tobject.layers = this.layers.mask;\r\n\t\tobject.matrix = this.matrix.toArray();\r\n\r\n\t\tif ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;\r\n\r\n\t\t//\r\n\r\n\t\tfunction serialize( library, element ) {\r\n\r\n\t\t\tif ( library[ element.uuid ] === undefined ) {\r\n\r\n\t\t\t\tlibrary[ element.uuid ] = element.toJSON( meta );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn element.uuid;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.isMesh || this.isLine || this.isPoints ) {\r\n\r\n\t\t\tobject.geometry = serialize( meta.geometries, this.geometry );\r\n\r\n\t\t\tvar parameters = this.geometry.parameters;\r\n\r\n\t\t\tif ( parameters !== undefined && parameters.shapes !== undefined ) {\r\n\r\n\t\t\t\tvar shapes = parameters.shapes;\r\n\r\n\t\t\t\tif ( Array.isArray( shapes ) ) {\r\n\r\n\t\t\t\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar shape = shapes[ i ];\r\n\r\n\t\t\t\t\t\tserialize( meta.shapes, shape );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tserialize( meta.shapes, shapes );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.material !== undefined ) {\r\n\r\n\t\t\tif ( Array.isArray( this.material ) ) {\r\n\r\n\t\t\t\tvar uuids = [];\r\n\r\n\t\t\t\tfor ( var i = 0, l = this.material.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tuuids.push( serialize( meta.materials, this.material[ i ] ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tobject.material = uuids;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tobject.material = serialize( meta.materials, this.material );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( this.children.length > 0 ) {\r\n\r\n\t\t\tobject.children = [];\r\n\r\n\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\r\n\r\n\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( isRootObject ) {\r\n\r\n\t\t\tvar geometries = extractFromCache( meta.geometries );\r\n\t\t\tvar materials = extractFromCache( meta.materials );\r\n\t\t\tvar textures = extractFromCache( meta.textures );\r\n\t\t\tvar images = extractFromCache( meta.images );\r\n\t\t\tvar shapes = extractFromCache( meta.shapes );\r\n\r\n\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\r\n\t\t\tif ( materials.length > 0 ) output.materials = materials;\r\n\t\t\tif ( textures.length > 0 ) output.textures = textures;\r\n\t\t\tif ( images.length > 0 ) output.images = images;\r\n\t\t\tif ( shapes.length > 0 ) output.shapes = shapes;\r\n\r\n\t\t}\r\n\r\n\t\toutput.object = object;\r\n\r\n\t\treturn output;\r\n\r\n\t\t// extract data from the cache hash\r\n\t\t// remove metadata on each item\r\n\t\t// and return as array\r\n\t\tfunction extractFromCache( cache ) {\r\n\r\n\t\t\tvar values = [];\r\n\t\t\tfor ( var key in cache ) {\r\n\r\n\t\t\t\tvar data = cache[ key ];\r\n\t\t\t\tdelete data.metadata;\r\n\t\t\t\tvalues.push( data );\r\n\r\n\t\t\t}\r\n\t\t\treturn values;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tclone: function ( recursive ) {\r\n\r\n\t\treturn new this.constructor().copy( this, recursive );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source, recursive ) {\r\n\r\n\t\tif ( recursive === undefined ) recursive = true;\r\n\r\n\t\tthis.name = source.name;\r\n\r\n\t\tthis.up.copy( source.up );\r\n\r\n\t\tthis.position.copy( source.position );\r\n\t\tthis.quaternion.copy( source.quaternion );\r\n\t\tthis.scale.copy( source.scale );\r\n\r\n\t\tthis.matrix.copy( source.matrix );\r\n\t\tthis.matrixWorld.copy( source.matrixWorld );\r\n\r\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\r\n\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\r\n\r\n\t\tthis.layers.mask = source.layers.mask;\r\n\t\tthis.visible = source.visible;\r\n\r\n\t\tthis.castShadow = source.castShadow;\r\n\t\tthis.receiveShadow = source.receiveShadow;\r\n\r\n\t\tthis.frustumCulled = source.frustumCulled;\r\n\t\tthis.renderOrder = source.renderOrder;\r\n\r\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\r\n\r\n\t\tif ( recursive === true ) {\r\n\r\n\t\t\tfor ( var i = 0; i < source.children.length; i ++ ) {\r\n\r\n\t\t\t\tvar child = source.children[ i ];\r\n\t\t\t\tthis.add( child.clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/loader/Geometry.js\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author kile / http://kile.stravaganza.org/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nvar geometryId = 0; // Geometry uses even numbers as Id\r\n\r\nfunction loader_Geometry_Geometry() {\r\n\r\n\tObject.defineProperty( this, 'id', { value: geometryId += 2 } );\r\n\r\n\tthis.uuid = _Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'Geometry';\r\n\r\n\tthis.vertices = [];\r\n\tthis.colors = [];\r\n\tthis.faces = [];\r\n\tthis.faceVertexUvs = [[]];\r\n\r\n\tthis.morphTargets = [];\r\n\tthis.morphNormals = [];\r\n\r\n\tthis.skinWeights = [];\r\n\tthis.skinIndices = [];\r\n\r\n\tthis.lineDistances = [];\r\n\r\n\tthis.boundingBox = null;\r\n\tthis.boundingSphere = null;\r\n\r\n\t// update flags\r\n\r\n\tthis.elementsNeedUpdate = false;\r\n\tthis.verticesNeedUpdate = false;\r\n\tthis.uvsNeedUpdate = false;\r\n\tthis.normalsNeedUpdate = false;\r\n\tthis.colorsNeedUpdate = false;\r\n\tthis.lineDistancesNeedUpdate = false;\r\n\tthis.groupsNeedUpdate = false;\r\n\r\n}\r\n\r\nloader_Geometry_Geometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\r\n\r\n\tconstructor: loader_Geometry_Geometry,\r\n\r\n\tisGeometry: true,\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\r\n\r\n\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar vertex = this.vertices[ i ];\r\n\t\t\tvertex.applyMatrix4( matrix );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar face = this.faces[ i ];\r\n\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingBox !== null ) {\r\n\r\n\t\t\tthis.computeBoundingBox();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.computeBoundingSphere();\r\n\r\n\t\t}\r\n\r\n\t\tthis.verticesNeedUpdate = true;\r\n\t\tthis.normalsNeedUpdate = true;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trotateX: function () {\r\n\r\n\t\t// rotate geometry around world x-axis\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function rotateX( angle ) {\r\n\r\n\t\t\tm1.makeRotationX( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateY: function () {\r\n\r\n\t\t// rotate geometry around world y-axis\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function rotateY( angle ) {\r\n\r\n\t\t\tm1.makeRotationY( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateZ: function () {\r\n\r\n\t\t// rotate geometry around world z-axis\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function rotateZ( angle ) {\r\n\r\n\t\t\tm1.makeRotationZ( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function () {\r\n\r\n\t\t// translate geometry\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function translate( x, y, z ) {\r\n\r\n\t\t\tm1.makeTranslation( x, y, z );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tscale: function () {\r\n\r\n\t\t// scale geometry\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function scale( x, y, z ) {\r\n\r\n\t\t\tm1.makeScale( x, y, z );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlookAt: function () {\r\n\r\n\t\tvar obj = new Object3D();\r\n\r\n\t\treturn function lookAt( vector ) {\r\n\r\n\t\t\tobj.lookAt( vector );\r\n\r\n\t\t\tobj.updateMatrix();\r\n\r\n\t\t\tthis.applyMatrix( obj.matrix );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tfromBufferGeometry: function ( geometry ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\r\n\t\tvar attributes = geometry.attributes;\r\n\r\n\t\tvar positions = attributes.position.array;\r\n\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\r\n\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\r\n\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\r\n\t\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\r\n\r\n\t\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\r\n\r\n\t\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\r\n\r\n\t\t\tscope.vertices.push( new Vector3().fromArray( positions, i ) );\r\n\r\n\t\t\tif ( colors !== undefined ) {\r\n\r\n\t\t\t\tscope.colors.push( new Color().fromArray( colors, i ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction addFace( a, b, c, materialIndex ) {\r\n\r\n\t\t\tvar vertexColors = ( colors === undefined ) ? [] : [\r\n\t\t\t\tscope.colors[ a ].clone(),\r\n\t\t\t\tscope.colors[ b ].clone(),\r\n\t\t\t\tscope.colors[ c ].clone() ];\r\n\r\n\t\t\tvar vertexNormals = ( normals === undefined ) ? [] : [\r\n\t\t\t\tnew Vector3().fromArray( normals, a * 3 ),\r\n\t\t\t\tnew Vector3().fromArray( normals, b * 3 ),\r\n\t\t\t\tnew Vector3().fromArray( normals, c * 3 )\r\n\t\t\t];\r\n\r\n\t\t\tvar face = new Face3_Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\r\n\r\n\t\t\tscope.faces.push( face );\r\n\r\n\t\t\tif ( uvs !== undefined ) {\r\n\r\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [\r\n\t\t\t\t\tnew Vector2().fromArray( uvs, a * 2 ),\r\n\t\t\t\t\tnew Vector2().fromArray( uvs, b * 2 ),\r\n\t\t\t\t\tnew Vector2().fromArray( uvs, c * 2 )\r\n\t\t\t\t] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( uvs2 !== undefined ) {\r\n\r\n\t\t\t\tscope.faceVertexUvs[ 1 ].push( [\r\n\t\t\t\t\tnew Vector2().fromArray( uvs2, a * 2 ),\r\n\t\t\t\t\tnew Vector2().fromArray( uvs2, b * 2 ),\r\n\t\t\t\t\tnew Vector2().fromArray( uvs2, c * 2 )\r\n\t\t\t\t] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar groups = geometry.groups;\r\n\r\n\t\tif ( groups.length > 0 ) {\r\n\r\n\t\t\tfor ( var i = 0; i < groups.length; i ++ ) {\r\n\r\n\t\t\t\tvar group = groups[ i ];\r\n\r\n\t\t\t\tvar start = group.start;\r\n\t\t\t\tvar count = group.count;\r\n\r\n\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\r\n\r\n\t\t\t\t\tif ( indices !== undefined ) {\r\n\r\n\t\t\t\t\t\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\taddFace( j, j + 1, j + 2, group.materialIndex );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( indices !== undefined ) {\r\n\r\n\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\r\n\r\n\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\r\n\r\n\t\t\t\t\taddFace( i, i + 1, i + 2 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.computeFaceNormals();\r\n\r\n\t\tif ( geometry.boundingBox !== null ) {\r\n\r\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcenter: function () {\r\n\r\n\t\tvar offset = new Vector3();\r\n\r\n\t\treturn function center() {\r\n\r\n\t\t\tthis.computeBoundingBox();\r\n\r\n\t\t\tthis.boundingBox.getCenter( offset ).negate();\r\n\r\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tnormalize: function () {\r\n\r\n\t\tthis.computeBoundingSphere();\r\n\r\n\t\tvar center = this.boundingSphere.center;\r\n\t\tvar radius = this.boundingSphere.radius;\r\n\r\n\t\tvar s = radius === 0 ? 1 : 1.0 / radius;\r\n\r\n\t\tvar matrix = new Matrix4();\r\n\t\tmatrix.set(\r\n\t\t\ts, 0, 0, - s * center.x,\r\n\t\t\t0, s, 0, - s * center.y,\r\n\t\t\t0, 0, s, - s * center.z,\r\n\t\t\t0, 0, 0, 1\r\n\t\t);\r\n\r\n\t\tthis.applyMatrix( matrix );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcomputeFaceNormals: function () {\r\n\r\n\t\tvar cb = new Vector3(), ab = new Vector3();\r\n\r\n\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tvar face = this.faces[ f ];\r\n\r\n\t\t\tvar vA = this.vertices[ face.a ];\r\n\t\t\tvar vB = this.vertices[ face.b ];\r\n\t\t\tvar vC = this.vertices[ face.c ];\r\n\r\n\t\t\tcb.subVectors( vC, vB );\r\n\t\t\tab.subVectors( vA, vB );\r\n\t\t\tcb.cross( ab );\r\n\r\n\t\t\tcb.normalize();\r\n\r\n\t\t\tface.normal.copy( cb );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeVertexNormals: function ( areaWeighted ) {\r\n\r\n\t\tif ( areaWeighted === undefined ) areaWeighted = true;\r\n\r\n\t\tvar v, vl, f, fl, face, vertices;\r\n\r\n\t\tvertices = new Array( this.vertices.length );\r\n\r\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\tvertices[ v ] = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tif ( areaWeighted ) {\r\n\r\n\t\t\t// vertex normals weighted by triangle areas\r\n\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\r\n\r\n\t\t\tvar vA, vB, vC;\r\n\t\t\tvar cb = new Vector3(), ab = new Vector3();\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tvA = this.vertices[ face.a ];\r\n\t\t\t\tvB = this.vertices[ face.b ];\r\n\t\t\t\tvC = this.vertices[ face.c ];\r\n\r\n\t\t\t\tcb.subVectors( vC, vB );\r\n\t\t\t\tab.subVectors( vA, vB );\r\n\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\tvertices[ face.a ].add( cb );\r\n\t\t\t\tvertices[ face.b ].add( cb );\r\n\t\t\t\tvertices[ face.c ].add( cb );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.computeFaceNormals();\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tvertices[ face.a ].add( face.normal );\r\n\t\t\t\tvertices[ face.b ].add( face.normal );\r\n\t\t\t\tvertices[ face.c ].add( face.normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\tvertices[ v ].normalize();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tvar vertexNormals = face.vertexNormals;\r\n\r\n\t\t\tif ( vertexNormals.length === 3 ) {\r\n\r\n\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\r\n\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\r\n\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\r\n\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\r\n\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.faces.length > 0 ) {\r\n\r\n\t\t\tthis.normalsNeedUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeFlatVertexNormals: function () {\r\n\r\n\t\tvar f, fl, face;\r\n\r\n\t\tthis.computeFaceNormals();\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tvar vertexNormals = face.vertexNormals;\r\n\r\n\t\t\tif ( vertexNormals.length === 3 ) {\r\n\r\n\t\t\t\tvertexNormals[ 0 ].copy( face.normal );\r\n\t\t\t\tvertexNormals[ 1 ].copy( face.normal );\r\n\t\t\t\tvertexNormals[ 2 ].copy( face.normal );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvertexNormals[ 0 ] = face.normal.clone();\r\n\t\t\t\tvertexNormals[ 1 ] = face.normal.clone();\r\n\t\t\t\tvertexNormals[ 2 ] = face.normal.clone();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.faces.length > 0 ) {\r\n\r\n\t\t\tthis.normalsNeedUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeMorphNormals: function () {\r\n\r\n\t\tvar i, il, f, fl, face;\r\n\r\n\t\t// save original normals\r\n\t\t// - create temp variables on first access\r\n\t\t//   otherwise just copy (for faster repeated calls)\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tif ( ! face.__originalFaceNormal ) {\r\n\r\n\t\t\t\tface.__originalFaceNormal = face.normal.clone();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tface.__originalFaceNormal.copy( face.normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\r\n\r\n\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\r\n\r\n\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// use temp geometry to compute face and vertex normals for each morph\r\n\r\n\t\tvar tmpGeo = new loader_Geometry_Geometry();\r\n\t\ttmpGeo.faces = this.faces;\r\n\r\n\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\t\t// create on first access\r\n\r\n\t\t\tif ( ! this.morphNormals[ i ] ) {\r\n\r\n\t\t\t\tthis.morphNormals[ i ] = {};\r\n\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\r\n\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\r\n\r\n\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\r\n\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\r\n\r\n\t\t\t\tvar faceNormal, vertexNormals;\r\n\r\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\tfaceNormal = new Vector3();\r\n\t\t\t\t\tvertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };\r\n\r\n\t\t\t\t\tdstNormalsFace.push( faceNormal );\r\n\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar morphNormals = this.morphNormals[ i ];\r\n\r\n\t\t\t// set vertices to morph target\r\n\r\n\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\r\n\r\n\t\t\t// compute morph normals\r\n\r\n\t\t\ttmpGeo.computeFaceNormals();\r\n\t\t\ttmpGeo.computeVertexNormals();\r\n\r\n\t\t\t// store morph normals\r\n\r\n\t\t\tvar faceNormal, vertexNormals;\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\r\n\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\r\n\r\n\t\t\t\tfaceNormal.copy( face.normal );\r\n\r\n\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\r\n\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\r\n\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// restore original normals\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tface.normal = face.__originalFaceNormal;\r\n\t\t\tface.vertexNormals = face.__originalVertexNormals;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeBoundingBox: function () {\r\n\r\n\t\tif ( this.boundingBox === null ) {\r\n\r\n\t\t\tthis.boundingBox = new Box3();\r\n\r\n\t\t}\r\n\r\n\t\tthis.boundingBox.setFromPoints( this.vertices );\r\n\r\n\t},\r\n\r\n\tcomputeBoundingSphere: function () {\r\n\r\n\t\tif ( this.boundingSphere === null ) {\r\n\r\n\t\t\tthis.boundingSphere = new Sphere();\r\n\r\n\t\t}\r\n\r\n\t\tthis.boundingSphere.setFromPoints( this.vertices );\r\n\r\n\t},\r\n\r\n\tmerge: function ( geometry, matrix, materialIndexOffset ) {\r\n\r\n\t\tif ( ! ( geometry && geometry.isGeometry ) ) {\r\n\r\n\t\t\tconsole.error( 'COOL.Geometry.merge(): geometry not an instance of COOL.Geometry.', geometry );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar normalMatrix,\r\n\t\t\tvertexOffset = this.vertices.length,\r\n\t\t\tvertices1 = this.vertices,\r\n\t\t\tvertices2 = geometry.vertices,\r\n\t\t\tfaces1 = this.faces,\r\n\t\t\tfaces2 = geometry.faces,\r\n\t\t\tuvs1 = this.faceVertexUvs[ 0 ],\r\n\t\t\tuvs2 = geometry.faceVertexUvs[ 0 ],\r\n\t\t\tcolors1 = this.colors,\r\n\t\t\tcolors2 = geometry.colors;\r\n\r\n\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\r\n\r\n\t\tif ( matrix !== undefined ) {\r\n\r\n\t\t\tnormalMatrix = new Matrix3().getNormalMatrix( matrix );\r\n\r\n\t\t}\r\n\r\n\t\t// vertices\r\n\r\n\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar vertex = vertices2[ i ];\r\n\r\n\t\t\tvar vertexCopy = vertex.clone();\r\n\r\n\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\r\n\r\n\t\t\tvertices1.push( vertexCopy );\r\n\r\n\t\t}\r\n\r\n\t\t// colors\r\n\r\n\t\tfor ( var i = 0, il = colors2.length; i < il; i ++ ) {\r\n\r\n\t\t\tcolors1.push( colors2[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\t// faces\r\n\r\n\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\r\n\t\t\t\tfaceVertexNormals = face.vertexNormals,\r\n\t\t\t\tfaceVertexColors = face.vertexColors;\r\n\r\n\t\t\tfaceCopy = new Face3_Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\r\n\t\t\tfaceCopy.normal.copy( face.normal );\r\n\r\n\t\t\tif ( normalMatrix !== undefined ) {\r\n\r\n\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tnormal = faceVertexNormals[ j ].clone();\r\n\r\n\t\t\t\tif ( normalMatrix !== undefined ) {\r\n\r\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfaceCopy.vertexNormals.push( normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfaceCopy.color.copy( face.color );\r\n\r\n\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tcolor = faceVertexColors[ j ];\r\n\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\r\n\r\n\t\t\tfaces1.push( faceCopy );\r\n\r\n\t\t}\r\n\r\n\t\t// uvs\r\n\r\n\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar uv = uvs2[ i ], uvCopy = [];\r\n\r\n\t\t\tif ( uv === undefined ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tuvCopy.push( uv[ j ].clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuvs1.push( uvCopy );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tmergeMesh: function ( mesh ) {\r\n\r\n\t\tif ( ! ( mesh && mesh.isMesh ) ) {\r\n\r\n\t\t\tconsole.error( 'COOL.Geometry.mergeMesh(): mesh not an instance of COOL.Mesh.', mesh );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( mesh.matrixAutoUpdate ) mesh.updateMatrix();\r\n\r\n\t\tthis.merge( mesh.geometry, mesh.matrix );\r\n\r\n\t},\r\n\r\n\t/*\r\n\t * Checks for duplicate vertices with hashmap.\r\n\t * Duplicated vertices are removed\r\n\t * and faces' vertices are updated.\r\n\t */\r\n\r\n\tmergeVertices: function () {\r\n\r\n\t\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\r\n\t\tvar unique = [], changes = [];\r\n\r\n\t\tvar v, key;\r\n\t\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\r\n\t\tvar precision = Math.pow( 10, precisionPoints );\r\n\t\tvar i, il, face;\r\n\t\tvar indices, j, jl;\r\n\r\n\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tv = this.vertices[ i ];\r\n\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\r\n\r\n\t\t\tif ( verticesMap[ key ] === undefined ) {\r\n\r\n\t\t\t\tverticesMap[ key ] = i;\r\n\t\t\t\tunique.push( this.vertices[ i ] );\r\n\t\t\t\tchanges[ i ] = unique.length - 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\r\n\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\t// if faces are completely degenerate after merging vertices, we\r\n\t\t// have to remove them from the geometry.\r\n\t\tvar faceIndicesToRemove = [];\r\n\r\n\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tface = this.faces[ i ];\r\n\r\n\t\t\tface.a = changes[ face.a ];\r\n\t\t\tface.b = changes[ face.b ];\r\n\t\t\tface.c = changes[ face.c ];\r\n\r\n\t\t\tindices = [ face.a, face.b, face.c ];\r\n\r\n\t\t\t// if any duplicate vertices are found in a Face3\r\n\t\t\t// we have to remove the face as nothing can be saved\r\n\t\t\tfor ( var n = 0; n < 3; n ++ ) {\r\n\r\n\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\r\n\r\n\t\t\t\t\tfaceIndicesToRemove.push( i );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\r\n\r\n\t\t\tvar idx = faceIndicesToRemove[ i ];\r\n\r\n\t\t\tthis.faces.splice( idx, 1 );\r\n\r\n\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Use unique set of vertices\r\n\r\n\t\tvar diff = this.vertices.length - unique.length;\r\n\t\tthis.vertices = unique;\r\n\t\treturn diff;\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function ( points ) {\r\n\r\n\t\tthis.vertices = [];\r\n\r\n\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar point = points[ i ];\r\n\t\t\tthis.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsortFacesByMaterialIndex: function () {\r\n\r\n\t\tvar faces = this.faces;\r\n\t\tvar length = faces.length;\r\n\r\n\t\t// tag faces\r\n\r\n\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\r\n\t\t\tfaces[ i ]._id = i;\r\n\r\n\t\t}\r\n\r\n\t\t// sort faces\r\n\r\n\t\tfunction materialIndexSort( a, b ) {\r\n\r\n\t\t\treturn a.materialIndex - b.materialIndex;\r\n\r\n\t\t}\r\n\r\n\t\tfaces.sort( materialIndexSort );\r\n\r\n\t\t// sort uvs\r\n\r\n\t\tvar uvs1 = this.faceVertexUvs[ 0 ];\r\n\t\tvar uvs2 = this.faceVertexUvs[ 1 ];\r\n\r\n\t\tvar newUvs1, newUvs2;\r\n\r\n\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\r\n\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\r\n\r\n\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\r\n\t\t\tvar id = faces[ i ]._id;\r\n\r\n\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\r\n\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\r\n\r\n\t\t}\r\n\r\n\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\r\n\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar data = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.5,\r\n\t\t\t\ttype: 'Geometry',\r\n\t\t\t\tgenerator: 'Geometry.toJSON'\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// standard Geometry serialization\r\n\r\n\t\tdata.uuid = this.uuid;\r\n\t\tdata.type = this.type;\r\n\t\tif ( this.name !== '' ) data.name = this.name;\r\n\r\n\t\tif ( this.parameters !== undefined ) {\r\n\r\n\t\t\tvar parameters = this.parameters;\r\n\r\n\t\t\tfor ( var key in parameters ) {\r\n\r\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tvar vertices = [];\r\n\r\n\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\r\n\r\n\t\t\tvar vertex = this.vertices[ i ];\r\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t}\r\n\r\n\t\tvar faces = [];\r\n\t\tvar normals = [];\r\n\t\tvar normalsHash = {};\r\n\t\tvar colors = [];\r\n\t\tvar colorsHash = {};\r\n\t\tvar uvs = [];\r\n\t\tvar uvsHash = {};\r\n\r\n\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\r\n\r\n\t\t\tvar face = this.faces[ i ];\r\n\r\n\t\t\tvar hasMaterial = true;\r\n\t\t\tvar hasFaceUv = false; // deprecated\r\n\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\r\n\t\t\tvar hasFaceNormal = face.normal.length() > 0;\r\n\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\r\n\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\r\n\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\r\n\r\n\t\t\tvar faceType = 0;\r\n\r\n\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\r\n\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\r\n\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\r\n\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\r\n\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\r\n\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\r\n\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\r\n\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\r\n\r\n\t\t\tfaces.push( faceType );\r\n\t\t\tfaces.push( face.a, face.b, face.c );\r\n\t\t\tfaces.push( face.materialIndex );\r\n\r\n\t\t\tif ( hasFaceVertexUv ) {\r\n\r\n\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\r\n\r\n\t\t\t\tfaces.push(\r\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\r\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\r\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceNormal ) {\r\n\r\n\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexNormal ) {\r\n\r\n\t\t\t\tvar vertexNormals = face.vertexNormals;\r\n\r\n\t\t\t\tfaces.push(\r\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\r\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\r\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceColor ) {\r\n\r\n\t\t\t\tfaces.push( getColorIndex( face.color ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexColor ) {\r\n\r\n\t\t\t\tvar vertexColors = face.vertexColors;\r\n\r\n\t\t\t\tfaces.push(\r\n\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\r\n\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\r\n\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction setBit( value, position, enabled ) {\r\n\r\n\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\r\n\r\n\t\t}\r\n\r\n\t\tfunction getNormalIndex( normal ) {\r\n\r\n\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\r\n\r\n\t\t\tif ( normalsHash[ hash ] !== undefined ) {\r\n\r\n\t\t\t\treturn normalsHash[ hash ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnormalsHash[ hash ] = normals.length / 3;\r\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\r\n\r\n\t\t\treturn normalsHash[ hash ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction getColorIndex( color ) {\r\n\r\n\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\r\n\r\n\t\t\tif ( colorsHash[ hash ] !== undefined ) {\r\n\r\n\t\t\t\treturn colorsHash[ hash ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcolorsHash[ hash ] = colors.length;\r\n\t\t\tcolors.push( color.getHex() );\r\n\r\n\t\t\treturn colorsHash[ hash ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction getUvIndex( uv ) {\r\n\r\n\t\t\tvar hash = uv.x.toString() + uv.y.toString();\r\n\r\n\t\t\tif ( uvsHash[ hash ] !== undefined ) {\r\n\r\n\t\t\t\treturn uvsHash[ hash ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuvsHash[ hash ] = uvs.length / 2;\r\n\t\t\tuvs.push( uv.x, uv.y );\r\n\r\n\t\t\treturn uvsHash[ hash ];\r\n\r\n\t\t}\r\n\r\n\t\tdata.data = {};\r\n\r\n\t\tdata.data.vertices = vertices;\r\n\t\tdata.data.normals = normals;\r\n\t\tif ( colors.length > 0 ) data.data.colors = colors;\r\n\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\r\n\t\tdata.data.faces = faces;\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\t/*\r\n\t\t // Handle primitives\r\n\r\n\t\t var parameters = this.parameters;\r\n\r\n\t\t if ( parameters !== undefined ) {\r\n\r\n\t\t var values = [];\r\n\r\n\t\t for ( var key in parameters ) {\r\n\r\n\t\t values.push( parameters[ key ] );\r\n\r\n\t\t }\r\n\r\n\t\t var geometry = Object.create( this.constructor.prototype );\r\n\t\t this.constructor.apply( geometry, values );\r\n\t\t return geometry;\r\n\r\n\t\t }\r\n\r\n\t\t return new this.constructor().copy( this );\r\n\t\t */\r\n\r\n\t\treturn new loader_Geometry_Geometry().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tvar i, il, j, jl, k, kl;\r\n\r\n\t\t// reset\r\n\r\n\t\tthis.vertices = [];\r\n\t\tthis.colors = [];\r\n\t\tthis.faces = [];\r\n\t\tthis.faceVertexUvs = [[]];\r\n\t\tthis.morphTargets = [];\r\n\t\tthis.morphNormals = [];\r\n\t\tthis.skinWeights = [];\r\n\t\tthis.skinIndices = [];\r\n\t\tthis.lineDistances = [];\r\n\t\tthis.boundingBox = null;\r\n\t\tthis.boundingSphere = null;\r\n\r\n\t\t// name\r\n\r\n\t\tthis.name = source.name;\r\n\r\n\t\t// vertices\r\n\r\n\t\tvar vertices = source.vertices;\r\n\r\n\t\tfor ( i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.vertices.push( vertices[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\t// colors\r\n\r\n\t\tvar colors = source.colors;\r\n\r\n\t\tfor ( i = 0, il = colors.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.colors.push( colors[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\t// faces\r\n\r\n\t\tvar faces = source.faces;\r\n\r\n\t\tfor ( i = 0, il = faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.faces.push( faces[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\t// face vertex uvs\r\n\r\n\t\tfor ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar faceVertexUvs = source.faceVertexUvs[ i ];\r\n\r\n\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\r\n\r\n\t\t\t\tthis.faceVertexUvs[ i ] = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\r\n\r\n\t\t\t\tfor ( k = 0, kl = uvs.length; k < kl; k ++ ) {\r\n\r\n\t\t\t\t\tvar uv = uvs[ k ];\r\n\r\n\t\t\t\t\tuvsCopy.push( uv.clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// morph targets\r\n\r\n\t\tvar morphTargets = source.morphTargets;\r\n\r\n\t\tfor ( i = 0, il = morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar morphTarget = {};\r\n\t\t\tmorphTarget.name = morphTargets[ i ].name;\r\n\r\n\t\t\t// vertices\r\n\r\n\t\t\tif ( morphTargets[ i ].vertices !== undefined ) {\r\n\r\n\t\t\t\tmorphTarget.vertices = [];\r\n\r\n\t\t\t\tfor ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tmorphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// normals\r\n\r\n\t\t\tif ( morphTargets[ i ].normals !== undefined ) {\r\n\r\n\t\t\t\tmorphTarget.normals = [];\r\n\r\n\t\t\t\tfor ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tmorphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.morphTargets.push( morphTarget );\r\n\r\n\t\t}\r\n\r\n\t\t// morph normals\r\n\r\n\t\tvar morphNormals = source.morphNormals;\r\n\r\n\t\tfor ( i = 0, il = morphNormals.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar morphNormal = {};\r\n\r\n\t\t\t// vertex normals\r\n\r\n\t\t\tif ( morphNormals[ i ].vertexNormals !== undefined ) {\r\n\r\n\t\t\t\tmorphNormal.vertexNormals = [];\r\n\r\n\t\t\t\tfor ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tvar srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];\r\n\t\t\t\t\tvar destVertexNormal = {};\r\n\r\n\t\t\t\t\tdestVertexNormal.a = srcVertexNormal.a.clone();\r\n\t\t\t\t\tdestVertexNormal.b = srcVertexNormal.b.clone();\r\n\t\t\t\t\tdestVertexNormal.c = srcVertexNormal.c.clone();\r\n\r\n\t\t\t\t\tmorphNormal.vertexNormals.push( destVertexNormal );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// face normals\r\n\r\n\t\t\tif ( morphNormals[ i ].faceNormals !== undefined ) {\r\n\r\n\t\t\t\tmorphNormal.faceNormals = [];\r\n\r\n\t\t\t\tfor ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tmorphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.morphNormals.push( morphNormal );\r\n\r\n\t\t}\r\n\r\n\t\t// skin weights\r\n\r\n\t\tvar skinWeights = source.skinWeights;\r\n\r\n\t\tfor ( i = 0, il = skinWeights.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.skinWeights.push( skinWeights[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\t// skin indices\r\n\r\n\t\tvar skinIndices = source.skinIndices;\r\n\r\n\t\tfor ( i = 0, il = skinIndices.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.skinIndices.push( skinIndices[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\t// line distances\r\n\r\n\t\tvar lineDistances = source.lineDistances;\r\n\r\n\t\tfor ( i = 0, il = lineDistances.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.lineDistances.push( lineDistances[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\t// bounding box\r\n\r\n\t\tvar boundingBox = source.boundingBox;\r\n\r\n\t\tif ( boundingBox !== null ) {\r\n\r\n\t\t\tthis.boundingBox = boundingBox.clone();\r\n\r\n\t\t}\r\n\r\n\t\t// bounding sphere\r\n\r\n\t\tvar boundingSphere = source.boundingSphere;\r\n\r\n\t\tif ( boundingSphere !== null ) {\r\n\r\n\t\t\tthis.boundingSphere = boundingSphere.clone();\r\n\r\n\t\t}\r\n\r\n\t\t// update flags\r\n\r\n\t\tthis.elementsNeedUpdate = source.elementsNeedUpdate;\r\n\t\tthis.verticesNeedUpdate = source.verticesNeedUpdate;\r\n\t\tthis.uvsNeedUpdate = source.uvsNeedUpdate;\r\n\t\tthis.normalsNeedUpdate = source.normalsNeedUpdate;\r\n\t\tthis.colorsNeedUpdate = source.colorsNeedUpdate;\r\n\t\tthis.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\r\n\t\tthis.groupsNeedUpdate = source.groupsNeedUpdate;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/math/Vector4.js\n/**\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author egraether / http://egraether.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nfunction Vector4_Vector4( x, y, z, w ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\tthis.z = z || 0;\r\n\tthis.w = ( w !== undefined ) ? w : 1;\r\n\r\n}\r\n\r\nObject.assign( Vector4_Vector4.prototype, {\r\n\r\n\tisVector4: true,\r\n\r\n\tset: function ( x, y, z, w ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\t\tthis.w = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetScalar: function ( scalar ) {\r\n\r\n\t\tthis.x = scalar;\r\n\t\tthis.y = scalar;\r\n\t\tthis.z = scalar;\r\n\t\tthis.w = scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetZ: function ( z ) {\r\n\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetW: function ( w ) {\r\n\r\n\t\tthis.w = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tcase 2: this.z = value; break;\r\n\t\t\tcase 3: this.w = value; break;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tcase 2: return this.z;\r\n\t\t\tcase 3: return this.w;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\t\tthis.z = v.z;\r\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\t\tthis.z += v.z;\r\n\t\tthis.w += v.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\t\tthis.z += s;\r\n\t\tthis.w += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\t\tthis.z = a.z + b.z;\r\n\t\tthis.w = a.w + b.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScaledVector: function ( v, s ) {\r\n\r\n\t\tthis.x += v.x * s;\r\n\t\tthis.y += v.y * s;\r\n\t\tthis.z += v.z * s;\r\n\t\tthis.w += v.w * s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\t\tthis.z -= v.z;\r\n\t\tthis.w -= v.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubScalar: function ( s ) {\r\n\r\n\t\tthis.x -= s;\r\n\t\tthis.y -= s;\r\n\t\tthis.z -= s;\r\n\t\tthis.w -= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\t\tthis.z = a.z - b.z;\r\n\t\tthis.w = a.w - b.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( scalar ) {\r\n\r\n\t\tthis.x *= scalar;\r\n\t\tthis.y *= scalar;\r\n\t\tthis.z *= scalar;\r\n\t\tthis.w *= scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( m ) {\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z, w = this.w;\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\r\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\r\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\r\n\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( scalar ) {\r\n\r\n\t\treturn this.multiplyScalar( 1 / scalar );\r\n\r\n\t},\r\n\r\n\tsetAxisAngleFromQuaternion: function ( q ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\r\n\r\n\t\t// q is assumed to be normalized\r\n\r\n\t\tthis.w = 2 * Math.acos( q.w );\r\n\r\n\t\tvar s = Math.sqrt( 1 - q.w * q.w );\r\n\r\n\t\tif ( s < 0.0001 ) {\r\n\r\n\t\t\tthis.x = 1;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.z = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.x = q.x / s;\r\n\t\t\tthis.y = q.y / s;\r\n\t\t\tthis.z = q.z / s;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetAxisAngleFromRotationMatrix: function ( m ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tvar angle, x, y, z,\t\t// variables for result\r\n\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\r\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\r\n\r\n\t\t\tte = m.elements,\r\n\r\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\r\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\r\n\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\r\n\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\r\n\r\n\t\t\t// singularity found\r\n\t\t\t// first check for identity matrix which must have +1 for all terms\r\n\t\t\t// in leading diagonal and zero in other terms\r\n\r\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\r\n\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\r\n\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\r\n\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\r\n\r\n\t\t\t\t// this singularity is identity matrix so angle = 0\r\n\r\n\t\t\t\tthis.set( 1, 0, 0, 0 );\r\n\r\n\t\t\t\treturn this; // zero angle, arbitrary axis\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// otherwise this singularity is angle = 180\r\n\r\n\t\t\tangle = Math.PI;\r\n\r\n\t\t\tvar xx = ( m11 + 1 ) / 2;\r\n\t\t\tvar yy = ( m22 + 1 ) / 2;\r\n\t\t\tvar zz = ( m33 + 1 ) / 2;\r\n\t\t\tvar xy = ( m12 + m21 ) / 4;\r\n\t\t\tvar xz = ( m13 + m31 ) / 4;\r\n\t\t\tvar yz = ( m23 + m32 ) / 4;\r\n\r\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\r\n\r\n\t\t\t\t// m11 is the largest diagonal term\r\n\r\n\t\t\t\tif ( xx < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0;\r\n\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\tz = 0.707106781;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tx = Math.sqrt( xx );\r\n\t\t\t\t\ty = xy / x;\r\n\t\t\t\t\tz = xz / x;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( yy > zz ) {\r\n\r\n\t\t\t\t// m22 is the largest diagonal term\r\n\r\n\t\t\t\tif ( yy < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\ty = 0;\r\n\t\t\t\t\tz = 0.707106781;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ty = Math.sqrt( yy );\r\n\t\t\t\t\tx = xy / y;\r\n\t\t\t\t\tz = yz / y;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// m33 is the largest diagonal term so base result on this\r\n\r\n\t\t\t\tif ( zz < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\tz = 0;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tz = Math.sqrt( zz );\r\n\t\t\t\t\tx = xz / z;\r\n\t\t\t\t\ty = yz / z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.set( x, y, z, angle );\r\n\r\n\t\t\treturn this; // return 180 deg rotation\r\n\r\n\t\t}\r\n\r\n\t\t// as we have reached here there are no singularities so we can handle normally\r\n\r\n\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\r\n\t\t                   ( m13 - m31 ) * ( m13 - m31 ) +\r\n\t\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\r\n\r\n\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\r\n\r\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\r\n\t\t// caught by singularity test above, but I've left it in just in case\r\n\r\n\t\tthis.x = ( m32 - m23 ) / s;\r\n\t\tthis.y = ( m13 - m31 ) / s;\r\n\t\tthis.z = ( m21 - m12 ) / s;\r\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tthis.x = Math.min( this.x, v.x );\r\n\t\tthis.y = Math.min( this.y, v.y );\r\n\t\tthis.z = Math.min( this.z, v.z );\r\n\t\tthis.w = Math.min( this.w, v.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tthis.x = Math.max( this.x, v.x );\r\n\t\tthis.y = Math.max( this.y, v.y );\r\n\t\tthis.z = Math.max( this.z, v.z );\r\n\t\tthis.w = Math.max( this.w, v.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// assumes min < max, componentwise\r\n\r\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\r\n\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclampScalar: function () {\r\n\r\n\t\tvar min, max;\r\n\r\n\t\treturn function clampScalar( minVal, maxVal ) {\r\n\r\n\t\t\tif ( min === undefined ) {\r\n\r\n\t\t\t\tmin = new Vector4_Vector4();\r\n\t\t\t\tmax = new Vector4_Vector4();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmin.set( minVal, minVal, minVal, minVal );\r\n\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\r\n\r\n\t\t\treturn this.clamp( min, max );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclampLength: function ( min, max ) {\r\n\r\n\t\tvar length = this.length();\r\n\r\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\r\n\r\n\t},\r\n\r\n\tfloor: function () {\r\n\r\n\t\tthis.x = Math.floor( this.x );\r\n\t\tthis.y = Math.floor( this.y );\r\n\t\tthis.z = Math.floor( this.z );\r\n\t\tthis.w = Math.floor( this.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tceil: function () {\r\n\r\n\t\tthis.x = Math.ceil( this.x );\r\n\t\tthis.y = Math.ceil( this.y );\r\n\t\tthis.z = Math.ceil( this.z );\r\n\t\tthis.w = Math.ceil( this.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tround: function () {\r\n\r\n\t\tthis.x = Math.round( this.x );\r\n\t\tthis.y = Math.round( this.y );\r\n\t\tthis.z = Math.round( this.z );\r\n\t\tthis.w = Math.round( this.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\troundToZero: function () {\r\n\r\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.x = - this.x;\r\n\t\tthis.y = - this.y;\r\n\t\tthis.z = - this.z;\r\n\t\tthis.w = - this.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\r\n\r\n\t},\r\n\r\n\tmanhattanLength: function () {\r\n\r\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() || 1 );\r\n\r\n\t},\r\n\r\n\tsetLength: function ( length ) {\r\n\r\n\t\treturn this.normalize().multiplyScalar( length );\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\t\tthis.w += ( v.w - this.w ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerpVectors: function ( v1, v2, alpha ) {\r\n\r\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.x = array[ offset ];\r\n\t\tthis.y = array[ offset + 1 ];\r\n\t\tthis.z = array[ offset + 2 ];\r\n\t\tthis.w = array[ offset + 3 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this.x;\r\n\t\tarray[ offset + 1 ] = this.y;\r\n\t\tarray[ offset + 2 ] = this.z;\r\n\t\tarray[ offset + 3 ] = this.w;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tfromBufferAttribute: function ( attribute, index, offset ) {\r\n\r\n\t\tif ( offset !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Vector4: offset has been removed from .fromBufferAttribute().' );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x = attribute.getX( index );\r\n\t\tthis.y = attribute.getY( index );\r\n\t\tthis.z = attribute.getZ( index );\r\n\t\tthis.w = attribute.getW( index );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/loader/BufferAttribute.js\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nfunction BufferAttribute( array, itemSize, normalized ) {\r\n\r\n\tif ( Array.isArray( array ) ) {\r\n\r\n\t\tthrow new TypeError( 'COOL.BufferAttribute: array should be a Typed Array.' );\r\n\r\n\t}\r\n\r\n\tthis.name = '';\r\n\r\n\tthis.array = array;\r\n\tthis.itemSize = itemSize;\r\n\tthis.count = array !== undefined ? array.length / itemSize : 0;\r\n\tthis.normalized = normalized === true;\r\n\r\n\tthis.dynamic = false;\r\n\tthis.updateRange = { offset: 0, count: - 1 };\r\n\r\n\tthis.version = 0;\r\n\r\n}\r\n\r\nObject.defineProperty( BufferAttribute.prototype, 'needsUpdate', {\r\n\r\n\tset: function ( value ) {\r\n\r\n\t\tif ( value === true ) this.version ++;\r\n\r\n\t}\r\n\r\n} );\r\n\r\nObject.assign( BufferAttribute.prototype, {\r\n\r\n\tisBufferAttribute: true,\r\n\r\n\tonUploadCallback: function () {},\r\n\r\n\tsetArray: function ( array ) {\r\n\r\n\t\tif ( Array.isArray( array ) ) {\r\n\r\n\t\t\tthrow new TypeError( 'COOL.BufferAttribute: array should be a Typed Array.' );\r\n\r\n\t\t}\r\n\r\n\t\tthis.count = array !== undefined ? array.length / this.itemSize : 0;\r\n\t\tthis.array = array;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetDynamic: function ( value ) {\r\n\r\n\t\tthis.dynamic = value;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.name = source.name;\r\n\t\tthis.array = new source.array.constructor( source.array );\r\n\t\tthis.itemSize = source.itemSize;\r\n\t\tthis.count = source.count;\r\n\t\tthis.normalized = source.normalized;\r\n\r\n\t\tthis.dynamic = source.dynamic;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyAt: function ( index1, attribute, index2 ) {\r\n\r\n\t\tindex1 *= this.itemSize;\r\n\t\tindex2 *= attribute.itemSize;\r\n\r\n\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\r\n\r\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyArray: function ( array ) {\r\n\r\n\t\tthis.array.set( array );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyColorsArray: function ( colors ) {\r\n\r\n\t\tvar array = this.array, offset = 0;\r\n\r\n\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar color = colors[ i ];\r\n\r\n\t\t\tif ( color === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'COOL.BufferAttribute.copyColorsArray(): color is undefined', i );\r\n\t\t\t\tcolor = new Color();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tarray[ offset ++ ] = color.r;\r\n\t\t\tarray[ offset ++ ] = color.g;\r\n\t\t\tarray[ offset ++ ] = color.b;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyVector2sArray: function ( vectors ) {\r\n\r\n\t\tvar array = this.array, offset = 0;\r\n\r\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar vector = vectors[ i ];\r\n\r\n\t\t\tif ( vector === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'COOL.BufferAttribute.copyVector2sArray(): vector is undefined', i );\r\n\t\t\t\tvector = new Vector2();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tarray[ offset ++ ] = vector.x;\r\n\t\t\tarray[ offset ++ ] = vector.y;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyVector3sArray: function ( vectors ) {\r\n\r\n\t\tvar array = this.array, offset = 0;\r\n\r\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar vector = vectors[ i ];\r\n\r\n\t\t\tif ( vector === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'COOL.BufferAttribute.copyVector3sArray(): vector is undefined', i );\r\n\t\t\t\tvector = new Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tarray[ offset ++ ] = vector.x;\r\n\t\t\tarray[ offset ++ ] = vector.y;\r\n\t\t\tarray[ offset ++ ] = vector.z;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyVector4sArray: function ( vectors ) {\r\n\r\n\t\tvar array = this.array, offset = 0;\r\n\r\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar vector = vectors[ i ];\r\n\r\n\t\t\tif ( vector === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'COOL.BufferAttribute.copyVector4sArray(): vector is undefined', i );\r\n\t\t\t\tvector = new Vector4_Vector4();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tarray[ offset ++ ] = vector.x;\r\n\t\t\tarray[ offset ++ ] = vector.y;\r\n\t\t\tarray[ offset ++ ] = vector.z;\r\n\t\t\tarray[ offset ++ ] = vector.w;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tset: function ( value, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.array.set( value, offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetX: function ( index ) {\r\n\r\n\t\treturn this.array[ index * this.itemSize ];\r\n\r\n\t},\r\n\r\n\tsetX: function ( index, x ) {\r\n\r\n\t\tthis.array[ index * this.itemSize ] = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetY: function ( index ) {\r\n\r\n\t\treturn this.array[ index * this.itemSize + 1 ];\r\n\r\n\t},\r\n\r\n\tsetY: function ( index, y ) {\r\n\r\n\t\tthis.array[ index * this.itemSize + 1 ] = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetZ: function ( index ) {\r\n\r\n\t\treturn this.array[ index * this.itemSize + 2 ];\r\n\r\n\t},\r\n\r\n\tsetZ: function ( index, z ) {\r\n\r\n\t\tthis.array[ index * this.itemSize + 2 ] = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetW: function ( index ) {\r\n\r\n\t\treturn this.array[ index * this.itemSize + 3 ];\r\n\r\n\t},\r\n\r\n\tsetW: function ( index, w ) {\r\n\r\n\t\tthis.array[ index * this.itemSize + 3 ] = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXY: function ( index, x, y ) {\r\n\r\n\t\tindex *= this.itemSize;\r\n\r\n\t\tthis.array[ index + 0 ] = x;\r\n\t\tthis.array[ index + 1 ] = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXYZ: function ( index, x, y, z ) {\r\n\r\n\t\tindex *= this.itemSize;\r\n\r\n\t\tthis.array[ index + 0 ] = x;\r\n\t\tthis.array[ index + 1 ] = y;\r\n\t\tthis.array[ index + 2 ] = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXYZW: function ( index, x, y, z, w ) {\r\n\r\n\t\tindex *= this.itemSize;\r\n\r\n\t\tthis.array[ index + 0 ] = x;\r\n\t\tthis.array[ index + 1 ] = y;\r\n\t\tthis.array[ index + 2 ] = z;\r\n\t\tthis.array[ index + 3 ] = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tonUpload: function ( callback ) {\r\n\r\n\t\tthis.onUploadCallback = callback;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.array, this.itemSize ).copy( this );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n//\r\n\r\nfunction Int8BufferAttribute( array, itemSize, normalized ) {\r\n\r\n\tBufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );\r\n\r\n}\r\n\r\nInt8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\r\nInt8BufferAttribute.prototype.constructor = Int8BufferAttribute;\r\n\r\n\r\nfunction Uint8BufferAttribute( array, itemSize, normalized ) {\r\n\r\n\tBufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );\r\n\r\n}\r\n\r\nUint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\r\nUint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;\r\n\r\n\r\nfunction Uint8ClampedBufferAttribute( array, itemSize, normalized ) {\r\n\r\n\tBufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );\r\n\r\n}\r\n\r\nUint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );\r\nUint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;\r\n\r\n\r\nfunction Int16BufferAttribute( array, itemSize, normalized ) {\r\n\r\n\tBufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );\r\n\r\n}\r\n\r\nInt16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\r\nInt16BufferAttribute.prototype.constructor = Int16BufferAttribute;\r\n\r\n\r\nfunction Uint16BufferAttribute( array, itemSize, normalized ) {\r\n\r\n\tBufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );\r\n\r\n}\r\n\r\nUint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\r\nUint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;\r\n\r\n\r\nfunction Int32BufferAttribute( array, itemSize, normalized ) {\r\n\r\n\tBufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );\r\n\r\n}\r\n\r\nInt32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\r\nInt32BufferAttribute.prototype.constructor = Int32BufferAttribute;\r\n\r\n\r\nfunction Uint32BufferAttribute( array, itemSize, normalized ) {\r\n\r\n\tBufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );\r\n\r\n}\r\n\r\nUint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\r\nUint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;\r\n\r\n\r\nfunction Float32BufferAttribute( array, itemSize, normalized ) {\r\n\r\n\tBufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );\r\n\r\n}\r\n\r\nFloat32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\r\nFloat32BufferAttribute.prototype.constructor = Float32BufferAttribute;\r\n\r\n\r\nfunction Float64BufferAttribute( array, itemSize, normalized ) {\r\n\r\n\tBufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );\r\n\r\n}\r\n\r\nFloat64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\r\nFloat64BufferAttribute.prototype.constructor = Float64BufferAttribute;\r\n\r\n//\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/loader/DirectGeometry.js\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\n\r\n\r\nfunction DirectGeometry() {\r\n\r\n\tthis.vertices = [];\r\n\tthis.normals = [];\r\n\tthis.colors = [];\r\n\tthis.uvs = [];\r\n\tthis.uvs2 = [];\r\n\r\n\tthis.groups = [];\r\n\r\n\tthis.morphTargets = {};\r\n\r\n\tthis.skinWeights = [];\r\n\tthis.skinIndices = [];\r\n\r\n\t// this.lineDistances = [];\r\n\r\n\tthis.boundingBox = null;\r\n\tthis.boundingSphere = null;\r\n\r\n\t// update flags\r\n\r\n\tthis.verticesNeedUpdate = false;\r\n\tthis.normalsNeedUpdate = false;\r\n\tthis.colorsNeedUpdate = false;\r\n\tthis.uvsNeedUpdate = false;\r\n\tthis.groupsNeedUpdate = false;\r\n\r\n}\r\n\r\nObject.assign( DirectGeometry.prototype, {\r\n\r\n\tcomputeGroups: function ( geometry ) {\r\n\r\n\t\tvar group;\r\n\t\tvar groups = [];\r\n\t\tvar materialIndex = undefined;\r\n\r\n\t\tvar faces = geometry.faces;\r\n\r\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\t// materials\r\n\r\n\t\t\tif ( face.materialIndex !== materialIndex ) {\r\n\r\n\t\t\t\tmaterialIndex = face.materialIndex;\r\n\r\n\t\t\t\tif ( group !== undefined ) {\r\n\r\n\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\r\n\t\t\t\t\tgroups.push( group );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgroup = {\r\n\t\t\t\t\tstart: i * 3,\r\n\t\t\t\t\tmaterialIndex: materialIndex\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( group !== undefined ) {\r\n\r\n\t\t\tgroup.count = ( i * 3 ) - group.start;\r\n\t\t\tgroups.push( group );\r\n\r\n\t\t}\r\n\r\n\t\tthis.groups = groups;\r\n\r\n\t},\r\n\r\n\tfromGeometry: function ( geometry ) {\r\n\r\n\t\tvar faces = geometry.faces;\r\n\t\tvar vertices = geometry.vertices;\r\n\t\tvar faceVertexUvs = geometry.faceVertexUvs;\r\n\r\n\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\r\n\t\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\r\n\r\n\t\t// morphs\r\n\r\n\t\tvar morphTargets = geometry.morphTargets;\r\n\t\tvar morphTargetsLength = morphTargets.length;\r\n\r\n\t\tvar morphTargetsPosition;\r\n\r\n\t\tif ( morphTargetsLength > 0 ) {\r\n\r\n\t\t\tmorphTargetsPosition = [];\r\n\r\n\t\t\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\r\n\r\n\t\t\t\tmorphTargetsPosition[ i ] = {\r\n\t\t\t\t\tname: morphTargets[ i ].name,\r\n\t\t\t\t \tdata: []\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.morphTargets.position = morphTargetsPosition;\r\n\r\n\t\t}\r\n\r\n\t\tvar morphNormals = geometry.morphNormals;\r\n\t\tvar morphNormalsLength = morphNormals.length;\r\n\r\n\t\tvar morphTargetsNormal;\r\n\r\n\t\tif ( morphNormalsLength > 0 ) {\r\n\r\n\t\t\tmorphTargetsNormal = [];\r\n\r\n\t\t\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\r\n\r\n\t\t\t\tmorphTargetsNormal[ i ] = {\r\n\t\t\t\t\tname: morphNormals[ i ].name,\r\n\t\t\t\t \tdata: []\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.morphTargets.normal = morphTargetsNormal;\r\n\r\n\t\t}\r\n\r\n\t\t// skins\r\n\r\n\t\tvar skinIndices = geometry.skinIndices;\r\n\t\tvar skinWeights = geometry.skinWeights;\r\n\r\n\t\tvar hasSkinIndices = skinIndices.length === vertices.length;\r\n\t\tvar hasSkinWeights = skinWeights.length === vertices.length;\r\n\r\n\t\t//\r\n\r\n\t\tif ( vertices.length > 0 && faces.length === 0 ) {\r\n\r\n\t\t\tconsole.error( 'COOL.DirectGeometry: Faceless geometries are not supported.' );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\r\n\r\n\t\t\tvar vertexNormals = face.vertexNormals;\r\n\r\n\t\t\tif ( vertexNormals.length === 3 ) {\r\n\r\n\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar normal = face.normal;\r\n\r\n\t\t\t\tthis.normals.push( normal, normal, normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar vertexColors = face.vertexColors;\r\n\r\n\t\t\tif ( vertexColors.length === 3 ) {\r\n\r\n\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar color = face.color;\r\n\r\n\t\t\t\tthis.colors.push( color, color, color );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexUv === true ) {\r\n\r\n\t\t\t\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\r\n\r\n\t\t\t\tif ( vertexUvs !== undefined ) {\r\n\r\n\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.warn( 'COOL.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\r\n\r\n\t\t\t\t\tthis.uvs.push( new Vector2(), new Vector2(), new Vector2() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexUv2 === true ) {\r\n\r\n\t\t\t\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\r\n\r\n\t\t\t\tif ( vertexUvs !== undefined ) {\r\n\r\n\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.warn( 'COOL.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\r\n\r\n\t\t\t\t\tthis.uvs2.push( new Vector2(), new Vector2(), new Vector2() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// morphs\r\n\r\n\t\t\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\r\n\r\n\t\t\t\tvar morphTarget = morphTargets[ j ].vertices;\r\n\r\n\t\t\t\tmorphTargetsPosition[ j ].data.push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\r\n\r\n\t\t\t\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\r\n\r\n\t\t\t\tmorphTargetsNormal[ j ].data.push( morphNormal.a, morphNormal.b, morphNormal.c );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// skins\r\n\r\n\t\t\tif ( hasSkinIndices ) {\r\n\r\n\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasSkinWeights ) {\r\n\r\n\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.computeGroups( geometry );\r\n\r\n\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\r\n\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\r\n\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\r\n\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\r\n\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/loader/utils.js\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nfunction arrayMin( array ) {\r\n\r\n\tif ( array.length === 0 ) return Infinity;\r\n\r\n\tvar min = array[ 0 ];\r\n\r\n\tfor ( var i = 1, l = array.length; i < l; ++ i ) {\r\n\r\n\t\tif ( array[ i ] < min ) min = array[ i ];\r\n\r\n\t}\r\n\r\n\treturn min;\r\n\r\n}\r\n\r\nfunction arrayMax( array ) {\r\n\r\n\tif ( array.length === 0 ) return - Infinity;\r\n\r\n\tvar max = array[ 0 ];\r\n\r\n\tfor ( var i = 1, l = array.length; i < l; ++ i ) {\r\n\r\n\t\tif ( array[ i ] > max ) max = array[ i ];\r\n\r\n\t}\r\n\r\n\treturn max;\r\n\r\n}\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/loader/BufferGeometry.js\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nvar bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id\r\n\r\nfunction BufferGeometry() {\r\n\r\n\tObject.defineProperty( this, 'id', { value: bufferGeometryId += 2 } );\r\n\r\n\tthis.uuid = _Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'BufferGeometry';\r\n\r\n\tthis.index = null;\r\n\tthis.attributes = {};\r\n\r\n\tthis.morphAttributes = {};\r\n\r\n\tthis.groups = [];\r\n\r\n\tthis.boundingBox = null;\r\n\tthis.boundingSphere = null;\r\n\r\n\tthis.drawRange = { start: 0, count: Infinity };\r\n\r\n\tthis.userData = {};\r\n\r\n}\r\n\r\nBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\r\n\r\n\tconstructor: BufferGeometry,\r\n\r\n\tisBufferGeometry: true,\r\n\r\n\tgetIndex: function () {\r\n\r\n\t\treturn this.index;\r\n\r\n\t},\r\n\r\n\tsetIndex: function ( index ) {\r\n\r\n\t\tif ( Array.isArray( index ) ) {\r\n\r\n\t\t\tthis.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.index = index;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\taddAttribute: function ( name, attribute ) {\r\n\r\n\t\tif ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\r\n\r\n\t\t\treturn this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( name === 'index' ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\r\n\t\t\tthis.setIndex( attribute );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tthis.attributes[ name ] = attribute;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetAttribute: function ( name ) {\r\n\r\n\t\treturn this.attributes[ name ];\r\n\r\n\t},\r\n\r\n\tremoveAttribute: function ( name ) {\r\n\r\n\t\tdelete this.attributes[ name ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddGroup: function ( start, count, materialIndex ) {\r\n\r\n\t\tthis.groups.push( {\r\n\r\n\t\t\tstart: start,\r\n\t\t\tcount: count,\r\n\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\r\n\r\n\t\t} );\r\n\r\n\t},\r\n\r\n\tclearGroups: function () {\r\n\r\n\t\tthis.groups = [];\r\n\r\n\t},\r\n\r\n\tsetDrawRange: function ( start, count ) {\r\n\r\n\t\tthis.drawRange.start = start;\r\n\t\tthis.drawRange.count = count;\r\n\r\n\t},\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tvar position = this.attributes.position;\r\n\r\n\t\tif ( position !== undefined ) {\r\n\r\n\t\t\tmatrix.applyToBufferAttribute( position );\r\n\t\t\tposition.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tvar normal = this.attributes.normal;\r\n\r\n\t\tif ( normal !== undefined ) {\r\n\r\n\t\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\r\n\r\n\t\t\tnormalMatrix.applyToBufferAttribute( normal );\r\n\t\t\tnormal.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingBox !== null ) {\r\n\r\n\t\t\tthis.computeBoundingBox();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.computeBoundingSphere();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trotateX: function () {\r\n\r\n\t\t// rotate geometry around world x-axis\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function rotateX( angle ) {\r\n\r\n\t\t\tm1.makeRotationX( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateY: function () {\r\n\r\n\t\t// rotate geometry around world y-axis\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function rotateY( angle ) {\r\n\r\n\t\t\tm1.makeRotationY( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateZ: function () {\r\n\r\n\t\t// rotate geometry around world z-axis\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function rotateZ( angle ) {\r\n\r\n\t\t\tm1.makeRotationZ( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function () {\r\n\r\n\t\t// translate geometry\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function translate( x, y, z ) {\r\n\r\n\t\t\tm1.makeTranslation( x, y, z );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tscale: function () {\r\n\r\n\t\t// scale geometry\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function scale( x, y, z ) {\r\n\r\n\t\t\tm1.makeScale( x, y, z );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlookAt: function () {\r\n\r\n\t\tvar obj = new Object3D();\r\n\r\n\t\treturn function lookAt( vector ) {\r\n\r\n\t\t\tobj.lookAt( vector );\r\n\r\n\t\t\tobj.updateMatrix();\r\n\r\n\t\t\tthis.applyMatrix( obj.matrix );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcenter: function () {\r\n\r\n\t\tvar offset = new Vector3();\r\n\r\n\t\treturn function center() {\r\n\r\n\t\t\tthis.computeBoundingBox();\r\n\r\n\t\t\tthis.boundingBox.getCenter( offset ).negate();\r\n\r\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetFromObject: function ( object ) {\r\n\r\n\t\t// console.log( 'COOL.BufferGeometry.setFromObject(). Converting', object, this );\r\n\r\n\t\tvar geometry = object.geometry;\r\n\r\n\t\tif ( object.isPoints || object.isLine ) {\r\n\r\n\t\t\tvar positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );\r\n\t\t\tvar colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );\r\n\r\n\t\t\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\r\n\t\t\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\r\n\r\n\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\r\n\r\n\t\t\t\tvar lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );\r\n\r\n\t\t\t\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( geometry.boundingSphere !== null ) {\r\n\r\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( geometry.boundingBox !== null ) {\r\n\r\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( object.isMesh ) {\r\n\r\n\t\t\tif ( geometry && geometry.isGeometry ) {\r\n\r\n\t\t\t\tthis.fromGeometry( geometry );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function ( points ) {\r\n\r\n\t\tvar position = [];\r\n\r\n\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar point = points[ i ];\r\n\t\t\tposition.push( point.x, point.y, point.z || 0 );\r\n\r\n\t\t}\r\n\r\n\t\tthis.addAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tupdateFromObject: function ( object ) {\r\n\r\n\t\tvar geometry = object.geometry;\r\n\r\n\t\tif ( object.isMesh ) {\r\n\r\n\t\t\tvar direct = geometry.__directGeometry;\r\n\r\n\t\t\tif ( geometry.elementsNeedUpdate === true ) {\r\n\r\n\t\t\t\tdirect = undefined;\r\n\t\t\t\tgeometry.elementsNeedUpdate = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( direct === undefined ) {\r\n\r\n\t\t\t\treturn this.fromGeometry( geometry );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\r\n\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\r\n\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\r\n\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\r\n\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\r\n\r\n\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\tgeometry.normalsNeedUpdate = false;\r\n\t\t\tgeometry.colorsNeedUpdate = false;\r\n\t\t\tgeometry.uvsNeedUpdate = false;\r\n\t\t\tgeometry.groupsNeedUpdate = false;\r\n\r\n\t\t\tgeometry = direct;\r\n\r\n\t\t}\r\n\r\n\t\tvar attribute;\r\n\r\n\t\tif ( geometry.verticesNeedUpdate === true ) {\r\n\r\n\t\t\tattribute = this.attributes.position;\r\n\r\n\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\r\n\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.verticesNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.normalsNeedUpdate === true ) {\r\n\r\n\t\t\tattribute = this.attributes.normal;\r\n\r\n\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\tattribute.copyVector3sArray( geometry.normals );\r\n\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.normalsNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.colorsNeedUpdate === true ) {\r\n\r\n\t\t\tattribute = this.attributes.color;\r\n\r\n\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\tattribute.copyColorsArray( geometry.colors );\r\n\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.colorsNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.uvsNeedUpdate ) {\r\n\r\n\t\t\tattribute = this.attributes.uv;\r\n\r\n\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\r\n\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.uvsNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.lineDistancesNeedUpdate ) {\r\n\r\n\t\t\tattribute = this.attributes.lineDistance;\r\n\r\n\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\tattribute.copyArray( geometry.lineDistances );\r\n\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.lineDistancesNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.groupsNeedUpdate ) {\r\n\r\n\t\t\tgeometry.computeGroups( object.geometry );\r\n\t\t\tthis.groups = geometry.groups;\r\n\r\n\t\t\tgeometry.groupsNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tfromGeometry: function ( geometry ) {\r\n\r\n\t\tgeometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );\r\n\r\n\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\r\n\r\n\t},\r\n\r\n\tfromDirectGeometry: function ( geometry ) {\r\n\r\n\t\tvar positions = new Float32Array( geometry.vertices.length * 3 );\r\n\t\tthis.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\r\n\r\n\t\tif ( geometry.normals.length > 0 ) {\r\n\r\n\t\t\tvar normals = new Float32Array( geometry.normals.length * 3 );\r\n\t\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.colors.length > 0 ) {\r\n\r\n\t\t\tvar colors = new Float32Array( geometry.colors.length * 3 );\r\n\t\t\tthis.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.uvs.length > 0 ) {\r\n\r\n\t\t\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\r\n\t\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.uvs2.length > 0 ) {\r\n\r\n\t\t\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\r\n\t\t\tthis.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\r\n\r\n\t\t}\r\n\r\n\t\t// groups\r\n\r\n\t\tthis.groups = geometry.groups;\r\n\r\n\t\t// morphs\r\n\r\n\t\tfor ( var name in geometry.morphTargets ) {\r\n\r\n\t\t\tvar array = [];\r\n\t\t\tvar morphTargets = geometry.morphTargets[ name ];\r\n\r\n\t\t\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar morphTarget = morphTargets[ i ];\r\n\r\n\t\t\t\tvar attribute = new Float32BufferAttribute( morphTarget.data.length * 3, 3 );\r\n\t\t\t\tattribute.name = morphTarget.name;\r\n\r\n\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget.data ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.morphAttributes[ name ] = array;\r\n\r\n\t\t}\r\n\r\n\t\t// skinning\r\n\r\n\t\tif ( geometry.skinIndices.length > 0 ) {\r\n\r\n\t\t\tvar skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );\r\n\t\t\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.skinWeights.length > 0 ) {\r\n\r\n\t\t\tvar skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );\r\n\t\t\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( geometry.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.boundingBox !== null ) {\r\n\r\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcomputeBoundingBox: function () {\r\n\r\n\t\tif ( this.boundingBox === null ) {\r\n\r\n\t\t\tthis.boundingBox = new Box3();\r\n\r\n\t\t}\r\n\r\n\t\tvar position = this.attributes.position;\r\n\r\n\t\tif ( position !== undefined ) {\r\n\r\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.boundingBox.makeEmpty();\r\n\r\n\t\t}\r\n\r\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\r\n\r\n\t\t\tconsole.error( 'COOL.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeBoundingSphere: function () {\r\n\r\n\t\tvar box = new Box3();\r\n\t\tvar vector = new Vector3();\r\n\r\n\t\treturn function computeBoundingSphere() {\r\n\r\n\t\t\tif ( this.boundingSphere === null ) {\r\n\r\n\t\t\t\tthis.boundingSphere = new Sphere();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar position = this.attributes.position;\r\n\r\n\t\t\tif ( position ) {\r\n\r\n\t\t\t\tvar center = this.boundingSphere.center;\r\n\r\n\t\t\t\tbox.setFromBufferAttribute( position );\r\n\t\t\t\tbox.getCenter( center );\r\n\r\n\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\r\n\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\r\n\r\n\t\t\t\tvar maxRadiusSq = 0;\r\n\r\n\t\t\t\tfor ( var i = 0, il = position.count; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvector.x = position.getX( i );\r\n\t\t\t\t\tvector.y = position.getY( i );\r\n\t\t\t\t\tvector.z = position.getZ( i );\r\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\r\n\r\n\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\r\n\r\n\t\t\t\t\tconsole.error( 'COOL.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcomputeFaceNormals: function () {\r\n\r\n\t\t// backwards compatibility\r\n\r\n\t},\r\n\r\n\tcomputeVertexNormals: function () {\r\n\r\n\t\tvar index = this.index;\r\n\t\tvar attributes = this.attributes;\r\n\r\n\t\tif ( attributes.position ) {\r\n\r\n\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\tif ( attributes.normal === undefined ) {\r\n\r\n\t\t\t\tthis.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// reset existing normals to zero\r\n\r\n\t\t\t\tvar array = attributes.normal.array;\r\n\r\n\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tarray[ i ] = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar normals = attributes.normal.array;\r\n\r\n\t\t\tvar vA, vB, vC;\r\n\t\t\tvar pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\r\n\t\t\tvar cb = new Vector3(), ab = new Vector3();\r\n\r\n\t\t\t// indexed elements\r\n\r\n\t\t\tif ( index ) {\r\n\r\n\t\t\t\tvar indices = index.array;\r\n\r\n\t\t\t\tfor ( var i = 0, il = index.count; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\tvA = indices[ i + 0 ] * 3;\r\n\t\t\t\t\tvB = indices[ i + 1 ] * 3;\r\n\t\t\t\t\tvC = indices[ i + 2 ] * 3;\r\n\r\n\t\t\t\t\tpA.fromArray( positions, vA );\r\n\t\t\t\t\tpB.fromArray( positions, vB );\r\n\t\t\t\t\tpC.fromArray( positions, vC );\r\n\r\n\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\t\tnormals[ vA ] += cb.x;\r\n\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\r\n\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\r\n\r\n\t\t\t\t\tnormals[ vB ] += cb.x;\r\n\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\r\n\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\r\n\r\n\t\t\t\t\tnormals[ vC ] += cb.x;\r\n\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\r\n\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\r\n\r\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\r\n\r\n\t\t\t\t\tpA.fromArray( positions, i );\r\n\t\t\t\t\tpB.fromArray( positions, i + 3 );\r\n\t\t\t\t\tpC.fromArray( positions, i + 6 );\r\n\r\n\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\t\tnormals[ i ] = cb.x;\r\n\t\t\t\t\tnormals[ i + 1 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 2 ] = cb.z;\r\n\r\n\t\t\t\t\tnormals[ i + 3 ] = cb.x;\r\n\t\t\t\t\tnormals[ i + 4 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 5 ] = cb.z;\r\n\r\n\t\t\t\t\tnormals[ i + 6 ] = cb.x;\r\n\t\t\t\t\tnormals[ i + 7 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 8 ] = cb.z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.normalizeNormals();\r\n\r\n\t\t\tattributes.normal.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tmerge: function ( geometry, offset ) {\r\n\r\n\t\tif ( ! ( geometry && geometry.isBufferGeometry ) ) {\r\n\r\n\t\t\tconsole.error( 'COOL.BufferGeometry.merge(): geometry not an instance of COOL.BufferGeometry.', geometry );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( offset === undefined ) {\r\n\r\n\t\t\toffset = 0;\r\n\r\n\t\t\tconsole.warn(\r\n\t\t\t\t'COOL.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '\r\n\t\t\t\t+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\tvar attributes = this.attributes;\r\n\r\n\t\tfor ( var key in attributes ) {\r\n\r\n\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\r\n\r\n\t\t\tvar attribute1 = attributes[ key ];\r\n\t\t\tvar attributeArray1 = attribute1.array;\r\n\r\n\t\t\tvar attribute2 = geometry.attributes[ key ];\r\n\t\t\tvar attributeArray2 = attribute2.array;\r\n\r\n\t\t\tvar attributeSize = attribute2.itemSize;\r\n\r\n\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\r\n\r\n\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnormalizeNormals: function () {\r\n\r\n\t\tvar vector = new Vector3();\r\n\r\n\t\treturn function normalizeNormals() {\r\n\r\n\t\t\tvar normals = this.attributes.normal;\r\n\r\n\t\t\tfor ( var i = 0, il = normals.count; i < il; i ++ ) {\r\n\r\n\t\t\t\tvector.x = normals.getX( i );\r\n\t\t\t\tvector.y = normals.getY( i );\r\n\t\t\t\tvector.z = normals.getZ( i );\r\n\r\n\t\t\t\tvector.normalize();\r\n\r\n\t\t\t\tnormals.setXYZ( i, vector.x, vector.y, vector.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttoNonIndexed: function () {\r\n\r\n\t\tif ( this.index === null ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tvar geometry2 = new BufferGeometry();\r\n\r\n\t\tvar indices = this.index.array;\r\n\t\tvar attributes = this.attributes;\r\n\r\n\t\tfor ( var name in attributes ) {\r\n\r\n\t\t\tvar attribute = attributes[ name ];\r\n\r\n\t\t\tvar array = attribute.array;\r\n\t\t\tvar itemSize = attribute.itemSize;\r\n\r\n\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\r\n\r\n\t\t\tvar index = 0, index2 = 0;\r\n\r\n\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tindex = indices[ i ] * itemSize;\r\n\r\n\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\r\n\r\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar groups = this.groups;\r\n\r\n\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar group = groups[ i ];\r\n\t\t\tgeometry2.addGroup( group.start, group.count, group.materialIndex );\r\n\r\n\t\t}\r\n\r\n\t\treturn geometry2;\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar data = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.5,\r\n\t\t\t\ttype: 'BufferGeometry',\r\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// standard BufferGeometry serialization\r\n\r\n\t\tdata.uuid = this.uuid;\r\n\t\tdata.type = this.type;\r\n\t\tif ( this.name !== '' ) data.name = this.name;\r\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\r\n\r\n\t\tif ( this.parameters !== undefined ) {\r\n\r\n\t\t\tvar parameters = this.parameters;\r\n\r\n\t\t\tfor ( var key in parameters ) {\r\n\r\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tdata.data = { attributes: {} };\r\n\r\n\t\tvar index = this.index;\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\tvar array = Array.prototype.slice.call( index.array );\r\n\r\n\t\t\tdata.data.index = {\r\n\t\t\t\ttype: index.array.constructor.name,\r\n\t\t\t\tarray: array\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tvar attributes = this.attributes;\r\n\r\n\t\tfor ( var key in attributes ) {\r\n\r\n\t\t\tvar attribute = attributes[ key ];\r\n\r\n\t\t\tvar array = Array.prototype.slice.call( attribute.array );\r\n\r\n\t\t\tdata.data.attributes[ key ] = {\r\n\t\t\t\titemSize: attribute.itemSize,\r\n\t\t\t\ttype: attribute.array.constructor.name,\r\n\t\t\t\tarray: array,\r\n\t\t\t\tnormalized: attribute.normalized\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tvar groups = this.groups;\r\n\r\n\t\tif ( groups.length > 0 ) {\r\n\r\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar boundingSphere = this.boundingSphere;\r\n\r\n\t\tif ( boundingSphere !== null ) {\r\n\r\n\t\t\tdata.data.boundingSphere = {\r\n\t\t\t\tcenter: boundingSphere.center.toArray(),\r\n\t\t\t\tradius: boundingSphere.radius\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\t/*\r\n\t\t // Handle primitives\r\n\r\n\t\t var parameters = this.parameters;\r\n\r\n\t\t if ( parameters !== undefined ) {\r\n\r\n\t\t var values = [];\r\n\r\n\t\t for ( var key in parameters ) {\r\n\r\n\t\t values.push( parameters[ key ] );\r\n\r\n\t\t }\r\n\r\n\t\t var geometry = Object.create( this.constructor.prototype );\r\n\t\t this.constructor.apply( geometry, values );\r\n\t\t return geometry;\r\n\r\n\t\t }\r\n\r\n\t\t return new this.constructor().copy( this );\r\n\t\t */\r\n\r\n\t\treturn new BufferGeometry().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tvar name, i, l;\r\n\r\n\t\t// reset\r\n\r\n\t\tthis.index = null;\r\n\t\tthis.attributes = {};\r\n\t\tthis.morphAttributes = {};\r\n\t\tthis.groups = [];\r\n\t\tthis.boundingBox = null;\r\n\t\tthis.boundingSphere = null;\r\n\r\n\t\t// name\r\n\r\n\t\tthis.name = source.name;\r\n\r\n\t\t// index\r\n\r\n\t\tvar index = source.index;\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\tthis.setIndex( index.clone() );\r\n\r\n\t\t}\r\n\r\n\t\t// attributes\r\n\r\n\t\tvar attributes = source.attributes;\r\n\r\n\t\tfor ( name in attributes ) {\r\n\r\n\t\t\tvar attribute = attributes[ name ];\r\n\t\t\tthis.addAttribute( name, attribute.clone() );\r\n\r\n\t\t}\r\n\r\n\t\t// morph attributes\r\n\r\n\t\tvar morphAttributes = source.morphAttributes;\r\n\r\n\t\tfor ( name in morphAttributes ) {\r\n\r\n\t\t\tvar array = [];\r\n\t\t\tvar morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\r\n\r\n\t\t\tfor ( i = 0, l = morphAttribute.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tarray.push( morphAttribute[ i ].clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.morphAttributes[ name ] = array;\r\n\r\n\t\t}\r\n\r\n\t\t// groups\r\n\r\n\t\tvar groups = source.groups;\r\n\r\n\t\tfor ( i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar group = groups[ i ];\r\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\r\n\r\n\t\t}\r\n\r\n\t\t// bounding box\r\n\r\n\t\tvar boundingBox = source.boundingBox;\r\n\r\n\t\tif ( boundingBox !== null ) {\r\n\r\n\t\t\tthis.boundingBox = boundingBox.clone();\r\n\r\n\t\t}\r\n\r\n\t\t// bounding sphere\r\n\r\n\t\tvar boundingSphere = source.boundingSphere;\r\n\r\n\t\tif ( boundingSphere !== null ) {\r\n\r\n\t\t\tthis.boundingSphere = boundingSphere.clone();\r\n\r\n\t\t}\r\n\r\n\t\t// draw range\r\n\r\n\t\tthis.drawRange.start = source.drawRange.start;\r\n\t\tthis.drawRange.count = source.drawRange.count;\r\n\r\n\t\t// user data\r\n\r\n\t\tthis.userData = source.userData;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/Earcut.js\n/**\r\n * @author Mugen87 / https://github.com/Mugen87\r\n * Port from https://github.com/mapbox/earcut (v2.1.2)\r\n */\r\n\r\nvar Earcut = {\r\n\r\n\ttriangulate: function ( data, holeIndices, dim ) {\r\n\r\n\t\tdim = dim || 2;\r\n\r\n\t\tvar hasHoles = holeIndices && holeIndices.length,\r\n\t\t\touterLen = hasHoles ? holeIndices[ 0 ] * dim : data.length,\r\n\t\t\touterNode = linkedList( data, 0, outerLen, dim, true ),\r\n\t\t\ttriangles = [];\r\n\r\n\t\tif ( ! outerNode ) return triangles;\r\n\r\n\t\tvar minX, minY, maxX, maxY, x, y, invSize;\r\n\r\n\t\tif ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );\r\n\r\n\t\t// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\r\n\r\n\t\tif ( data.length > 80 * dim ) {\r\n\r\n\t\t\tminX = maxX = data[ 0 ];\r\n\t\t\tminY = maxY = data[ 1 ];\r\n\r\n\t\t\tfor ( var i = dim; i < outerLen; i += dim ) {\r\n\r\n\t\t\t\tx = data[ i ];\r\n\t\t\t\ty = data[ i + 1 ];\r\n\t\t\t\tif ( x < minX ) minX = x;\r\n\t\t\t\tif ( y < minY ) minY = y;\r\n\t\t\t\tif ( x > maxX ) maxX = x;\r\n\t\t\t\tif ( y > maxY ) maxY = y;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// minX, minY and invSize are later used to transform coords into integers for z-order calculation\r\n\r\n\t\t\tinvSize = Math.max( maxX - minX, maxY - minY );\r\n\t\t\tinvSize = invSize !== 0 ? 1 / invSize : 0;\r\n\r\n\t\t}\r\n\r\n\t\tearcutLinked( outerNode, triangles, dim, minX, minY, invSize );\r\n\r\n\t\treturn triangles;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// create a circular doubly linked list from polygon points in the specified winding order\r\n\r\nfunction linkedList( data, start, end, dim, clockwise ) {\r\n\r\n\tvar i, last;\r\n\r\n\tif ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {\r\n\r\n\t\tfor ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\r\n\r\n\t} else {\r\n\r\n\t\tfor ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\r\n\r\n\t}\r\n\r\n\tif ( last && equals( last, last.next ) ) {\r\n\r\n\t\tremoveNode( last );\r\n\t\tlast = last.next;\r\n\r\n\t}\r\n\r\n\treturn last;\r\n\r\n}\r\n\r\n// eliminate colinear or duplicate points\r\n\r\nfunction filterPoints( start, end ) {\r\n\r\n\tif ( ! start ) return start;\r\n\tif ( ! end ) end = start;\r\n\r\n\tvar p = start, again;\r\n\r\n\tdo {\r\n\r\n\t\tagain = false;\r\n\r\n\t\tif ( ! p.steiner && ( equals( p, p.next ) || Earcut_area( p.prev, p, p.next ) === 0 ) ) {\r\n\r\n\t\t\tremoveNode( p );\r\n\t\t\tp = end = p.prev;\r\n\t\t\tif ( p === p.next ) break;\r\n\t\t\tagain = true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tp = p.next;\r\n\r\n\t\t}\r\n\r\n\t} while ( again || p !== end );\r\n\r\n\treturn end;\r\n\r\n}\r\n\r\n// main ear slicing loop which triangulates a polygon (given as a linked list)\r\n\r\nfunction earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {\r\n\r\n\tif ( ! ear ) return;\r\n\r\n\t// interlink polygon nodes in z-order\r\n\r\n\tif ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );\r\n\r\n\tvar stop = ear, prev, next;\r\n\r\n\t// iterate through ears, slicing them one by one\r\n\r\n\twhile ( ear.prev !== ear.next ) {\r\n\r\n\t\tprev = ear.prev;\r\n\t\tnext = ear.next;\r\n\r\n\t\tif ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {\r\n\r\n\t\t\t// cut off the triangle\r\n\t\t\ttriangles.push( prev.i / dim );\r\n\t\t\ttriangles.push( ear.i / dim );\r\n\t\t\ttriangles.push( next.i / dim );\r\n\r\n\t\t\tremoveNode( ear );\r\n\r\n\t\t\t// skipping the next vertice leads to less sliver triangles\r\n\t\t\tear = next.next;\r\n\t\t\tstop = next.next;\r\n\r\n\t\t\tcontinue;\r\n\r\n\t\t}\r\n\r\n\t\tear = next;\r\n\r\n\t\t// if we looped through the whole remaining polygon and can't find any more ears\r\n\r\n\t\tif ( ear === stop ) {\r\n\r\n\t\t\t// try filtering points and slicing again\r\n\r\n\t\t\tif ( ! pass ) {\r\n\r\n\t\t\t\tearcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );\r\n\r\n\t\t\t\t// if this didn't work, try curing all small self-intersections locally\r\n\r\n\t\t\t} else if ( pass === 1 ) {\r\n\r\n\t\t\t\tear = cureLocalIntersections( ear, triangles, dim );\r\n\t\t\t\tearcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );\r\n\r\n\t\t\t\t// as a last resort, try splitting the remaining polygon into two\r\n\r\n\t\t\t} else if ( pass === 2 ) {\r\n\r\n\t\t\t\tsplitEarcut( ear, triangles, dim, minX, minY, invSize );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n// check whether a polygon node forms a valid ear with adjacent nodes\r\n\r\nfunction isEar( ear ) {\r\n\r\n\tvar a = ear.prev,\r\n\t\tb = ear,\r\n\t\tc = ear.next;\r\n\r\n\tif ( Earcut_area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\r\n\r\n\t// now make sure we don't have other points inside the potential ear\r\n\tvar p = ear.next.next;\r\n\r\n\twhile ( p !== ear.prev ) {\r\n\r\n\t\tif ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) && Earcut_area( p.prev, p, p.next ) >= 0 ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\tp = p.next;\r\n\r\n\t}\r\n\r\n\treturn true;\r\n\r\n}\r\n\r\nfunction isEarHashed( ear, minX, minY, invSize ) {\r\n\r\n\tvar a = ear.prev,\r\n\t\tb = ear,\r\n\t\tc = ear.next;\r\n\r\n\tif ( Earcut_area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\r\n\r\n\t// triangle bbox; min & max are calculated like this for speed\r\n\r\n\tvar minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),\r\n\t\tminTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),\r\n\t\tmaxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),\r\n\t\tmaxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );\r\n\r\n\t// z-order range for the current triangle bbox;\r\n\r\n\tvar minZ = zOrder( minTX, minTY, minX, minY, invSize ),\r\n\t\tmaxZ = zOrder( maxTX, maxTY, minX, minY, invSize );\r\n\r\n\t// first look for points inside the triangle in increasing z-order\r\n\r\n\tvar p = ear.nextZ;\r\n\r\n\twhile ( p && p.z <= maxZ ) {\r\n\r\n\t\tif ( p !== ear.prev && p !== ear.next &&\r\n\t\t\t\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\r\n\t\t\t\tEarcut_area( p.prev, p, p.next ) >= 0 ) return false;\r\n\t\tp = p.nextZ;\r\n\r\n\t}\r\n\r\n\t// then look for points in decreasing z-order\r\n\r\n\tp = ear.prevZ;\r\n\r\n\twhile ( p && p.z >= minZ ) {\r\n\r\n\t\tif ( p !== ear.prev && p !== ear.next &&\r\n\t\t\t\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\r\n\t\t\t\tEarcut_area( p.prev, p, p.next ) >= 0 ) return false;\r\n\r\n\t\tp = p.prevZ;\r\n\r\n\t}\r\n\r\n\treturn true;\r\n\r\n}\r\n\r\n// go through all polygon nodes and cure small local self-intersections\r\n\r\nfunction cureLocalIntersections( start, triangles, dim ) {\r\n\r\n\tvar p = start;\r\n\r\n\tdo {\r\n\r\n\t\tvar a = p.prev, b = p.next.next;\r\n\r\n\t\tif ( ! equals( a, b ) && Earcut_intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {\r\n\r\n\t\t\ttriangles.push( a.i / dim );\r\n\t\t\ttriangles.push( p.i / dim );\r\n\t\t\ttriangles.push( b.i / dim );\r\n\r\n\t\t\t// remove two nodes involved\r\n\r\n\t\t\tremoveNode( p );\r\n\t\t\tremoveNode( p.next );\r\n\r\n\t\t\tp = start = b;\r\n\r\n\t\t}\r\n\r\n\t\tp = p.next;\r\n\r\n\t} while ( p !== start );\r\n\r\n\treturn p;\r\n\r\n}\r\n\r\n// try splitting polygon into two and triangulate them independently\r\n\r\nfunction splitEarcut( start, triangles, dim, minX, minY, invSize ) {\r\n\r\n\t// look for a valid diagonal that divides the polygon into two\r\n\r\n\tvar a = start;\r\n\r\n\tdo {\r\n\r\n\t\tvar b = a.next.next;\r\n\r\n\t\twhile ( b !== a.prev ) {\r\n\r\n\t\t\tif ( a.i !== b.i && isValidDiagonal( a, b ) ) {\r\n\r\n\t\t\t\t// split the polygon in two by the diagonal\r\n\r\n\t\t\t\tvar c = splitPolygon( a, b );\r\n\r\n\t\t\t\t// filter colinear points around the cuts\r\n\r\n\t\t\t\ta = filterPoints( a, a.next );\r\n\t\t\t\tc = filterPoints( c, c.next );\r\n\r\n\t\t\t\t// run earcut on each half\r\n\r\n\t\t\t\tearcutLinked( a, triangles, dim, minX, minY, invSize );\r\n\t\t\t\tearcutLinked( c, triangles, dim, minX, minY, invSize );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tb = b.next;\r\n\r\n\t\t}\r\n\r\n\t\ta = a.next;\r\n\r\n\t} while ( a !== start );\r\n\r\n}\r\n\r\n// link every hole into the outer loop, producing a single-ring polygon without holes\r\n\r\nfunction eliminateHoles( data, holeIndices, outerNode, dim ) {\r\n\r\n\tvar queue = [], i, len, start, end, list;\r\n\r\n\tfor ( i = 0, len = holeIndices.length; i < len; i ++ ) {\r\n\r\n\t\tstart = holeIndices[ i ] * dim;\r\n\t\tend = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;\r\n\t\tlist = linkedList( data, start, end, dim, false );\r\n\t\tif ( list === list.next ) list.steiner = true;\r\n\t\tqueue.push( getLeftmost( list ) );\r\n\r\n\t}\r\n\r\n\tqueue.sort( compareX );\r\n\r\n\t// process holes from left to right\r\n\r\n\tfor ( i = 0; i < queue.length; i ++ ) {\r\n\r\n\t\teliminateHole( queue[ i ], outerNode );\r\n\t\touterNode = filterPoints( outerNode, outerNode.next );\r\n\r\n\t}\r\n\r\n\treturn outerNode;\r\n\r\n}\r\n\r\nfunction compareX( a, b ) {\r\n\r\n\treturn a.x - b.x;\r\n\r\n}\r\n\r\n// find a bridge between vertices that connects hole with an outer ring and and link it\r\n\r\nfunction eliminateHole( hole, outerNode ) {\r\n\r\n\touterNode = findHoleBridge( hole, outerNode );\r\n\r\n\tif ( outerNode ) {\r\n\r\n\t\tvar b = splitPolygon( outerNode, hole );\r\n\r\n\t\tfilterPoints( b, b.next );\r\n\r\n\t}\r\n\r\n}\r\n\r\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\r\n\r\nfunction findHoleBridge( hole, outerNode ) {\r\n\r\n\tvar p = outerNode,\r\n\t\thx = hole.x,\r\n\t\thy = hole.y,\r\n\t\tqx = - Infinity,\r\n\t\tm;\r\n\r\n\t// find a segment intersected by a ray from the hole's leftmost point to the left;\r\n\t// segment's endpoint with lesser x will be potential connection point\r\n\r\n\tdo {\r\n\r\n\t\tif ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {\r\n\r\n\t\t\tvar x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );\r\n\r\n\t\t\tif ( x <= hx && x > qx ) {\r\n\r\n\t\t\t\tqx = x;\r\n\r\n\t\t\t\tif ( x === hx ) {\r\n\r\n\t\t\t\t\tif ( hy === p.y ) return p;\r\n\t\t\t\t\tif ( hy === p.next.y ) return p.next;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tm = p.x < p.next.x ? p : p.next;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tp = p.next;\r\n\r\n\t} while ( p !== outerNode );\r\n\r\n\tif ( ! m ) return null;\r\n\r\n\tif ( hx === qx ) return m.prev; // hole touches outer segment; pick lower endpoint\r\n\r\n\t// look for points inside the triangle of hole point, segment intersection and endpoint;\r\n\t// if there are no points found, we have a valid connection;\r\n\t// otherwise choose the point of the minimum angle with the ray as connection point\r\n\r\n\tvar stop = m,\r\n\t\tmx = m.x,\r\n\t\tmy = m.y,\r\n\t\ttanMin = Infinity,\r\n\t\ttan;\r\n\r\n\tp = m.next;\r\n\r\n\twhile ( p !== stop ) {\r\n\r\n\t\tif ( hx >= p.x && p.x >= mx && hx !== p.x &&\r\n\t\t\t\t\t\tpointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {\r\n\r\n\t\t\ttan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential\r\n\r\n\t\t\tif ( ( tan < tanMin || ( tan === tanMin && p.x > m.x ) ) && locallyInside( p, hole ) ) {\r\n\r\n\t\t\t\tm = p;\r\n\t\t\t\ttanMin = tan;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tp = p.next;\r\n\r\n\t}\r\n\r\n\treturn m;\r\n\r\n}\r\n\r\n// interlink polygon nodes in z-order\r\n\r\nfunction indexCurve( start, minX, minY, invSize ) {\r\n\r\n\tvar p = start;\r\n\r\n\tdo {\r\n\r\n\t\tif ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );\r\n\t\tp.prevZ = p.prev;\r\n\t\tp.nextZ = p.next;\r\n\t\tp = p.next;\r\n\r\n\t} while ( p !== start );\r\n\r\n\tp.prevZ.nextZ = null;\r\n\tp.prevZ = null;\r\n\r\n\tsortLinked( p );\r\n\r\n}\r\n\r\n// Simon Tatham's linked list merge sort algorithm\r\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\r\n\r\nfunction sortLinked( list ) {\r\n\r\n\tvar i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;\r\n\r\n\tdo {\r\n\r\n\t\tp = list;\r\n\t\tlist = null;\r\n\t\ttail = null;\r\n\t\tnumMerges = 0;\r\n\r\n\t\twhile ( p ) {\r\n\r\n\t\t\tnumMerges ++;\r\n\t\t\tq = p;\r\n\t\t\tpSize = 0;\r\n\r\n\t\t\tfor ( i = 0; i < inSize; i ++ ) {\r\n\r\n\t\t\t\tpSize ++;\r\n\t\t\t\tq = q.nextZ;\r\n\t\t\t\tif ( ! q ) break;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tqSize = inSize;\r\n\r\n\t\t\twhile ( pSize > 0 || ( qSize > 0 && q ) ) {\r\n\r\n\t\t\t\tif ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {\r\n\r\n\t\t\t\t\te = p;\r\n\t\t\t\t\tp = p.nextZ;\r\n\t\t\t\t\tpSize --;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\te = q;\r\n\t\t\t\t\tq = q.nextZ;\r\n\t\t\t\t\tqSize --;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( tail ) tail.nextZ = e;\r\n\t\t\t\telse list = e;\r\n\r\n\t\t\t\te.prevZ = tail;\r\n\t\t\t\ttail = e;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tp = q;\r\n\r\n\t\t}\r\n\r\n\t\ttail.nextZ = null;\r\n\t\tinSize *= 2;\r\n\r\n\t} while ( numMerges > 1 );\r\n\r\n\treturn list;\r\n\r\n}\r\n\r\n// z-order of a point given coords and inverse of the longer side of data bbox\r\n\r\nfunction zOrder( x, y, minX, minY, invSize ) {\r\n\r\n\t// coords are transformed into non-negative 15-bit integer range\r\n\r\n\tx = 32767 * ( x - minX ) * invSize;\r\n\ty = 32767 * ( y - minY ) * invSize;\r\n\r\n\tx = ( x | ( x << 8 ) ) & 0x00FF00FF;\r\n\tx = ( x | ( x << 4 ) ) & 0x0F0F0F0F;\r\n\tx = ( x | ( x << 2 ) ) & 0x33333333;\r\n\tx = ( x | ( x << 1 ) ) & 0x55555555;\r\n\r\n\ty = ( y | ( y << 8 ) ) & 0x00FF00FF;\r\n\ty = ( y | ( y << 4 ) ) & 0x0F0F0F0F;\r\n\ty = ( y | ( y << 2 ) ) & 0x33333333;\r\n\ty = ( y | ( y << 1 ) ) & 0x55555555;\r\n\r\n\treturn x | ( y << 1 );\r\n\r\n}\r\n\r\n// find the leftmost node of a polygon ring\r\n\r\nfunction getLeftmost( start ) {\r\n\r\n\tvar p = start, leftmost = start;\r\n\r\n\tdo {\r\n\r\n\t\tif ( p.x < leftmost.x ) leftmost = p;\r\n\t\tp = p.next;\r\n\r\n\t} while ( p !== start );\r\n\r\n\treturn leftmost;\r\n\r\n}\r\n\r\n// check if a point lies within a convex triangle\r\n\r\nfunction pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {\r\n\r\n\treturn ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&\r\n\t ( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&\r\n\t ( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;\r\n\r\n}\r\n\r\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\r\n\r\nfunction isValidDiagonal( a, b ) {\r\n\r\n\treturn a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) &&\r\n\t\tlocallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b );\r\n\r\n}\r\n\r\n// signed area of a triangle\r\n\r\nfunction Earcut_area( p, q, r ) {\r\n\r\n\treturn ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );\r\n\r\n}\r\n\r\n// check if two points are equal\r\n\r\nfunction equals( p1, p2 ) {\r\n\r\n\treturn p1.x === p2.x && p1.y === p2.y;\r\n\r\n}\r\n\r\n// check if two segments intersect\r\n\r\nfunction Earcut_intersects( p1, q1, p2, q2 ) {\r\n\r\n\tif ( ( equals( p1, q1 ) && equals( p2, q2 ) ) ||\r\n\t\t\t( equals( p1, q2 ) && equals( p2, q1 ) ) ) return true;\r\n\r\n\treturn Earcut_area( p1, q1, p2 ) > 0 !== Earcut_area( p1, q1, q2 ) > 0 &&\r\n\t\t\t\t Earcut_area( p2, q2, p1 ) > 0 !== Earcut_area( p2, q2, q1 ) > 0;\r\n\r\n}\r\n\r\n// check if a polygon diagonal intersects any polygon segments\r\n\r\nfunction intersectsPolygon( a, b ) {\r\n\r\n\tvar p = a;\r\n\r\n\tdo {\r\n\r\n\t\tif ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\r\n\t\t\t\t\t\tEarcut_intersects( p, p.next, a, b ) ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\tp = p.next;\r\n\r\n\t} while ( p !== a );\r\n\r\n\treturn false;\r\n\r\n}\r\n\r\n// check if a polygon diagonal is locally inside the polygon\r\n\r\nfunction locallyInside( a, b ) {\r\n\r\n\treturn Earcut_area( a.prev, a, a.next ) < 0 ?\r\n\t\tEarcut_area( a, b, a.next ) >= 0 && Earcut_area( a, a.prev, b ) >= 0 :\r\n\t\tEarcut_area( a, b, a.prev ) < 0 || Earcut_area( a, a.next, b ) < 0;\r\n\r\n}\r\n\r\n// check if the middle point of a polygon diagonal is inside the polygon\r\n\r\nfunction middleInside( a, b ) {\r\n\r\n\tvar p = a,\r\n\t\tinside = false,\r\n\t\tpx = ( a.x + b.x ) / 2,\r\n\t\tpy = ( a.y + b.y ) / 2;\r\n\r\n\tdo {\r\n\r\n\t\tif ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&\r\n\t\t\t\t\t\t( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) ) {\r\n\r\n\t\t\tinside = ! inside;\r\n\r\n\t\t}\r\n\r\n\t\tp = p.next;\r\n\r\n\t} while ( p !== a );\r\n\r\n\treturn inside;\r\n\r\n}\r\n\r\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\r\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\r\n\r\nfunction splitPolygon( a, b ) {\r\n\r\n\tvar a2 = new Node( a.i, a.x, a.y ),\r\n\t\tb2 = new Node( b.i, b.x, b.y ),\r\n\t\tan = a.next,\r\n\t\tbp = b.prev;\r\n\r\n\ta.next = b;\r\n\tb.prev = a;\r\n\r\n\ta2.next = an;\r\n\tan.prev = a2;\r\n\r\n\tb2.next = a2;\r\n\ta2.prev = b2;\r\n\r\n\tbp.next = b2;\r\n\tb2.prev = bp;\r\n\r\n\treturn b2;\r\n\r\n}\r\n\r\n// create a node and optionally link it with previous one (in a circular doubly linked list)\r\n\r\nfunction insertNode( i, x, y, last ) {\r\n\r\n\tvar p = new Node( i, x, y );\r\n\r\n\tif ( ! last ) {\r\n\r\n\t\tp.prev = p;\r\n\t\tp.next = p;\r\n\r\n\t} else {\r\n\r\n\t\tp.next = last.next;\r\n\t\tp.prev = last;\r\n\t\tlast.next.prev = p;\r\n\t\tlast.next = p;\r\n\r\n\t}\r\n\r\n\treturn p;\r\n\r\n}\r\n\r\nfunction removeNode( p ) {\r\n\r\n\tp.next.prev = p.prev;\r\n\tp.prev.next = p.next;\r\n\r\n\tif ( p.prevZ ) p.prevZ.nextZ = p.nextZ;\r\n\tif ( p.nextZ ) p.nextZ.prevZ = p.prevZ;\r\n\r\n}\r\n\r\nfunction Node( i, x, y ) {\r\n\r\n\t// vertice index in coordinates array\r\n\tthis.i = i;\r\n\r\n\t// vertex coordinates\r\n\tthis.x = x;\r\n\tthis.y = y;\r\n\r\n\t// previous and next vertice nodes in a polygon ring\r\n\tthis.prev = null;\r\n\tthis.next = null;\r\n\r\n\t// z-order curve value\r\n\tthis.z = null;\r\n\r\n\t// previous and next nodes in z-order\r\n\tthis.prevZ = null;\r\n\tthis.nextZ = null;\r\n\r\n\t// indicates whether this is a steiner point\r\n\tthis.steiner = false;\r\n\r\n}\r\n\r\nfunction signedArea( data, start, end, dim ) {\r\n\r\n\tvar sum = 0;\r\n\r\n\tfor ( var i = start, j = end - dim; i < end; i += dim ) {\r\n\r\n\t\tsum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );\r\n\t\tj = i;\r\n\r\n\t}\r\n\r\n\treturn sum;\r\n\r\n}\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/ShapeUtils.js\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\n\r\n\r\nvar ShapeUtils = {\r\n\r\n\t// calculate area of the contour polygon\r\n\r\n\tarea: function ( contour ) {\r\n\r\n\t\tvar n = contour.length;\r\n\t\tvar a = 0.0;\r\n\r\n\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\r\n\r\n\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\r\n\r\n\t\t}\r\n\r\n\t\treturn a * 0.5;\r\n\r\n\t},\r\n\r\n\tisClockWise: function ( pts ) {\r\n\r\n\t\treturn ShapeUtils.area( pts ) < 0;\r\n\r\n\t},\r\n\r\n\ttriangulateShape: function ( contour, holes ) {\r\n\r\n\t\tvar vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]\r\n\t\tvar holeIndices = []; // array of hole indices\r\n\t\tvar faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]\r\n\r\n\t\tremoveDupEndPts( contour );\r\n\t\taddContour( vertices, contour );\r\n\r\n\t\t//\r\n\r\n\t\tvar holeIndex = contour.length;\r\n\r\n\t\tholes.forEach( removeDupEndPts );\r\n\r\n\t\tfor ( var i = 0; i < holes.length; i ++ ) {\r\n\r\n\t\t\tholeIndices.push( holeIndex );\r\n\t\t\tholeIndex += holes[ i ].length;\r\n\t\t\taddContour( vertices, holes[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tvar triangles = Earcut.triangulate( vertices, holeIndices );\r\n\r\n\t\t//\r\n\r\n\t\tfor ( var i = 0; i < triangles.length; i += 3 ) {\r\n\r\n\t\t\tfaces.push( triangles.slice( i, i + 3 ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn faces;\r\n\r\n\t}\r\n\r\n};\r\n\r\nfunction removeDupEndPts( points ) {\r\n\r\n\tvar l = points.length;\r\n\r\n\tif ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {\r\n\r\n\t\tpoints.pop();\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction addContour( vertices, contour ) {\r\n\r\n\tfor ( var i = 0; i < contour.length; i ++ ) {\r\n\r\n\t\tvertices.push( contour[ i ].x );\r\n\t\tvertices.push( contour[ i ].y );\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/loader/ExtrudeGeometry.js\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n * Creates extruded geometry from a path shape.\r\n *\r\n * parameters = {\r\n *\r\n *  curveSegments: <int>, // number of points on the curves\r\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\r\n *  depth: <float>, // Depth to extrude the shape\r\n *\r\n *  bevelEnabled: <bool>, // turn on bevel\r\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\r\n *  bevelSize: <float>, // how far from shape outline is bevel\r\n *  bevelSegments: <int>, // number of bevel layers\r\n *\r\n *  extrudePath: <COOL.Curve> // curve to extrude shape along\r\n *\r\n *  UVGenerator: <Object> // object that provides UV generator functions\r\n *\r\n * }\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// ExtrudeGeometry\r\n\r\nfunction ExtrudeGeometry( shapes, options ) {\r\n\r\n\tloader_Geometry_Geometry.call( this );\r\n\r\n\tthis.type = 'ExtrudeGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tshapes: shapes,\r\n\t\toptions: options\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );\r\n\tthis.mergeVertices();\r\n\r\n}\r\n\r\nExtrudeGeometry.prototype = Object.create( loader_Geometry_Geometry.prototype );\r\nExtrudeGeometry.prototype.constructor = ExtrudeGeometry;\r\n\r\nExtrudeGeometry.prototype.toJSON = function () {\r\n\r\n\tvar data = loader_Geometry_Geometry.prototype.toJSON.call( this );\r\n\r\n\tvar shapes = this.parameters.shapes;\r\n\tvar options = this.parameters.options;\r\n\r\n\treturn toJSON( shapes, options, data );\r\n\r\n};\r\n\r\n// ExtrudeBufferGeometry\r\n\r\nfunction ExtrudeBufferGeometry( shapes, options ) {\r\n\r\n\tBufferGeometry.call( this );\r\n\r\n\tthis.type = 'ExtrudeBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tshapes: shapes,\r\n\t\toptions: options\r\n\t};\r\n\r\n\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\r\n\r\n\tvar scope = this;\r\n\r\n\tvar verticesArray = [];\r\n\tvar uvArray = [];\r\n\r\n\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\r\n\r\n\t\tvar shape = shapes[ i ];\r\n\t\taddShape( shape );\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\r\n\tthis.addAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );\r\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );\r\n\r\n\tthis.computeVertexNormals();\r\n\r\n\t// functions\r\n\r\n\tfunction addShape( shape ) {\r\n\r\n\t\tvar placeholder = [];\r\n\r\n\t\t// options\r\n\r\n\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\t\tvar steps = options.steps !== undefined ? options.steps : 1;\r\n\t\tvar depth = options.depth !== undefined ? options.depth : 100;\r\n\r\n\t\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\r\n\t\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;\r\n\t\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;\r\n\t\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\r\n\r\n\t\tvar extrudePath = options.extrudePath;\r\n\r\n\t\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;\r\n\r\n\t\t// deprecated options\r\n\r\n\t\tif ( options.amount !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.ExtrudeBufferGeometry: amount has been renamed to depth.' );\r\n\t\t\tdepth = options.amount;\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tvar extrudePts, extrudeByPath = false;\r\n\t\tvar splineTube, binormal, normal, position2;\r\n\r\n\t\tif ( extrudePath ) {\r\n\r\n\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\r\n\r\n\t\t\textrudeByPath = true;\r\n\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\r\n\r\n\t\t\t// SETUP TNB variables\r\n\r\n\t\t\t// TODO1 - have a .isClosed in spline?\r\n\r\n\t\t\tsplineTube = extrudePath.computeFrenetFrames( steps, false );\r\n\r\n\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\r\n\r\n\t\t\tbinormal = new Vector3();\r\n\t\t\tnormal = new Vector3();\r\n\t\t\tposition2 = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\t// Safeguards if bevels are not enabled\r\n\r\n\t\tif ( ! bevelEnabled ) {\r\n\r\n\t\t\tbevelSegments = 0;\r\n\t\t\tbevelThickness = 0;\r\n\t\t\tbevelSize = 0;\r\n\r\n\t\t}\r\n\r\n\t\t// Variables initialization\r\n\r\n\t\tvar ahole, h, hl; // looping of holes\r\n\r\n\t\tvar shapePoints = shape.extractPoints( curveSegments );\r\n\r\n\t\tvar vertices = shapePoints.shape;\r\n\t\tvar holes = shapePoints.holes;\r\n\r\n\t\tvar reverse = ! ShapeUtils.isClockWise( vertices );\r\n\r\n\t\tif ( reverse ) {\r\n\r\n\t\t\tvertices = vertices.reverse();\r\n\r\n\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\r\n\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\t\tahole = holes[ h ];\r\n\r\n\t\t\t\tif ( ShapeUtils.isClockWise( ahole ) ) {\r\n\r\n\t\t\t\t\tholes[ h ] = ahole.reverse();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\tvar faces = ShapeUtils.triangulateShape( vertices, holes );\r\n\r\n\t\t/* Vertices */\r\n\r\n\t\tvar contour = vertices; // vertices has all points but contour has only points of circumference\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\r\n\t\t\tvertices = vertices.concat( ahole );\r\n\r\n\t\t}\r\n\r\n\r\n\t\tfunction scalePt2( pt, vec, size ) {\r\n\r\n\t\t\tif ( ! vec ) console.error( \"COOL.ExtrudeGeometry: vec does not exist\" );\r\n\r\n\t\t\treturn vec.clone().multiplyScalar( size ).add( pt );\r\n\r\n\t\t}\r\n\r\n\t\tvar b, bs, t, z,\r\n\t\t\tvert, vlen = vertices.length,\r\n\t\t\tface, flen = faces.length;\r\n\r\n\r\n\t\t// Find directions for point movement\r\n\r\n\r\n\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\r\n\r\n\t\t\t// computes for inPt the corresponding point inPt' on a new contour\r\n\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\r\n\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\r\n\t\t\t//\r\n\t\t\t// inPt' is the intersection of the two lines parallel to the two\r\n\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\r\n\r\n\t\t\tvar v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\r\n\r\n\t\t\t// good reading for geometry algorithms (here: line-line intersection)\r\n\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\r\n\r\n\t\t\tvar v_prev_x = inPt.x - inPrev.x,\r\n\t\t\t\tv_prev_y = inPt.y - inPrev.y;\r\n\t\t\tvar v_next_x = inNext.x - inPt.x,\r\n\t\t\t\tv_next_y = inNext.y - inPt.y;\r\n\r\n\t\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\r\n\r\n\t\t\t// check for collinear edges\r\n\t\t\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\r\n\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\r\n\r\n\t\t\t\t// not collinear\r\n\r\n\t\t\t\t// length of vectors for normalizing\r\n\r\n\t\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\r\n\t\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\r\n\r\n\t\t\t\t// shift adjacent points by unit vectors to the left\r\n\r\n\t\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\r\n\t\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\r\n\r\n\t\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\r\n\t\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\r\n\r\n\t\t\t\t// scaling factor for v_prev to intersection point\r\n\r\n\t\t\t\tvar sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\r\n\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /\r\n\t\t\t\t\t( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\r\n\t\t\t\t// vector from inPt to intersection point\r\n\r\n\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\r\n\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\r\n\r\n\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\r\n\t\t\t\t//  but prevent crazy spikes\r\n\t\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\r\n\t\t\t\tif ( v_trans_lensq <= 2 ) {\r\n\r\n\t\t\t\t\treturn new Vector2( v_trans_x, v_trans_y );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// handle special case of collinear edges\r\n\r\n\t\t\t\tvar direction_eq = false; // assumes: opposite\r\n\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\r\n\r\n\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\r\n\r\n\t\t\t\t\t\tdirection_eq = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\r\n\r\n\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\r\n\r\n\t\t\t\t\t\t\tdirection_eq = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\r\n\r\n\t\t\t\t\t\t\tdirection_eq = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( direction_eq ) {\r\n\r\n\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\r\n\t\t\t\t\tv_trans_x = - v_prev_y;\r\n\t\t\t\t\tv_trans_y = v_prev_x;\r\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\r\n\t\t\t\t\tv_trans_x = v_prev_x;\r\n\t\t\t\t\tv_trans_y = v_prev_y;\r\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\r\n\r\n\t\t}\r\n\r\n\r\n\t\tvar contourMovements = [];\r\n\r\n\t\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\r\n\t\t\tif ( j === il ) j = 0;\r\n\t\t\tif ( k === il ) k = 0;\r\n\r\n\t\t\t//  (j)---(i)---(k)\r\n\t\t\t// console.log('i,j,k', i, j , k)\r\n\r\n\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\r\n\r\n\t\t}\r\n\r\n\t\tvar holesMovements = [],\r\n\t\t\toneHoleMovements, verticesMovements = contourMovements.concat();\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\r\n\t\t\toneHoleMovements = [];\r\n\r\n\t\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\r\n\t\t\t\tif ( j === il ) j = 0;\r\n\t\t\t\tif ( k === il ) k = 0;\r\n\r\n\t\t\t\t//  (j)---(i)---(k)\r\n\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tholesMovements.push( oneHoleMovements );\r\n\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\r\n\r\n\t\t}\r\n\r\n\r\n\t\t// Loop bevelSegments, 1 for the front, 1 for the back\r\n\r\n\t\tfor ( b = 0; b < bevelSegments; b ++ ) {\r\n\r\n\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\r\n\r\n\t\t\tt = b / bevelSegments;\r\n\t\t\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\r\n\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\r\n\r\n\t\t\t// contract shape\r\n\r\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\r\n\t\t\t\tv( vert.x, vert.y, - z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// expand holes\r\n\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\t\tahole = holes[ h ];\r\n\t\t\t\toneHoleMovements = holesMovements[ h ];\r\n\r\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\r\n\t\t\t\t\tv( vert.x, vert.y, - z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tbs = bevelSize;\r\n\r\n\t\t// Back facing vertices\r\n\r\n\t\tfor ( i = 0; i < vlen; i ++ ) {\r\n\r\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\r\n\t\t\tif ( ! extrudeByPath ) {\r\n\r\n\t\t\t\tv( vert.x, vert.y, 0 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\r\n\r\n\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\r\n\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\r\n\r\n\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\r\n\r\n\t\t\t\tv( position2.x, position2.y, position2.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Add stepped vertices...\r\n\t\t// Including front facing vertices\r\n\r\n\t\tvar s;\r\n\r\n\t\tfor ( s = 1; s <= steps; s ++ ) {\r\n\r\n\t\t\tfor ( i = 0; i < vlen; i ++ ) {\r\n\r\n\t\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\r\n\t\t\t\tif ( ! extrudeByPath ) {\r\n\r\n\t\t\t\t\tv( vert.x, vert.y, depth / steps * s );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\r\n\r\n\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\r\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\r\n\r\n\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\r\n\r\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\t// Add bevel segments planes\r\n\r\n\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\r\n\t\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\r\n\r\n\t\t\tt = b / bevelSegments;\r\n\t\t\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\r\n\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\r\n\r\n\t\t\t// contract shape\r\n\r\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\t\t\t\tv( vert.x, vert.y, depth + z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// expand holes\r\n\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\t\tahole = holes[ h ];\r\n\t\t\t\toneHoleMovements = holesMovements[ h ];\r\n\r\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\r\n\t\t\t\t\tif ( ! extrudeByPath ) {\r\n\r\n\t\t\t\t\t\tv( vert.x, vert.y, depth + z );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t/* Faces */\r\n\r\n\t\t// Top and bottom faces\r\n\r\n\t\tbuildLidFaces();\r\n\r\n\t\t// Sides faces\r\n\r\n\t\tbuildSideFaces();\r\n\r\n\r\n\t\t/////  Internal functions\r\n\r\n\t\tfunction buildLidFaces() {\r\n\r\n\t\t\tvar start = verticesArray.length / 3;\r\n\r\n\t\t\tif ( bevelEnabled ) {\r\n\r\n\t\t\t\tvar layer = 0; // steps + 1\r\n\t\t\t\tvar offset = vlen * layer;\r\n\r\n\t\t\t\t// Bottom faces\r\n\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlayer = steps + bevelSegments * 2;\r\n\t\t\t\toffset = vlen * layer;\r\n\r\n\t\t\t\t// Top faces\r\n\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Bottom faces\r\n\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Top faces\r\n\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 0 );\r\n\r\n\t\t}\r\n\r\n\t\t// Create faces for the z-sides of the shape\r\n\r\n\t\tfunction buildSideFaces() {\r\n\r\n\t\t\tvar start = verticesArray.length / 3;\r\n\t\t\tvar layeroffset = 0;\r\n\t\t\tsidewalls( contour, layeroffset );\r\n\t\t\tlayeroffset += contour.length;\r\n\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\t\tahole = holes[ h ];\r\n\t\t\t\tsidewalls( ahole, layeroffset );\r\n\r\n\t\t\t\t//, true\r\n\t\t\t\tlayeroffset += ahole.length;\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 1 );\r\n\r\n\r\n\t\t}\r\n\r\n\t\tfunction sidewalls( contour, layeroffset ) {\r\n\r\n\t\t\tvar j, k;\r\n\t\t\ti = contour.length;\r\n\r\n\t\t\twhile ( -- i >= 0 ) {\r\n\r\n\t\t\t\tj = i;\r\n\t\t\t\tk = i - 1;\r\n\t\t\t\tif ( k < 0 ) k = contour.length - 1;\r\n\r\n\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\r\n\r\n\t\t\t\tvar s = 0,\r\n\t\t\t\t\tsl = steps + bevelSegments * 2;\r\n\r\n\t\t\t\tfor ( s = 0; s < sl; s ++ ) {\r\n\r\n\t\t\t\t\tvar slen1 = vlen * s;\r\n\t\t\t\t\tvar slen2 = vlen * ( s + 1 );\r\n\r\n\t\t\t\t\tvar a = layeroffset + j + slen1,\r\n\t\t\t\t\t\tb = layeroffset + k + slen1,\r\n\t\t\t\t\t\tc = layeroffset + k + slen2,\r\n\t\t\t\t\t\td = layeroffset + j + slen2;\r\n\r\n\t\t\t\t\tf4( a, b, c, d );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction v( x, y, z ) {\r\n\r\n\t\t\tplaceholder.push( x );\r\n\t\t\tplaceholder.push( y );\r\n\t\t\tplaceholder.push( z );\r\n\r\n\t\t}\r\n\r\n\r\n\t\tfunction f3( a, b, c ) {\r\n\r\n\t\t\taddVertex( a );\r\n\t\t\taddVertex( b );\r\n\t\t\taddVertex( c );\r\n\r\n\t\t\tvar nextIndex = verticesArray.length / 3;\r\n\t\t\tvar uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\r\n\r\n\t\t\taddUV( uvs[ 0 ] );\r\n\t\t\taddUV( uvs[ 1 ] );\r\n\t\t\taddUV( uvs[ 2 ] );\r\n\r\n\t\t}\r\n\r\n\t\tfunction f4( a, b, c, d ) {\r\n\r\n\t\t\taddVertex( a );\r\n\t\t\taddVertex( b );\r\n\t\t\taddVertex( d );\r\n\r\n\t\t\taddVertex( b );\r\n\t\t\taddVertex( c );\r\n\t\t\taddVertex( d );\r\n\r\n\r\n\t\t\tvar nextIndex = verticesArray.length / 3;\r\n\t\t\tvar uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\r\n\r\n\t\t\taddUV( uvs[ 0 ] );\r\n\t\t\taddUV( uvs[ 1 ] );\r\n\t\t\taddUV( uvs[ 3 ] );\r\n\r\n\t\t\taddUV( uvs[ 1 ] );\r\n\t\t\taddUV( uvs[ 2 ] );\r\n\t\t\taddUV( uvs[ 3 ] );\r\n\r\n\t\t}\r\n\r\n\t\tfunction addVertex( index ) {\r\n\r\n\t\t\tverticesArray.push( placeholder[ index * 3 + 0 ] );\r\n\t\t\tverticesArray.push( placeholder[ index * 3 + 1 ] );\r\n\t\t\tverticesArray.push( placeholder[ index * 3 + 2 ] );\r\n\r\n\t\t}\r\n\r\n\r\n\t\tfunction addUV( vector2 ) {\r\n\r\n\t\t\tuvArray.push( vector2.x );\r\n\t\t\tuvArray.push( vector2.y );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\r\nExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;\r\n\r\nExtrudeBufferGeometry.prototype.toJSON = function () {\r\n\r\n\tvar data = BufferGeometry.prototype.toJSON.call( this );\r\n\r\n\tvar shapes = this.parameters.shapes;\r\n\tvar options = this.parameters.options;\r\n\r\n\treturn toJSON( shapes, options, data );\r\n\r\n};\r\n\r\n//\r\n\r\nvar WorldUVGenerator = {\r\n\r\n\tgenerateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {\r\n\r\n\t\tvar a_x = vertices[ indexA * 3 ];\r\n\t\tvar a_y = vertices[ indexA * 3 + 1 ];\r\n\t\tvar b_x = vertices[ indexB * 3 ];\r\n\t\tvar b_y = vertices[ indexB * 3 + 1 ];\r\n\t\tvar c_x = vertices[ indexC * 3 ];\r\n\t\tvar c_y = vertices[ indexC * 3 + 1 ];\r\n\r\n\t\treturn [\r\n\t\t\tnew Vector2( a_x, a_y ),\r\n\t\t\tnew Vector2( b_x, b_y ),\r\n\t\t\tnew Vector2( c_x, c_y )\r\n\t\t];\r\n\r\n\t},\r\n\r\n\tgenerateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {\r\n\r\n\t\tvar a_x = vertices[ indexA * 3 ];\r\n\t\tvar a_y = vertices[ indexA * 3 + 1 ];\r\n\t\tvar a_z = vertices[ indexA * 3 + 2 ];\r\n\t\tvar b_x = vertices[ indexB * 3 ];\r\n\t\tvar b_y = vertices[ indexB * 3 + 1 ];\r\n\t\tvar b_z = vertices[ indexB * 3 + 2 ];\r\n\t\tvar c_x = vertices[ indexC * 3 ];\r\n\t\tvar c_y = vertices[ indexC * 3 + 1 ];\r\n\t\tvar c_z = vertices[ indexC * 3 + 2 ];\r\n\t\tvar d_x = vertices[ indexD * 3 ];\r\n\t\tvar d_y = vertices[ indexD * 3 + 1 ];\r\n\t\tvar d_z = vertices[ indexD * 3 + 2 ];\r\n\r\n\t\tif ( Math.abs( a_y - b_y ) < 0.01 ) {\r\n\r\n\t\t\treturn [\r\n\t\t\t\tnew Vector2( a_x, 1 - a_z ),\r\n\t\t\t\tnew Vector2( b_x, 1 - b_z ),\r\n\t\t\t\tnew Vector2( c_x, 1 - c_z ),\r\n\t\t\t\tnew Vector2( d_x, 1 - d_z )\r\n\t\t\t];\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn [\r\n\t\t\t\tnew Vector2( a_y, 1 - a_z ),\r\n\t\t\t\tnew Vector2( b_y, 1 - b_z ),\r\n\t\t\t\tnew Vector2( c_y, 1 - c_z ),\r\n\t\t\t\tnew Vector2( d_y, 1 - d_z )\r\n\t\t\t];\r\n\r\n\t\t}\r\n\r\n\t}\r\n};\r\n\r\nfunction toJSON( shapes, options, data ) {\r\n\r\n\t//\r\n\r\n\tdata.shapes = [];\r\n\r\n\tif ( Array.isArray( shapes ) ) {\r\n\r\n\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar shape = shapes[ i ];\r\n\r\n\t\t\tdata.shapes.push( shape.uuid );\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tdata.shapes.push( shapes.uuid );\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tif ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();\r\n\r\n\treturn data;\r\n\r\n}\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/core/Curve.js\n\r\n\r\n\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Extensible curve object\r\n *\r\n * Some common of curve methods:\r\n * .getPoint( t, optionalTarget ), .getTangent( t )\r\n * .getPointAt( u, optionalTarget ), .getTangentAt( u )\r\n * .getPoints(), .getSpacedPoints()\r\n * .getLength()\r\n * .updateArcLengths()\r\n *\r\n * This following curves inherit from COOL.Curve:\r\n *\r\n * -- 2D curves --\r\n * COOL.ArcCurve\r\n * COOL.CubicBezierCurve\r\n * COOL.EllipseCurve\r\n * COOL.LineCurve\r\n * COOL.QuadraticBezierCurve\r\n * COOL.SplineCurve\r\n *\r\n * -- 3D curves --\r\n * COOL.CatmullRomCurve3\r\n * COOL.CubicBezierCurve3\r\n * COOL.LineCurve3\r\n * COOL.QuadraticBezierCurve3\r\n *\r\n * A series of curves can be represented as a COOL.CurvePath.\r\n *\r\n **/\r\n\r\n/**************************************************************\r\n *\tAbstract Curve base class\r\n **************************************************************/\r\n\r\nfunction Curve() {\r\n\r\n\tthis.type = 'Curve';\r\n\r\n\tthis.arcLengthDivisions = 200;\r\n\r\n}\r\n\r\nObject.assign( Curve.prototype, {\r\n\r\n\t// Virtual base class method to overwrite and implement in subclasses\r\n\t//\t- t [0 .. 1]\r\n\r\n\tgetPoint: function ( /* t, optionalTarget */ ) {\r\n\r\n\t\tconsole.warn( 'COOL.Curve: .getPoint() not implemented.' );\r\n\t\treturn null;\r\n\r\n\t},\r\n\r\n\t// Get point at relative position in curve according to arc length\r\n\t// - u [0 .. 1]\r\n\r\n\tgetPointAt: function ( u, optionalTarget ) {\r\n\r\n\t\tvar t = this.getUtoTmapping( u );\r\n\t\treturn this.getPoint( t, optionalTarget );\r\n\r\n\t},\r\n\r\n\t// Get sequence of points using getPoint( t )\r\n\r\n\tgetPoints: function ( divisions ) {\r\n\r\n\t\tif ( divisions === undefined ) divisions = 5;\r\n\r\n\t\tvar points = [];\r\n\r\n\t\tfor ( var d = 0; d <= divisions; d ++ ) {\r\n\r\n\t\t\tpoints.push( this.getPoint( d / divisions ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn points;\r\n\r\n\t},\r\n\r\n\t// Get sequence of points using getPointAt( u )\r\n\r\n\tgetSpacedPoints: function ( divisions ) {\r\n\r\n\t\tif ( divisions === undefined ) divisions = 5;\r\n\r\n\t\tvar points = [];\r\n\r\n\t\tfor ( var d = 0; d <= divisions; d ++ ) {\r\n\r\n\t\t\tpoints.push( this.getPointAt( d / divisions ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn points;\r\n\r\n\t},\r\n\r\n\t// Get total curve arc length\r\n\r\n\tgetLength: function () {\r\n\r\n\t\tvar lengths = this.getLengths();\r\n\t\treturn lengths[ lengths.length - 1 ];\r\n\r\n\t},\r\n\r\n\t// Get list of cumulative segment lengths\r\n\r\n\tgetLengths: function ( divisions ) {\r\n\r\n\t\tif ( divisions === undefined ) divisions = this.arcLengthDivisions;\r\n\r\n\t\tif ( this.cacheArcLengths &&\r\n\t\t\t( this.cacheArcLengths.length === divisions + 1 ) &&\r\n\t\t\t! this.needsUpdate ) {\r\n\r\n\t\t\treturn this.cacheArcLengths;\r\n\r\n\t\t}\r\n\r\n\t\tthis.needsUpdate = false;\r\n\r\n\t\tvar cache = [];\r\n\t\tvar current, last = this.getPoint( 0 );\r\n\t\tvar p, sum = 0;\r\n\r\n\t\tcache.push( 0 );\r\n\r\n\t\tfor ( p = 1; p <= divisions; p ++ ) {\r\n\r\n\t\t\tcurrent = this.getPoint( p / divisions );\r\n\t\t\tsum += current.distanceTo( last );\r\n\t\t\tcache.push( sum );\r\n\t\t\tlast = current;\r\n\r\n\t\t}\r\n\r\n\t\tthis.cacheArcLengths = cache;\r\n\r\n\t\treturn cache; // { sums: cache, sum: sum }; Sum is in the last element.\r\n\r\n\t},\r\n\r\n\tupdateArcLengths: function () {\r\n\r\n\t\tthis.needsUpdate = true;\r\n\t\tthis.getLengths();\r\n\r\n\t},\r\n\r\n\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\r\n\r\n\tgetUtoTmapping: function ( u, distance ) {\r\n\r\n\t\tvar arcLengths = this.getLengths();\r\n\r\n\t\tvar i = 0, il = arcLengths.length;\r\n\r\n\t\tvar targetArcLength; // The targeted u distance value to get\r\n\r\n\t\tif ( distance ) {\r\n\r\n\t\t\ttargetArcLength = distance;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\r\n\r\n\t\t}\r\n\r\n\t\t// binary search for the index with largest value smaller than target u distance\r\n\r\n\t\tvar low = 0, high = il - 1, comparison;\r\n\r\n\t\twhile ( low <= high ) {\r\n\r\n\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\r\n\r\n\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\r\n\r\n\t\t\tif ( comparison < 0 ) {\r\n\r\n\t\t\t\tlow = i + 1;\r\n\r\n\t\t\t} else if ( comparison > 0 ) {\r\n\r\n\t\t\t\thigh = i - 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\thigh = i;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t\t// DONE\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\ti = high;\r\n\r\n\t\tif ( arcLengths[ i ] === targetArcLength ) {\r\n\r\n\t\t\treturn i / ( il - 1 );\r\n\r\n\t\t}\r\n\r\n\t\t// we could get finer grain at lengths, or use simple interpolation between two points\r\n\r\n\t\tvar lengthBefore = arcLengths[ i ];\r\n\t\tvar lengthAfter = arcLengths[ i + 1 ];\r\n\r\n\t\tvar segmentLength = lengthAfter - lengthBefore;\r\n\r\n\t\t// determine where we are between the 'before' and 'after' points\r\n\r\n\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\r\n\r\n\t\t// add that fractional amount to t\r\n\r\n\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\r\n\r\n\t\treturn t;\r\n\r\n\t},\r\n\r\n\t// Returns a unit vector tangent at t\r\n\t// In case any sub curve does not implement its tangent derivation,\r\n\t// 2 points a small delta apart will be used to find its gradient\r\n\t// which seems to give a reasonable approximation\r\n\r\n\tgetTangent: function ( t ) {\r\n\r\n\t\tvar delta = 0.0001;\r\n\t\tvar t1 = t - delta;\r\n\t\tvar t2 = t + delta;\r\n\r\n\t\t// Capping in case of danger\r\n\r\n\t\tif ( t1 < 0 ) t1 = 0;\r\n\t\tif ( t2 > 1 ) t2 = 1;\r\n\r\n\t\tvar pt1 = this.getPoint( t1 );\r\n\t\tvar pt2 = this.getPoint( t2 );\r\n\r\n\t\tvar vec = pt2.clone().sub( pt1 );\r\n\t\treturn vec.normalize();\r\n\r\n\t},\r\n\r\n\tgetTangentAt: function ( u ) {\r\n\r\n\t\tvar t = this.getUtoTmapping( u );\r\n\t\treturn this.getTangent( t );\r\n\r\n\t},\r\n\r\n\tcomputeFrenetFrames: function ( segments, closed ) {\r\n\r\n\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\r\n\r\n\t\tvar normal = new Vector3();\r\n\r\n\t\tvar tangents = [];\r\n\t\tvar normals = [];\r\n\t\tvar binormals = [];\r\n\r\n\t\tvar vec = new Vector3();\r\n\t\tvar mat = new Matrix4();\r\n\r\n\t\tvar i, u, theta;\r\n\r\n\t\t// compute the tangent vectors for each segment on the curve\r\n\r\n\t\tfor ( i = 0; i <= segments; i ++ ) {\r\n\r\n\t\t\tu = i / segments;\r\n\r\n\t\t\ttangents[ i ] = this.getTangentAt( u );\r\n\t\t\ttangents[ i ].normalize();\r\n\r\n\t\t}\r\n\r\n\t\t// select an initial normal vector perpendicular to the first tangent vector,\r\n\t\t// and in the direction of the minimum tangent xyz component\r\n\r\n\t\tnormals[ 0 ] = new Vector3();\r\n\t\tbinormals[ 0 ] = new Vector3();\r\n\t\tvar min = Number.MAX_VALUE;\r\n\t\tvar tx = Math.abs( tangents[ 0 ].x );\r\n\t\tvar ty = Math.abs( tangents[ 0 ].y );\r\n\t\tvar tz = Math.abs( tangents[ 0 ].z );\r\n\r\n\t\tif ( tx <= min ) {\r\n\r\n\t\t\tmin = tx;\r\n\t\t\tnormal.set( 1, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( ty <= min ) {\r\n\r\n\t\t\tmin = ty;\r\n\t\t\tnormal.set( 0, 1, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( tz <= min ) {\r\n\r\n\t\t\tnormal.set( 0, 0, 1 );\r\n\r\n\t\t}\r\n\r\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\r\n\r\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\r\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\r\n\r\n\t\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\r\n\r\n\t\tfor ( i = 1; i <= segments; i ++ ) {\r\n\r\n\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\r\n\r\n\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\r\n\r\n\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\r\n\r\n\t\t\tif ( vec.length() > Number.EPSILON ) {\r\n\r\n\t\t\t\tvec.normalize();\r\n\r\n\t\t\t\ttheta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\r\n\r\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\r\n\r\n\t\tif ( closed === true ) {\r\n\r\n\t\t\ttheta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\r\n\t\t\ttheta /= segments;\r\n\r\n\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\r\n\r\n\t\t\t\ttheta = - theta;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( i = 1; i <= segments; i ++ ) {\r\n\r\n\t\t\t\t// twist a little...\r\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\r\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\ttangents: tangents,\r\n\t\t\tnormals: normals,\r\n\t\t\tbinormals: binormals\r\n\t\t};\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.arcLengthDivisions = source.arcLengthDivisions;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar data = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.5,\r\n\t\t\t\ttype: 'Curve',\r\n\t\t\t\tgenerator: 'Curve.toJSON'\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tdata.arcLengthDivisions = this.arcLengthDivisions;\r\n\t\tdata.type = this.type;\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tfromJSON: function ( json ) {\r\n\r\n\t\tthis.arcLengthDivisions = json.arcLengthDivisions;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/curves/EllipseCurve.js\n\r\n\r\n\r\n\r\nfunction EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\r\n\tCurve.call( this );\r\n\r\n\tthis.type = 'EllipseCurve';\r\n\r\n\tthis.aX = aX || 0;\r\n\tthis.aY = aY || 0;\r\n\r\n\tthis.xRadius = xRadius || 1;\r\n\tthis.yRadius = yRadius || 1;\r\n\r\n\tthis.aStartAngle = aStartAngle || 0;\r\n\tthis.aEndAngle = aEndAngle || 2 * Math.PI;\r\n\r\n\tthis.aClockwise = aClockwise || false;\r\n\r\n\tthis.aRotation = aRotation || 0;\r\n\r\n}\r\n\r\nEllipseCurve.prototype = Object.create( Curve.prototype );\r\nEllipseCurve.prototype.constructor = EllipseCurve;\r\n\r\nEllipseCurve.prototype.isEllipseCurve = true;\r\n\r\nEllipseCurve.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\tvar point = optionalTarget || new Vector2();\r\n\r\n\tvar twoPi = Math.PI * 2;\r\n\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\r\n\tvar samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\r\n\r\n\t// ensures that deltaAngle is 0 .. 2 PI\r\n\twhile ( deltaAngle < 0 ) deltaAngle += twoPi;\r\n\twhile ( deltaAngle > twoPi ) deltaAngle -= twoPi;\r\n\r\n\tif ( deltaAngle < Number.EPSILON ) {\r\n\r\n\t\tif ( samePoints ) {\r\n\r\n\t\t\tdeltaAngle = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tdeltaAngle = twoPi;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif ( this.aClockwise === true && ! samePoints ) {\r\n\r\n\t\tif ( deltaAngle === twoPi ) {\r\n\r\n\t\t\tdeltaAngle = - twoPi;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tdeltaAngle = deltaAngle - twoPi;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvar angle = this.aStartAngle + t * deltaAngle;\r\n\tvar x = this.aX + this.xRadius * Math.cos( angle );\r\n\tvar y = this.aY + this.yRadius * Math.sin( angle );\r\n\r\n\tif ( this.aRotation !== 0 ) {\r\n\r\n\t\tvar cos = Math.cos( this.aRotation );\r\n\t\tvar sin = Math.sin( this.aRotation );\r\n\r\n\t\tvar tx = x - this.aX;\r\n\t\tvar ty = y - this.aY;\r\n\r\n\t\t// Rotate the point about the center of the ellipse.\r\n\t\tx = tx * cos - ty * sin + this.aX;\r\n\t\ty = tx * sin + ty * cos + this.aY;\r\n\r\n\t}\r\n\r\n\treturn point.set( x, y );\r\n\r\n};\r\n\r\nEllipseCurve.prototype.copy = function ( source ) {\r\n\r\n\tCurve.prototype.copy.call( this, source );\r\n\r\n\tthis.aX = source.aX;\r\n\tthis.aY = source.aY;\r\n\r\n\tthis.xRadius = source.xRadius;\r\n\tthis.yRadius = source.yRadius;\r\n\r\n\tthis.aStartAngle = source.aStartAngle;\r\n\tthis.aEndAngle = source.aEndAngle;\r\n\r\n\tthis.aClockwise = source.aClockwise;\r\n\r\n\tthis.aRotation = source.aRotation;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n\r\nEllipseCurve.prototype.toJSON = function () {\r\n\r\n\tvar data = Curve.prototype.toJSON.call( this );\r\n\r\n\tdata.aX = this.aX;\r\n\tdata.aY = this.aY;\r\n\r\n\tdata.xRadius = this.xRadius;\r\n\tdata.yRadius = this.yRadius;\r\n\r\n\tdata.aStartAngle = this.aStartAngle;\r\n\tdata.aEndAngle = this.aEndAngle;\r\n\r\n\tdata.aClockwise = this.aClockwise;\r\n\r\n\tdata.aRotation = this.aRotation;\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nEllipseCurve.prototype.fromJSON = function ( json ) {\r\n\r\n\tCurve.prototype.fromJSON.call( this, json );\r\n\r\n\tthis.aX = json.aX;\r\n\tthis.aY = json.aY;\r\n\r\n\tthis.xRadius = json.xRadius;\r\n\tthis.yRadius = json.yRadius;\r\n\r\n\tthis.aStartAngle = json.aStartAngle;\r\n\tthis.aEndAngle = json.aEndAngle;\r\n\r\n\tthis.aClockwise = json.aClockwise;\r\n\r\n\tthis.aRotation = json.aRotation;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/curves/ArcCurve.js\n\r\n\r\n\r\nfunction ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tEllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\r\n\r\n\tthis.type = 'ArcCurve';\r\n\r\n}\r\n\r\nArcCurve.prototype = Object.create( EllipseCurve.prototype );\r\nArcCurve.prototype.constructor = ArcCurve;\r\n\r\nArcCurve.prototype.isArcCurve = true;\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/curves/CatmullRomCurve3.js\n\r\n\r\n\r\n/**\r\n * @author zz85 https://github.com/zz85\r\n *\r\n * Centripetal CatmullRom Curve - which is useful for avoiding\r\n * cusps and self-intersections in non-uniform catmull rom curves.\r\n * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\r\n *\r\n * curve.type accepts centripetal(default), chordal and catmullrom\r\n * curve.tension is used for catmullrom which defaults to 0.5\r\n */\r\n\r\n\r\n/*\r\nBased on an optimized c++ solution in\r\n - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\r\n - http://ideone.com/NoEbVM\r\n\r\nThis CubicPoly class could be used for reusing some variables and calculations,\r\nbut for COOL.js curve use, it could be possible inlined and flatten into a single function call\r\nwhich can be placed in CurveUtils.\r\n*/\r\n\r\nfunction CubicPoly() {\r\n\r\n\tvar c0 = 0, c1 = 0, c2 = 0, c3 = 0;\r\n\r\n\t/*\r\n\t * Compute coefficients for a cubic polynomial\r\n\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\r\n\t * such that\r\n\t *   p(0) = x0, p(1) = x1\r\n\t *  and\r\n\t *   p'(0) = t0, p'(1) = t1.\r\n\t */\r\n\tfunction init( x0, x1, t0, t1 ) {\r\n\r\n\t\tc0 = x0;\r\n\t\tc1 = t0;\r\n\t\tc2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\r\n\t\tc3 = 2 * x0 - 2 * x1 + t0 + t1;\r\n\r\n\t}\r\n\r\n\treturn {\r\n\r\n\t\tinitCatmullRom: function ( x0, x1, x2, x3, tension ) {\r\n\r\n\t\t\tinit( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\r\n\r\n\t\t},\r\n\r\n\t\tinitNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {\r\n\r\n\t\t\t// compute tangents when parameterized in [t1,t2]\r\n\t\t\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\r\n\t\t\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\r\n\r\n\t\t\t// rescale tangents for parametrization in [0,1]\r\n\t\t\tt1 *= dt1;\r\n\t\t\tt2 *= dt1;\r\n\r\n\t\t\tinit( x1, x2, t1, t2 );\r\n\r\n\t\t},\r\n\r\n\t\tcalc: function ( t ) {\r\n\r\n\t\t\tvar t2 = t * t;\r\n\t\t\tvar t3 = t2 * t;\r\n\t\t\treturn c0 + c1 * t + c2 * t2 + c3 * t3;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}\r\n\r\n//\r\n\r\nvar tmp = new Vector3();\r\nvar px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();\r\n\r\nfunction CatmullRomCurve3( points, closed, curveType, tension ) {\r\n\r\n\tCurve.call( this );\r\n\r\n\tthis.type = 'CatmullRomCurve3';\r\n\r\n\tthis.points = points || [];\r\n\tthis.closed = closed || false;\r\n\tthis.curveType = curveType || 'centripetal';\r\n\tthis.tension = tension || 0.5;\r\n\r\n}\r\n\r\nCatmullRomCurve3.prototype = Object.create( Curve.prototype );\r\nCatmullRomCurve3.prototype.constructor = CatmullRomCurve3;\r\n\r\nCatmullRomCurve3.prototype.isCatmullRomCurve3 = true;\r\n\r\nCatmullRomCurve3.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\tvar point = optionalTarget || new Vector3();\r\n\r\n\tvar points = this.points;\r\n\tvar l = points.length;\r\n\r\n\tvar p = ( l - ( this.closed ? 0 : 1 ) ) * t;\r\n\tvar intPoint = Math.floor( p );\r\n\tvar weight = p - intPoint;\r\n\r\n\tif ( this.closed ) {\r\n\r\n\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;\r\n\r\n\t} else if ( weight === 0 && intPoint === l - 1 ) {\r\n\r\n\t\tintPoint = l - 2;\r\n\t\tweight = 1;\r\n\r\n\t}\r\n\r\n\tvar p0, p1, p2, p3; // 4 points\r\n\r\n\tif ( this.closed || intPoint > 0 ) {\r\n\r\n\t\tp0 = points[ ( intPoint - 1 ) % l ];\r\n\r\n\t} else {\r\n\r\n\t\t// extrapolate first point\r\n\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\r\n\t\tp0 = tmp;\r\n\r\n\t}\r\n\r\n\tp1 = points[ intPoint % l ];\r\n\tp2 = points[ ( intPoint + 1 ) % l ];\r\n\r\n\tif ( this.closed || intPoint + 2 < l ) {\r\n\r\n\t\tp3 = points[ ( intPoint + 2 ) % l ];\r\n\r\n\t} else {\r\n\r\n\t\t// extrapolate last point\r\n\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\r\n\t\tp3 = tmp;\r\n\r\n\t}\r\n\r\n\tif ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {\r\n\r\n\t\t// init Centripetal / Chordal Catmull-Rom\r\n\t\tvar pow = this.curveType === 'chordal' ? 0.5 : 0.25;\r\n\t\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\r\n\t\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\r\n\t\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\r\n\r\n\t\t// safety check for repeated points\r\n\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\r\n\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\r\n\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\r\n\r\n\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\r\n\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\r\n\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\r\n\r\n\t} else if ( this.curveType === 'catmullrom' ) {\r\n\r\n\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );\r\n\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );\r\n\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );\r\n\r\n\t}\r\n\r\n\tpoint.set(\r\n\t\tpx.calc( weight ),\r\n\t\tpy.calc( weight ),\r\n\t\tpz.calc( weight )\r\n\t);\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\nCatmullRomCurve3.prototype.copy = function ( source ) {\r\n\r\n\tCurve.prototype.copy.call( this, source );\r\n\r\n\tthis.points = [];\r\n\r\n\tfor ( var i = 0, l = source.points.length; i < l; i ++ ) {\r\n\r\n\t\tvar point = source.points[ i ];\r\n\r\n\t\tthis.points.push( point.clone() );\r\n\r\n\t}\r\n\r\n\tthis.closed = source.closed;\r\n\tthis.curveType = source.curveType;\r\n\tthis.tension = source.tension;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nCatmullRomCurve3.prototype.toJSON = function () {\r\n\r\n\tvar data = Curve.prototype.toJSON.call( this );\r\n\r\n\tdata.points = [];\r\n\r\n\tfor ( var i = 0, l = this.points.length; i < l; i ++ ) {\r\n\r\n\t\tvar point = this.points[ i ];\r\n\t\tdata.points.push( point.toArray() );\r\n\r\n\t}\r\n\r\n\tdata.closed = this.closed;\r\n\tdata.curveType = this.curveType;\r\n\tdata.tension = this.tension;\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nCatmullRomCurve3.prototype.fromJSON = function ( json ) {\r\n\r\n\tCurve.prototype.fromJSON.call( this, json );\r\n\r\n\tthis.points = [];\r\n\r\n\tfor ( var i = 0, l = json.points.length; i < l; i ++ ) {\r\n\r\n\t\tvar point = json.points[ i ];\r\n\t\tthis.points.push( new Vector3().fromArray( point ) );\r\n\r\n\t}\r\n\r\n\tthis.closed = json.closed;\r\n\tthis.curveType = json.curveType;\r\n\tthis.tension = json.tension;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/core/Interpolations.js\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n * Bezier Curves formulas obtained from\r\n * http://en.wikipedia.org/wiki/Bzier_curve\r\n */\r\n\r\nfunction CatmullRom( t, p0, p1, p2, p3 ) {\r\n\r\n\tvar v0 = ( p2 - p0 ) * 0.5;\r\n\tvar v1 = ( p3 - p1 ) * 0.5;\r\n\tvar t2 = t * t;\r\n\tvar t3 = t * t2;\r\n\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\r\n}\r\n\r\n//\r\n\r\nfunction QuadraticBezierP0( t, p ) {\r\n\r\n\tvar k = 1 - t;\r\n\treturn k * k * p;\r\n\r\n}\r\n\r\nfunction QuadraticBezierP1( t, p ) {\r\n\r\n\treturn 2 * ( 1 - t ) * t * p;\r\n\r\n}\r\n\r\nfunction QuadraticBezierP2( t, p ) {\r\n\r\n\treturn t * t * p;\r\n\r\n}\r\n\r\nfunction QuadraticBezier( t, p0, p1, p2 ) {\r\n\r\n\treturn QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +\r\n\t\tQuadraticBezierP2( t, p2 );\r\n\r\n}\r\n\r\n//\r\n\r\nfunction CubicBezierP0( t, p ) {\r\n\r\n\tvar k = 1 - t;\r\n\treturn k * k * k * p;\r\n\r\n}\r\n\r\nfunction CubicBezierP1( t, p ) {\r\n\r\n\tvar k = 1 - t;\r\n\treturn 3 * k * k * t * p;\r\n\r\n}\r\n\r\nfunction CubicBezierP2( t, p ) {\r\n\r\n\treturn 3 * ( 1 - t ) * t * t * p;\r\n\r\n}\r\n\r\nfunction CubicBezierP3( t, p ) {\r\n\r\n\treturn t * t * t * p;\r\n\r\n}\r\n\r\nfunction CubicBezier( t, p0, p1, p2, p3 ) {\r\n\r\n\treturn CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +\r\n\t\tCubicBezierP3( t, p3 );\r\n\r\n}\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/curves/CubicBezierCurve.js\n\r\n\r\n\r\n\r\n\r\nfunction CubicBezierCurve( v0, v1, v2, v3 ) {\r\n\r\n\tCurve.call( this );\r\n\r\n\tthis.type = 'CubicBezierCurve';\r\n\r\n\tthis.v0 = v0 || new Vector2();\r\n\tthis.v1 = v1 || new Vector2();\r\n\tthis.v2 = v2 || new Vector2();\r\n\tthis.v3 = v3 || new Vector2();\r\n\r\n}\r\n\r\nCubicBezierCurve.prototype = Object.create( Curve.prototype );\r\nCubicBezierCurve.prototype.constructor = CubicBezierCurve;\r\n\r\nCubicBezierCurve.prototype.isCubicBezierCurve = true;\r\n\r\nCubicBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\tvar point = optionalTarget || new Vector2();\r\n\r\n\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\r\n\r\n\tpoint.set(\r\n\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\r\n\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y )\r\n\t);\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\nCubicBezierCurve.prototype.copy = function ( source ) {\r\n\r\n\tCurve.prototype.copy.call( this, source );\r\n\r\n\tthis.v0.copy( source.v0 );\r\n\tthis.v1.copy( source.v1 );\r\n\tthis.v2.copy( source.v2 );\r\n\tthis.v3.copy( source.v3 );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nCubicBezierCurve.prototype.toJSON = function () {\r\n\r\n\tvar data = Curve.prototype.toJSON.call( this );\r\n\r\n\tdata.v0 = this.v0.toArray();\r\n\tdata.v1 = this.v1.toArray();\r\n\tdata.v2 = this.v2.toArray();\r\n\tdata.v3 = this.v3.toArray();\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nCubicBezierCurve.prototype.fromJSON = function ( json ) {\r\n\r\n\tCurve.prototype.fromJSON.call( this, json );\r\n\r\n\tthis.v0.fromArray( json.v0 );\r\n\tthis.v1.fromArray( json.v1 );\r\n\tthis.v2.fromArray( json.v2 );\r\n\tthis.v3.fromArray( json.v3 );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/curves/CubicBezierCurve3.js\n\r\n\r\n\r\n\r\n\r\nfunction CubicBezierCurve3( v0, v1, v2, v3 ) {\r\n\r\n\tCurve.call( this );\r\n\r\n\tthis.type = 'CubicBezierCurve3';\r\n\r\n\tthis.v0 = v0 || new Vector3();\r\n\tthis.v1 = v1 || new Vector3();\r\n\tthis.v2 = v2 || new Vector3();\r\n\tthis.v3 = v3 || new Vector3();\r\n\r\n}\r\n\r\nCubicBezierCurve3.prototype = Object.create( Curve.prototype );\r\nCubicBezierCurve3.prototype.constructor = CubicBezierCurve3;\r\n\r\nCubicBezierCurve3.prototype.isCubicBezierCurve3 = true;\r\n\r\nCubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\tvar point = optionalTarget || new Vector3();\r\n\r\n\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\r\n\r\n\tpoint.set(\r\n\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\r\n\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y ),\r\n\t\tCubicBezier( t, v0.z, v1.z, v2.z, v3.z )\r\n\t);\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\nCubicBezierCurve3.prototype.copy = function ( source ) {\r\n\r\n\tCurve.prototype.copy.call( this, source );\r\n\r\n\tthis.v0.copy( source.v0 );\r\n\tthis.v1.copy( source.v1 );\r\n\tthis.v2.copy( source.v2 );\r\n\tthis.v3.copy( source.v3 );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nCubicBezierCurve3.prototype.toJSON = function () {\r\n\r\n\tvar data = Curve.prototype.toJSON.call( this );\r\n\r\n\tdata.v0 = this.v0.toArray();\r\n\tdata.v1 = this.v1.toArray();\r\n\tdata.v2 = this.v2.toArray();\r\n\tdata.v3 = this.v3.toArray();\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nCubicBezierCurve3.prototype.fromJSON = function ( json ) {\r\n\r\n\tCurve.prototype.fromJSON.call( this, json );\r\n\r\n\tthis.v0.fromArray( json.v0 );\r\n\tthis.v1.fromArray( json.v1 );\r\n\tthis.v2.fromArray( json.v2 );\r\n\tthis.v3.fromArray( json.v3 );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/curves/LineCurve.js\n\r\n\r\n\r\n\r\nfunction LineCurve( v1, v2 ) {\r\n\r\n\tCurve.call( this );\r\n\r\n\tthis.type = 'LineCurve';\r\n\r\n\tthis.v1 = v1 || new Vector2();\r\n\tthis.v2 = v2 || new Vector2();\r\n\r\n}\r\n\r\nLineCurve.prototype = Object.create( Curve.prototype );\r\nLineCurve.prototype.constructor = LineCurve;\r\n\r\nLineCurve.prototype.isLineCurve = true;\r\n\r\nLineCurve.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\tvar point = optionalTarget || new Vector2();\r\n\r\n\tif ( t === 1 ) {\r\n\r\n\t\tpoint.copy( this.v2 );\r\n\r\n\t} else {\r\n\r\n\t\tpoint.copy( this.v2 ).sub( this.v1 );\r\n\t\tpoint.multiplyScalar( t ).add( this.v1 );\r\n\r\n\t}\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\n// Line curve is linear, so we can overwrite default getPointAt\r\n\r\nLineCurve.prototype.getPointAt = function ( u, optionalTarget ) {\r\n\r\n\treturn this.getPoint( u, optionalTarget );\r\n\r\n};\r\n\r\nLineCurve.prototype.getTangent = function ( /* t */ ) {\r\n\r\n\tvar tangent = this.v2.clone().sub( this.v1 );\r\n\r\n\treturn tangent.normalize();\r\n\r\n};\r\n\r\nLineCurve.prototype.copy = function ( source ) {\r\n\r\n\tCurve.prototype.copy.call( this, source );\r\n\r\n\tthis.v1.copy( source.v1 );\r\n\tthis.v2.copy( source.v2 );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nLineCurve.prototype.toJSON = function () {\r\n\r\n\tvar data = Curve.prototype.toJSON.call( this );\r\n\r\n\tdata.v1 = this.v1.toArray();\r\n\tdata.v2 = this.v2.toArray();\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nLineCurve.prototype.fromJSON = function ( json ) {\r\n\r\n\tCurve.prototype.fromJSON.call( this, json );\r\n\r\n\tthis.v1.fromArray( json.v1 );\r\n\tthis.v2.fromArray( json.v2 );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/curves/LineCurve3.js\n\r\n\r\n\r\n\r\nfunction LineCurve3( v1, v2 ) {\r\n\r\n\tCurve.call( this );\r\n\r\n\tthis.type = 'LineCurve3';\r\n\r\n\tthis.v1 = v1 || new Vector3();\r\n\tthis.v2 = v2 || new Vector3();\r\n\r\n}\r\n\r\nLineCurve3.prototype = Object.create( Curve.prototype );\r\nLineCurve3.prototype.constructor = LineCurve3;\r\n\r\nLineCurve3.prototype.isLineCurve3 = true;\r\n\r\nLineCurve3.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\tvar point = optionalTarget || new Vector3();\r\n\r\n\tif ( t === 1 ) {\r\n\r\n\t\tpoint.copy( this.v2 );\r\n\r\n\t} else {\r\n\r\n\t\tpoint.copy( this.v2 ).sub( this.v1 );\r\n\t\tpoint.multiplyScalar( t ).add( this.v1 );\r\n\r\n\t}\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\n// Line curve is linear, so we can overwrite default getPointAt\r\n\r\nLineCurve3.prototype.getPointAt = function ( u, optionalTarget ) {\r\n\r\n\treturn this.getPoint( u, optionalTarget );\r\n\r\n};\r\n\r\nLineCurve3.prototype.copy = function ( source ) {\r\n\r\n\tCurve.prototype.copy.call( this, source );\r\n\r\n\tthis.v1.copy( source.v1 );\r\n\tthis.v2.copy( source.v2 );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nLineCurve3.prototype.toJSON = function () {\r\n\r\n\tvar data = Curve.prototype.toJSON.call( this );\r\n\r\n\tdata.v1 = this.v1.toArray();\r\n\tdata.v2 = this.v2.toArray();\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nLineCurve3.prototype.fromJSON = function ( json ) {\r\n\r\n\tCurve.prototype.fromJSON.call( this, json );\r\n\r\n\tthis.v1.fromArray( json.v1 );\r\n\tthis.v2.fromArray( json.v2 );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/curves/QuadraticBezierCurve.js\n\r\n\r\n\r\n\r\n\r\nfunction QuadraticBezierCurve( v0, v1, v2 ) {\r\n\r\n\tCurve.call( this );\r\n\r\n\tthis.type = 'QuadraticBezierCurve';\r\n\r\n\tthis.v0 = v0 || new Vector2();\r\n\tthis.v1 = v1 || new Vector2();\r\n\tthis.v2 = v2 || new Vector2();\r\n\r\n}\r\n\r\nQuadraticBezierCurve.prototype = Object.create( Curve.prototype );\r\nQuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;\r\n\r\nQuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;\r\n\r\nQuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\tvar point = optionalTarget || new Vector2();\r\n\r\n\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2;\r\n\r\n\tpoint.set(\r\n\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\r\n\t\tQuadraticBezier( t, v0.y, v1.y, v2.y )\r\n\t);\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\nQuadraticBezierCurve.prototype.copy = function ( source ) {\r\n\r\n\tCurve.prototype.copy.call( this, source );\r\n\r\n\tthis.v0.copy( source.v0 );\r\n\tthis.v1.copy( source.v1 );\r\n\tthis.v2.copy( source.v2 );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nQuadraticBezierCurve.prototype.toJSON = function () {\r\n\r\n\tvar data = Curve.prototype.toJSON.call( this );\r\n\r\n\tdata.v0 = this.v0.toArray();\r\n\tdata.v1 = this.v1.toArray();\r\n\tdata.v2 = this.v2.toArray();\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nQuadraticBezierCurve.prototype.fromJSON = function ( json ) {\r\n\r\n\tCurve.prototype.fromJSON.call( this, json );\r\n\r\n\tthis.v0.fromArray( json.v0 );\r\n\tthis.v1.fromArray( json.v1 );\r\n\tthis.v2.fromArray( json.v2 );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/curves/QuadraticBezierCurve3.js\n\r\n\r\n\r\n\r\n\r\nfunction QuadraticBezierCurve3( v0, v1, v2 ) {\r\n\r\n\tCurve.call( this );\r\n\r\n\tthis.type = 'QuadraticBezierCurve3';\r\n\r\n\tthis.v0 = v0 || new Vector3();\r\n\tthis.v1 = v1 || new Vector3();\r\n\tthis.v2 = v2 || new Vector3();\r\n\r\n}\r\n\r\nQuadraticBezierCurve3.prototype = Object.create( Curve.prototype );\r\nQuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;\r\n\r\nQuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;\r\n\r\nQuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\tvar point = optionalTarget || new Vector3();\r\n\r\n\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2;\r\n\r\n\tpoint.set(\r\n\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\r\n\t\tQuadraticBezier( t, v0.y, v1.y, v2.y ),\r\n\t\tQuadraticBezier( t, v0.z, v1.z, v2.z )\r\n\t);\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\nQuadraticBezierCurve3.prototype.copy = function ( source ) {\r\n\r\n\tCurve.prototype.copy.call( this, source );\r\n\r\n\tthis.v0.copy( source.v0 );\r\n\tthis.v1.copy( source.v1 );\r\n\tthis.v2.copy( source.v2 );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nQuadraticBezierCurve3.prototype.toJSON = function () {\r\n\r\n\tvar data = Curve.prototype.toJSON.call( this );\r\n\r\n\tdata.v0 = this.v0.toArray();\r\n\tdata.v1 = this.v1.toArray();\r\n\tdata.v2 = this.v2.toArray();\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nQuadraticBezierCurve3.prototype.fromJSON = function ( json ) {\r\n\r\n\tCurve.prototype.fromJSON.call( this, json );\r\n\r\n\tthis.v0.fromArray( json.v0 );\r\n\tthis.v1.fromArray( json.v1 );\r\n\tthis.v2.fromArray( json.v2 );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/curves/SplineCurve.js\n\r\n\r\n\r\n\r\n\r\nfunction SplineCurve( points /* array of Vector2 */ ) {\r\n\r\n\tCurve.call( this );\r\n\r\n\tthis.type = 'SplineCurve';\r\n\r\n\tthis.points = points || [];\r\n\r\n}\r\n\r\nSplineCurve.prototype = Object.create( Curve.prototype );\r\nSplineCurve.prototype.constructor = SplineCurve;\r\n\r\nSplineCurve.prototype.isSplineCurve = true;\r\n\r\nSplineCurve.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\tvar point = optionalTarget || new Vector2();\r\n\r\n\tvar points = this.points;\r\n\tvar p = ( points.length - 1 ) * t;\r\n\r\n\tvar intPoint = Math.floor( p );\r\n\tvar weight = p - intPoint;\r\n\r\n\tvar p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\r\n\tvar p1 = points[ intPoint ];\r\n\tvar p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\r\n\tvar p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\r\n\r\n\tpoint.set(\r\n\t\tCatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),\r\n\t\tCatmullRom( weight, p0.y, p1.y, p2.y, p3.y )\r\n\t);\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\nSplineCurve.prototype.copy = function ( source ) {\r\n\r\n\tCurve.prototype.copy.call( this, source );\r\n\r\n\tthis.points = [];\r\n\r\n\tfor ( var i = 0, l = source.points.length; i < l; i ++ ) {\r\n\r\n\t\tvar point = source.points[ i ];\r\n\r\n\t\tthis.points.push( point.clone() );\r\n\r\n\t}\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nSplineCurve.prototype.toJSON = function () {\r\n\r\n\tvar data = Curve.prototype.toJSON.call( this );\r\n\r\n\tdata.points = [];\r\n\r\n\tfor ( var i = 0, l = this.points.length; i < l; i ++ ) {\r\n\r\n\t\tvar point = this.points[ i ];\r\n\t\tdata.points.push( point.toArray() );\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nSplineCurve.prototype.fromJSON = function ( json ) {\r\n\r\n\tCurve.prototype.fromJSON.call( this, json );\r\n\r\n\tthis.points = [];\r\n\r\n\tfor ( var i = 0, l = json.points.length; i < l; i ++ ) {\r\n\r\n\t\tvar point = json.points[ i ];\r\n\t\tthis.points.push( new Vector2().fromArray( point ) );\r\n\r\n\t}\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/curves/Curves.js\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/core/CurvePath.js\n\r\n\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n **/\r\n\r\n/**************************************************************\r\n *\tCurved Path - a curve path is simply a array of connected\r\n *  curves, but retains the api of a curve\r\n **************************************************************/\r\n\r\nfunction CurvePath() {\r\n\r\n\tCurve.call( this );\r\n\r\n\tthis.type = 'CurvePath';\r\n\r\n\tthis.curves = [];\r\n\tthis.autoClose = false; // Automatically closes the path\r\n\r\n}\r\n\r\nCurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {\r\n\r\n\tconstructor: CurvePath,\r\n\r\n\tadd: function ( curve ) {\r\n\r\n\t\tthis.curves.push( curve );\r\n\r\n\t},\r\n\r\n\tclosePath: function () {\r\n\r\n\t\t// Add a line curve if start and end of lines are not connected\r\n\t\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\r\n\t\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\r\n\r\n\t\tif ( ! startPoint.equals( endPoint ) ) {\r\n\r\n\t\t\tthis.curves.push( new LineCurve( endPoint, startPoint ) );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t// To get accurate point with reference to\r\n\t// entire path distance at time t,\r\n\t// following has to be done:\r\n\r\n\t// 1. Length of each sub path have to be known\r\n\t// 2. Locate and identify type of curve\r\n\t// 3. Get t for the curve\r\n\t// 4. Return curve.getPointAt(t')\r\n\r\n\tgetPoint: function ( t ) {\r\n\r\n\t\tvar d = t * this.getLength();\r\n\t\tvar curveLengths = this.getCurveLengths();\r\n\t\tvar i = 0;\r\n\r\n\t\t// To think about boundaries points.\r\n\r\n\t\twhile ( i < curveLengths.length ) {\r\n\r\n\t\t\tif ( curveLengths[ i ] >= d ) {\r\n\r\n\t\t\t\tvar diff = curveLengths[ i ] - d;\r\n\t\t\t\tvar curve = this.curves[ i ];\r\n\r\n\t\t\t\tvar segmentLength = curve.getLength();\r\n\t\t\t\tvar u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\r\n\r\n\t\t\t\treturn curve.getPointAt( u );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ti ++;\r\n\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t\t// loop where sum != 0, sum > d , sum+1 <d\r\n\r\n\t},\r\n\r\n\t// We cannot use the default COOL.Curve getPoint() with getLength() because in\r\n\t// COOL.Curve, getLength() depends on getPoint() but in COOL.CurvePath\r\n\t// getPoint() depends on getLength\r\n\r\n\tgetLength: function () {\r\n\r\n\t\tvar lens = this.getCurveLengths();\r\n\t\treturn lens[ lens.length - 1 ];\r\n\r\n\t},\r\n\r\n\t// cacheLengths must be recalculated.\r\n\tupdateArcLengths: function () {\r\n\r\n\t\tthis.needsUpdate = true;\r\n\t\tthis.cacheLengths = null;\r\n\t\tthis.getCurveLengths();\r\n\r\n\t},\r\n\r\n\t// Compute lengths and cache them\r\n\t// We cannot overwrite getLengths() because UtoT mapping uses it.\r\n\r\n\tgetCurveLengths: function () {\r\n\r\n\t\t// We use cache values if curves and cache array are same length\r\n\r\n\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\r\n\r\n\t\t\treturn this.cacheLengths;\r\n\r\n\t\t}\r\n\r\n\t\t// Get length of sub-curve\r\n\t\t// Push sums into cached array\r\n\r\n\t\tvar lengths = [], sums = 0;\r\n\r\n\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\r\n\r\n\t\t\tsums += this.curves[ i ].getLength();\r\n\t\t\tlengths.push( sums );\r\n\r\n\t\t}\r\n\r\n\t\tthis.cacheLengths = lengths;\r\n\r\n\t\treturn lengths;\r\n\r\n\t},\r\n\r\n\tgetSpacedPoints: function ( divisions ) {\r\n\r\n\t\tif ( divisions === undefined ) divisions = 40;\r\n\r\n\t\tvar points = [];\r\n\r\n\t\tfor ( var i = 0; i <= divisions; i ++ ) {\r\n\r\n\t\t\tpoints.push( this.getPoint( i / divisions ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.autoClose ) {\r\n\r\n\t\t\tpoints.push( points[ 0 ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn points;\r\n\r\n\t},\r\n\r\n\tgetPoints: function ( divisions ) {\r\n\r\n\t\tdivisions = divisions || 12;\r\n\r\n\t\tvar points = [], last;\r\n\r\n\t\tfor ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {\r\n\r\n\t\t\tvar curve = curves[ i ];\r\n\t\t\tvar resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2\r\n\t\t\t\t: ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1\r\n\t\t\t\t\t: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length\r\n\t\t\t\t\t\t: divisions;\r\n\r\n\t\t\tvar pts = curve.getPoints( resolution );\r\n\r\n\t\t\tfor ( var j = 0; j < pts.length; j ++ ) {\r\n\r\n\t\t\t\tvar point = pts[ j ];\r\n\r\n\t\t\t\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\r\n\r\n\t\t\t\tpoints.push( point );\r\n\t\t\t\tlast = point;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {\r\n\r\n\t\t\tpoints.push( points[ 0 ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn points;\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tCurve.prototype.copy.call( this, source );\r\n\r\n\t\tthis.curves = [];\r\n\r\n\t\tfor ( var i = 0, l = source.curves.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar curve = source.curves[ i ];\r\n\r\n\t\t\tthis.curves.push( curve.clone() );\r\n\r\n\t\t}\r\n\r\n\t\tthis.autoClose = source.autoClose;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar data = Curve.prototype.toJSON.call( this );\r\n\r\n\t\tdata.autoClose = this.autoClose;\r\n\t\tdata.curves = [];\r\n\r\n\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar curve = this.curves[ i ];\r\n\t\t\tdata.curves.push( curve.toJSON() );\r\n\r\n\t\t}\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tfromJSON: function ( json ) {\r\n\r\n\t\tCurve.prototype.fromJSON.call( this, json );\r\n\r\n\t\tthis.autoClose = json.autoClose;\r\n\t\tthis.curves = [];\r\n\r\n\t\tfor ( var i = 0, l = json.curves.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar curve = json.curves[ i ];\r\n\t\t\tthis.curves.push( new Curves_namespaceObject[ curve.type ]().fromJSON( curve ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/core/Path.js\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Creates free form 2d path using series of points, lines or curves.\r\n **/\r\n\r\nfunction Path( points ) {\r\n\r\n\tCurvePath.call( this );\r\n\r\n\tthis.type = 'Path';\r\n\r\n\tthis.currentPoint = new Vector2();\r\n\r\n\tif ( points ) {\r\n\r\n\t\tthis.setFromPoints( points );\r\n\r\n\t}\r\n\r\n}\r\n\r\nPath.prototype = Object.assign( Object.create( CurvePath.prototype ), {\r\n\r\n\tconstructor: Path,\r\n\r\n\tsetFromPoints: function ( points ) {\r\n\r\n\t\tthis.moveTo( points[ 0 ].x, points[ 0 ].y );\r\n\r\n\t\tfor ( var i = 1, l = points.length; i < l; i ++ ) {\r\n\r\n\t\t\tthis.lineTo( points[ i ].x, points[ i ].y );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tmoveTo: function ( x, y ) {\r\n\r\n\t\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\r\n\r\n\t},\r\n\r\n\tlineTo: function ( x, y ) {\r\n\r\n\t\tvar curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\r\n\t\tthis.curves.push( curve );\r\n\r\n\t\tthis.currentPoint.set( x, y );\r\n\r\n\t},\r\n\r\n\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\r\n\r\n\t\tvar curve = new QuadraticBezierCurve(\r\n\t\t\tthis.currentPoint.clone(),\r\n\t\t\tnew Vector2( aCPx, aCPy ),\r\n\t\t\tnew Vector2( aX, aY )\r\n\t\t);\r\n\r\n\t\tthis.curves.push( curve );\r\n\r\n\t\tthis.currentPoint.set( aX, aY );\r\n\r\n\t},\r\n\r\n\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\r\n\r\n\t\tvar curve = new CubicBezierCurve(\r\n\t\t\tthis.currentPoint.clone(),\r\n\t\t\tnew Vector2( aCP1x, aCP1y ),\r\n\t\t\tnew Vector2( aCP2x, aCP2y ),\r\n\t\t\tnew Vector2( aX, aY )\r\n\t\t);\r\n\r\n\t\tthis.curves.push( curve );\r\n\r\n\t\tthis.currentPoint.set( aX, aY );\r\n\r\n\t},\r\n\r\n\tsplineThru: function ( pts /*Array of Vector*/ ) {\r\n\r\n\t\tvar npts = [ this.currentPoint.clone() ].concat( pts );\r\n\r\n\t\tvar curve = new SplineCurve( npts );\r\n\t\tthis.curves.push( curve );\r\n\r\n\t\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\r\n\r\n\t},\r\n\r\n\tarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\t\tvar x0 = this.currentPoint.x;\r\n\t\tvar y0 = this.currentPoint.y;\r\n\r\n\t\tthis.absarc( aX + x0, aY + y0, aRadius,\r\n\t\t\taStartAngle, aEndAngle, aClockwise );\r\n\r\n\t},\r\n\r\n\tabsarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\r\n\r\n\t},\r\n\r\n\tellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\r\n\t\tvar x0 = this.currentPoint.x;\r\n\t\tvar y0 = this.currentPoint.y;\r\n\r\n\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\r\n\r\n\t},\r\n\r\n\tabsellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\r\n\t\tvar curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\r\n\r\n\t\tif ( this.curves.length > 0 ) {\r\n\r\n\t\t\t// if a previous curve is present, attempt to join\r\n\t\t\tvar firstPoint = curve.getPoint( 0 );\r\n\r\n\t\t\tif ( ! firstPoint.equals( this.currentPoint ) ) {\r\n\r\n\t\t\t\tthis.lineTo( firstPoint.x, firstPoint.y );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.curves.push( curve );\r\n\r\n\t\tvar lastPoint = curve.getPoint( 1 );\r\n\t\tthis.currentPoint.copy( lastPoint );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tCurvePath.prototype.copy.call( this, source );\r\n\r\n\t\tthis.currentPoint.copy( source.currentPoint );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar data = CurvePath.prototype.toJSON.call( this );\r\n\r\n\t\tdata.currentPoint = this.currentPoint.toArray();\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tfromJSON: function ( json ) {\r\n\r\n\t\tCurvePath.prototype.fromJSON.call( this, json );\r\n\r\n\t\tthis.currentPoint.fromArray( json.currentPoint );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/core/Shape.js\n\r\n\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Defines a 2d shape plane using paths.\r\n **/\r\n\r\n// STEP 1 Create a path.\r\n// STEP 2 Turn path into shape.\r\n// STEP 3 ExtrudeGeometry takes in Shape/Shapes\r\n// STEP 3a - Extract points from each shape, turn to vertices\r\n// STEP 3b - Triangulate each shape, add faces.\r\n\r\nfunction Shape( points ) {\r\n\r\n\tPath.call( this, points );\r\n\r\n\tthis.uuid = _Math.generateUUID();\r\n\r\n\tthis.type = 'Shape';\r\n\r\n\tthis.holes = [];\r\n\r\n}\r\n\r\nShape.prototype = Object.assign( Object.create( Path.prototype ), {\r\n\r\n\tconstructor: Shape,\r\n\r\n\tgetPointsHoles: function ( divisions ) {\r\n\r\n\t\tvar holesPts = [];\r\n\r\n\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\r\n\r\n\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\r\n\r\n\t\t}\r\n\r\n\t\treturn holesPts;\r\n\r\n\t},\r\n\r\n\t// get points of shape and holes (keypoints based on segments parameter)\r\n\r\n\textractPoints: function ( divisions ) {\r\n\r\n\t\treturn {\r\n\r\n\t\t\tshape: this.getPoints( divisions ),\r\n\t\t\tholes: this.getPointsHoles( divisions )\r\n\r\n\t\t};\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tPath.prototype.copy.call( this, source );\r\n\r\n\t\tthis.holes = [];\r\n\r\n\t\tfor ( var i = 0, l = source.holes.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar hole = source.holes[ i ];\r\n\r\n\t\t\tthis.holes.push( hole.clone() );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar data = Path.prototype.toJSON.call( this );\r\n\r\n\t\tdata.uuid = this.uuid;\r\n\t\tdata.holes = [];\r\n\r\n\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar hole = this.holes[ i ];\r\n\t\t\tdata.holes.push( hole.toJSON() );\r\n\r\n\t\t}\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tfromJSON: function ( json ) {\r\n\r\n\t\tPath.prototype.fromJSON.call( this, json );\r\n\r\n\t\tthis.uuid = json.uuid;\r\n\t\tthis.holes = [];\r\n\r\n\t\tfor ( var i = 0, l = json.holes.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar hole = json.holes[ i ];\r\n\t\t\tthis.holes.push( new Path().fromJSON( hole ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/core/TextGeometry.js\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass TextGeometry_TextGeometry {\r\n    constructor(param) {\r\n        param = param || {};\r\n\r\n        this.text = param.text == undefined ? '0' : param.text;\r\n\r\n        if(this.text == '2'){\r\n\r\n            var pts = [];\r\n\r\n            pts.push( new Vector2( 0, 10 ) );\r\n            pts.push( new Vector2( 5, 10 ) );\r\n            pts.push( new Vector2( 5, 4.5 ) );\r\n            pts.push( new Vector2( 1, 4.5 ) );\r\n            pts.push( new Vector2( 1, 1 ) );\r\n            pts.push( new Vector2( 5, 1 ) );\r\n            pts.push( new Vector2( 5, 0 ) );\r\n            pts.push( new Vector2( 0, 0 ) );\r\n            pts.push( new Vector2( 0, 5.5 ) );\r\n            pts.push( new Vector2( 4, 5.5 ) );\r\n            pts.push( new Vector2( 4, 9 ) );\r\n            pts.push( new Vector2( 0, 9 ) );\r\n\r\n            var shape = new Shape( pts );\r\n            var extrudeSettings = {\r\n                depth: 3,\r\n                steps: 1,\r\n                bevelEnabled: false,\r\n                bevelThickness: 2,\r\n                bevelSize: 4,\r\n                bevelSegments: 1\r\n            };\r\n            var extrudeGeometry = new ExtrudeBufferGeometry( shape, extrudeSettings );\r\n\r\n            var indices = [];\r\n            for(var i=0; i<extrudeGeometry.attributes.position.array.length/3; i++){\r\n                indices.push(i);\r\n            }\r\n\r\n            param.vertices = extrudeGeometry.attributes.position.array;\r\n            param.normal = extrudeGeometry.attributes.normal.array;\r\n            param.uv = extrudeGeometry.attributes.uv.array;\r\n            param.indices = indices;\r\n\r\n\r\n        }else if(this.text == '1'){\r\n\r\n            var pts = [];\r\n\r\n            pts.push( new Vector2( 4.5, 0 ) );\r\n            pts.push( new Vector2( 4.5, 10 ) );\r\n            pts.push( new Vector2( 5.5, 10 ) );\r\n            pts.push( new Vector2( 5.5, 0 ) );\r\n\r\n\r\n            var shape = new Shape( pts );\r\n            var extrudeSettings = {\r\n                depth: 3,\r\n                steps: 1,\r\n                bevelEnabled: false,\r\n                bevelThickness: 2,\r\n                bevelSize: 4,\r\n                bevelSegments: 1\r\n            };\r\n            var extrudeGeometry = new ExtrudeBufferGeometry( shape, extrudeSettings );\r\n\r\n            var indices = [];\r\n            for(var i=0; i<extrudeGeometry.attributes.position.array.length/3; i++){\r\n                indices.push(i);\r\n            }\r\n\r\n            param.vertices = extrudeGeometry.attributes.position.array;\r\n            param.normal = extrudeGeometry.attributes.normal.array;\r\n            param.uv = extrudeGeometry.attributes.uv.array;\r\n            param.indices = indices;\r\n\r\n\r\n        }else if(this.text == '3'){\r\n\r\n            var pts = [];\r\n\r\n            pts.push( new Vector2( 0, 0 ) );\r\n            pts.push( new Vector2( 0, 1 ) );\r\n            pts.push( new Vector2( 4, 1 ) );\r\n            pts.push( new Vector2( 4, 4.5 ) );\r\n            pts.push( new Vector2( 0, 4.5 ) );\r\n            pts.push( new Vector2( 0, 5.5 ) );\r\n            pts.push( new Vector2( 4, 5.5 ) );\r\n            pts.push( new Vector2( 4, 9 ) );\r\n            pts.push( new Vector2( 0, 9 ) );\r\n            pts.push( new Vector2( 0, 10 ) );\r\n            pts.push( new Vector2( 5, 10 ) );\r\n            pts.push( new Vector2( 5, 0 ) );\r\n            pts.push( new Vector2( 5, 0 ) );\r\n\r\n\r\n\r\n            var shape = new Shape( pts );\r\n            var extrudeSettings = {\r\n                depth: 3,\r\n                steps: 1,\r\n                bevelEnabled: false,\r\n                bevelThickness: 2,\r\n                bevelSize: 4,\r\n                bevelSegments: 1\r\n            };\r\n            var extrudeGeometry = new ExtrudeBufferGeometry( shape, extrudeSettings );\r\n\r\n            var indices = [];\r\n            for(var i=0; i<extrudeGeometry.attributes.position.array.length/3; i++){\r\n                indices.push(i);\r\n            }\r\n\r\n            param.vertices = extrudeGeometry.attributes.position.array;\r\n            param.normal = extrudeGeometry.attributes.normal.array;\r\n            param.uv = extrudeGeometry.attributes.uv.array;\r\n            param.indices = indices;\r\n\r\n\r\n        }else if(this.text == '4'){\r\n\r\n            var pts = [];\r\n\r\n            pts.push( new Vector2( 0, 10 ) );\r\n            pts.push( new Vector2( 1, 10 ) );\r\n            pts.push( new Vector2( 1, 5.5 ) );\r\n            pts.push( new Vector2( 4, 5.5 ) );\r\n            pts.push( new Vector2( 4, 10 ) );\r\n            pts.push( new Vector2( 5, 10 ) );\r\n            pts.push( new Vector2( 5, 0 ) );\r\n            pts.push( new Vector2( 4, 0 ) );\r\n            pts.push( new Vector2( 4, 4.5 ) );\r\n            pts.push( new Vector2( 0, 4.5 ) );\r\n\r\n\r\n            var shape = new Shape( pts );\r\n            var extrudeSettings = {\r\n                depth: 3,\r\n                steps: 1,\r\n                bevelEnabled: false,\r\n                bevelThickness: 2,\r\n                bevelSize: 4,\r\n                bevelSegments: 1\r\n            };\r\n            var extrudeGeometry = new ExtrudeBufferGeometry( shape, extrudeSettings );\r\n\r\n            var indices = [];\r\n            for(var i=0; i<extrudeGeometry.attributes.position.array.length/3; i++){\r\n                indices.push(i);\r\n            }\r\n\r\n            param.vertices = extrudeGeometry.attributes.position.array;\r\n            param.normal = extrudeGeometry.attributes.normal.array;\r\n            param.uv = extrudeGeometry.attributes.uv.array;\r\n            param.indices = indices;\r\n\r\n\r\n        }else if(this.text == '5'){\r\n\r\n            var pts = [];\r\n\r\n            pts.push( new Vector2( 0, 0 ) );\r\n            pts.push( new Vector2( 0, 1 ) );\r\n            pts.push( new Vector2( 4, 1 ) );\r\n            pts.push( new Vector2( 4, 4.5 ) );\r\n            pts.push( new Vector2( 0, 4.5 ) );\r\n            pts.push( new Vector2( 0, 10 ) );\r\n            pts.push( new Vector2( 5, 10 ) );\r\n            pts.push( new Vector2( 5, 9 ) );\r\n            pts.push( new Vector2( 1, 9 ) );\r\n            pts.push( new Vector2( 1, 5.5 ) );\r\n            pts.push( new Vector2( 5, 5.5 ) );\r\n            pts.push( new Vector2( 5, 0 ) );\r\n\r\n\r\n            var shape = new Shape( pts );\r\n            var extrudeSettings = {\r\n                depth: 3,\r\n                steps: 1,\r\n                bevelEnabled: false,\r\n                bevelThickness: 2,\r\n                bevelSize: 4,\r\n                bevelSegments: 1\r\n            };\r\n            var extrudeGeometry = new ExtrudeBufferGeometry( shape, extrudeSettings );\r\n\r\n            var indices = [];\r\n            for(var i=0; i<extrudeGeometry.attributes.position.array.length/3; i++){\r\n                indices.push(i);\r\n            }\r\n\r\n            param.vertices = extrudeGeometry.attributes.position.array;\r\n            param.normal = extrudeGeometry.attributes.normal.array;\r\n            param.uv = extrudeGeometry.attributes.uv.array;\r\n            param.indices = indices;\r\n        }else if(this.text == '6'){\r\n\r\n            var pts = [];\r\n\r\n            pts.push( new Vector2( 5, 10 ) );\r\n            pts.push( new Vector2( 0, 10 ) );\r\n            pts.push( new Vector2( 0, 0 ) );\r\n            pts.push( new Vector2( 5, 0 ) );\r\n            pts.push( new Vector2( 5, 5.5 ) );\r\n            pts.push( new Vector2( 1, 5.5 ) );\r\n            pts.push( new Vector2( 1, 4.5 ) );\r\n            pts.push( new Vector2( 4, 4.5 ) );\r\n            pts.push( new Vector2( 4, 1 ) );\r\n            pts.push( new Vector2( 1, 1 ) );\r\n            pts.push( new Vector2( 1, 9 ) );\r\n            pts.push( new Vector2( 5, 9 ) );\r\n\r\n\r\n\r\n            var shape = new Shape( pts );\r\n            var extrudeSettings = {\r\n                depth: 3,\r\n                steps: 1,\r\n                bevelEnabled: false,\r\n                bevelThickness: 2,\r\n                bevelSize: 4,\r\n                bevelSegments: 1\r\n            };\r\n            var extrudeGeometry = new ExtrudeBufferGeometry( shape, extrudeSettings );\r\n\r\n            var indices = [];\r\n            for(var i=0; i<extrudeGeometry.attributes.position.array.length/3; i++){\r\n                indices.push(i);\r\n            }\r\n\r\n            param.vertices = extrudeGeometry.attributes.position.array;\r\n            param.normal = extrudeGeometry.attributes.normal.array;\r\n            param.uv = extrudeGeometry.attributes.uv.array;\r\n            param.indices = indices;\r\n        }else if(this.text == '7'){\r\n\r\n            var pts = [];\r\n\r\n            pts.push( new Vector2( 0, 10 ) );\r\n            pts.push( new Vector2( 5, 10 ) );\r\n            pts.push( new Vector2( 5, 0 ) );\r\n            pts.push( new Vector2( 4, 0 ) );\r\n            pts.push( new Vector2( 4, 9 ) );\r\n            pts.push( new Vector2( 0, 9 ) );\r\n\r\n\r\n            var shape = new Shape( pts );\r\n            var extrudeSettings = {\r\n                depth: 3,\r\n                steps: 1,\r\n                bevelEnabled: false,\r\n                bevelThickness: 2,\r\n                bevelSize: 4,\r\n                bevelSegments: 1\r\n            };\r\n            var extrudeGeometry = new ExtrudeBufferGeometry( shape, extrudeSettings );\r\n\r\n            var indices = [];\r\n            for(var i=0; i<extrudeGeometry.attributes.position.array.length/3; i++){\r\n                indices.push(i);\r\n            }\r\n\r\n            param.vertices = extrudeGeometry.attributes.position.array;\r\n            param.normal = extrudeGeometry.attributes.normal.array;\r\n            param.uv = extrudeGeometry.attributes.uv.array;\r\n            param.indices = indices;\r\n        }else if(this.text == '8'){\r\n\r\n            var pts = [];\r\n\r\n            pts.push( new Vector2( 5, 10 ) );\r\n            pts.push( new Vector2( 0, 10 ) );\r\n            pts.push( new Vector2( 0, 0 ) );\r\n            pts.push( new Vector2( 5, 0 ) );\r\n\r\n            pts.push( new Vector2( 5, 9 ) );\r\n            pts.push( new Vector2( 4, 9 ) );\r\n            pts.push( new Vector2( 4, 5.5 ) );\r\n            pts.push( new Vector2( 1, 5.5 ) );\r\n\r\n            pts.push( new Vector2( 1, 4.5 ) );\r\n            pts.push( new Vector2( 4, 4.5 ) );\r\n            pts.push( new Vector2( 4, 1 ) );\r\n            pts.push( new Vector2( 1, 1 ) );\r\n            pts.push( new Vector2( 1, 9 ) );\r\n            pts.push( new Vector2( 5, 9 ) );\r\n\r\n\r\n            var shape = new Shape( pts );\r\n            var extrudeSettings = {\r\n                depth: 3,\r\n                steps: 1,\r\n                bevelEnabled: false,\r\n                bevelThickness: 2,\r\n                bevelSize: 4,\r\n                bevelSegments: 1\r\n            };\r\n            var extrudeGeometry = new ExtrudeBufferGeometry( shape, extrudeSettings );\r\n\r\n            var indices = [];\r\n            for(var i=0; i<extrudeGeometry.attributes.position.array.length/3; i++){\r\n                indices.push(i);\r\n            }\r\n\r\n            param.vertices = extrudeGeometry.attributes.position.array;\r\n            param.normal = extrudeGeometry.attributes.normal.array;\r\n            param.uv = extrudeGeometry.attributes.uv.array;\r\n            param.indices = indices;\r\n        }else if(this.text == '9'){\r\n\r\n            var pts = [];\r\n\r\n            pts.push( new Vector2( 0, 10 ) );\r\n            pts.push( new Vector2( 1, 10 ) );\r\n            pts.push( new Vector2( 1, 5.5 ) );\r\n            pts.push( new Vector2( 4, 5.5 ) );\r\n\r\n            pts.push( new Vector2( 4, 9 ) );\r\n            pts.push( new Vector2( 1, 9 ) );\r\n            pts.push( new Vector2( 1, 10 ) );\r\n            pts.push( new Vector2( 5, 10 ) );\r\n\r\n            pts.push( new Vector2( 5, 0 ) );\r\n            pts.push( new Vector2( 4, 0 ) );\r\n            pts.push( new Vector2( 4, 4.5 ) );\r\n            pts.push( new Vector2( 0, 4.5 ) );\r\n\r\n\r\n            var shape = new Shape( pts );\r\n            var extrudeSettings = {\r\n                depth: 3,\r\n                steps: 1,\r\n                bevelEnabled: false,\r\n                bevelThickness: 2,\r\n                bevelSize: 4,\r\n                bevelSegments: 1\r\n            };\r\n            var extrudeGeometry = new ExtrudeBufferGeometry( shape, extrudeSettings );\r\n\r\n            var indices = [];\r\n            for(var i=0; i<extrudeGeometry.attributes.position.array.length/3; i++){\r\n                indices.push(i);\r\n            }\r\n\r\n            param.vertices = extrudeGeometry.attributes.position.array;\r\n            param.normal = extrudeGeometry.attributes.normal.array;\r\n            param.uv = extrudeGeometry.attributes.uv.array;\r\n            param.indices = indices;\r\n        }else if(this.text == '0'){\r\n\r\n            var pts = [];\r\n\r\n            pts.push( new Vector2( 5, 10 ) );\r\n            pts.push( new Vector2( 0, 10 ) );\r\n            pts.push( new Vector2( 0, 0 ) );\r\n            pts.push( new Vector2( 5, 0 ) );\r\n\r\n            pts.push( new Vector2( 5, 9 ) );\r\n            pts.push( new Vector2( 4, 9 ) );\r\n            pts.push( new Vector2( 4, 1 ) );\r\n            pts.push( new Vector2( 1, 1 ) );\r\n\r\n            pts.push( new Vector2( 1, 9 ) );\r\n            pts.push( new Vector2( 5, 9 ) );\r\n\r\n\r\n            var shape = new Shape( pts );\r\n            var extrudeSettings = {\r\n                depth: 3,\r\n                steps: 1,\r\n                bevelEnabled: false,\r\n                bevelThickness: 2,\r\n                bevelSize: 4,\r\n                bevelSegments: 1\r\n            };\r\n            var extrudeGeometry = new ExtrudeBufferGeometry( shape, extrudeSettings );\r\n\r\n            var indices = [];\r\n            for(var i=0; i<extrudeGeometry.attributes.position.array.length/3; i++){\r\n                indices.push(i);\r\n            }\r\n\r\n            param.vertices = extrudeGeometry.attributes.position.array;\r\n            param.normal = extrudeGeometry.attributes.normal.array;\r\n            param.uv = extrudeGeometry.attributes.uv.array;\r\n            param.indices = indices;\r\n        }\r\n\r\n        this.uv = param.uv || new Float32Array([   // Vertex coordinates\r\n\r\n            1,1, 0,1, 0,0, 1,0,  // v0-v1-v2-v3 front\r\n            0,1, 0,0, 1,0, 1,1,  // v0-v3-v4-v5 right\r\n            1,0, 1,1, 0,1, 0,0,  // v0-v5-v6-v1 up\r\n            1,1, 0,1, 0,0, 1,0,  // v1-v6-v7-v2 left\r\n            0,1, 1,1, 1,0, 0,0,  // v7-v4-v3-v2 down\r\n            1,0, 0,0, 0,1, 1,1   // v4-v7-v6-v5 back\r\n\r\n        ]);\r\n\r\n        this.vertices = param.vertices || new Float32Array([   // Vertex coordinates\r\n            0.5, 0.5, 0.5,  -0.5, 0.5, 0.5,  -0.5,-0.5, 0.5,   0.5,-0.5, 0.5,  // v0-v1-v2-v3 front\r\n            0.5, 0.5, 0.5,   0.5,-0.5, 0.5,   0.5,-0.5,-0.5,   0.5, 0.5,-0.5,  // v0-v3-v4-v5 right\r\n            0.5, 0.5, 0.5,   0.5, 0.5,-0.5,  -0.5, 0.5,-0.5,  -0.5, 0.5, 0.5,  // v0-v5-v6-v1 up\r\n            -0.5, 0.5, 0.5,  -0.5, 0.5,-0.5,  -0.5,-0.5,-0.5,  -0.5,-0.5, 0.5,  // v1-v6-v7-v2 left\r\n            -0.5,-0.5,-0.5,   0.5,-0.5,-0.5,   0.5,-0.5, 0.5,  -0.5,-0.5, 0.5,  // v7-v4-v3-v2 down\r\n            0.5,-0.5,-0.5,  -0.5,-0.5,-0.5,  -0.5, 0.5,-0.5,   0.5, 0.5,-0.5   // v4-v7-v6-v5 back\r\n        ]);\r\n\r\n        this.normal = param.normal || this.vertices;\r\n\r\n        this.indices = new Uint16Array(param.indices);\r\n\r\n        this.morphAttributes = param.morphAttributes;\r\n\r\n        this.boundingSphere = new Sphere();\r\n        this.boundingBox = new Box3();\r\n        this.computeBoundingBox();\r\n\r\n        // this.updateNormal();\r\n\r\n        this.updataBuffer();\r\n\r\n    }\r\n\r\n    updataBuffer(){\r\n        var buffer = [];\r\n        var uv = this.uv;\r\n        var vertices = this.vertices;\r\n        var normal = this.normal;\r\n        for(var i=0; i<vertices.length; i+=3){\r\n            buffer.push(vertices[i+0]);\r\n            buffer.push(vertices[i+1]);\r\n            buffer.push(vertices[i+2]);\r\n\r\n            buffer.push(normal[i+0]);\r\n            buffer.push(normal[i+1]);\r\n            buffer.push(normal[i+2]);\r\n\r\n            buffer.push(uv[i/3*2+0]);\r\n            buffer.push(uv[i/3*2+1]);\r\n        }\r\n\r\n        this.buffer = new Float32Array(buffer);\r\n    }\r\n\r\n    updateNormal(){\r\n        var normal = [];\r\n        var vertices = this.vertices;\r\n        for(var i=0; i<vertices.length; i+=3*4){\r\n            var line1 = new Vector3().subVectors(\r\n                new Vector3(vertices[i+0], vertices[i+1], vertices[i+2]),\r\n                new Vector3(vertices[i+3], vertices[i+4], vertices[i+5])\r\n            );\r\n            var line2 = new Vector3().subVectors(\r\n                new Vector3(vertices[i+3], vertices[i+4], vertices[i+5]),\r\n                new Vector3(vertices[i+6], vertices[i+7], vertices[i+8]),\r\n            );\r\n            var cur_normal = new Vector3().crossVectors(\r\n                line1,\r\n                line2\r\n            ).toArray();\r\n            for(var j=0 ;j<4; j++){\r\n                normal.push(cur_normal[0], cur_normal[1], cur_normal[2]);\r\n            }\r\n        }\r\n        this.normal = new Float32Array(normal);\r\n\r\n    }\r\n\r\n    computeBoundingBox () {\r\n        var verticesV3 = [];\r\n        for(var i=0; i<this.vertices.length; i+=3){\r\n            verticesV3.push(new Vector3(this.vertices[i], this.vertices[i+1], this.vertices[i+2]))\r\n        }\r\n        this.boundingBox.setFromPoints(verticesV3);\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ var core_TextGeometry = (TextGeometry_TextGeometry);\r\n\n// CONCATENATED MODULE: ./src/material/CubeTexture.js\n\r\n\r\nclass CubeTexture_CubeTexture extends material_Texture{\r\n    constructor(param) {\r\n        super(param);\r\n\r\n        param = param || {};\r\n        this.urls = param.urls;\r\n\r\n        this.images = [];\r\n        this.imgLoadCount = 0;\r\n        this.imgReady = false;\r\n\r\n        var that = this;\r\n        var urls = this.urls;\r\n        for(var i in urls){\r\n            var image = new Image();\r\n            that.images.push(image);\r\n            image.addEventListener('load', function() {\r\n                that.imgLoadCount ++;\r\n                if(that.imgLoadCount == 6){\r\n                    that.imgReady = true;\r\n                }\r\n            });\r\n            image.src = urls[i];\r\n        }\r\n\r\n    }\r\n\r\n    clone(){\r\n\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ var material_CubeTexture = (CubeTexture_CubeTexture);\r\n\n// CONCATENATED MODULE: ./src/main.js\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// import _GLTFLoader from \"./core/GLTFLoader\";\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar main_COOL = window.COOL = {};\r\n\r\nmain_COOL.LINEAR = 9729;\r\nmain_COOL.NEAREST = 9728;\r\n\r\nmain_COOL.CLAMP_TO_EDGE = 33071;\r\nmain_COOL.REPEAT = 10497;\r\nmain_COOL.MIRRORED_REPEAT = 33648;\r\n\r\nmain_COOL.Renderer = core_Renderer;\r\nmain_COOL.Mesh = core_Mesh;\r\nmain_COOL.Camera = camera_Camera;\r\nmain_COOL.OrthoCamera = camera_OrthoCamera;\r\nmain_COOL.CameraController = camera_CameraController;\r\nmain_COOL.Scene = core_Scene;\r\nmain_COOL.Material = material_Material;\r\nmain_COOL.MeshBasicMaterial = material_MeshBasicMaterial;\r\nmain_COOL.MeshLambertMaterial = material_MeshLambertMaterial;\r\nmain_COOL.MeshStandardMaterial = material_MeshStandardMaterial;\r\n\r\nmain_COOL.Texture = material_Texture;\r\nmain_COOL.CubeTexture = material_CubeTexture;\r\n\r\nmain_COOL.AmbientLight = light_AmbientLight;\r\nmain_COOL.DirectionalLight = light_DirectionalLight;\r\n\r\nmain_COOL.Geometry = core_Geometry;\r\nmain_COOL.BoxGeometry = core_BoxGeometry;\r\nmain_COOL.SphereGeometry = core_SphereGeometry;\r\n\r\n// COOL.GLTFLoader = _GLTFLoader;\r\nmain_COOL.GLTFLoader2 = GLTFLoader2;\r\n\r\nmain_COOL.Animation = animation_Animation;\r\n\r\nmain_COOL.Raycaster = Raycaster;\r\n\r\nmain_COOL.Vector2 = Vector2;\r\nmain_COOL.Vector3 = Vector3;\r\n\r\nmain_COOL.ExtrudeGeometry = ExtrudeGeometry;\r\nmain_COOL.ExtrudeBufferGeometry = ExtrudeBufferGeometry;\r\nmain_COOL.TextGeometry = core_TextGeometry;\r\nmain_COOL.Shape = Shape;\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tYXRoL01hdGguanM/NWRiMCIsIndlYnBhY2s6Ly8vLi9zcmMvbWF0aC9NYXRyaXg0LmpzPzQ3ZWIiLCJ3ZWJwYWNrOi8vLy4vc3JjL21hdGgvUXVhdGVybmlvbi5qcz9kOGVlIiwid2VicGFjazovLy8uL3NyYy9tYXRoL1ZlY3RvcjMuanM/MWIyOCIsIndlYnBhY2s6Ly8vLi9zcmMvbWF0aC9Cb3gzLmpzPzYxZDEiLCJ3ZWJwYWNrOi8vLy4vc3JjL21hdGgvU3BoZXJlLmpzP2VmYjkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvR2VvbWV0cnkuanM/ZmFkZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9Cb3hHZW9tZXRyeS5qcz9hN2NmIiwid2VicGFjazovLy8uL3NyYy9tYXRlcmlhbC9NYXRlcmlhbC5qcz83MTcwIiwid2VicGFjazovLy8uL3NyYy9tYXRoL0V1bGVyLmpzP2U4MGIiLCJ3ZWJwYWNrOi8vLy4vc3JjL21hdGgvVmVjdG9yMi5qcz8wMjBkIiwid2VicGFjazovLy8uL3NyYy9tYXRoL1JheS5qcz83Y2QzIiwid2VicGFjazovLy8uL3NyYy9tYXRoL1RyaWFuZ2xlLmpzPzcxYzgiLCJ3ZWJwYWNrOi8vLy4vc3JjL21hdGgvQ29sb3IuanM/MGQ3ZCIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9GYWNlMy5qcz81ZWU1Iiwid2VicGFjazovLy8uL3NyYy9jb3JlL01lc2guanM/MmEyZiIsIndlYnBhY2s6Ly8vLi9zcmMvY2FtZXJhL0NhbWVyYS5qcz9lMjFkIiwid2VicGFjazovLy8uL3NyYy91dGlsL3dlYmdsLXV0aWxzLmpzPzRhMzEiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvd2ViZ2wtZGVidWcuanM/YzJhMyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC9VdGlsLmpzPzQyZGIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpZ2h0L0xpZ2h0LmpzP2ViMjMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpZ2h0L0FtYmllbnRMaWdodC5qcz9jZDIwIiwid2VicGFjazovLy8uL3NyYy9saWdodC9EaXJlY3Rpb25hbExpZ2h0LmpzPzA0OTUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvc2VyL0NvbXBvc2VyLmpzPzM4NzUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvc2VyL0NvbXBvc2VyT3RoZXJzLmpzP2NhY2MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvc2VyL0NvbXBvc2VyU2NoZW1lLmpzPzE1OWQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvUmVuZGVyZXIuanM/OGIxNSIsIndlYnBhY2s6Ly8vLi9zcmMvY2FtZXJhL0NhbWVyYUNvbnRyb2xsZXIuanM/ZTA2OCIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9TY2VuZS5qcz84NWNhIiwid2VicGFjazovLy8uL3NyYy9tYXRlcmlhbC9UZXh0dXJlLmpzPzRjMGYiLCJ3ZWJwYWNrOi8vLy4vc3JjL21hdGVyaWFsL01lc2hCYXNpY01hdGVyaWFsLmpzP2JmZTQiLCJ3ZWJwYWNrOi8vLy4vc3JjL21hdGVyaWFsL01lc2hMYW1iZXJ0TWF0ZXJpYWwuanM/NDM2ZCIsIndlYnBhY2s6Ly8vLi9zcmMvbWF0ZXJpYWwvTWVzaFN0YW5kYXJkTWF0ZXJpYWwuanM/MjdiMSIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9TcGhlcmVHZW9tZXRyeS5qcz8zNWFjIiwid2VicGFjazovLy8uL3NyYy9jb3JlL0dMVEZMb2FkZXIyLmpzPzc2MjciLCJ3ZWJwYWNrOi8vLy4vc3JjL2NhbWVyYS9PcnRob0NhbWVyYS5qcz8zYTU2Iiwid2VicGFjazovLy8uL3NyYy9hbmltYXRpb24vQW5pbWF0aW9uLmpzP2ViODYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvUmF5Y2FzdGVyLmpzP2JmYjIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xvYWRlci9FdmVudERpc3BhdGNoZXIuanM/NGEwMiIsIndlYnBhY2s6Ly8vLi9zcmMvbG9hZGVyL0ZhY2UzLmpzPzAzNzMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21hdGgvTWF0cml4My5qcz80ZWNkIiwid2VicGFjazovLy8uL3NyYy9sb2FkZXIvTGF5ZXJzLmpzPzA5ZDEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xvYWRlci9PYmplY3QzRC5qcz8yYTUwIiwid2VicGFjazovLy8uL3NyYy9sb2FkZXIvR2VvbWV0cnkuanM/MWFmMCIsIndlYnBhY2s6Ly8vLi9zcmMvbWF0aC9WZWN0b3I0LmpzP2RiYTkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xvYWRlci9CdWZmZXJBdHRyaWJ1dGUuanM/NjNlYSIsIndlYnBhY2s6Ly8vLi9zcmMvbG9hZGVyL0RpcmVjdEdlb21ldHJ5LmpzP2NlNWIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xvYWRlci91dGlscy5qcz9hYmQ4Iiwid2VicGFjazovLy8uL3NyYy9sb2FkZXIvQnVmZmVyR2VvbWV0cnkuanM/MzI0NSIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0cmFzL0VhcmN1dC5qcz84NTI4Iiwid2VicGFjazovLy8uL3NyYy9leHRyYXMvU2hhcGVVdGlscy5qcz84N2UyIiwid2VicGFjazovLy8uL3NyYy9sb2FkZXIvRXh0cnVkZUdlb21ldHJ5LmpzP2JjMjYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dHJhcy9jb3JlL0N1cnZlLmpzP2JjYjUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dHJhcy9jdXJ2ZXMvRWxsaXBzZUN1cnZlLmpzPzc5ZTciLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dHJhcy9jdXJ2ZXMvQXJjQ3VydmUuanM/MTJiZiIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0cmFzL2N1cnZlcy9DYXRtdWxsUm9tQ3VydmUzLmpzPzYyMGQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dHJhcy9jb3JlL0ludGVycG9sYXRpb25zLmpzP2NhYWEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dHJhcy9jdXJ2ZXMvQ3ViaWNCZXppZXJDdXJ2ZS5qcz9iMmE4Iiwid2VicGFjazovLy8uL3NyYy9leHRyYXMvY3VydmVzL0N1YmljQmV6aWVyQ3VydmUzLmpzPzhjYzkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dHJhcy9jdXJ2ZXMvTGluZUN1cnZlLmpzPzM3Y2YiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dHJhcy9jdXJ2ZXMvTGluZUN1cnZlMy5qcz8xMWE1Iiwid2VicGFjazovLy8uL3NyYy9leHRyYXMvY3VydmVzL1F1YWRyYXRpY0JlemllckN1cnZlLmpzPzM2MGYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dHJhcy9jdXJ2ZXMvUXVhZHJhdGljQmV6aWVyQ3VydmUzLmpzP2E0N2EiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dHJhcy9jdXJ2ZXMvU3BsaW5lQ3VydmUuanM/ZDE1YyIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0cmFzL2N1cnZlcy9DdXJ2ZXMuanM/ZmYyOSIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0cmFzL2NvcmUvQ3VydmVQYXRoLmpzP2NmOTIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dHJhcy9jb3JlL1BhdGguanM/MGYyOSIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0cmFzL2NvcmUvU2hhcGUuanM/NmJhZiIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9UZXh0R2VvbWV0cnkuanM/YmNiMyIsIndlYnBhY2s6Ly8vLi9zcmMvbWF0ZXJpYWwvQ3ViZVRleHR1cmUuanM/ZjM5NiIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcz81NmQ3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcbnZhciBfTWF0aCA9IHtcclxuXHJcblx0REVHMlJBRDogTWF0aC5QSSAvIDE4MCxcclxuXHRSQUQyREVHOiAxODAgLyBNYXRoLlBJLFxyXG5cclxuXHRnZW5lcmF0ZVVVSUQ6ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA1MDM0L2hvdy10by1jcmVhdGUtYS1ndWlkLXV1aWQtaW4tamF2YXNjcmlwdC8yMTk2MzEzNiMyMTk2MzEzNlxyXG5cclxuXHRcdHZhciBsdXQgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCAyNTY7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRsdXRbIGkgXSA9ICggaSA8IDE2ID8gJzAnIDogJycgKSArICggaSApLnRvU3RyaW5nKCAxNiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKCkge1xyXG5cclxuXHRcdFx0dmFyIGQwID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xyXG5cdFx0XHR2YXIgZDEgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XHJcblx0XHRcdHZhciBkMiA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcclxuXHRcdFx0dmFyIGQzID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xyXG5cdFx0XHR2YXIgdXVpZCA9IGx1dFsgZDAgJiAweGZmIF0gKyBsdXRbIGQwID4+IDggJiAweGZmIF0gKyBsdXRbIGQwID4+IDE2ICYgMHhmZiBdICsgbHV0WyBkMCA+PiAyNCAmIDB4ZmYgXSArICctJyArXHJcblx0XHRcdFx0bHV0WyBkMSAmIDB4ZmYgXSArIGx1dFsgZDEgPj4gOCAmIDB4ZmYgXSArICctJyArIGx1dFsgZDEgPj4gMTYgJiAweDBmIHwgMHg0MCBdICsgbHV0WyBkMSA+PiAyNCAmIDB4ZmYgXSArICctJyArXHJcblx0XHRcdFx0bHV0WyBkMiAmIDB4M2YgfCAweDgwIF0gKyBsdXRbIGQyID4+IDggJiAweGZmIF0gKyAnLScgKyBsdXRbIGQyID4+IDE2ICYgMHhmZiBdICsgbHV0WyBkMiA+PiAyNCAmIDB4ZmYgXSArXHJcblx0XHRcdFx0bHV0WyBkMyAmIDB4ZmYgXSArIGx1dFsgZDMgPj4gOCAmIDB4ZmYgXSArIGx1dFsgZDMgPj4gMTYgJiAweGZmIF0gKyBsdXRbIGQzID4+IDI0ICYgMHhmZiBdO1xyXG5cclxuXHRcdFx0Ly8gLnRvVXBwZXJDYXNlKCkgaGVyZSBmbGF0dGVucyBjb25jYXRlbmF0ZWQgc3RyaW5ncyB0byBzYXZlIGhlYXAgbWVtb3J5IHNwYWNlLlxyXG5cdFx0XHRyZXR1cm4gdXVpZC50b1VwcGVyQ2FzZSgpO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0gKSgpLFxyXG5cclxuXHRjbGFtcDogZnVuY3Rpb24gKCB2YWx1ZSwgbWluLCBtYXggKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIHZhbHVlICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gY29tcHV0ZSBldWNsaWRpYW4gbW9kdWxvIG9mIG0gJSBuXHJcblx0Ly8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9kdWxvX29wZXJhdGlvblxyXG5cclxuXHRldWNsaWRlYW5Nb2R1bG86IGZ1bmN0aW9uICggbiwgbSApIHtcclxuXHJcblx0XHRyZXR1cm4gKCAoIG4gJSBtICkgKyBtICkgJSBtO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBMaW5lYXIgbWFwcGluZyBmcm9tIHJhbmdlIDxhMSwgYTI+IHRvIHJhbmdlIDxiMSwgYjI+XHJcblxyXG5cdG1hcExpbmVhcjogZnVuY3Rpb24gKCB4LCBhMSwgYTIsIGIxLCBiMiApIHtcclxuXHJcblx0XHRyZXR1cm4gYjEgKyAoIHggLSBhMSApICogKCBiMiAtIGIxICkgLyAoIGEyIC0gYTEgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZWFyX2ludGVycG9sYXRpb25cclxuXHJcblx0bGVycDogZnVuY3Rpb24gKCB4LCB5LCB0ICkge1xyXG5cclxuXHRcdHJldHVybiAoIDEgLSB0ICkgKiB4ICsgdCAqIHk7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU21vb3Roc3RlcFxyXG5cclxuXHRzbW9vdGhzdGVwOiBmdW5jdGlvbiAoIHgsIG1pbiwgbWF4ICkge1xyXG5cclxuXHRcdGlmICggeCA8PSBtaW4gKSByZXR1cm4gMDtcclxuXHRcdGlmICggeCA+PSBtYXggKSByZXR1cm4gMTtcclxuXHJcblx0XHR4ID0gKCB4IC0gbWluICkgLyAoIG1heCAtIG1pbiApO1xyXG5cclxuXHRcdHJldHVybiB4ICogeCAqICggMyAtIDIgKiB4ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNtb290aGVyc3RlcDogZnVuY3Rpb24gKCB4LCBtaW4sIG1heCApIHtcclxuXHJcblx0XHRpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XHJcblx0XHRpZiAoIHggPj0gbWF4ICkgcmV0dXJuIDE7XHJcblxyXG5cdFx0eCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcclxuXHJcblx0XHRyZXR1cm4geCAqIHggKiB4ICogKCB4ICogKCB4ICogNiAtIDE1ICkgKyAxMCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBSYW5kb20gaW50ZWdlciBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXHJcblxyXG5cdHJhbmRJbnQ6IGZ1bmN0aW9uICggbG93LCBoaWdoICkge1xyXG5cclxuXHRcdHJldHVybiBsb3cgKyBNYXRoLmZsb29yKCBNYXRoLnJhbmRvbSgpICogKCBoaWdoIC0gbG93ICsgMSApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIFJhbmRvbSBmbG9hdCBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXHJcblxyXG5cdHJhbmRGbG9hdDogZnVuY3Rpb24gKCBsb3csIGhpZ2ggKSB7XHJcblxyXG5cdFx0cmV0dXJuIGxvdyArIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gUmFuZG9tIGZsb2F0IGZyb20gPC1yYW5nZS8yLCByYW5nZS8yPiBpbnRlcnZhbFxyXG5cclxuXHRyYW5kRmxvYXRTcHJlYWQ6IGZ1bmN0aW9uICggcmFuZ2UgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHJhbmdlICogKCAwLjUgLSBNYXRoLnJhbmRvbSgpICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRlZ1RvUmFkOiBmdW5jdGlvbiAoIGRlZ3JlZXMgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGRlZ3JlZXMgKiBfTWF0aC5ERUcyUkFEO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyYWRUb0RlZzogZnVuY3Rpb24gKCByYWRpYW5zICkge1xyXG5cclxuXHRcdHJldHVybiByYWRpYW5zICogX01hdGguUkFEMkRFRztcclxuXHJcblx0fSxcclxuXHJcblx0aXNQb3dlck9mVHdvOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHJldHVybiAoIHZhbHVlICYgKCB2YWx1ZSAtIDEgKSApID09PSAwICYmIHZhbHVlICE9PSAwO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjZWlsUG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5wb3coIDIsIE1hdGguY2VpbCggTWF0aC5sb2coIHZhbHVlICkgLyBNYXRoLkxOMiApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZsb29yUG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5wb3coIDIsIE1hdGguZmxvb3IoIE1hdGgubG9nKCB2YWx1ZSApIC8gTWF0aC5MTjIgKSApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuXHJcbmV4cG9ydCB7IF9NYXRoIH07XHJcbiIsImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuL1ZlY3RvcjMuanMnO1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3Igc3VwZXJlZ2diZXJ0IC8gaHR0cDovL3d3dy5wYXVsYnJ1bnQuY28udWsvXHJcbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXHJcbiAqIEBhdXRob3Igam9yZGlfcm9zIC8gaHR0cDovL3BsYXR0c29mdC5jb21cclxuICogQGF1dGhvciBEMXBsbzFkIC8gaHR0cDovL2dpdGh1Yi5jb20vRDFwbG8xZFxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIHRpbWtuaXAgLyBodHRwOi8vd3d3LmZsb29ycGxhbm5lci5jb20vXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gTWF0cml4NCgpIHtcclxuXHJcblx0dGhpcy5lbGVtZW50cyA9IFtcclxuXHJcblx0XHQxLCAwLCAwLCAwLFxyXG5cdFx0MCwgMSwgMCwgMCxcclxuXHRcdDAsIDAsIDEsIDAsXHJcblx0XHQwLCAwLCAwLCAxXHJcblxyXG5cdF07XHJcblxyXG5cdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0Y29uc29sZS5lcnJvciggJ0NPT0wuTWF0cml4NDogdGhlIGNvbnN0cnVjdG9yIG5vIGxvbmdlciByZWFkcyBhcmd1bWVudHMuIHVzZSAuc2V0KCkgaW5zdGVhZC4nICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbk9iamVjdC5hc3NpZ24oIE1hdHJpeDQucHJvdG90eXBlLCB7XHJcblxyXG5cdGlzTWF0cml4NDogdHJ1ZSxcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIG4xMSwgbjEyLCBuMTMsIG4xNCwgbjIxLCBuMjIsIG4yMywgbjI0LCBuMzEsIG4zMiwgbjMzLCBuMzQsIG40MSwgbjQyLCBuNDMsIG40NCApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRlWyAwIF0gPSBuMTE7IHRlWyA0IF0gPSBuMTI7IHRlWyA4IF0gPSBuMTM7IHRlWyAxMiBdID0gbjE0O1xyXG5cdFx0dGVbIDEgXSA9IG4yMTsgdGVbIDUgXSA9IG4yMjsgdGVbIDkgXSA9IG4yMzsgdGVbIDEzIF0gPSBuMjQ7XHJcblx0XHR0ZVsgMiBdID0gbjMxOyB0ZVsgNiBdID0gbjMyOyB0ZVsgMTAgXSA9IG4zMzsgdGVbIDE0IF0gPSBuMzQ7XHJcblx0XHR0ZVsgMyBdID0gbjQxOyB0ZVsgNyBdID0gbjQyOyB0ZVsgMTEgXSA9IG40MzsgdGVbIDE1IF0gPSBuNDQ7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG4gICAgc2V0SWRlbnRpdHkgOmZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBlID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICBlWzBdID0gMTsgICBlWzRdID0gMDsgICBlWzhdICA9IDA7ICAgZVsxMl0gPSAwO1xyXG4gICAgICAgIGVbMV0gPSAwOyAgIGVbNV0gPSAxOyAgIGVbOV0gID0gMDsgICBlWzEzXSA9IDA7XHJcbiAgICAgICAgZVsyXSA9IDA7ICAgZVs2XSA9IDA7ICAgZVsxMF0gPSAxOyAgIGVbMTRdID0gMDtcclxuICAgICAgICBlWzNdID0gMDsgICBlWzddID0gMDsgICBlWzExXSA9IDA7ICAgZVsxNV0gPSAxO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBtdWx0aXBseVZlY3RvcjMgOmZ1bmN0aW9uKHBvcykge1xyXG4gICAgICAgIHZhciBlID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICB2YXIgcCA9IHBvcy5lbGVtZW50cztcclxuICAgICAgICB2YXIgdiA9IG5ldyBWZWN0b3IzKCk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHYuZWxlbWVudHM7XHJcblxyXG4gICAgICAgIHJlc3VsdFswXSA9IHBbMF0gKiBlWzBdICsgcFsxXSAqIGVbNF0gKyBwWzJdICogZVsgOF0gKyBlWzExXTtcclxuICAgICAgICByZXN1bHRbMV0gPSBwWzBdICogZVsxXSArIHBbMV0gKiBlWzVdICsgcFsyXSAqIGVbIDldICsgZVsxMl07XHJcbiAgICAgICAgcmVzdWx0WzJdID0gcFswXSAqIGVbMl0gKyBwWzFdICogZVs2XSArIHBbMl0gKiBlWzEwXSArIGVbMTNdO1xyXG5cclxuICAgICAgICByZXR1cm4gdjtcclxuICAgIH0sXHJcblxyXG4gICAgbXVsdGlwbHlWZWN0b3I0IDpmdW5jdGlvbihwb3MpIHtcclxuICAgICAgICB2YXIgZSA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICAgICAgdmFyIHAgPSBwb3MuZWxlbWVudHM7XHJcbiAgICAgICAgdmFyIHYgPSBuZXcgVmVjdG9yNCgpO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB2LmVsZW1lbnRzO1xyXG5cclxuICAgICAgICByZXN1bHRbMF0gPSBwWzBdICogZVswXSArIHBbMV0gKiBlWzRdICsgcFsyXSAqIGVbIDhdICsgcFszXSAqIGVbMTJdO1xyXG4gICAgICAgIHJlc3VsdFsxXSA9IHBbMF0gKiBlWzFdICsgcFsxXSAqIGVbNV0gKyBwWzJdICogZVsgOV0gKyBwWzNdICogZVsxM107XHJcbiAgICAgICAgcmVzdWx0WzJdID0gcFswXSAqIGVbMl0gKyBwWzFdICogZVs2XSArIHBbMl0gKiBlWzEwXSArIHBbM10gKiBlWzE0XTtcclxuICAgICAgICByZXN1bHRbM10gPSBwWzBdICogZVszXSArIHBbMV0gKiBlWzddICsgcFsyXSAqIGVbMTFdICsgcFszXSAqIGVbMTVdO1xyXG5cclxuICAgICAgICByZXR1cm4gdjtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0SW52ZXJzZU9mIDpmdW5jdGlvbihvdGhlcikge1xyXG4gICAgICAgIHZhciBpLCBzLCBkLCBpbnYsIGRldDtcclxuXHJcbiAgICAgICAgcyA9IG90aGVyLmVsZW1lbnRzO1xyXG4gICAgICAgIGQgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgICAgIGludiA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xyXG5cclxuICAgICAgICBpbnZbMF0gID0gICBzWzVdKnNbMTBdKnNbMTVdIC0gc1s1XSAqc1sxMV0qc1sxNF0gLSBzWzldICpzWzZdKnNbMTVdXHJcbiAgICAgICAgICAgICsgc1s5XSpzWzddICpzWzE0XSArIHNbMTNdKnNbNl0gKnNbMTFdIC0gc1sxM10qc1s3XSpzWzEwXTtcclxuICAgICAgICBpbnZbNF0gID0gLSBzWzRdKnNbMTBdKnNbMTVdICsgc1s0XSAqc1sxMV0qc1sxNF0gKyBzWzhdICpzWzZdKnNbMTVdXHJcbiAgICAgICAgICAgIC0gc1s4XSpzWzddICpzWzE0XSAtIHNbMTJdKnNbNl0gKnNbMTFdICsgc1sxMl0qc1s3XSpzWzEwXTtcclxuICAgICAgICBpbnZbOF0gID0gICBzWzRdKnNbOV0gKnNbMTVdIC0gc1s0XSAqc1sxMV0qc1sxM10gLSBzWzhdICpzWzVdKnNbMTVdXHJcbiAgICAgICAgICAgICsgc1s4XSpzWzddICpzWzEzXSArIHNbMTJdKnNbNV0gKnNbMTFdIC0gc1sxMl0qc1s3XSpzWzldO1xyXG4gICAgICAgIGludlsxMl0gPSAtIHNbNF0qc1s5XSAqc1sxNF0gKyBzWzRdICpzWzEwXSpzWzEzXSArIHNbOF0gKnNbNV0qc1sxNF1cclxuICAgICAgICAgICAgLSBzWzhdKnNbNl0gKnNbMTNdIC0gc1sxMl0qc1s1XSAqc1sxMF0gKyBzWzEyXSpzWzZdKnNbOV07XHJcblxyXG4gICAgICAgIGludlsxXSAgPSAtIHNbMV0qc1sxMF0qc1sxNV0gKyBzWzFdICpzWzExXSpzWzE0XSArIHNbOV0gKnNbMl0qc1sxNV1cclxuICAgICAgICAgICAgLSBzWzldKnNbM10gKnNbMTRdIC0gc1sxM10qc1syXSAqc1sxMV0gKyBzWzEzXSpzWzNdKnNbMTBdO1xyXG4gICAgICAgIGludls1XSAgPSAgIHNbMF0qc1sxMF0qc1sxNV0gLSBzWzBdICpzWzExXSpzWzE0XSAtIHNbOF0gKnNbMl0qc1sxNV1cclxuICAgICAgICAgICAgKyBzWzhdKnNbM10gKnNbMTRdICsgc1sxMl0qc1syXSAqc1sxMV0gLSBzWzEyXSpzWzNdKnNbMTBdO1xyXG4gICAgICAgIGludls5XSAgPSAtIHNbMF0qc1s5XSAqc1sxNV0gKyBzWzBdICpzWzExXSpzWzEzXSArIHNbOF0gKnNbMV0qc1sxNV1cclxuICAgICAgICAgICAgLSBzWzhdKnNbM10gKnNbMTNdIC0gc1sxMl0qc1sxXSAqc1sxMV0gKyBzWzEyXSpzWzNdKnNbOV07XHJcbiAgICAgICAgaW52WzEzXSA9ICAgc1swXSpzWzldICpzWzE0XSAtIHNbMF0gKnNbMTBdKnNbMTNdIC0gc1s4XSAqc1sxXSpzWzE0XVxyXG4gICAgICAgICAgICArIHNbOF0qc1syXSAqc1sxM10gKyBzWzEyXSpzWzFdICpzWzEwXSAtIHNbMTJdKnNbMl0qc1s5XTtcclxuXHJcbiAgICAgICAgaW52WzJdICA9ICAgc1sxXSpzWzZdKnNbMTVdIC0gc1sxXSAqc1s3XSpzWzE0XSAtIHNbNV0gKnNbMl0qc1sxNV1cclxuICAgICAgICAgICAgKyBzWzVdKnNbM10qc1sxNF0gKyBzWzEzXSpzWzJdKnNbN10gIC0gc1sxM10qc1szXSpzWzZdO1xyXG4gICAgICAgIGludls2XSAgPSAtIHNbMF0qc1s2XSpzWzE1XSArIHNbMF0gKnNbN10qc1sxNF0gKyBzWzRdICpzWzJdKnNbMTVdXHJcbiAgICAgICAgICAgIC0gc1s0XSpzWzNdKnNbMTRdIC0gc1sxMl0qc1syXSpzWzddICArIHNbMTJdKnNbM10qc1s2XTtcclxuICAgICAgICBpbnZbMTBdID0gICBzWzBdKnNbNV0qc1sxNV0gLSBzWzBdICpzWzddKnNbMTNdIC0gc1s0XSAqc1sxXSpzWzE1XVxyXG4gICAgICAgICAgICArIHNbNF0qc1szXSpzWzEzXSArIHNbMTJdKnNbMV0qc1s3XSAgLSBzWzEyXSpzWzNdKnNbNV07XHJcbiAgICAgICAgaW52WzE0XSA9IC0gc1swXSpzWzVdKnNbMTRdICsgc1swXSAqc1s2XSpzWzEzXSArIHNbNF0gKnNbMV0qc1sxNF1cclxuICAgICAgICAgICAgLSBzWzRdKnNbMl0qc1sxM10gLSBzWzEyXSpzWzFdKnNbNl0gICsgc1sxMl0qc1syXSpzWzVdO1xyXG5cclxuICAgICAgICBpbnZbM10gID0gLSBzWzFdKnNbNl0qc1sxMV0gKyBzWzFdKnNbN10qc1sxMF0gKyBzWzVdKnNbMl0qc1sxMV1cclxuICAgICAgICAgICAgLSBzWzVdKnNbM10qc1sxMF0gLSBzWzldKnNbMl0qc1s3XSAgKyBzWzldKnNbM10qc1s2XTtcclxuICAgICAgICBpbnZbN10gID0gICBzWzBdKnNbNl0qc1sxMV0gLSBzWzBdKnNbN10qc1sxMF0gLSBzWzRdKnNbMl0qc1sxMV1cclxuICAgICAgICAgICAgKyBzWzRdKnNbM10qc1sxMF0gKyBzWzhdKnNbMl0qc1s3XSAgLSBzWzhdKnNbM10qc1s2XTtcclxuICAgICAgICBpbnZbMTFdID0gLSBzWzBdKnNbNV0qc1sxMV0gKyBzWzBdKnNbN10qc1s5XSAgKyBzWzRdKnNbMV0qc1sxMV1cclxuICAgICAgICAgICAgLSBzWzRdKnNbM10qc1s5XSAgLSBzWzhdKnNbMV0qc1s3XSAgKyBzWzhdKnNbM10qc1s1XTtcclxuICAgICAgICBpbnZbMTVdID0gICBzWzBdKnNbNV0qc1sxMF0gLSBzWzBdKnNbNl0qc1s5XSAgLSBzWzRdKnNbMV0qc1sxMF1cclxuICAgICAgICAgICAgKyBzWzRdKnNbMl0qc1s5XSAgKyBzWzhdKnNbMV0qc1s2XSAgLSBzWzhdKnNbMl0qc1s1XTtcclxuXHJcbiAgICAgICAgZGV0ID0gc1swXSppbnZbMF0gKyBzWzFdKmludls0XSArIHNbMl0qaW52WzhdICsgc1szXSppbnZbMTJdO1xyXG4gICAgICAgIGlmIChkZXQgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkZXQgPSAxIC8gZGV0O1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRbaV0gPSBpbnZbaV0gKiBkZXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgaW52ZXJ0IDpmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZXRJbnZlcnNlT2YodGhpcyk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9ydGhvIDpmdW5jdGlvbihsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbmNhdChuZXcgTWF0cml4NCgpLnNldE9ydGhvKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZydXN0dW0gOmZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XHJcbiAgICAgICAgdmFyIGUsIHJ3LCByaCwgcmQ7XHJcblxyXG4gICAgICAgIGlmIChsZWZ0ID09PSByaWdodCB8fCB0b3AgPT09IGJvdHRvbSB8fCBuZWFyID09PSBmYXIpIHtcclxuICAgICAgICAgICAgdGhyb3cgJ251bGwgZnJ1c3R1bSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuZWFyIDw9IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgJ25lYXIgPD0gMCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmYXIgPD0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyAnZmFyIDw9IDAnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcncgPSAxIC8gKHJpZ2h0IC0gbGVmdCk7XHJcbiAgICAgICAgcmggPSAxIC8gKHRvcCAtIGJvdHRvbSk7XHJcbiAgICAgICAgcmQgPSAxIC8gKGZhciAtIG5lYXIpO1xyXG5cclxuICAgICAgICBlID0gdGhpcy5lbGVtZW50cztcclxuXHJcbiAgICAgICAgZVsgMF0gPSAyICogbmVhciAqIHJ3O1xyXG4gICAgICAgIGVbIDFdID0gMDtcclxuICAgICAgICBlWyAyXSA9IDA7XHJcbiAgICAgICAgZVsgM10gPSAwO1xyXG5cclxuICAgICAgICBlWyA0XSA9IDA7XHJcbiAgICAgICAgZVsgNV0gPSAyICogbmVhciAqIHJoO1xyXG4gICAgICAgIGVbIDZdID0gMDtcclxuICAgICAgICBlWyA3XSA9IDA7XHJcblxyXG4gICAgICAgIGVbIDhdID0gKHJpZ2h0ICsgbGVmdCkgKiBydztcclxuICAgICAgICBlWyA5XSA9ICh0b3AgKyBib3R0b20pICogcmg7XHJcbiAgICAgICAgZVsxMF0gPSAtKGZhciArIG5lYXIpICogcmQ7XHJcbiAgICAgICAgZVsxMV0gPSAtMTtcclxuXHJcbiAgICAgICAgZVsxMl0gPSAwO1xyXG4gICAgICAgIGVbMTNdID0gMDtcclxuICAgICAgICBlWzE0XSA9IC0yICogbmVhciAqIGZhciAqIHJkO1xyXG4gICAgICAgIGVbMTVdID0gMDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldE9ydGhvIDpmdW5jdGlvbihsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xyXG4gICAgICAgIHZhciBlLCBydywgcmgsIHJkO1xyXG5cclxuICAgICAgICBpZiAobGVmdCA9PT0gcmlnaHQgfHwgYm90dG9tID09PSB0b3AgfHwgbmVhciA9PT0gZmFyKSB7XHJcbiAgICAgICAgICAgIHRocm93ICdudWxsIGZydXN0dW0nO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcncgPSAxIC8gKHJpZ2h0IC0gbGVmdCk7XHJcbiAgICAgICAgcmggPSAxIC8gKHRvcCAtIGJvdHRvbSk7XHJcbiAgICAgICAgcmQgPSAxIC8gKGZhciAtIG5lYXIpO1xyXG5cclxuICAgICAgICBlID0gdGhpcy5lbGVtZW50cztcclxuXHJcbiAgICAgICAgZVswXSAgPSAyICogcnc7XHJcbiAgICAgICAgZVsxXSAgPSAwO1xyXG4gICAgICAgIGVbMl0gID0gMDtcclxuICAgICAgICBlWzNdICA9IDA7XHJcblxyXG4gICAgICAgIGVbNF0gID0gMDtcclxuICAgICAgICBlWzVdICA9IDIgKiByaDtcclxuICAgICAgICBlWzZdICA9IDA7XHJcbiAgICAgICAgZVs3XSAgPSAwO1xyXG5cclxuICAgICAgICBlWzhdICA9IDA7XHJcbiAgICAgICAgZVs5XSAgPSAwO1xyXG4gICAgICAgIGVbMTBdID0gLTIgKiByZDtcclxuICAgICAgICBlWzExXSA9IDA7XHJcblxyXG4gICAgICAgIGVbMTJdID0gLShyaWdodCArIGxlZnQpICogcnc7XHJcbiAgICAgICAgZVsxM10gPSAtKHRvcCArIGJvdHRvbSkgKiByaDtcclxuICAgICAgICBlWzE0XSA9IC0oZmFyICsgbmVhcikgKiByZDtcclxuICAgICAgICBlWzE1XSA9IDE7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBjb25jYXQgOmZ1bmN0aW9uKG90aGVyKSB7XHJcbiAgICAgICAgdmFyIGksIGUsIGEsIGIsIGFpMCwgYWkxLCBhaTIsIGFpMztcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGUgPSBhICogYlxyXG4gICAgICAgIGUgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgICAgIGEgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgICAgIGIgPSBvdGhlci5lbGVtZW50cztcclxuXHJcbiAgICAgICAgLy8gSWYgZSBlcXVhbHMgYiwgY29weSBiIHRvIHRlbXBvcmFyeSBtYXRyaXguXHJcbiAgICAgICAgaWYgKGUgPT09IGIpIHtcclxuICAgICAgICAgICAgYiA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTY7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgYltpXSA9IGVbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpKyspIHtcclxuICAgICAgICAgICAgYWkwPWFbaV07ICBhaTE9YVtpKzRdOyAgYWkyPWFbaSs4XTsgIGFpMz1hW2krMTJdO1xyXG4gICAgICAgICAgICBlW2ldICAgID0gYWkwICogYlswXSAgKyBhaTEgKiBiWzFdICArIGFpMiAqIGJbMl0gICsgYWkzICogYlszXTtcclxuICAgICAgICAgICAgZVtpKzRdICA9IGFpMCAqIGJbNF0gICsgYWkxICogYls1XSAgKyBhaTIgKiBiWzZdICArIGFpMyAqIGJbN107XHJcbiAgICAgICAgICAgIGVbaSs4XSAgPSBhaTAgKiBiWzhdICArIGFpMSAqIGJbOV0gICsgYWkyICogYlsxMF0gKyBhaTMgKiBiWzExXTtcclxuICAgICAgICAgICAgZVtpKzEyXSA9IGFpMCAqIGJbMTJdICsgYWkxICogYlsxM10gKyBhaTIgKiBiWzE0XSArIGFpMyAqIGJbMTVdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGZydXN0dW0gOmZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uY2F0KG5ldyBNYXRyaXg0KCkuc2V0RnJ1c3R1bShsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRQZXJzcGVjdGl2ZSA6ZnVuY3Rpb24oZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpIHtcclxuICAgICAgICB2YXIgZSwgcmQsIHMsIGN0O1xyXG5cclxuICAgICAgICBpZiAobmVhciA9PT0gZmFyIHx8IGFzcGVjdCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyAnbnVsbCBmcnVzdHVtJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5lYXIgPD0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyAnbmVhciA8PSAwJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZhciA8PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93ICdmYXIgPD0gMCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3Z5ID0gTWF0aC5QSSAqIGZvdnkgLyAxODAgLyAyO1xyXG4gICAgICAgIHMgPSBNYXRoLnNpbihmb3Z5KTtcclxuICAgICAgICBpZiAocyA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyAnbnVsbCBmcnVzdHVtJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJkID0gMSAvIChmYXIgLSBuZWFyKTtcclxuICAgICAgICBjdCA9IE1hdGguY29zKGZvdnkpIC8gcztcclxuXHJcbiAgICAgICAgZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG4gICAgICAgIGVbMF0gID0gY3QgLyBhc3BlY3Q7XHJcbiAgICAgICAgZVsxXSAgPSAwO1xyXG4gICAgICAgIGVbMl0gID0gMDtcclxuICAgICAgICBlWzNdICA9IDA7XHJcblxyXG4gICAgICAgIGVbNF0gID0gMDtcclxuICAgICAgICBlWzVdICA9IGN0O1xyXG4gICAgICAgIGVbNl0gID0gMDtcclxuICAgICAgICBlWzddICA9IDA7XHJcblxyXG4gICAgICAgIGVbOF0gID0gMDtcclxuICAgICAgICBlWzldICA9IDA7XHJcbiAgICAgICAgZVsxMF0gPSAtKGZhciArIG5lYXIpICogcmQ7XHJcbiAgICAgICAgZVsxMV0gPSAtMTtcclxuXHJcbiAgICAgICAgZVsxMl0gPSAwO1xyXG4gICAgICAgIGVbMTNdID0gMDtcclxuICAgICAgICBlWzE0XSA9IC0yICogbmVhciAqIGZhciAqIHJkO1xyXG4gICAgICAgIGVbMTVdID0gMDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHBlcnNwZWN0aXZlIDpmdW5jdGlvbihmb3Z5LCBhc3BlY3QsIG5lYXIsIGZhcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbmNhdChuZXcgTWF0cml4NCgpLnNldFBlcnNwZWN0aXZlKGZvdnksIGFzcGVjdCwgbmVhciwgZmFyKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNjYWxlIDpmdW5jdGlvbih4LCB5LCB6KSB7XHJcbiAgICAgICAgdmFyIGUgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgICAgIGVbMF0gPSB4OyAgZVs0XSA9IDA7ICBlWzhdICA9IDA7ICBlWzEyXSA9IDA7XHJcbiAgICAgICAgZVsxXSA9IDA7ICBlWzVdID0geTsgIGVbOV0gID0gMDsgIGVbMTNdID0gMDtcclxuICAgICAgICBlWzJdID0gMDsgIGVbNl0gPSAwOyAgZVsxMF0gPSB6OyAgZVsxNF0gPSAwO1xyXG4gICAgICAgIGVbM10gPSAwOyAgZVs3XSA9IDA7ICBlWzExXSA9IDA7ICBlWzE1XSA9IDE7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNjYWxlIDpmdW5jdGlvbih4LCB5LCB6KSB7XHJcbiAgICAgICAgdmFyIGUgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgICAgIGVbMF0gKj0geDsgIGVbNF0gKj0geTsgIGVbOF0gICo9IHo7XHJcbiAgICAgICAgZVsxXSAqPSB4OyAgZVs1XSAqPSB5OyAgZVs5XSAgKj0gejtcclxuICAgICAgICBlWzJdICo9IHg7ICBlWzZdICo9IHk7ICBlWzEwXSAqPSB6O1xyXG4gICAgICAgIGVbM10gKj0geDsgIGVbN10gKj0geTsgIGVbMTFdICo9IHo7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuXHRpZGVudGl0eTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0MSwgMCwgMCwgMCxcclxuXHRcdFx0MCwgMSwgMCwgMCxcclxuXHRcdFx0MCwgMCwgMSwgMCxcclxuXHRcdFx0MCwgMCwgMCwgMVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBNYXRyaXg0KCkuZnJvbUFycmF5KCB0aGlzLmVsZW1lbnRzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0dmFyIG1lID0gbS5lbGVtZW50cztcclxuXHJcblx0XHR0ZVsgMCBdID0gbWVbIDAgXTsgdGVbIDEgXSA9IG1lWyAxIF07IHRlWyAyIF0gPSBtZVsgMiBdOyB0ZVsgMyBdID0gbWVbIDMgXTtcclxuXHRcdHRlWyA0IF0gPSBtZVsgNCBdOyB0ZVsgNSBdID0gbWVbIDUgXTsgdGVbIDYgXSA9IG1lWyA2IF07IHRlWyA3IF0gPSBtZVsgNyBdO1xyXG5cdFx0dGVbIDggXSA9IG1lWyA4IF07IHRlWyA5IF0gPSBtZVsgOSBdOyB0ZVsgMTAgXSA9IG1lWyAxMCBdOyB0ZVsgMTEgXSA9IG1lWyAxMSBdO1xyXG5cdFx0dGVbIDEyIF0gPSBtZVsgMTIgXTsgdGVbIDEzIF0gPSBtZVsgMTMgXTsgdGVbIDE0IF0gPSBtZVsgMTQgXTsgdGVbIDE1IF0gPSBtZVsgMTUgXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weVBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cywgbWUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRlWyAxMiBdID0gbWVbIDEyIF07XHJcblx0XHR0ZVsgMTMgXSA9IG1lWyAxMyBdO1xyXG5cdFx0dGVbIDE0IF0gPSBtZVsgMTQgXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXh0cmFjdEJhc2lzOiBmdW5jdGlvbiAoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XHJcblxyXG5cdFx0eEF4aXMuc2V0RnJvbU1hdHJpeENvbHVtbiggdGhpcywgMCApO1xyXG5cdFx0eUF4aXMuc2V0RnJvbU1hdHJpeENvbHVtbiggdGhpcywgMSApO1xyXG5cdFx0ekF4aXMuc2V0RnJvbU1hdHJpeENvbHVtbiggdGhpcywgMiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlQmFzaXM6IGZ1bmN0aW9uICggeEF4aXMsIHlBeGlzLCB6QXhpcyApIHtcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHRcdFx0eEF4aXMueCwgeUF4aXMueCwgekF4aXMueCwgMCxcclxuXHRcdFx0eEF4aXMueSwgeUF4aXMueSwgekF4aXMueSwgMCxcclxuXHRcdFx0eEF4aXMueiwgeUF4aXMueiwgekF4aXMueiwgMCxcclxuXHRcdFx0MCwgMCwgMCwgMVxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXh0cmFjdFJvdGF0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gZXh0cmFjdFJvdGF0aW9uKCBtICkge1xyXG5cclxuXHRcdFx0Ly8gdGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCByZWZsZWN0aW9uIG1hdHJpY2VzXHJcblxyXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0XHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdFx0dmFyIHNjYWxlWCA9IDEgLyB2MS5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAwICkubGVuZ3RoKCk7XHJcblx0XHRcdHZhciBzY2FsZVkgPSAxIC8gdjEuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMSApLmxlbmd0aCgpO1xyXG5cdFx0XHR2YXIgc2NhbGVaID0gMSAvIHYxLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDIgKS5sZW5ndGgoKTtcclxuXHJcblx0XHRcdHRlWyAwIF0gPSBtZVsgMCBdICogc2NhbGVYO1xyXG5cdFx0XHR0ZVsgMSBdID0gbWVbIDEgXSAqIHNjYWxlWDtcclxuXHRcdFx0dGVbIDIgXSA9IG1lWyAyIF0gKiBzY2FsZVg7XHJcblx0XHRcdHRlWyAzIF0gPSAwO1xyXG5cclxuXHRcdFx0dGVbIDQgXSA9IG1lWyA0IF0gKiBzY2FsZVk7XHJcblx0XHRcdHRlWyA1IF0gPSBtZVsgNSBdICogc2NhbGVZO1xyXG5cdFx0XHR0ZVsgNiBdID0gbWVbIDYgXSAqIHNjYWxlWTtcclxuXHRcdFx0dGVbIDcgXSA9IDA7XHJcblxyXG5cdFx0XHR0ZVsgOCBdID0gbWVbIDggXSAqIHNjYWxlWjtcclxuXHRcdFx0dGVbIDkgXSA9IG1lWyA5IF0gKiBzY2FsZVo7XHJcblx0XHRcdHRlWyAxMCBdID0gbWVbIDEwIF0gKiBzY2FsZVo7XHJcblx0XHRcdHRlWyAxMSBdID0gMDtcclxuXHJcblx0XHRcdHRlWyAxMiBdID0gMDtcclxuXHRcdFx0dGVbIDEzIF0gPSAwO1xyXG5cdFx0XHR0ZVsgMTQgXSA9IDA7XHJcblx0XHRcdHRlWyAxNSBdID0gMTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0bWFrZVJvdGF0aW9uRnJvbUV1bGVyOiBmdW5jdGlvbiAoIGV1bGVyICkge1xyXG5cclxuXHRcdGlmICggISAoIGV1bGVyICYmIGV1bGVyLmlzRXVsZXIgKSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdDT09MLk1hdHJpeDQ6IC5tYWtlUm90YXRpb25Gcm9tRXVsZXIoKSBub3cgZXhwZWN0cyBhIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHZhciB4ID0gZXVsZXIueCwgeSA9IGV1bGVyLnksIHogPSBldWxlci56O1xyXG5cdFx0dmFyIGEgPSBNYXRoLmNvcyggeCApLCBiID0gTWF0aC5zaW4oIHggKTtcclxuXHRcdHZhciBjID0gTWF0aC5jb3MoIHkgKSwgZCA9IE1hdGguc2luKCB5ICk7XHJcblx0XHR2YXIgZSA9IE1hdGguY29zKCB6ICksIGYgPSBNYXRoLnNpbiggeiApO1xyXG5cclxuXHRcdGlmICggZXVsZXIub3JkZXIgPT09ICdYWVonICkge1xyXG5cclxuXHRcdFx0dmFyIGFlID0gYSAqIGUsIGFmID0gYSAqIGYsIGJlID0gYiAqIGUsIGJmID0gYiAqIGY7XHJcblxyXG5cdFx0XHR0ZVsgMCBdID0gYyAqIGU7XHJcblx0XHRcdHRlWyA0IF0gPSAtIGMgKiBmO1xyXG5cdFx0XHR0ZVsgOCBdID0gZDtcclxuXHJcblx0XHRcdHRlWyAxIF0gPSBhZiArIGJlICogZDtcclxuXHRcdFx0dGVbIDUgXSA9IGFlIC0gYmYgKiBkO1xyXG5cdFx0XHR0ZVsgOSBdID0gLSBiICogYztcclxuXHJcblx0XHRcdHRlWyAyIF0gPSBiZiAtIGFlICogZDtcclxuXHRcdFx0dGVbIDYgXSA9IGJlICsgYWYgKiBkO1xyXG5cdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWVhaJyApIHtcclxuXHJcblx0XHRcdHZhciBjZSA9IGMgKiBlLCBjZiA9IGMgKiBmLCBkZSA9IGQgKiBlLCBkZiA9IGQgKiBmO1xyXG5cclxuXHRcdFx0dGVbIDAgXSA9IGNlICsgZGYgKiBiO1xyXG5cdFx0XHR0ZVsgNCBdID0gZGUgKiBiIC0gY2Y7XHJcblx0XHRcdHRlWyA4IF0gPSBhICogZDtcclxuXHJcblx0XHRcdHRlWyAxIF0gPSBhICogZjtcclxuXHRcdFx0dGVbIDUgXSA9IGEgKiBlO1xyXG5cdFx0XHR0ZVsgOSBdID0gLSBiO1xyXG5cclxuXHRcdFx0dGVbIDIgXSA9IGNmICogYiAtIGRlO1xyXG5cdFx0XHR0ZVsgNiBdID0gZGYgKyBjZSAqIGI7XHJcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWFknICkge1xyXG5cclxuXHRcdFx0dmFyIGNlID0gYyAqIGUsIGNmID0gYyAqIGYsIGRlID0gZCAqIGUsIGRmID0gZCAqIGY7XHJcblxyXG5cdFx0XHR0ZVsgMCBdID0gY2UgLSBkZiAqIGI7XHJcblx0XHRcdHRlWyA0IF0gPSAtIGEgKiBmO1xyXG5cdFx0XHR0ZVsgOCBdID0gZGUgKyBjZiAqIGI7XHJcblxyXG5cdFx0XHR0ZVsgMSBdID0gY2YgKyBkZSAqIGI7XHJcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcclxuXHRcdFx0dGVbIDkgXSA9IGRmIC0gY2UgKiBiO1xyXG5cclxuXHRcdFx0dGVbIDIgXSA9IC0gYSAqIGQ7XHJcblx0XHRcdHRlWyA2IF0gPSBiO1xyXG5cdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWllYJyApIHtcclxuXHJcblx0XHRcdHZhciBhZSA9IGEgKiBlLCBhZiA9IGEgKiBmLCBiZSA9IGIgKiBlLCBiZiA9IGIgKiBmO1xyXG5cclxuXHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xyXG5cdFx0XHR0ZVsgNCBdID0gYmUgKiBkIC0gYWY7XHJcblx0XHRcdHRlWyA4IF0gPSBhZSAqIGQgKyBiZjtcclxuXHJcblx0XHRcdHRlWyAxIF0gPSBjICogZjtcclxuXHRcdFx0dGVbIDUgXSA9IGJmICogZCArIGFlO1xyXG5cdFx0XHR0ZVsgOSBdID0gYWYgKiBkIC0gYmU7XHJcblxyXG5cdFx0XHR0ZVsgMiBdID0gLSBkO1xyXG5cdFx0XHR0ZVsgNiBdID0gYiAqIGM7XHJcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWlgnICkge1xyXG5cclxuXHRcdFx0dmFyIGFjID0gYSAqIGMsIGFkID0gYSAqIGQsIGJjID0gYiAqIGMsIGJkID0gYiAqIGQ7XHJcblxyXG5cdFx0XHR0ZVsgMCBdID0gYyAqIGU7XHJcblx0XHRcdHRlWyA0IF0gPSBiZCAtIGFjICogZjtcclxuXHRcdFx0dGVbIDggXSA9IGJjICogZiArIGFkO1xyXG5cclxuXHRcdFx0dGVbIDEgXSA9IGY7XHJcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcclxuXHRcdFx0dGVbIDkgXSA9IC0gYiAqIGU7XHJcblxyXG5cdFx0XHR0ZVsgMiBdID0gLSBkICogZTtcclxuXHRcdFx0dGVbIDYgXSA9IGFkICogZiArIGJjO1xyXG5cdFx0XHR0ZVsgMTAgXSA9IGFjIC0gYmQgKiBmO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWFpZJyApIHtcclxuXHJcblx0XHRcdHZhciBhYyA9IGEgKiBjLCBhZCA9IGEgKiBkLCBiYyA9IGIgKiBjLCBiZCA9IGIgKiBkO1xyXG5cclxuXHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xyXG5cdFx0XHR0ZVsgNCBdID0gLSBmO1xyXG5cdFx0XHR0ZVsgOCBdID0gZCAqIGU7XHJcblxyXG5cdFx0XHR0ZVsgMSBdID0gYWMgKiBmICsgYmQ7XHJcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcclxuXHRcdFx0dGVbIDkgXSA9IGFkICogZiAtIGJjO1xyXG5cclxuXHRcdFx0dGVbIDIgXSA9IGJjICogZiAtIGFkO1xyXG5cdFx0XHR0ZVsgNiBdID0gYiAqIGU7XHJcblx0XHRcdHRlWyAxMCBdID0gYmQgKiBmICsgYWM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGJvdHRvbSByb3dcclxuXHRcdHRlWyAzIF0gPSAwO1xyXG5cdFx0dGVbIDcgXSA9IDA7XHJcblx0XHR0ZVsgMTEgXSA9IDA7XHJcblxyXG5cdFx0Ly8gbGFzdCBjb2x1bW5cclxuXHRcdHRlWyAxMiBdID0gMDtcclxuXHRcdHRlWyAxMyBdID0gMDtcclxuXHRcdHRlWyAxNCBdID0gMDtcclxuXHRcdHRlWyAxNSBdID0gMTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgemVybyA9IG5ldyBWZWN0b3IzKCAwLCAwLCAwICk7XHJcblx0XHR2YXIgb25lID0gbmV3IFZlY3RvcjMoIDEsIDEsIDEgKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gbWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5jb21wb3NlKCB6ZXJvLCBxLCBvbmUgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGxvb2tBdDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB4ID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHZhciB5ID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHZhciB6ID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gbG9va0F0KCBleWUsIHRhcmdldCwgdXAgKSB7XHJcblxyXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdFx0ei5zdWJWZWN0b3JzKCBleWUsIHRhcmdldCApO1xyXG5cclxuXHRcdFx0aWYgKCB6Lmxlbmd0aFNxKCkgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGV5ZSBhbmQgdGFyZ2V0IGFyZSBpbiB0aGUgc2FtZSBwb3NpdGlvblxyXG5cclxuXHRcdFx0XHR6LnogPSAxO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ei5ub3JtYWxpemUoKTtcclxuXHRcdFx0eC5jcm9zc1ZlY3RvcnMoIHVwLCB6ICk7XHJcblxyXG5cdFx0XHRpZiAoIHgubGVuZ3RoU3EoKSA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0Ly8gdXAgYW5kIHogYXJlIHBhcmFsbGVsXHJcblxyXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIHVwLnogKSA9PT0gMSApIHtcclxuXHJcblx0XHRcdFx0XHR6LnggKz0gMC4wMDAxO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHoueiArPSAwLjAwMDE7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0ei5ub3JtYWxpemUoKTtcclxuXHRcdFx0XHR4LmNyb3NzVmVjdG9ycyggdXAsIHogKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHgubm9ybWFsaXplKCk7XHJcblx0XHRcdHkuY3Jvc3NWZWN0b3JzKCB6LCB4ICk7XHJcblxyXG5cdFx0XHR0ZVsgMCBdID0geC54OyB0ZVsgNCBdID0geS54OyB0ZVsgOCBdID0gei54O1xyXG5cdFx0XHR0ZVsgMSBdID0geC55OyB0ZVsgNSBdID0geS55OyB0ZVsgOSBdID0gei55O1xyXG5cdFx0XHR0ZVsgMiBdID0geC56OyB0ZVsgNiBdID0geS56OyB0ZVsgMTAgXSA9IHouejtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggbSwgbiApIHtcclxuXHJcblx0XHRpZiAoIG4gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ0NPT0wuTWF0cml4NDogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlNYXRyaWNlcyggYSwgYiApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCBtLCBuICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIHRoaXMsIG0gKTtcclxuXHJcblx0fSxcclxuXHJcblx0cHJlbXVsdGlwbHk6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCBtLCB0aGlzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5TWF0cmljZXM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHR2YXIgYWUgPSBhLmVsZW1lbnRzO1xyXG5cdFx0dmFyIGJlID0gYi5lbGVtZW50cztcclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dmFyIGExMSA9IGFlWyAwIF0sIGExMiA9IGFlWyA0IF0sIGExMyA9IGFlWyA4IF0sIGExNCA9IGFlWyAxMiBdO1xyXG5cdFx0dmFyIGEyMSA9IGFlWyAxIF0sIGEyMiA9IGFlWyA1IF0sIGEyMyA9IGFlWyA5IF0sIGEyNCA9IGFlWyAxMyBdO1xyXG5cdFx0dmFyIGEzMSA9IGFlWyAyIF0sIGEzMiA9IGFlWyA2IF0sIGEzMyA9IGFlWyAxMCBdLCBhMzQgPSBhZVsgMTQgXTtcclxuXHRcdHZhciBhNDEgPSBhZVsgMyBdLCBhNDIgPSBhZVsgNyBdLCBhNDMgPSBhZVsgMTEgXSwgYTQ0ID0gYWVbIDE1IF07XHJcblxyXG5cdFx0dmFyIGIxMSA9IGJlWyAwIF0sIGIxMiA9IGJlWyA0IF0sIGIxMyA9IGJlWyA4IF0sIGIxNCA9IGJlWyAxMiBdO1xyXG5cdFx0dmFyIGIyMSA9IGJlWyAxIF0sIGIyMiA9IGJlWyA1IF0sIGIyMyA9IGJlWyA5IF0sIGIyNCA9IGJlWyAxMyBdO1xyXG5cdFx0dmFyIGIzMSA9IGJlWyAyIF0sIGIzMiA9IGJlWyA2IF0sIGIzMyA9IGJlWyAxMCBdLCBiMzQgPSBiZVsgMTQgXTtcclxuXHRcdHZhciBiNDEgPSBiZVsgMyBdLCBiNDIgPSBiZVsgNyBdLCBiNDMgPSBiZVsgMTEgXSwgYjQ0ID0gYmVbIDE1IF07XHJcblxyXG5cdFx0dGVbIDAgXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMSArIGExNCAqIGI0MTtcclxuXHRcdHRlWyA0IF0gPSBhMTEgKiBiMTIgKyBhMTIgKiBiMjIgKyBhMTMgKiBiMzIgKyBhMTQgKiBiNDI7XHJcblx0XHR0ZVsgOCBdID0gYTExICogYjEzICsgYTEyICogYjIzICsgYTEzICogYjMzICsgYTE0ICogYjQzO1xyXG5cdFx0dGVbIDEyIF0gPSBhMTEgKiBiMTQgKyBhMTIgKiBiMjQgKyBhMTMgKiBiMzQgKyBhMTQgKiBiNDQ7XHJcblxyXG5cdFx0dGVbIDEgXSA9IGEyMSAqIGIxMSArIGEyMiAqIGIyMSArIGEyMyAqIGIzMSArIGEyNCAqIGI0MTtcclxuXHRcdHRlWyA1IF0gPSBhMjEgKiBiMTIgKyBhMjIgKiBiMjIgKyBhMjMgKiBiMzIgKyBhMjQgKiBiNDI7XHJcblx0XHR0ZVsgOSBdID0gYTIxICogYjEzICsgYTIyICogYjIzICsgYTIzICogYjMzICsgYTI0ICogYjQzO1xyXG5cdFx0dGVbIDEzIF0gPSBhMjEgKiBiMTQgKyBhMjIgKiBiMjQgKyBhMjMgKiBiMzQgKyBhMjQgKiBiNDQ7XHJcblxyXG5cdFx0dGVbIDIgXSA9IGEzMSAqIGIxMSArIGEzMiAqIGIyMSArIGEzMyAqIGIzMSArIGEzNCAqIGI0MTtcclxuXHRcdHRlWyA2IF0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzIgKyBhMzQgKiBiNDI7XHJcblx0XHR0ZVsgMTAgXSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMyArIGEzNCAqIGI0MztcclxuXHRcdHRlWyAxNCBdID0gYTMxICogYjE0ICsgYTMyICogYjI0ICsgYTMzICogYjM0ICsgYTM0ICogYjQ0O1xyXG5cclxuXHRcdHRlWyAzIF0gPSBhNDEgKiBiMTEgKyBhNDIgKiBiMjEgKyBhNDMgKiBiMzEgKyBhNDQgKiBiNDE7XHJcblx0XHR0ZVsgNyBdID0gYTQxICogYjEyICsgYTQyICogYjIyICsgYTQzICogYjMyICsgYTQ0ICogYjQyO1xyXG5cdFx0dGVbIDExIF0gPSBhNDEgKiBiMTMgKyBhNDIgKiBiMjMgKyBhNDMgKiBiMzMgKyBhNDQgKiBiNDM7XHJcblx0XHR0ZVsgMTUgXSA9IGE0MSAqIGIxNCArIGE0MiAqIGIyNCArIGE0MyAqIGIzNCArIGE0NCAqIGI0NDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRlWyAwIF0gKj0gczsgdGVbIDQgXSAqPSBzOyB0ZVsgOCBdICo9IHM7IHRlWyAxMiBdICo9IHM7XHJcblx0XHR0ZVsgMSBdICo9IHM7IHRlWyA1IF0gKj0gczsgdGVbIDkgXSAqPSBzOyB0ZVsgMTMgXSAqPSBzO1xyXG5cdFx0dGVbIDIgXSAqPSBzOyB0ZVsgNiBdICo9IHM7IHRlWyAxMCBdICo9IHM7IHRlWyAxNCBdICo9IHM7XHJcblx0XHR0ZVsgMyBdICo9IHM7IHRlWyA3IF0gKj0gczsgdGVbIDExIF0gKj0gczsgdGVbIDE1IF0gKj0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlUb0J1ZmZlckF0dHJpYnV0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGFwcGx5VG9CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGF0dHJpYnV0ZS5jb3VudDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHYxLnggPSBhdHRyaWJ1dGUuZ2V0WCggaSApO1xyXG5cdFx0XHRcdHYxLnkgPSBhdHRyaWJ1dGUuZ2V0WSggaSApO1xyXG5cdFx0XHRcdHYxLnogPSBhdHRyaWJ1dGUuZ2V0WiggaSApO1xyXG5cclxuXHRcdFx0XHR2MS5hcHBseU1hdHJpeDQoIHRoaXMgKTtcclxuXHJcblx0XHRcdFx0YXR0cmlidXRlLnNldFhZWiggaSwgdjEueCwgdjEueSwgdjEueiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGF0dHJpYnV0ZTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGRldGVybWluYW50OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR2YXIgbjExID0gdGVbIDAgXSwgbjEyID0gdGVbIDQgXSwgbjEzID0gdGVbIDggXSwgbjE0ID0gdGVbIDEyIF07XHJcblx0XHR2YXIgbjIxID0gdGVbIDEgXSwgbjIyID0gdGVbIDUgXSwgbjIzID0gdGVbIDkgXSwgbjI0ID0gdGVbIDEzIF07XHJcblx0XHR2YXIgbjMxID0gdGVbIDIgXSwgbjMyID0gdGVbIDYgXSwgbjMzID0gdGVbIDEwIF0sIG4zNCA9IHRlWyAxNCBdO1xyXG5cdFx0dmFyIG40MSA9IHRlWyAzIF0sIG40MiA9IHRlWyA3IF0sIG40MyA9IHRlWyAxMSBdLCBuNDQgPSB0ZVsgMTUgXTtcclxuXHJcblx0XHQvL1RPRE86IG1ha2UgdGhpcyBtb3JlIGVmZmljaWVudFxyXG5cdFx0Ly8oIGJhc2VkIG9uIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bSApXHJcblxyXG5cdFx0cmV0dXJuIChcclxuXHRcdFx0bjQxICogKFxyXG5cdFx0XHRcdCsgbjE0ICogbjIzICogbjMyXHJcblx0XHRcdFx0IC0gbjEzICogbjI0ICogbjMyXHJcblx0XHRcdFx0IC0gbjE0ICogbjIyICogbjMzXHJcblx0XHRcdFx0ICsgbjEyICogbjI0ICogbjMzXHJcblx0XHRcdFx0ICsgbjEzICogbjIyICogbjM0XHJcblx0XHRcdFx0IC0gbjEyICogbjIzICogbjM0XHJcblx0XHRcdCkgK1xyXG5cdFx0XHRuNDIgKiAoXHJcblx0XHRcdFx0KyBuMTEgKiBuMjMgKiBuMzRcclxuXHRcdFx0XHQgLSBuMTEgKiBuMjQgKiBuMzNcclxuXHRcdFx0XHQgKyBuMTQgKiBuMjEgKiBuMzNcclxuXHRcdFx0XHQgLSBuMTMgKiBuMjEgKiBuMzRcclxuXHRcdFx0XHQgKyBuMTMgKiBuMjQgKiBuMzFcclxuXHRcdFx0XHQgLSBuMTQgKiBuMjMgKiBuMzFcclxuXHRcdFx0KSArXHJcblx0XHRcdG40MyAqIChcclxuXHRcdFx0XHQrIG4xMSAqIG4yNCAqIG4zMlxyXG5cdFx0XHRcdCAtIG4xMSAqIG4yMiAqIG4zNFxyXG5cdFx0XHRcdCAtIG4xNCAqIG4yMSAqIG4zMlxyXG5cdFx0XHRcdCArIG4xMiAqIG4yMSAqIG4zNFxyXG5cdFx0XHRcdCArIG4xNCAqIG4yMiAqIG4zMVxyXG5cdFx0XHRcdCAtIG4xMiAqIG4yNCAqIG4zMVxyXG5cdFx0XHQpICtcclxuXHRcdFx0bjQ0ICogKFxyXG5cdFx0XHRcdC0gbjEzICogbjIyICogbjMxXHJcblx0XHRcdFx0IC0gbjExICogbjIzICogbjMyXHJcblx0XHRcdFx0ICsgbjExICogbjIyICogbjMzXHJcblx0XHRcdFx0ICsgbjEzICogbjIxICogbjMyXHJcblx0XHRcdFx0IC0gbjEyICogbjIxICogbjMzXHJcblx0XHRcdFx0ICsgbjEyICogbjIzICogbjMxXHJcblx0XHRcdClcclxuXHJcblx0XHQpO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0cmFuc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0dmFyIHRtcDtcclxuXHJcblx0XHR0bXAgPSB0ZVsgMSBdOyB0ZVsgMSBdID0gdGVbIDQgXTsgdGVbIDQgXSA9IHRtcDtcclxuXHRcdHRtcCA9IHRlWyAyIF07IHRlWyAyIF0gPSB0ZVsgOCBdOyB0ZVsgOCBdID0gdG1wO1xyXG5cdFx0dG1wID0gdGVbIDYgXTsgdGVbIDYgXSA9IHRlWyA5IF07IHRlWyA5IF0gPSB0bXA7XHJcblxyXG5cdFx0dG1wID0gdGVbIDMgXTsgdGVbIDMgXSA9IHRlWyAxMiBdOyB0ZVsgMTIgXSA9IHRtcDtcclxuXHRcdHRtcCA9IHRlWyA3IF07IHRlWyA3IF0gPSB0ZVsgMTMgXTsgdGVbIDEzIF0gPSB0bXA7XHJcblx0XHR0bXAgPSB0ZVsgMTEgXTsgdGVbIDExIF0gPSB0ZVsgMTQgXTsgdGVbIDE0IF0gPSB0bXA7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFBvc2l0aW9uOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR0ZVsgMTIgXSA9IHYueDtcclxuXHRcdHRlWyAxMyBdID0gdi55O1xyXG5cdFx0dGVbIDE0IF0gPSB2Lno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEludmVyc2U6IGZ1bmN0aW9uICggbSwgdGhyb3dPbkRlZ2VuZXJhdGUgKSB7XHJcblxyXG5cdFx0Ly8gYmFzZWQgb24gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzLFxyXG5cdFx0XHRtZSA9IG0uZWxlbWVudHMsXHJcblxyXG5cdFx0XHRuMTEgPSBtZVsgMCBdLCBuMjEgPSBtZVsgMSBdLCBuMzEgPSBtZVsgMiBdLCBuNDEgPSBtZVsgMyBdLFxyXG5cdFx0XHRuMTIgPSBtZVsgNCBdLCBuMjIgPSBtZVsgNSBdLCBuMzIgPSBtZVsgNiBdLCBuNDIgPSBtZVsgNyBdLFxyXG5cdFx0XHRuMTMgPSBtZVsgOCBdLCBuMjMgPSBtZVsgOSBdLCBuMzMgPSBtZVsgMTAgXSwgbjQzID0gbWVbIDExIF0sXHJcblx0XHRcdG4xNCA9IG1lWyAxMiBdLCBuMjQgPSBtZVsgMTMgXSwgbjM0ID0gbWVbIDE0IF0sIG40NCA9IG1lWyAxNSBdLFxyXG5cclxuXHRcdFx0dDExID0gbjIzICogbjM0ICogbjQyIC0gbjI0ICogbjMzICogbjQyICsgbjI0ICogbjMyICogbjQzIC0gbjIyICogbjM0ICogbjQzIC0gbjIzICogbjMyICogbjQ0ICsgbjIyICogbjMzICogbjQ0LFxyXG5cdFx0XHR0MTIgPSBuMTQgKiBuMzMgKiBuNDIgLSBuMTMgKiBuMzQgKiBuNDIgLSBuMTQgKiBuMzIgKiBuNDMgKyBuMTIgKiBuMzQgKiBuNDMgKyBuMTMgKiBuMzIgKiBuNDQgLSBuMTIgKiBuMzMgKiBuNDQsXHJcblx0XHRcdHQxMyA9IG4xMyAqIG4yNCAqIG40MiAtIG4xNCAqIG4yMyAqIG40MiArIG4xNCAqIG4yMiAqIG40MyAtIG4xMiAqIG4yNCAqIG40MyAtIG4xMyAqIG4yMiAqIG40NCArIG4xMiAqIG4yMyAqIG40NCxcclxuXHRcdFx0dDE0ID0gbjE0ICogbjIzICogbjMyIC0gbjEzICogbjI0ICogbjMyIC0gbjE0ICogbjIyICogbjMzICsgbjEyICogbjI0ICogbjMzICsgbjEzICogbjIyICogbjM0IC0gbjEyICogbjIzICogbjM0O1xyXG5cclxuXHRcdHZhciBkZXQgPSBuMTEgKiB0MTEgKyBuMjEgKiB0MTIgKyBuMzEgKiB0MTMgKyBuNDEgKiB0MTQ7XHJcblxyXG5cdFx0aWYgKCBkZXQgPT09IDAgKSB7XHJcblxyXG5cdFx0XHR2YXIgbXNnID0gXCJDT09MLk1hdHJpeDQ6IC5nZXRJbnZlcnNlKCkgY2FuJ3QgaW52ZXJ0IG1hdHJpeCwgZGV0ZXJtaW5hbnQgaXMgMFwiO1xyXG5cclxuXHRcdFx0aWYgKCB0aHJvd09uRGVnZW5lcmF0ZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggbXNnICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5pZGVudGl0eSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZGV0SW52ID0gMSAvIGRldDtcclxuXHJcblx0XHR0ZVsgMCBdID0gdDExICogZGV0SW52O1xyXG5cdFx0dGVbIDEgXSA9ICggbjI0ICogbjMzICogbjQxIC0gbjIzICogbjM0ICogbjQxIC0gbjI0ICogbjMxICogbjQzICsgbjIxICogbjM0ICogbjQzICsgbjIzICogbjMxICogbjQ0IC0gbjIxICogbjMzICogbjQ0ICkgKiBkZXRJbnY7XHJcblx0XHR0ZVsgMiBdID0gKCBuMjIgKiBuMzQgKiBuNDEgLSBuMjQgKiBuMzIgKiBuNDEgKyBuMjQgKiBuMzEgKiBuNDIgLSBuMjEgKiBuMzQgKiBuNDIgLSBuMjIgKiBuMzEgKiBuNDQgKyBuMjEgKiBuMzIgKiBuNDQgKSAqIGRldEludjtcclxuXHRcdHRlWyAzIF0gPSAoIG4yMyAqIG4zMiAqIG40MSAtIG4yMiAqIG4zMyAqIG40MSAtIG4yMyAqIG4zMSAqIG40MiArIG4yMSAqIG4zMyAqIG40MiArIG4yMiAqIG4zMSAqIG40MyAtIG4yMSAqIG4zMiAqIG40MyApICogZGV0SW52O1xyXG5cclxuXHRcdHRlWyA0IF0gPSB0MTIgKiBkZXRJbnY7XHJcblx0XHR0ZVsgNSBdID0gKCBuMTMgKiBuMzQgKiBuNDEgLSBuMTQgKiBuMzMgKiBuNDEgKyBuMTQgKiBuMzEgKiBuNDMgLSBuMTEgKiBuMzQgKiBuNDMgLSBuMTMgKiBuMzEgKiBuNDQgKyBuMTEgKiBuMzMgKiBuNDQgKSAqIGRldEludjtcclxuXHRcdHRlWyA2IF0gPSAoIG4xNCAqIG4zMiAqIG40MSAtIG4xMiAqIG4zNCAqIG40MSAtIG4xNCAqIG4zMSAqIG40MiArIG4xMSAqIG4zNCAqIG40MiArIG4xMiAqIG4zMSAqIG40NCAtIG4xMSAqIG4zMiAqIG40NCApICogZGV0SW52O1xyXG5cdFx0dGVbIDcgXSA9ICggbjEyICogbjMzICogbjQxIC0gbjEzICogbjMyICogbjQxICsgbjEzICogbjMxICogbjQyIC0gbjExICogbjMzICogbjQyIC0gbjEyICogbjMxICogbjQzICsgbjExICogbjMyICogbjQzICkgKiBkZXRJbnY7XHJcblxyXG5cdFx0dGVbIDggXSA9IHQxMyAqIGRldEludjtcclxuXHRcdHRlWyA5IF0gPSAoIG4xNCAqIG4yMyAqIG40MSAtIG4xMyAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMSAqIG40MyArIG4xMSAqIG4yNCAqIG40MyArIG4xMyAqIG4yMSAqIG40NCAtIG4xMSAqIG4yMyAqIG40NCApICogZGV0SW52O1xyXG5cdFx0dGVbIDEwIF0gPSAoIG4xMiAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMiAqIG40MSArIG4xNCAqIG4yMSAqIG40MiAtIG4xMSAqIG4yNCAqIG40MiAtIG4xMiAqIG4yMSAqIG40NCArIG4xMSAqIG4yMiAqIG40NCApICogZGV0SW52O1xyXG5cdFx0dGVbIDExIF0gPSAoIG4xMyAqIG4yMiAqIG40MSAtIG4xMiAqIG4yMyAqIG40MSAtIG4xMyAqIG4yMSAqIG40MiArIG4xMSAqIG4yMyAqIG40MiArIG4xMiAqIG4yMSAqIG40MyAtIG4xMSAqIG4yMiAqIG40MyApICogZGV0SW52O1xyXG5cclxuXHRcdHRlWyAxMiBdID0gdDE0ICogZGV0SW52O1xyXG5cdFx0dGVbIDEzIF0gPSAoIG4xMyAqIG4yNCAqIG4zMSAtIG4xNCAqIG4yMyAqIG4zMSArIG4xNCAqIG4yMSAqIG4zMyAtIG4xMSAqIG4yNCAqIG4zMyAtIG4xMyAqIG4yMSAqIG4zNCArIG4xMSAqIG4yMyAqIG4zNCApICogZGV0SW52O1xyXG5cdFx0dGVbIDE0IF0gPSAoIG4xNCAqIG4yMiAqIG4zMSAtIG4xMiAqIG4yNCAqIG4zMSAtIG4xNCAqIG4yMSAqIG4zMiArIG4xMSAqIG4yNCAqIG4zMiArIG4xMiAqIG4yMSAqIG4zNCAtIG4xMSAqIG4yMiAqIG4zNCApICogZGV0SW52O1xyXG5cdFx0dGVbIDE1IF0gPSAoIG4xMiAqIG4yMyAqIG4zMSAtIG4xMyAqIG4yMiAqIG4zMSArIG4xMyAqIG4yMSAqIG4zMiAtIG4xMSAqIG4yMyAqIG4zMiAtIG4xMiAqIG4yMSAqIG4zMyArIG4xMSAqIG4yMiAqIG4zMyApICogZGV0SW52O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzY2FsZTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHR2YXIgeCA9IHYueCwgeSA9IHYueSwgeiA9IHYuejtcclxuXHJcblx0XHR0ZVsgMCBdICo9IHg7IHRlWyA0IF0gKj0geTsgdGVbIDggXSAqPSB6O1xyXG5cdFx0dGVbIDEgXSAqPSB4OyB0ZVsgNSBdICo9IHk7IHRlWyA5IF0gKj0gejtcclxuXHRcdHRlWyAyIF0gKj0geDsgdGVbIDYgXSAqPSB5OyB0ZVsgMTAgXSAqPSB6O1xyXG5cdFx0dGVbIDMgXSAqPSB4OyB0ZVsgNyBdICo9IHk7IHRlWyAxMSBdICo9IHo7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG4gICAgc2V0VHJhbnNsYXRlIDpmdW5jdGlvbih4LCB5LCB6KSB7XHJcbiAgICAgICAgdmFyIGUgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgICAgIGVbMF0gPSAxOyAgZVs0XSA9IDA7ICBlWzhdICA9IDA7ICBlWzEyXSA9IHg7XHJcbiAgICAgICAgZVsxXSA9IDA7ICBlWzVdID0gMTsgIGVbOV0gID0gMDsgIGVbMTNdID0geTtcclxuICAgICAgICBlWzJdID0gMDsgIGVbNl0gPSAwOyAgZVsxMF0gPSAxOyAgZVsxNF0gPSB6O1xyXG4gICAgICAgIGVbM10gPSAwOyAgZVs3XSA9IDA7ICBlWzExXSA9IDA7ICBlWzE1XSA9IDE7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHRyYW5zbGF0ZSA6ZnVuY3Rpb24oeCwgeSwgeikge1xyXG4gICAgICAgIHZhciBlID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICBlWzEyXSArPSBlWzBdICogeCArIGVbNF0gKiB5ICsgZVs4XSAgKiB6O1xyXG4gICAgICAgIGVbMTNdICs9IGVbMV0gKiB4ICsgZVs1XSAqIHkgKyBlWzldICAqIHo7XHJcbiAgICAgICAgZVsxNF0gKz0gZVsyXSAqIHggKyBlWzZdICogeSArIGVbMTBdICogejtcclxuICAgICAgICBlWzE1XSArPSBlWzNdICogeCArIGVbN10gKiB5ICsgZVsxMV0gKiB6O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRSb3RhdGUgOmZ1bmN0aW9uKGFuZ2xlLCB4LCB5LCB6KSB7XHJcbiAgICAgICAgdmFyIGUsIHMsIGMsIGxlbiwgcmxlbiwgbmMsIHh5LCB5eiwgengsIHhzLCB5cywgenM7XHJcblxyXG4gICAgICAgIGFuZ2xlID0gTWF0aC5QSSAqIGFuZ2xlIC8gMTgwO1xyXG4gICAgICAgIGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuICAgICAgICBzID0gTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgICAgIGMgPSBNYXRoLmNvcyhhbmdsZSk7XHJcblxyXG4gICAgICAgIGlmICgwICE9PSB4ICYmIDAgPT09IHkgJiYgMCA9PT0geikge1xyXG4gICAgICAgICAgICAvLyBSb3RhdGlvbiBhcm91bmQgWCBheGlzXHJcbiAgICAgICAgICAgIGlmICh4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgcyA9IC1zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVbMF0gPSAxOyAgZVs0XSA9IDA7ICBlWyA4XSA9IDA7ICBlWzEyXSA9IDA7XHJcbiAgICAgICAgICAgIGVbMV0gPSAwOyAgZVs1XSA9IGM7ICBlWyA5XSA9LXM7ICBlWzEzXSA9IDA7XHJcbiAgICAgICAgICAgIGVbMl0gPSAwOyAgZVs2XSA9IHM7ICBlWzEwXSA9IGM7ICBlWzE0XSA9IDA7XHJcbiAgICAgICAgICAgIGVbM10gPSAwOyAgZVs3XSA9IDA7ICBlWzExXSA9IDA7ICBlWzE1XSA9IDE7XHJcbiAgICAgICAgfSBlbHNlIGlmICgwID09PSB4ICYmIDAgIT09IHkgJiYgMCA9PT0geikge1xyXG4gICAgICAgICAgICAvLyBSb3RhdGlvbiBhcm91bmQgWSBheGlzXHJcbiAgICAgICAgICAgIGlmICh5IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgcyA9IC1zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVbMF0gPSBjOyAgZVs0XSA9IDA7ICBlWyA4XSA9IHM7ICBlWzEyXSA9IDA7XHJcbiAgICAgICAgICAgIGVbMV0gPSAwOyAgZVs1XSA9IDE7ICBlWyA5XSA9IDA7ICBlWzEzXSA9IDA7XHJcbiAgICAgICAgICAgIGVbMl0gPS1zOyAgZVs2XSA9IDA7ICBlWzEwXSA9IGM7ICBlWzE0XSA9IDA7XHJcbiAgICAgICAgICAgIGVbM10gPSAwOyAgZVs3XSA9IDA7ICBlWzExXSA9IDA7ICBlWzE1XSA9IDE7XHJcbiAgICAgICAgfSBlbHNlIGlmICgwID09PSB4ICYmIDAgPT09IHkgJiYgMCAhPT0geikge1xyXG4gICAgICAgICAgICAvLyBSb3RhdGlvbiBhcm91bmQgWiBheGlzXHJcbiAgICAgICAgICAgIGlmICh6IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgcyA9IC1zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVbMF0gPSBjOyAgZVs0XSA9LXM7ICBlWyA4XSA9IDA7ICBlWzEyXSA9IDA7XHJcbiAgICAgICAgICAgIGVbMV0gPSBzOyAgZVs1XSA9IGM7ICBlWyA5XSA9IDA7ICBlWzEzXSA9IDA7XHJcbiAgICAgICAgICAgIGVbMl0gPSAwOyAgZVs2XSA9IDA7ICBlWzEwXSA9IDE7ICBlWzE0XSA9IDA7XHJcbiAgICAgICAgICAgIGVbM10gPSAwOyAgZVs3XSA9IDA7ICBlWzExXSA9IDA7ICBlWzE1XSA9IDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gUm90YXRpb24gYXJvdW5kIGFub3RoZXIgYXhpc1xyXG4gICAgICAgICAgICBsZW4gPSBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KTtcclxuICAgICAgICAgICAgaWYgKGxlbiAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmxlbiA9IDEgLyBsZW47XHJcbiAgICAgICAgICAgICAgICB4ICo9IHJsZW47XHJcbiAgICAgICAgICAgICAgICB5ICo9IHJsZW47XHJcbiAgICAgICAgICAgICAgICB6ICo9IHJsZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbmMgPSAxIC0gYztcclxuICAgICAgICAgICAgeHkgPSB4ICogeTtcclxuICAgICAgICAgICAgeXogPSB5ICogejtcclxuICAgICAgICAgICAgenggPSB6ICogeDtcclxuICAgICAgICAgICAgeHMgPSB4ICogcztcclxuICAgICAgICAgICAgeXMgPSB5ICogcztcclxuICAgICAgICAgICAgenMgPSB6ICogcztcclxuXHJcbiAgICAgICAgICAgIGVbIDBdID0geCp4Km5jICsgIGM7XHJcbiAgICAgICAgICAgIGVbIDFdID0geHkgKm5jICsgenM7XHJcbiAgICAgICAgICAgIGVbIDJdID0genggKm5jIC0geXM7XHJcbiAgICAgICAgICAgIGVbIDNdID0gMDtcclxuXHJcbiAgICAgICAgICAgIGVbIDRdID0geHkgKm5jIC0genM7XHJcbiAgICAgICAgICAgIGVbIDVdID0geSp5Km5jICsgIGM7XHJcbiAgICAgICAgICAgIGVbIDZdID0geXogKm5jICsgeHM7XHJcbiAgICAgICAgICAgIGVbIDddID0gMDtcclxuXHJcbiAgICAgICAgICAgIGVbIDhdID0genggKm5jICsgeXM7XHJcbiAgICAgICAgICAgIGVbIDldID0geXogKm5jIC0geHM7XHJcbiAgICAgICAgICAgIGVbMTBdID0geip6Km5jICsgIGM7XHJcbiAgICAgICAgICAgIGVbMTFdID0gMDtcclxuXHJcbiAgICAgICAgICAgIGVbMTJdID0gMDtcclxuICAgICAgICAgICAgZVsxM10gPSAwO1xyXG4gICAgICAgICAgICBlWzE0XSA9IDA7XHJcbiAgICAgICAgICAgIGVbMTVdID0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICByb3RhdGUgOmZ1bmN0aW9uKGFuZ2xlLCB4LCB5LCB6KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uY2F0KG5ldyBNYXRyaXg0KCkuc2V0Um90YXRlKGFuZ2xlLCB4LCB5LCB6KSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldExvb2tBdCA6ZnVuY3Rpb24oZXllWCwgZXllWSwgZXllWiwgY2VudGVyWCwgY2VudGVyWSwgY2VudGVyWiwgdXBYLCB1cFksIHVwWikge1xyXG4gICAgICAgIHZhciBlLCBmeCwgZnksIGZ6LCBybGYsIHN4LCBzeSwgc3osIHJscywgdXgsIHV5LCB1ejtcclxuXHJcbiAgICAgICAgZnggPSBjZW50ZXJYIC0gZXllWDtcclxuICAgICAgICBmeSA9IGNlbnRlclkgLSBleWVZO1xyXG4gICAgICAgIGZ6ID0gY2VudGVyWiAtIGV5ZVo7XHJcblxyXG4gICAgICAgIC8vIE5vcm1hbGl6ZSBmLlxyXG4gICAgICAgIHJsZiA9IDEgLyBNYXRoLnNxcnQoZngqZnggKyBmeSpmeSArIGZ6KmZ6KTtcclxuICAgICAgICBmeCAqPSBybGY7XHJcbiAgICAgICAgZnkgKj0gcmxmO1xyXG4gICAgICAgIGZ6ICo9IHJsZjtcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGNyb3NzIHByb2R1Y3Qgb2YgZiBhbmQgdXAuXHJcbiAgICAgICAgc3ggPSBmeSAqIHVwWiAtIGZ6ICogdXBZO1xyXG4gICAgICAgIHN5ID0gZnogKiB1cFggLSBmeCAqIHVwWjtcclxuICAgICAgICBzeiA9IGZ4ICogdXBZIC0gZnkgKiB1cFg7XHJcblxyXG4gICAgICAgIC8vIE5vcm1hbGl6ZSBzLlxyXG4gICAgICAgIHJscyA9IDEgLyBNYXRoLnNxcnQoc3gqc3ggKyBzeSpzeSArIHN6KnN6KTtcclxuICAgICAgICBzeCAqPSBybHM7XHJcbiAgICAgICAgc3kgKj0gcmxzO1xyXG4gICAgICAgIHN6ICo9IHJscztcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGNyb3NzIHByb2R1Y3Qgb2YgcyBhbmQgZi5cclxuICAgICAgICB1eCA9IHN5ICogZnogLSBzeiAqIGZ5O1xyXG4gICAgICAgIHV5ID0gc3ogKiBmeCAtIHN4ICogZno7XHJcbiAgICAgICAgdXogPSBzeCAqIGZ5IC0gc3kgKiBmeDtcclxuXHJcbiAgICAgICAgLy8gU2V0IHRvIHRoaXMuXHJcbiAgICAgICAgZSA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICAgICAgZVswXSA9IHN4O1xyXG4gICAgICAgIGVbMV0gPSB1eDtcclxuICAgICAgICBlWzJdID0gLWZ4O1xyXG4gICAgICAgIGVbM10gPSAwO1xyXG5cclxuICAgICAgICBlWzRdID0gc3k7XHJcbiAgICAgICAgZVs1XSA9IHV5O1xyXG4gICAgICAgIGVbNl0gPSAtZnk7XHJcbiAgICAgICAgZVs3XSA9IDA7XHJcblxyXG4gICAgICAgIGVbOF0gPSBzejtcclxuICAgICAgICBlWzldID0gdXo7XHJcbiAgICAgICAgZVsxMF0gPSAtZno7XHJcbiAgICAgICAgZVsxMV0gPSAwO1xyXG5cclxuICAgICAgICBlWzEyXSA9IDA7XHJcbiAgICAgICAgZVsxM10gPSAwO1xyXG4gICAgICAgIGVbMTRdID0gMDtcclxuICAgICAgICBlWzE1XSA9IDE7XHJcblxyXG4gICAgICAgIC8vIFRyYW5zbGF0ZS5cclxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGUoLWV5ZVgsIC1leWVZLCAtZXllWik7XHJcbiAgICB9LFxyXG5cclxuICAgIGxvb2tBdDIgOmZ1bmN0aW9uKGV5ZVgsIGV5ZVksIGV5ZVosIGNlbnRlclgsIGNlbnRlclksIGNlbnRlclosIHVwWCwgdXBZLCB1cFopIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb25jYXQobmV3IE1hdHJpeDQoKS5zZXRMb29rQXQoZXllWCwgZXllWSwgZXllWiwgY2VudGVyWCwgY2VudGVyWSwgY2VudGVyWiwgdXBYLCB1cFksIHVwWikpO1xyXG4gICAgfSxcclxuXHJcblx0Z2V0TWF4U2NhbGVPbkF4aXM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHZhciBzY2FsZVhTcSA9IHRlWyAwIF0gKiB0ZVsgMCBdICsgdGVbIDEgXSAqIHRlWyAxIF0gKyB0ZVsgMiBdICogdGVbIDIgXTtcclxuXHRcdHZhciBzY2FsZVlTcSA9IHRlWyA0IF0gKiB0ZVsgNCBdICsgdGVbIDUgXSAqIHRlWyA1IF0gKyB0ZVsgNiBdICogdGVbIDYgXTtcclxuXHRcdHZhciBzY2FsZVpTcSA9IHRlWyA4IF0gKiB0ZVsgOCBdICsgdGVbIDkgXSAqIHRlWyA5IF0gKyB0ZVsgMTAgXSAqIHRlWyAxMCBdO1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIE1hdGgubWF4KCBzY2FsZVhTcSwgc2NhbGVZU3EsIHNjYWxlWlNxICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bWFrZVRyYW5zbGF0aW9uOiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHQxLCAwLCAwLCB4LFxyXG5cdFx0XHQwLCAxLCAwLCB5LFxyXG5cdFx0XHQwLCAwLCAxLCB6LFxyXG5cdFx0XHQwLCAwLCAwLCAxXHJcblxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWFrZVJvdGF0aW9uWDogZnVuY3Rpb24gKCB0aGV0YSApIHtcclxuXHJcblx0XHR2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XHJcblxyXG5cdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHQxLCAwLCAwLCAwLFxyXG5cdFx0XHQwLCBjLCAtIHMsIDAsXHJcblx0XHRcdDAsIHMsIGMsIDAsXHJcblx0XHRcdDAsIDAsIDAsIDFcclxuXHJcblx0XHQpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlUm90YXRpb25ZOiBmdW5jdGlvbiAoIHRoZXRhICkge1xyXG5cclxuXHRcdHZhciBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHJcblx0XHRcdCBjLCAwLCBzLCAwLFxyXG5cdFx0XHQgMCwgMSwgMCwgMCxcclxuXHRcdFx0LSBzLCAwLCBjLCAwLFxyXG5cdFx0XHQgMCwgMCwgMCwgMVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1ha2VSb3RhdGlvblo6IGZ1bmN0aW9uICggdGhldGEgKSB7XHJcblxyXG5cdFx0dmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0YywgLSBzLCAwLCAwLFxyXG5cdFx0XHRzLCBjLCAwLCAwLFxyXG5cdFx0XHQwLCAwLCAxLCAwLFxyXG5cdFx0XHQwLCAwLCAwLCAxXHJcblxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWFrZVJvdGF0aW9uQXhpczogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcclxuXHJcblx0XHQvLyBCYXNlZCBvbiBodHRwOi8vd3d3LmdhbWVkZXYubmV0L3JlZmVyZW5jZS9hcnRpY2xlcy9hcnRpY2xlMTE5OS5hc3BcclxuXHJcblx0XHR2YXIgYyA9IE1hdGguY29zKCBhbmdsZSApO1xyXG5cdFx0dmFyIHMgPSBNYXRoLnNpbiggYW5nbGUgKTtcclxuXHRcdHZhciB0ID0gMSAtIGM7XHJcblx0XHR2YXIgeCA9IGF4aXMueCwgeSA9IGF4aXMueSwgeiA9IGF4aXMuejtcclxuXHRcdHZhciB0eCA9IHQgKiB4LCB0eSA9IHQgKiB5O1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0dHggKiB4ICsgYywgdHggKiB5IC0gcyAqIHosIHR4ICogeiArIHMgKiB5LCAwLFxyXG5cdFx0XHR0eCAqIHkgKyBzICogeiwgdHkgKiB5ICsgYywgdHkgKiB6IC0gcyAqIHgsIDAsXHJcblx0XHRcdHR4ICogeiAtIHMgKiB5LCB0eSAqIHogKyBzICogeCwgdCAqIHogKiB6ICsgYywgMCxcclxuXHRcdFx0MCwgMCwgMCwgMVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0IHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlU2NhbGU6IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHJcblx0XHRcdHgsIDAsIDAsIDAsXHJcblx0XHRcdDAsIHksIDAsIDAsXHJcblx0XHRcdDAsIDAsIHosIDAsXHJcblx0XHRcdDAsIDAsIDAsIDFcclxuXHJcblx0XHQpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlU2hlYXI6IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHJcblx0XHRcdDEsIHksIHosIDAsXHJcblx0XHRcdHgsIDEsIHosIDAsXHJcblx0XHRcdHgsIHksIDEsIDAsXHJcblx0XHRcdDAsIDAsIDAsIDFcclxuXHJcblx0XHQpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wb3NlOiBmdW5jdGlvbiAoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHZhciB4ID0gcXVhdGVybmlvbi5feCwgeSA9IHF1YXRlcm5pb24uX3ksIHogPSBxdWF0ZXJuaW9uLl96LCB3ID0gcXVhdGVybmlvbi5fdztcclxuXHRcdHZhciB4MiA9IHggKyB4LFx0eTIgPSB5ICsgeSwgejIgPSB6ICsgejtcclxuXHRcdHZhciB4eCA9IHggKiB4MiwgeHkgPSB4ICogeTIsIHh6ID0geCAqIHoyO1xyXG5cdFx0dmFyIHl5ID0geSAqIHkyLCB5eiA9IHkgKiB6MiwgenogPSB6ICogejI7XHJcblx0XHR2YXIgd3ggPSB3ICogeDIsIHd5ID0gdyAqIHkyLCB3eiA9IHcgKiB6MjtcclxuXHJcblx0XHR2YXIgc3ggPSBzY2FsZS54LCBzeSA9IHNjYWxlLnksIHN6ID0gc2NhbGUuejtcclxuXHJcblx0ICAgICAgICB0ZVsgMCBdID0gKCAxIC0gKCB5eSArIHp6ICkgKSAqIHN4O1xyXG5cdCAgICAgICAgdGVbIDEgXSA9ICggeHkgKyB3eiApICogc3g7XHJcblx0ICAgICAgICB0ZVsgMiBdID0gKCB4eiAtIHd5ICkgKiBzeDtcclxuXHQgICAgICAgIHRlWyAzIF0gPSAwO1xyXG5cclxuXHQgICAgICAgIHRlWyA0IF0gPSAoIHh5IC0gd3ogKSAqIHN5O1xyXG5cdCAgICAgICAgdGVbIDUgXSA9ICggMSAtICggeHggKyB6eiApICkgKiBzeTtcclxuXHQgICAgICAgIHRlWyA2IF0gPSAoIHl6ICsgd3ggKSAqIHN5O1xyXG5cdCAgICAgICAgdGVbIDcgXSA9IDA7XHJcblxyXG5cdCAgICAgICAgdGVbIDggXSA9ICggeHogKyB3eSApICogc3o7XHJcblx0ICAgICAgICB0ZVsgOSBdID0gKCB5eiAtIHd4ICkgKiBzejtcclxuXHQgICAgICAgIHRlWyAxMCBdID0gKCAxIC0gKCB4eCArIHl5ICkgKSAqIHN6O1xyXG5cdCAgICAgICAgdGVbIDExIF0gPSAwO1xyXG5cclxuXHQgICAgICAgIHRlWyAxMiBdID0gcG9zaXRpb24ueDtcclxuXHQgICAgICAgIHRlWyAxMyBdID0gcG9zaXRpb24ueTtcclxuXHQgICAgICAgIHRlWyAxNCBdID0gcG9zaXRpb24uejtcclxuXHQgICAgICAgIHRlWyAxNSBdID0gMTtcclxuXHJcblx0ICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZGVjb21wb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHR2YXIgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKSB7XHJcblxyXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdFx0dmFyIHN4ID0gdmVjdG9yLnNldCggdGVbIDAgXSwgdGVbIDEgXSwgdGVbIDIgXSApLmxlbmd0aCgpO1xyXG5cdFx0XHR2YXIgc3kgPSB2ZWN0b3Iuc2V0KCB0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdICkubGVuZ3RoKCk7XHJcblx0XHRcdHZhciBzeiA9IHZlY3Rvci5zZXQoIHRlWyA4IF0sIHRlWyA5IF0sIHRlWyAxMCBdICkubGVuZ3RoKCk7XHJcblxyXG5cdFx0XHQvLyBpZiBkZXRlcm1pbmUgaXMgbmVnYXRpdmUsIHdlIG5lZWQgdG8gaW52ZXJ0IG9uZSBzY2FsZVxyXG5cdFx0XHR2YXIgZGV0ID0gdGhpcy5kZXRlcm1pbmFudCgpO1xyXG5cdFx0XHRpZiAoIGRldCA8IDAgKSBzeCA9IC0gc3g7XHJcblxyXG5cdFx0XHRwb3NpdGlvbi54ID0gdGVbIDEyIF07XHJcblx0XHRcdHBvc2l0aW9uLnkgPSB0ZVsgMTMgXTtcclxuXHRcdFx0cG9zaXRpb24ueiA9IHRlWyAxNCBdO1xyXG5cclxuXHRcdFx0Ly8gc2NhbGUgdGhlIHJvdGF0aW9uIHBhcnRcclxuXHRcdFx0bWF0cml4LmNvcHkoIHRoaXMgKTtcclxuXHJcblx0XHRcdHZhciBpbnZTWCA9IDEgLyBzeDtcclxuXHRcdFx0dmFyIGludlNZID0gMSAvIHN5O1xyXG5cdFx0XHR2YXIgaW52U1ogPSAxIC8gc3o7XHJcblxyXG5cdFx0XHRtYXRyaXguZWxlbWVudHNbIDAgXSAqPSBpbnZTWDtcclxuXHRcdFx0bWF0cml4LmVsZW1lbnRzWyAxIF0gKj0gaW52U1g7XHJcblx0XHRcdG1hdHJpeC5lbGVtZW50c1sgMiBdICo9IGludlNYO1xyXG5cclxuXHRcdFx0bWF0cml4LmVsZW1lbnRzWyA0IF0gKj0gaW52U1k7XHJcblx0XHRcdG1hdHJpeC5lbGVtZW50c1sgNSBdICo9IGludlNZO1xyXG5cdFx0XHRtYXRyaXguZWxlbWVudHNbIDYgXSAqPSBpbnZTWTtcclxuXHJcblx0XHRcdG1hdHJpeC5lbGVtZW50c1sgOCBdICo9IGludlNaO1xyXG5cdFx0XHRtYXRyaXguZWxlbWVudHNbIDkgXSAqPSBpbnZTWjtcclxuXHRcdFx0bWF0cml4LmVsZW1lbnRzWyAxMCBdICo9IGludlNaO1xyXG5cclxuXHRcdFx0cXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG1hdHJpeCApO1xyXG5cclxuXHRcdFx0c2NhbGUueCA9IHN4O1xyXG5cdFx0XHRzY2FsZS55ID0gc3k7XHJcblx0XHRcdHNjYWxlLnogPSBzejtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0bWFrZVBlcnNwZWN0aXZlOiBmdW5jdGlvbiAoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICkge1xyXG5cclxuXHRcdGlmICggZmFyID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdDT09MLk1hdHJpeDQ6IC5tYWtlUGVyc3BlY3RpdmUoKSBoYXMgYmVlbiByZWRlZmluZWQgYW5kIGhhcyBhIG5ldyBzaWduYXR1cmUuIFBsZWFzZSBjaGVjayB0aGUgZG9jcy4nICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHR2YXIgeCA9IDIgKiBuZWFyIC8gKCByaWdodCAtIGxlZnQgKTtcclxuXHRcdHZhciB5ID0gMiAqIG5lYXIgLyAoIHRvcCAtIGJvdHRvbSApO1xyXG5cclxuXHRcdHZhciBhID0gKCByaWdodCArIGxlZnQgKSAvICggcmlnaHQgLSBsZWZ0ICk7XHJcblx0XHR2YXIgYiA9ICggdG9wICsgYm90dG9tICkgLyAoIHRvcCAtIGJvdHRvbSApO1xyXG5cdFx0dmFyIGMgPSAtICggZmFyICsgbmVhciApIC8gKCBmYXIgLSBuZWFyICk7XHJcblx0XHR2YXIgZCA9IC0gMiAqIGZhciAqIG5lYXIgLyAoIGZhciAtIG5lYXIgKTtcclxuXHJcblx0XHR0ZVsgMCBdID0geDtcdHRlWyA0IF0gPSAwO1x0dGVbIDggXSA9IGE7XHR0ZVsgMTIgXSA9IDA7XHJcblx0XHR0ZVsgMSBdID0gMDtcdHRlWyA1IF0gPSB5O1x0dGVbIDkgXSA9IGI7XHR0ZVsgMTMgXSA9IDA7XHJcblx0XHR0ZVsgMiBdID0gMDtcdHRlWyA2IF0gPSAwO1x0dGVbIDEwIF0gPSBjO1x0dGVbIDE0IF0gPSBkO1xyXG5cdFx0dGVbIDMgXSA9IDA7XHR0ZVsgNyBdID0gMDtcdHRlWyAxMSBdID0gLSAxO1x0dGVbIDE1IF0gPSAwO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlT3J0aG9ncmFwaGljOiBmdW5jdGlvbiAoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHR2YXIgdyA9IDEuMCAvICggcmlnaHQgLSBsZWZ0ICk7XHJcblx0XHR2YXIgaCA9IDEuMCAvICggdG9wIC0gYm90dG9tICk7XHJcblx0XHR2YXIgcCA9IDEuMCAvICggZmFyIC0gbmVhciApO1xyXG5cclxuXHRcdHZhciB4ID0gKCByaWdodCArIGxlZnQgKSAqIHc7XHJcblx0XHR2YXIgeSA9ICggdG9wICsgYm90dG9tICkgKiBoO1xyXG5cdFx0dmFyIHogPSAoIGZhciArIG5lYXIgKSAqIHA7XHJcblxyXG5cdFx0dGVbIDAgXSA9IDIgKiB3O1x0dGVbIDQgXSA9IDA7XHR0ZVsgOCBdID0gMDtcdHRlWyAxMiBdID0gLSB4O1xyXG5cdFx0dGVbIDEgXSA9IDA7XHR0ZVsgNSBdID0gMiAqIGg7XHR0ZVsgOSBdID0gMDtcdHRlWyAxMyBdID0gLSB5O1xyXG5cdFx0dGVbIDIgXSA9IDA7XHR0ZVsgNiBdID0gMDtcdHRlWyAxMCBdID0gLSAyICogcDtcdHRlWyAxNCBdID0gLSB6O1xyXG5cdFx0dGVbIDMgXSA9IDA7XHR0ZVsgNyBdID0gMDtcdHRlWyAxMSBdID0gMDtcdHRlWyAxNSBdID0gMTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0dmFyIG1lID0gbWF0cml4LmVsZW1lbnRzO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDE2OyBpICsrICkge1xyXG5cclxuXHRcdFx0aWYgKCB0ZVsgaSBdICE9PSBtZVsgaSBdICkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgMTY7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmVsZW1lbnRzWyBpIF0gPSBhcnJheVsgaSArIG9mZnNldCBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XHJcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRlWyAwIF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGVbIDEgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0ZVsgMiBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRlWyAzIF07XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgNSBdID0gdGVbIDUgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyA2IF0gPSB0ZVsgNiBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDcgXSA9IHRlWyA3IF07XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCArIDggXSA9IHRlWyA4IF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgOSBdID0gdGVbIDkgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxMCBdID0gdGVbIDEwIF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTEgXSA9IHRlWyAxMSBdO1xyXG5cclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxMiBdID0gdGVbIDEyIF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTMgXSA9IHRlWyAxMyBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDE0IF0gPSB0ZVsgMTQgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxNSBdID0gdGVbIDE1IF07XHJcblxyXG5cdFx0cmV0dXJuIGFycmF5O1xyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcblxyXG5cclxuZXhwb3J0IHsgTWF0cml4NCB9O1xyXG4iLCIvKipcclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICovXHJcblxyXG5pbXBvcnQgIHtfTWF0aH0gZnJvbSAnLi8vTWF0aC5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuL1ZlY3RvcjMuanMnO1xyXG5cclxuZnVuY3Rpb24gUXVhdGVybmlvbiggeCwgeSwgeiwgdyApIHtcclxuXHJcblx0dGhpcy5feCA9IHggfHwgMDtcclxuXHR0aGlzLl95ID0geSB8fCAwO1xyXG5cdHRoaXMuX3ogPSB6IHx8IDA7XHJcblx0dGhpcy5fdyA9ICggdyAhPT0gdW5kZWZpbmVkICkgPyB3IDogMTtcclxuXHJcbn1cclxuXHJcbk9iamVjdC5hc3NpZ24oIFF1YXRlcm5pb24sIHtcclxuXHJcblx0c2xlcnA6IGZ1bmN0aW9uICggcWEsIHFiLCBxbSwgdCApIHtcclxuXHJcblx0XHRyZXR1cm4gcW0uY29weSggcWEgKS5zbGVycCggcWIsIHQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2xlcnBGbGF0OiBmdW5jdGlvbiAoIGRzdCwgZHN0T2Zmc2V0LCBzcmMwLCBzcmNPZmZzZXQwLCBzcmMxLCBzcmNPZmZzZXQxLCB0ICkge1xyXG5cclxuXHRcdC8vIGZ1enotZnJlZSwgYXJyYXktYmFzZWQgUXVhdGVybmlvbiBTTEVSUCBvcGVyYXRpb25cclxuXHJcblx0XHR2YXIgeDAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMCBdLFxyXG5cdFx0XHR5MCA9IHNyYzBbIHNyY09mZnNldDAgKyAxIF0sXHJcblx0XHRcdHowID0gc3JjMFsgc3JjT2Zmc2V0MCArIDIgXSxcclxuXHRcdFx0dzAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMyBdLFxyXG5cclxuXHRcdFx0eDEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMCBdLFxyXG5cdFx0XHR5MSA9IHNyYzFbIHNyY09mZnNldDEgKyAxIF0sXHJcblx0XHRcdHoxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDIgXSxcclxuXHRcdFx0dzEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMyBdO1xyXG5cclxuXHRcdGlmICggdzAgIT09IHcxIHx8IHgwICE9PSB4MSB8fCB5MCAhPT0geTEgfHwgejAgIT09IHoxICkge1xyXG5cclxuXHRcdFx0dmFyIHMgPSAxIC0gdCxcclxuXHJcblx0XHRcdFx0Y29zID0geDAgKiB4MSArIHkwICogeTEgKyB6MCAqIHoxICsgdzAgKiB3MSxcclxuXHJcblx0XHRcdFx0ZGlyID0gKCBjb3MgPj0gMCA/IDEgOiAtIDEgKSxcclxuXHRcdFx0XHRzcXJTaW4gPSAxIC0gY29zICogY29zO1xyXG5cclxuXHRcdFx0Ly8gU2tpcCB0aGUgU2xlcnAgZm9yIHRpbnkgc3RlcHMgdG8gYXZvaWQgbnVtZXJpYyBwcm9ibGVtczpcclxuXHRcdFx0aWYgKCBzcXJTaW4gPiBOdW1iZXIuRVBTSUxPTiApIHtcclxuXHJcblx0XHRcdFx0dmFyIHNpbiA9IE1hdGguc3FydCggc3FyU2luICksXHJcblx0XHRcdFx0XHRsZW4gPSBNYXRoLmF0YW4yKCBzaW4sIGNvcyAqIGRpciApO1xyXG5cclxuXHRcdFx0XHRzID0gTWF0aC5zaW4oIHMgKiBsZW4gKSAvIHNpbjtcclxuXHRcdFx0XHR0ID0gTWF0aC5zaW4oIHQgKiBsZW4gKSAvIHNpbjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciB0RGlyID0gdCAqIGRpcjtcclxuXHJcblx0XHRcdHgwID0geDAgKiBzICsgeDEgKiB0RGlyO1xyXG5cdFx0XHR5MCA9IHkwICogcyArIHkxICogdERpcjtcclxuXHRcdFx0ejAgPSB6MCAqIHMgKyB6MSAqIHREaXI7XHJcblx0XHRcdHcwID0gdzAgKiBzICsgdzEgKiB0RGlyO1xyXG5cclxuXHRcdFx0Ly8gTm9ybWFsaXplIGluIGNhc2Ugd2UganVzdCBkaWQgYSBsZXJwOlxyXG5cdFx0XHRpZiAoIHMgPT09IDEgLSB0ICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZiA9IDEgLyBNYXRoLnNxcnQoIHgwICogeDAgKyB5MCAqIHkwICsgejAgKiB6MCArIHcwICogdzAgKTtcclxuXHJcblx0XHRcdFx0eDAgKj0gZjtcclxuXHRcdFx0XHR5MCAqPSBmO1xyXG5cdFx0XHRcdHowICo9IGY7XHJcblx0XHRcdFx0dzAgKj0gZjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZHN0WyBkc3RPZmZzZXQgXSA9IHgwO1xyXG5cdFx0ZHN0WyBkc3RPZmZzZXQgKyAxIF0gPSB5MDtcclxuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMiBdID0gejA7XHJcblx0XHRkc3RbIGRzdE9mZnNldCArIDMgXSA9IHcwO1xyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggUXVhdGVybmlvbi5wcm90b3R5cGUsIHtcclxuXHJcblx0eDoge1xyXG5cclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuX3g7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl94ID0gdmFsdWU7XHJcblx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0eToge1xyXG5cclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuX3k7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl95ID0gdmFsdWU7XHJcblx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0ejoge1xyXG5cclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuX3o7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl96ID0gdmFsdWU7XHJcblx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0dzoge1xyXG5cclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuX3c7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl93ID0gdmFsdWU7XHJcblx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufSApO1xyXG5cclxuT2JqZWN0LmFzc2lnbiggUXVhdGVybmlvbi5wcm90b3R5cGUsIHtcclxuXHJcblx0aXNRdWF0ZXJuaW9uOiB0cnVlLFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcclxuXHJcblx0XHR0aGlzLl94ID0geDtcclxuXHRcdHRoaXMuX3kgPSB5O1xyXG5cdFx0dGhpcy5feiA9IHo7XHJcblx0XHR0aGlzLl93ID0gdztcclxuXHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX3cgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBxdWF0ZXJuaW9uICkge1xyXG5cclxuXHRcdHRoaXMuX3ggPSBxdWF0ZXJuaW9uLng7XHJcblx0XHR0aGlzLl95ID0gcXVhdGVybmlvbi55O1xyXG5cdFx0dGhpcy5feiA9IHF1YXRlcm5pb24uejtcclxuXHRcdHRoaXMuX3cgPSBxdWF0ZXJuaW9uLnc7XHJcblxyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21FdWxlcjogZnVuY3Rpb24gKCBldWxlciwgdXBkYXRlICkge1xyXG5cclxuXHRcdGlmICggISAoIGV1bGVyICYmIGV1bGVyLmlzRXVsZXIgKSApIHtcclxuXHJcblx0XHRcdHRocm93IG5ldyBFcnJvciggJ0NPT0wuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIG5vdyBleHBlY3RzIGFuIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgeCA9IGV1bGVyLl94LCB5ID0gZXVsZXIuX3ksIHogPSBldWxlci5feiwgb3JkZXIgPSBldWxlci5vcmRlcjtcclxuXHJcblx0XHQvLyBodHRwOi8vd3d3Lm1hdGh3b3Jrcy5jb20vbWF0bGFiY2VudHJhbC9maWxlZXhjaGFuZ2UvXHJcblx0XHQvLyBcdDIwNjk2LWZ1bmN0aW9uLXRvLWNvbnZlcnQtYmV0d2Vlbi1kY20tZXVsZXItYW5nbGVzLXF1YXRlcm5pb25zLWFuZC1ldWxlci12ZWN0b3JzL1xyXG5cdFx0Ly9cdGNvbnRlbnQvU3BpbkNhbGMubVxyXG5cclxuXHRcdHZhciBjb3MgPSBNYXRoLmNvcztcclxuXHRcdHZhciBzaW4gPSBNYXRoLnNpbjtcclxuXHJcblx0XHR2YXIgYzEgPSBjb3MoIHggLyAyICk7XHJcblx0XHR2YXIgYzIgPSBjb3MoIHkgLyAyICk7XHJcblx0XHR2YXIgYzMgPSBjb3MoIHogLyAyICk7XHJcblxyXG5cdFx0dmFyIHMxID0gc2luKCB4IC8gMiApO1xyXG5cdFx0dmFyIHMyID0gc2luKCB5IC8gMiApO1xyXG5cdFx0dmFyIHMzID0gc2luKCB6IC8gMiApO1xyXG5cclxuXHRcdGlmICggb3JkZXIgPT09ICdYWVonICkge1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcclxuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcclxuXHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcclxuXHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1lYWicgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xyXG5cdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xyXG5cdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xyXG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWlhZJyApIHtcclxuXHJcblx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XHJcblx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XHJcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XHJcblx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWVgnICkge1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcclxuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcclxuXHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcclxuXHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1laWCcgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xyXG5cdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xyXG5cdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xyXG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWFpZJyApIHtcclxuXHJcblx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XHJcblx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XHJcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XHJcblx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdXBkYXRlICE9PSBmYWxzZSApIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tQXhpc0FuZ2xlOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xyXG5cclxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9hbmdsZVRvUXVhdGVybmlvbi9pbmRleC5odG1cclxuXHJcblx0XHQvLyBhc3N1bWVzIGF4aXMgaXMgbm9ybWFsaXplZFxyXG5cclxuXHRcdHZhciBoYWxmQW5nbGUgPSBhbmdsZSAvIDIsIHMgPSBNYXRoLnNpbiggaGFsZkFuZ2xlICk7XHJcblxyXG5cdFx0dGhpcy5feCA9IGF4aXMueCAqIHM7XHJcblx0XHR0aGlzLl95ID0gYXhpcy55ICogcztcclxuXHRcdHRoaXMuX3ogPSBheGlzLnogKiBzO1xyXG5cdFx0dGhpcy5fdyA9IE1hdGguY29zKCBoYWxmQW5nbGUgKTtcclxuXHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvUXVhdGVybmlvbi9pbmRleC5odG1cclxuXHJcblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxyXG5cclxuXHRcdHZhciB0ZSA9IG0uZWxlbWVudHMsXHJcblxyXG5cdFx0XHRtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdLFxyXG5cdFx0XHRtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdLFxyXG5cdFx0XHRtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXSxcclxuXHJcblx0XHRcdHRyYWNlID0gbTExICsgbTIyICsgbTMzLFxyXG5cdFx0XHRzO1xyXG5cclxuXHRcdGlmICggdHJhY2UgPiAwICkge1xyXG5cclxuXHRcdFx0cyA9IDAuNSAvIE1hdGguc3FydCggdHJhY2UgKyAxLjAgKTtcclxuXHJcblx0XHRcdHRoaXMuX3cgPSAwLjI1IC8gcztcclxuXHRcdFx0dGhpcy5feCA9ICggbTMyIC0gbTIzICkgKiBzO1xyXG5cdFx0XHR0aGlzLl95ID0gKCBtMTMgLSBtMzEgKSAqIHM7XHJcblx0XHRcdHRoaXMuX3ogPSAoIG0yMSAtIG0xMiApICogcztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtMTEgPiBtMjIgJiYgbTExID4gbTMzICkge1xyXG5cclxuXHRcdFx0cyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTExIC0gbTIyIC0gbTMzICk7XHJcblxyXG5cdFx0XHR0aGlzLl93ID0gKCBtMzIgLSBtMjMgKSAvIHM7XHJcblx0XHRcdHRoaXMuX3ggPSAwLjI1ICogcztcclxuXHRcdFx0dGhpcy5feSA9ICggbTEyICsgbTIxICkgLyBzO1xyXG5cdFx0XHR0aGlzLl96ID0gKCBtMTMgKyBtMzEgKSAvIHM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbTIyID4gbTMzICkge1xyXG5cclxuXHRcdFx0cyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTIyIC0gbTExIC0gbTMzICk7XHJcblxyXG5cdFx0XHR0aGlzLl93ID0gKCBtMTMgLSBtMzEgKSAvIHM7XHJcblx0XHRcdHRoaXMuX3ggPSAoIG0xMiArIG0yMSApIC8gcztcclxuXHRcdFx0dGhpcy5feSA9IDAuMjUgKiBzO1xyXG5cdFx0XHR0aGlzLl96ID0gKCBtMjMgKyBtMzIgKSAvIHM7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0zMyAtIG0xMSAtIG0yMiApO1xyXG5cclxuXHRcdFx0dGhpcy5fdyA9ICggbTIxIC0gbTEyICkgLyBzO1xyXG5cdFx0XHR0aGlzLl94ID0gKCBtMTMgKyBtMzEgKSAvIHM7XHJcblx0XHRcdHRoaXMuX3kgPSAoIG0yMyArIG0zMiApIC8gcztcclxuXHRcdFx0dGhpcy5feiA9IDAuMjUgKiBzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbVVuaXRWZWN0b3JzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gYXNzdW1lcyBkaXJlY3Rpb24gdmVjdG9ycyB2RnJvbSBhbmQgdlRvIGFyZSBub3JtYWxpemVkXHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHZhciByO1xyXG5cclxuXHRcdHZhciBFUFMgPSAwLjAwMDAwMTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gc2V0RnJvbVVuaXRWZWN0b3JzKCB2RnJvbSwgdlRvICkge1xyXG5cclxuXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0ciA9IHZGcm9tLmRvdCggdlRvICkgKyAxO1xyXG5cclxuXHRcdFx0aWYgKCByIDwgRVBTICkge1xyXG5cclxuXHRcdFx0XHRyID0gMDtcclxuXHJcblx0XHRcdFx0aWYgKCBNYXRoLmFicyggdkZyb20ueCApID4gTWF0aC5hYnMoIHZGcm9tLnogKSApIHtcclxuXHJcblx0XHRcdFx0XHR2MS5zZXQoIC0gdkZyb20ueSwgdkZyb20ueCwgMCApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHYxLnNldCggMCwgLSB2RnJvbS56LCB2RnJvbS55ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHYxLmNyb3NzVmVjdG9ycyggdkZyb20sIHZUbyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5feCA9IHYxLng7XHJcblx0XHRcdHRoaXMuX3kgPSB2MS55O1xyXG5cdFx0XHR0aGlzLl96ID0gdjEuejtcclxuXHRcdFx0dGhpcy5fdyA9IHI7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGFuZ2xlVG86IGZ1bmN0aW9uICggcSApIHtcclxuXHJcblx0XHRyZXR1cm4gMiAqIE1hdGguYWNvcyggTWF0aC5hYnMoIF9NYXRoLmNsYW1wKCB0aGlzLmRvdCggcSApLCAtIDEsIDEgKSApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdGF0ZVRvd2FyZHM6IGZ1bmN0aW9uICggcSwgc3RlcCApIHtcclxuXHJcblx0XHR2YXIgYW5nbGUgPSB0aGlzLmFuZ2xlVG8oIHEgKTtcclxuXHJcblx0XHRpZiAoIGFuZ2xlID09PSAwICkgcmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0dmFyIHQgPSBNYXRoLm1pbiggMSwgc3RlcCAvIGFuZ2xlICk7XHJcblxyXG5cdFx0dGhpcy5zbGVycCggcSwgdCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbnZlcnNlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gcXVhdGVybmlvbiBpcyBhc3N1bWVkIHRvIGhhdmUgdW5pdCBsZW5ndGhcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5jb25qdWdhdGUoKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29uanVnYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5feCAqPSAtIDE7XHJcblx0XHR0aGlzLl95ICo9IC0gMTtcclxuXHRcdHRoaXMuX3ogKj0gLSAxO1xyXG5cclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5feCAqIHYuX3ggKyB0aGlzLl95ICogdi5feSArIHRoaXMuX3ogKiB2Ll96ICsgdGhpcy5fdyAqIHYuX3c7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93O1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgbCA9IHRoaXMubGVuZ3RoKCk7XHJcblxyXG5cdFx0aWYgKCBsID09PSAwICkge1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IDA7XHJcblx0XHRcdHRoaXMuX3kgPSAwO1xyXG5cdFx0XHR0aGlzLl96ID0gMDtcclxuXHRcdFx0dGhpcy5fdyA9IDE7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGwgPSAxIC8gbDtcclxuXHJcblx0XHRcdHRoaXMuX3ggPSB0aGlzLl94ICogbDtcclxuXHRcdFx0dGhpcy5feSA9IHRoaXMuX3kgKiBsO1xyXG5cdFx0XHR0aGlzLl96ID0gdGhpcy5feiAqIGw7XHJcblx0XHRcdHRoaXMuX3cgPSB0aGlzLl93ICogbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5OiBmdW5jdGlvbiAoIHEsIHAgKSB7XHJcblxyXG5cdFx0aWYgKCBwICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdDT09MLlF1YXRlcm5pb246IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5UXVhdGVybmlvbnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggcSwgcCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCB0aGlzLCBxICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHByZW11bHRpcGx5OiBmdW5jdGlvbiAoIHEgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggcSwgdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseVF1YXRlcm5pb25zOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0Ly8gZnJvbSBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL2NvZGUvaW5kZXguaHRtXHJcblxyXG5cdFx0dmFyIHFheCA9IGEuX3gsIHFheSA9IGEuX3ksIHFheiA9IGEuX3osIHFhdyA9IGEuX3c7XHJcblx0XHR2YXIgcWJ4ID0gYi5feCwgcWJ5ID0gYi5feSwgcWJ6ID0gYi5feiwgcWJ3ID0gYi5fdztcclxuXHJcblx0XHR0aGlzLl94ID0gcWF4ICogcWJ3ICsgcWF3ICogcWJ4ICsgcWF5ICogcWJ6IC0gcWF6ICogcWJ5O1xyXG5cdFx0dGhpcy5feSA9IHFheSAqIHFidyArIHFhdyAqIHFieSArIHFheiAqIHFieCAtIHFheCAqIHFiejtcclxuXHRcdHRoaXMuX3ogPSBxYXogKiBxYncgKyBxYXcgKiBxYnogKyBxYXggKiBxYnkgLSBxYXkgKiBxYng7XHJcblx0XHR0aGlzLl93ID0gcWF3ICogcWJ3IC0gcWF4ICogcWJ4IC0gcWF5ICogcWJ5IC0gcWF6ICogcWJ6O1xyXG5cclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzbGVycDogZnVuY3Rpb24gKCBxYiwgdCApIHtcclxuXHJcblx0XHRpZiAoIHQgPT09IDAgKSByZXR1cm4gdGhpcztcclxuXHRcdGlmICggdCA9PT0gMSApIHJldHVybiB0aGlzLmNvcHkoIHFiICk7XHJcblxyXG5cdFx0dmFyIHggPSB0aGlzLl94LCB5ID0gdGhpcy5feSwgeiA9IHRoaXMuX3osIHcgPSB0aGlzLl93O1xyXG5cclxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvc2xlcnAvXHJcblxyXG5cdFx0dmFyIGNvc0hhbGZUaGV0YSA9IHcgKiBxYi5fdyArIHggKiBxYi5feCArIHkgKiBxYi5feSArIHogKiBxYi5fejtcclxuXHJcblx0XHRpZiAoIGNvc0hhbGZUaGV0YSA8IDAgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl93ID0gLSBxYi5fdztcclxuXHRcdFx0dGhpcy5feCA9IC0gcWIuX3g7XHJcblx0XHRcdHRoaXMuX3kgPSAtIHFiLl95O1xyXG5cdFx0XHR0aGlzLl96ID0gLSBxYi5fejtcclxuXHJcblx0XHRcdGNvc0hhbGZUaGV0YSA9IC0gY29zSGFsZlRoZXRhO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLmNvcHkoIHFiICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggY29zSGFsZlRoZXRhID49IDEuMCApIHtcclxuXHJcblx0XHRcdHRoaXMuX3cgPSB3O1xyXG5cdFx0XHR0aGlzLl94ID0geDtcclxuXHRcdFx0dGhpcy5feSA9IHk7XHJcblx0XHRcdHRoaXMuX3ogPSB6O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzcXJTaW5IYWxmVGhldGEgPSAxLjAgLSBjb3NIYWxmVGhldGEgKiBjb3NIYWxmVGhldGE7XHJcblxyXG5cdFx0aWYgKCBzcXJTaW5IYWxmVGhldGEgPD0gTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG5cdFx0XHR2YXIgcyA9IDEgLSB0O1xyXG5cdFx0XHR0aGlzLl93ID0gcyAqIHcgKyB0ICogdGhpcy5fdztcclxuXHRcdFx0dGhpcy5feCA9IHMgKiB4ICsgdCAqIHRoaXMuX3g7XHJcblx0XHRcdHRoaXMuX3kgPSBzICogeSArIHQgKiB0aGlzLl95O1xyXG5cdFx0XHR0aGlzLl96ID0gcyAqIHogKyB0ICogdGhpcy5fejtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc2luSGFsZlRoZXRhID0gTWF0aC5zcXJ0KCBzcXJTaW5IYWxmVGhldGEgKTtcclxuXHRcdHZhciBoYWxmVGhldGEgPSBNYXRoLmF0YW4yKCBzaW5IYWxmVGhldGEsIGNvc0hhbGZUaGV0YSApO1xyXG5cdFx0dmFyIHJhdGlvQSA9IE1hdGguc2luKCAoIDEgLSB0ICkgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YSxcclxuXHRcdFx0cmF0aW9CID0gTWF0aC5zaW4oIHQgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YTtcclxuXHJcblx0XHR0aGlzLl93ID0gKCB3ICogcmF0aW9BICsgdGhpcy5fdyAqIHJhdGlvQiApO1xyXG5cdFx0dGhpcy5feCA9ICggeCAqIHJhdGlvQSArIHRoaXMuX3ggKiByYXRpb0IgKTtcclxuXHRcdHRoaXMuX3kgPSAoIHkgKiByYXRpb0EgKyB0aGlzLl95ICogcmF0aW9CICk7XHJcblx0XHR0aGlzLl96ID0gKCB6ICogcmF0aW9BICsgdGhpcy5feiAqIHJhdGlvQiApO1xyXG5cclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggcXVhdGVybmlvbiApIHtcclxuXHJcblx0XHRyZXR1cm4gKCBxdWF0ZXJuaW9uLl94ID09PSB0aGlzLl94ICkgJiYgKCBxdWF0ZXJuaW9uLl95ID09PSB0aGlzLl95ICkgJiYgKCBxdWF0ZXJuaW9uLl96ID09PSB0aGlzLl96ICkgJiYgKCBxdWF0ZXJuaW9uLl93ID09PSB0aGlzLl93ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdHRoaXMuX3ggPSBhcnJheVsgb2Zmc2V0IF07XHJcblx0XHR0aGlzLl95ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcclxuXHRcdHRoaXMuX3ogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xyXG5cdFx0dGhpcy5fdyA9IGFycmF5WyBvZmZzZXQgKyAzIF07XHJcblxyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xyXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5feDtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLl95O1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuX3o7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy5fdztcclxuXHJcblx0XHRyZXR1cm4gYXJyYXk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG9uQ2hhbmdlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xyXG5cclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRvbkNoYW5nZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7fVxyXG5cclxufSApO1xyXG5cclxuXHJcbmV4cG9ydCB7IFF1YXRlcm5pb24gfTtcclxuIiwiaW1wb3J0IHtfTWF0aH0gZnJvbSAnLi8vTWF0aC5qcyc7XHJcbmltcG9ydCB7IE1hdHJpeDR9IGZyb20gJy4vTWF0cml4NC5qcyc7XHJcbmltcG9ydCB7UXVhdGVybmlvbn0gZnJvbSAnLi9RdWF0ZXJuaW9uLmpzJztcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGtpbGUgLyBodHRwOi8va2lsZS5zdHJhdmFnYW56YS5vcmcvXHJcbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIFZlY3RvcjMoIHgsIHksIHogKSB7XHJcblxyXG5cdHRoaXMueCA9IHggfHwgMDtcclxuXHR0aGlzLnkgPSB5IHx8IDA7XHJcblx0dGhpcy56ID0geiB8fCAwO1xyXG5cclxufVxyXG5cclxuT2JqZWN0LmFzc2lnbiggVmVjdG9yMy5wcm90b3R5cGUsIHtcclxuXHJcblx0aXNWZWN0b3IzOiB0cnVlLFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcclxuXHJcblx0XHR0aGlzLnggPSB4O1xyXG5cdFx0dGhpcy55ID0geTtcclxuXHRcdHRoaXMueiA9IHo7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gc2NhbGFyO1xyXG5cdFx0dGhpcy55ID0gc2NhbGFyO1xyXG5cdFx0dGhpcy56ID0gc2NhbGFyO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRYOiBmdW5jdGlvbiAoIHggKSB7XHJcblxyXG5cdFx0dGhpcy54ID0geDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WTogZnVuY3Rpb24gKCB5ICkge1xyXG5cclxuXHRcdHRoaXMueSA9IHk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFo6IGZ1bmN0aW9uICggeiApIHtcclxuXHJcblx0XHR0aGlzLnogPSB6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXgsIHZhbHVlICkge1xyXG5cclxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0Y2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIDI6IHRoaXMueiA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcclxuXHJcblx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcclxuXHRcdFx0Y2FzZSAxOiByZXR1cm4gdGhpcy55O1xyXG5cdFx0XHRjYXNlIDI6IHJldHVybiB0aGlzLno7XHJcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnksIHRoaXMueiApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gdi54O1xyXG5cdFx0dGhpcy55ID0gdi55O1xyXG5cdFx0dGhpcy56ID0gdi56O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGQ6IGZ1bmN0aW9uICggdiwgdyApIHtcclxuXHJcblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ0NPT0wuVmVjdG9yMzogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnggKz0gdi54O1xyXG5cdFx0dGhpcy55ICs9IHYueTtcclxuXHRcdHRoaXMueiArPSB2Lno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMueCArPSBzO1xyXG5cdFx0dGhpcy55ICs9IHM7XHJcblx0XHR0aGlzLnogKz0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHRoaXMueCA9IGEueCArIGIueDtcclxuXHRcdHRoaXMueSA9IGEueSArIGIueTtcclxuXHRcdHRoaXMueiA9IGEueiArIGIuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkU2NhbGVkVmVjdG9yOiBmdW5jdGlvbiAoIHYsIHMgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9IHYueCAqIHM7XHJcblx0XHR0aGlzLnkgKz0gdi55ICogcztcclxuXHRcdHRoaXMueiArPSB2LnogKiBzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzdWI6IGZ1bmN0aW9uICggdiwgdyApIHtcclxuXHJcblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ0NPT0wuVmVjdG9yMzogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnggLT0gdi54O1xyXG5cdFx0dGhpcy55IC09IHYueTtcclxuXHRcdHRoaXMueiAtPSB2Lno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHN1YlNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMueCAtPSBzO1xyXG5cdFx0dGhpcy55IC09IHM7XHJcblx0XHR0aGlzLnogLT0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcbiAgICBzY2FsZVZlY3RvcnMgOmZ1bmN0aW9uKHYxLHNjYWxlKXtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjModjEueCpzY2FsZSwgdjEueSpzY2FsZSwgdjEueipzY2FsZSApO1xyXG4gICAgfSxcclxuXHJcblx0c3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHRoaXMueCA9IGEueCAtIGIueDtcclxuXHRcdHRoaXMueSA9IGEueSAtIGIueTtcclxuXHRcdHRoaXMueiA9IGEueiAtIGIuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggdiwgdyApIHtcclxuXHJcblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ0NPT0wuVmVjdG9yMzogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5VmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnggKj0gdi54O1xyXG5cdFx0dGhpcy55ICo9IHYueTtcclxuXHRcdHRoaXMueiAqPSB2Lno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcclxuXHJcblx0XHR0aGlzLnggKj0gc2NhbGFyO1xyXG5cdFx0dGhpcy55ICo9IHNjYWxhcjtcclxuXHRcdHRoaXMueiAqPSBzY2FsYXI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5VmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHRoaXMueCA9IGEueCAqIGIueDtcclxuXHRcdHRoaXMueSA9IGEueSAqIGIueTtcclxuXHRcdHRoaXMueiA9IGEueiAqIGIuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlFdWxlcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gYXBwbHlFdWxlciggZXVsZXIgKSB7XHJcblxyXG5cdFx0XHRpZiAoICEgKCBldWxlciAmJiBldWxlci5pc0V1bGVyICkgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdDT09MLlZlY3RvcjM6IC5hcHBseUV1bGVyKCkgbm93IGV4cGVjdHMgYW4gRXVsZXIgcm90YXRpb24gcmF0aGVyIHRoYW4gYSBWZWN0b3IzIGFuZCBvcmRlci4nICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciApICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRhcHBseUF4aXNBbmdsZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gYXBwbHlBeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGFwcGx5TWF0cml4MzogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xyXG5cdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyAzIF0gKiB5ICsgZVsgNiBdICogejtcclxuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgNyBdICogejtcclxuXHRcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOCBdICogejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XHJcblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XHJcblxyXG5cdFx0dmFyIHcgPSAxIC8gKCBlWyAzIF0gKiB4ICsgZVsgNyBdICogeSArIGVbIDExIF0gKiB6ICsgZVsgMTUgXSApO1xyXG5cclxuXHRcdHRoaXMueCA9ICggZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gKiB6ICsgZVsgMTIgXSApICogdztcclxuXHRcdHRoaXMueSA9ICggZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gKiB6ICsgZVsgMTMgXSApICogdztcclxuXHRcdHRoaXMueiA9ICggZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF0gKSAqIHc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5UXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xyXG5cclxuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xyXG5cdFx0dmFyIHF4ID0gcS54LCBxeSA9IHEueSwgcXogPSBxLnosIHF3ID0gcS53O1xyXG5cclxuXHRcdC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjdG9yXHJcblxyXG5cdFx0dmFyIGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5O1xyXG5cdFx0dmFyIGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6O1xyXG5cdFx0dmFyIGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xyXG5cdFx0dmFyIGl3ID0gLSBxeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XHJcblxyXG5cdFx0Ly8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxyXG5cclxuXHRcdHRoaXMueCA9IGl4ICogcXcgKyBpdyAqIC0gcXggKyBpeSAqIC0gcXogLSBpeiAqIC0gcXk7XHJcblx0XHR0aGlzLnkgPSBpeSAqIHF3ICsgaXcgKiAtIHF5ICsgaXogKiAtIHF4IC0gaXggKiAtIHF6O1xyXG5cdFx0dGhpcy56ID0gaXogKiBxdyArIGl3ICogLSBxeiArIGl4ICogLSBxeSAtIGl5ICogLSBxeDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICkuYXBwbHlNYXRyaXg0KCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gdW5wcm9qZWN0KCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQoIG1hdHJpeC5nZXRJbnZlcnNlKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApICkuYXBwbHlNYXRyaXg0KCBjYW1lcmEubWF0cml4V29ybGQgKTtcclxuICAgICAgICAgICAgLy8gcmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KCBtYXRyaXguZ2V0SW52ZXJzZSggY2FtZXJhLlZQbWF0cml4ICkgKTsg562J5Lu3XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHR0cmFuc2Zvcm1EaXJlY3Rpb246IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHQvLyBpbnB1dDogQ09PTC5NYXRyaXg0IGFmZmluZSBtYXRyaXhcclxuXHRcdC8vIHZlY3RvciBpbnRlcnByZXRlZCBhcyBhIGRpcmVjdGlvblxyXG5cclxuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xyXG5cdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICogejtcclxuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICogejtcclxuXHRcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHo7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpdmlkZTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCAvPSB2Lng7XHJcblx0XHR0aGlzLnkgLz0gdi55O1xyXG5cdFx0dGhpcy56IC89IHYuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggMSAvIHNjYWxhciApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtaW46IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLm1pbiggdGhpcy54LCB2LnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGgubWluKCB0aGlzLnksIHYueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5taW4oIHRoaXMueiwgdi56ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1heDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCB0aGlzLngsIHYueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIHRoaXMueSwgdi55ICk7XHJcblx0XHR0aGlzLnogPSBNYXRoLm1heCggdGhpcy56LCB2LnogKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG5cdFx0Ly8gYXNzdW1lcyBtaW4gPCBtYXgsIGNvbXBvbmVudHdpc2VcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLm1heCggbWluLngsIE1hdGgubWluKCBtYXgueCwgdGhpcy54ICkgKTtcclxuXHRcdHRoaXMueSA9IE1hdGgubWF4KCBtaW4ueSwgTWF0aC5taW4oIG1heC55LCB0aGlzLnkgKSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5tYXgoIG1pbi56LCBNYXRoLm1pbiggbWF4LnosIHRoaXMueiApICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsYW1wU2NhbGFyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG1pbiA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHR2YXIgbWF4ID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gY2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xyXG5cclxuXHRcdFx0bWluLnNldCggbWluVmFsLCBtaW5WYWwsIG1pblZhbCApO1xyXG5cdFx0XHRtYXguc2V0KCBtYXhWYWwsIG1heFZhbCwgbWF4VmFsICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5jbGFtcCggbWluLCBtYXggKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGNsYW1wTGVuZ3RoOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xyXG5cclxuXHRcdHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggbGVuZ3RoIHx8IDEgKS5tdWx0aXBseVNjYWxhciggTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgbGVuZ3RoICkgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmbG9vcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XHJcblx0XHR0aGlzLnogPSBNYXRoLmZsb29yKCB0aGlzLnogKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2VpbDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKCB0aGlzLnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5yb3VuZCggdGhpcy56ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcclxuXHRcdHRoaXMueiA9ICggdGhpcy56IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnogKSA6IE1hdGguZmxvb3IoIHRoaXMueiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnggPSAtIHRoaXMueDtcclxuXHRcdHRoaXMueSA9IC0gdGhpcy55O1xyXG5cdFx0dGhpcy56ID0gLSB0aGlzLno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRvdDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2Lno7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIFRPRE8gbGVuZ3RoU3F1YXJlZD9cclxuXHJcblx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56O1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKTtcclxuXHJcblx0fSxcclxuXHJcblx0bWFuaGF0dGFuTGVuZ3RoOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKSArIE1hdGguYWJzKCB0aGlzLnogKTtcclxuXHJcblx0fSxcclxuXHJcblx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpIHx8IDEgKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0TGVuZ3RoOiBmdW5jdGlvbiAoIGxlbmd0aCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggbGVuZ3RoICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlcnA6IGZ1bmN0aW9uICggdiwgYWxwaGEgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcclxuXHRcdHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XHJcblx0XHR0aGlzLnogKz0gKCB2LnogLSB0aGlzLnogKSAqIGFscGhhO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZXJwVmVjdG9yczogZnVuY3Rpb24gKCB2MSwgdjIsIGFscGhhICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYyLCB2MSApLm11bHRpcGx5U2NhbGFyKCBhbHBoYSApLmFkZCggdjEgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y3Jvc3M6IGZ1bmN0aW9uICggdiwgdyApIHtcclxuXHJcblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ0NPT0wuVmVjdG9yMzogLmNyb3NzKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuY3Jvc3NWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmNyb3NzVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5jcm9zc1ZlY3RvcnMoIHRoaXMsIHYgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y3Jvc3NWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0dmFyIGF4ID0gYS54LCBheSA9IGEueSwgYXogPSBhLno7XHJcblx0XHR2YXIgYnggPSBiLngsIGJ5ID0gYi55LCBieiA9IGIuejtcclxuXHJcblx0XHR0aGlzLnggPSBheSAqIGJ6IC0gYXogKiBieTtcclxuXHRcdHRoaXMueSA9IGF6ICogYnggLSBheCAqIGJ6O1xyXG5cdFx0dGhpcy56ID0gYXggKiBieSAtIGF5ICogYng7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHByb2plY3RPblZlY3RvcjogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0dmFyIHNjYWxhciA9IHZlY3Rvci5kb3QoIHRoaXMgKSAvIHZlY3Rvci5sZW5ndGhTcSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmNvcHkoIHZlY3RvciApLm11bHRpcGx5U2NhbGFyKCBzY2FsYXIgKTtcclxuXHJcblx0fSxcclxuXHJcblx0cHJvamVjdE9uUGxhbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBwcm9qZWN0T25QbGFuZSggcGxhbmVOb3JtYWwgKSB7XHJcblxyXG5cdFx0XHR2MS5jb3B5KCB0aGlzICkucHJvamVjdE9uVmVjdG9yKCBwbGFuZU5vcm1hbCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuc3ViKCB2MSApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0cmVmbGVjdDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHJlZmxlY3QgaW5jaWRlbnQgdmVjdG9yIG9mZiBwbGFuZSBvcnRob2dvbmFsIHRvIG5vcm1hbFxyXG5cdFx0Ly8gbm9ybWFsIGlzIGFzc3VtZWQgdG8gaGF2ZSB1bml0IGxlbmd0aFxyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJlZmxlY3QoIG5vcm1hbCApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLnN1YiggdjEuY29weSggbm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIDIgKiB0aGlzLmRvdCggbm9ybWFsICkgKSApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0YW5nbGVUbzogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHZhciB0aGV0YSA9IHRoaXMuZG90KCB2ICkgLyAoIE1hdGguc3FydCggdGhpcy5sZW5ndGhTcSgpICogdi5sZW5ndGhTcSgpICkgKTtcclxuXHJcblx0XHQvLyBjbGFtcCwgdG8gaGFuZGxlIG51bWVyaWNhbCBwcm9ibGVtc1xyXG5cclxuXHRcdHJldHVybiBNYXRoLmFjb3MoIF9NYXRoLmNsYW1wKCB0aGV0YSwgLSAxLCAxICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVRvU3F1YXJlZDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHZhciBkeCA9IHRoaXMueCAtIHYueCwgZHkgPSB0aGlzLnkgLSB2LnksIGR6ID0gdGhpcy56IC0gdi56O1xyXG5cclxuXHRcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHo7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1hbmhhdHRhbkRpc3RhbmNlVG86IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCAtIHYueCApICsgTWF0aC5hYnMoIHRoaXMueSAtIHYueSApICsgTWF0aC5hYnMoIHRoaXMueiAtIHYueiApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tU3BoZXJpY2FsOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbVNwaGVyaWNhbENvb3Jkcyggcy5yYWRpdXMsIHMucGhpLCBzLnRoZXRhICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21TcGhlcmljYWxDb29yZHM6IGZ1bmN0aW9uICggcmFkaXVzLCBwaGksIHRoZXRhICkge1xyXG5cclxuXHRcdHZhciBzaW5QaGlSYWRpdXMgPSBNYXRoLnNpbiggcGhpICkgKiByYWRpdXM7XHJcblxyXG5cdFx0dGhpcy54ID0gc2luUGhpUmFkaXVzICogTWF0aC5zaW4oIHRoZXRhICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmNvcyggcGhpICkgKiByYWRpdXM7XHJcblx0XHR0aGlzLnogPSBzaW5QaGlSYWRpdXMgKiBNYXRoLmNvcyggdGhldGEgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbUN5bGluZHJpY2FsOiBmdW5jdGlvbiAoIGMgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbUN5bGluZHJpY2FsQ29vcmRzKCBjLnJhZGl1cywgYy50aGV0YSwgYy55ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21DeWxpbmRyaWNhbENvb3JkczogZnVuY3Rpb24gKCByYWRpdXMsIHRoZXRhLCB5ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHJhZGl1cyAqIE1hdGguc2luKCB0aGV0YSApO1xyXG5cdFx0dGhpcy55ID0geTtcclxuXHRcdHRoaXMueiA9IHJhZGl1cyAqIE1hdGguY29zKCB0aGV0YSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tTWF0cml4UG9zaXRpb246IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XHJcblxyXG5cdFx0dGhpcy54ID0gZVsgMTIgXTtcclxuXHRcdHRoaXMueSA9IGVbIDEzIF07XHJcblx0XHR0aGlzLnogPSBlWyAxNCBdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tTWF0cml4U2NhbGU6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHR2YXIgc3ggPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDAgKS5sZW5ndGgoKTtcclxuXHRcdHZhciBzeSA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMSApLmxlbmd0aCgpO1xyXG5cdFx0dmFyIHN6ID0gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAyICkubGVuZ3RoKCk7XHJcblxyXG5cdFx0dGhpcy54ID0gc3g7XHJcblx0XHR0aGlzLnkgPSBzeTtcclxuXHRcdHRoaXMueiA9IHN6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tTWF0cml4Q29sdW1uOiBmdW5jdGlvbiAoIG0sIGluZGV4ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmZyb21BcnJheSggbS5lbGVtZW50cywgaW5kZXggKiA0ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgJiYgKCB2LnogPT09IHRoaXMueiApICk7XHJcblxyXG5cdH0sXHJcblxyXG4gICAgcm90YXRlQnlWZWN0b3IgOmZ1bmN0aW9uKHZlYzEsIHZlYzIsIGFuZ2xlKSB7XHJcbiAgICAgICAgdmFyIHYxID0gdmVjMS50b0FycmF5KCk7XHJcbiAgICAgICAgdmFyIHYyID0gdmVjMi50b0FycmF5KCk7XHJcbiAgICAgICAgYW5nbGUgPSAtIGFuZ2xlO1xyXG4gICAgICAgIHZhciBwb3MgPSBbXTtcclxuICAgICAgICBwb3NbMF0gPSB2MVswXSAqIE1hdGguY29zKGFuZ2xlKSArICh2MlsxXSAqIHYxWzJdIC0gdjJbMl0gKiB2MVsxXSkgKiBNYXRoLnNpbihhbmdsZSkgKyB2MlswXSAqICh2MlswXSAqIHYxWzBdICsgdjJbMV0gKiB2MVsxXSArIHYyWzJdICogdjFbMl0pICogKDEgLSBNYXRoLmNvcyhhbmdsZSkpO1xyXG4gICAgICAgIHBvc1sxXSA9IHYxWzFdICogTWF0aC5jb3MoYW5nbGUpICsgKHYyWzJdICogdjFbMF0gLSB2MlswXSAqIHYxWzJdKSAqIE1hdGguc2luKGFuZ2xlKSArIHYyWzFdICogKHYyWzBdICogdjFbMF0gKyB2MlsxXSAqIHYxWzFdICsgdjJbMl0gKiB2MVsyXSkgKiAoMSAtIE1hdGguY29zKGFuZ2xlKSk7XHJcbiAgICAgICAgcG9zWzJdID0gdjFbMl0gKiBNYXRoLmNvcyhhbmdsZSkgKyAodjJbMF0gKiB2MVsxXSAtIHYyWzFdICogdjFbMF0pICogTWF0aC5zaW4oYW5nbGUpICsgdjJbMl0gKiAodjJbMF0gKiB2MVswXSArIHYyWzFdICogdjFbMV0gKyB2MlsyXSAqIHYxWzJdKSAqICgxIC0gTWF0aC5jb3MoYW5nbGUpKTtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkocG9zKTtcclxuICAgIH0sXHJcblxyXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcclxuXHRcdHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XHJcblx0XHR0aGlzLnogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy56O1xyXG5cclxuXHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0fSxcclxuXHJcblx0ZnJvbUJ1ZmZlckF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBvZmZzZXQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ0NPT0wuVmVjdG9yMzogb2Zmc2V0IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSgpLicgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy54ID0gYXR0cmlidXRlLmdldFgoIGluZGV4ICk7XHJcblx0XHR0aGlzLnkgPSBhdHRyaWJ1dGUuZ2V0WSggaW5kZXggKTtcclxuXHRcdHRoaXMueiA9IGF0dHJpYnV0ZS5nZXRaKCBpbmRleCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcblxyXG5cclxuZXhwb3J0IHsgVmVjdG9yMyB9O1xyXG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi9WZWN0b3IzLmpzJztcclxuaW1wb3J0IHsgU3BoZXJlIH0gZnJvbSAnLi9TcGhlcmUuanMnO1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gQm94MyggbWluLCBtYXggKSB7XHJcblxyXG5cdHRoaXMubWluID0gKCBtaW4gIT09IHVuZGVmaW5lZCApID8gbWluIDogbmV3IFZlY3RvcjMoICsgSW5maW5pdHksICsgSW5maW5pdHksICsgSW5maW5pdHkgKTtcclxuXHR0aGlzLm1heCA9ICggbWF4ICE9PSB1bmRlZmluZWQgKSA/IG1heCA6IG5ldyBWZWN0b3IzKCAtIEluZmluaXR5LCAtIEluZmluaXR5LCAtIEluZmluaXR5ICk7XHJcblxyXG59XHJcblxyXG5PYmplY3QuYXNzaWduKCBCb3gzLnByb3RvdHlwZSwge1xyXG5cclxuXHRpc0JveDM6IHRydWUsXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5jb3B5KCBtaW4gKTtcclxuXHRcdHRoaXMubWF4LmNvcHkoIG1heCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XHJcblxyXG5cdFx0dmFyIG1pblggPSArIEluZmluaXR5O1xyXG5cdFx0dmFyIG1pblkgPSArIEluZmluaXR5O1xyXG5cdFx0dmFyIG1pblogPSArIEluZmluaXR5O1xyXG5cclxuXHRcdHZhciBtYXhYID0gLSBJbmZpbml0eTtcclxuXHRcdHZhciBtYXhZID0gLSBJbmZpbml0eTtcclxuXHRcdHZhciBtYXhaID0gLSBJbmZpbml0eTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHR2YXIgeCA9IGFycmF5WyBpIF07XHJcblx0XHRcdHZhciB5ID0gYXJyYXlbIGkgKyAxIF07XHJcblx0XHRcdHZhciB6ID0gYXJyYXlbIGkgKyAyIF07XHJcblxyXG5cdFx0XHRpZiAoIHggPCBtaW5YICkgbWluWCA9IHg7XHJcblx0XHRcdGlmICggeSA8IG1pblkgKSBtaW5ZID0geTtcclxuXHRcdFx0aWYgKCB6IDwgbWluWiApIG1pblogPSB6O1xyXG5cclxuXHRcdFx0aWYgKCB4ID4gbWF4WCApIG1heFggPSB4O1xyXG5cdFx0XHRpZiAoIHkgPiBtYXhZICkgbWF4WSA9IHk7XHJcblx0XHRcdGlmICggeiA+IG1heFogKSBtYXhaID0gejtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5taW4uc2V0KCBtaW5YLCBtaW5ZLCBtaW5aICk7XHJcblx0XHR0aGlzLm1heC5zZXQoIG1heFgsIG1heFksIG1heFogKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0dmFyIG1pblggPSArIEluZmluaXR5O1xyXG5cdFx0dmFyIG1pblkgPSArIEluZmluaXR5O1xyXG5cdFx0dmFyIG1pblogPSArIEluZmluaXR5O1xyXG5cclxuXHRcdHZhciBtYXhYID0gLSBJbmZpbml0eTtcclxuXHRcdHZhciBtYXhZID0gLSBJbmZpbml0eTtcclxuXHRcdHZhciBtYXhaID0gLSBJbmZpbml0eTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBhdHRyaWJ1dGUuY291bnQ7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHggPSBhdHRyaWJ1dGUuZ2V0WCggaSApO1xyXG5cdFx0XHR2YXIgeSA9IGF0dHJpYnV0ZS5nZXRZKCBpICk7XHJcblx0XHRcdHZhciB6ID0gYXR0cmlidXRlLmdldFooIGkgKTtcclxuXHJcblx0XHRcdGlmICggeCA8IG1pblggKSBtaW5YID0geDtcclxuXHRcdFx0aWYgKCB5IDwgbWluWSApIG1pblkgPSB5O1xyXG5cdFx0XHRpZiAoIHogPCBtaW5aICkgbWluWiA9IHo7XHJcblxyXG5cdFx0XHRpZiAoIHggPiBtYXhYICkgbWF4WCA9IHg7XHJcblx0XHRcdGlmICggeSA+IG1heFkgKSBtYXhZID0geTtcclxuXHRcdFx0aWYgKCB6ID4gbWF4WiApIG1heFogPSB6O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm1pbi5zZXQoIG1pblgsIG1pblksIG1pblogKTtcclxuXHRcdHRoaXMubWF4LnNldCggbWF4WCwgbWF4WSwgbWF4WiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoIHBvaW50cyApIHtcclxuXHJcblx0XHR0aGlzLm1ha2VFbXB0eSgpO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoIHBvaW50c1sgaSBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tQ2VudGVyQW5kU2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHNldEZyb21DZW50ZXJBbmRTaXplKCBjZW50ZXIsIHNpemUgKSB7XHJcblxyXG5cdFx0XHR2YXIgaGFsZlNpemUgPSB2MS5jb3B5KCBzaXplICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG5cclxuXHRcdFx0dGhpcy5taW4uY29weSggY2VudGVyICkuc3ViKCBoYWxmU2l6ZSApO1xyXG5cdFx0XHR0aGlzLm1heC5jb3B5KCBjZW50ZXIgKS5hZGQoIGhhbGZTaXplICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHNldEZyb21PYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRcdHRoaXMubWFrZUVtcHR5KCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZXhwYW5kQnlPYmplY3QoIG9iamVjdCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0dGhpcy5taW4uY29weSggYm94Lm1pbiApO1xyXG5cdFx0dGhpcy5tYXguY29weSggYm94Lm1heCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlRW1wdHk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLm1pbi54ID0gdGhpcy5taW4ueSA9IHRoaXMubWluLnogPSArIEluZmluaXR5O1xyXG5cdFx0dGhpcy5tYXgueCA9IHRoaXMubWF4LnkgPSB0aGlzLm1heC56ID0gLSBJbmZpbml0eTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHRoaXMgaXMgYSBtb3JlIHJvYnVzdCBjaGVjayBmb3IgZW1wdHkgdGhhbiAoIHZvbHVtZSA8PSAwICkgYmVjYXVzZSB2b2x1bWUgY2FuIGdldCBwb3NpdGl2ZSB3aXRoIHR3byBuZWdhdGl2ZSBheGVzXHJcblxyXG5cdFx0cmV0dXJuICggdGhpcy5tYXgueCA8IHRoaXMubWluLnggKSB8fCAoIHRoaXMubWF4LnkgPCB0aGlzLm1pbi55ICkgfHwgKCB0aGlzLm1heC56IDwgdGhpcy5taW4ueiApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICggdGFyZ2V0ICkge1xyXG5cclxuXHRcdGlmICggdGFyZ2V0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdDT09MLkJveDM6IC5nZXRDZW50ZXIoKSB0YXJnZXQgaXMgbm93IHJlcXVpcmVkJyApO1xyXG5cdFx0XHR0YXJnZXQgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyB0YXJnZXQuc2V0KCAwLCAwLCAwICkgOiB0YXJnZXQuYWRkVmVjdG9ycyggdGhpcy5taW4sIHRoaXMubWF4ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRTaXplOiBmdW5jdGlvbiAoIHRhcmdldCApIHtcclxuXHJcblx0XHRpZiAoIHRhcmdldCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5Cb3gzOiAuZ2V0U2l6ZSgpIHRhcmdldCBpcyBub3cgcmVxdWlyZWQnICk7XHJcblx0XHRcdHRhcmdldCA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IHRhcmdldC5zZXQoIDAsIDAsIDAgKSA6IHRhcmdldC5zdWJWZWN0b3JzKCB0aGlzLm1heCwgdGhpcy5taW4gKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZXhwYW5kQnlQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5taW4oIHBvaW50ICk7XHJcblx0XHR0aGlzLm1heC5tYXgoIHBvaW50ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGV4cGFuZEJ5VmVjdG9yOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5zdWIoIHZlY3RvciApO1xyXG5cdFx0dGhpcy5tYXguYWRkKCB2ZWN0b3IgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXhwYW5kQnlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdHRoaXMubWluLmFkZFNjYWxhciggLSBzY2FsYXIgKTtcclxuXHRcdHRoaXMubWF4LmFkZFNjYWxhciggc2NhbGFyICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGV4cGFuZEJ5T2JqZWN0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gQ29tcHV0ZXMgdGhlIHdvcmxkLWF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggb2YgYW4gb2JqZWN0IChpbmNsdWRpbmcgaXRzIGNoaWxkcmVuKSxcclxuXHRcdC8vIGFjY291bnRpbmcgZm9yIGJvdGggdGhlIG9iamVjdCdzLCBhbmQgY2hpbGRyZW4ncywgd29ybGQgdHJhbnNmb3Jtc1xyXG5cclxuXHRcdHZhciBzY29wZSwgaSwgbDtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdGZ1bmN0aW9uIHRyYXZlcnNlKCBub2RlICkge1xyXG5cclxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gbm9kZS5nZW9tZXRyeTtcclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBnZW9tZXRyeS5pc0dlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHYxLmNvcHkoIHZlcnRpY2VzWyBpIF0gKTtcclxuXHRcdFx0XHRcdFx0djEuYXBwbHlNYXRyaXg0KCBub2RlLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHRcdFx0XHRzY29wZS5leHBhbmRCeVBvaW50KCB2MSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgYXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBhdHRyaWJ1dGUuY291bnQ7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2MS5mcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGkgKS5hcHBseU1hdHJpeDQoIG5vZGUubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0c2NvcGUuZXhwYW5kQnlQb2ludCggdjEgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGV4cGFuZEJ5T2JqZWN0KCBvYmplY3QgKSB7XHJcblxyXG5cdFx0XHRzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0XHRvYmplY3QudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcclxuXHJcblx0XHRcdG9iamVjdC50cmF2ZXJzZSggdHJhdmVyc2UgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHRyZXR1cm4gcG9pbnQueCA8IHRoaXMubWluLnggfHwgcG9pbnQueCA+IHRoaXMubWF4LnggfHxcclxuXHRcdFx0cG9pbnQueSA8IHRoaXMubWluLnkgfHwgcG9pbnQueSA+IHRoaXMubWF4LnkgfHxcclxuXHRcdFx0cG9pbnQueiA8IHRoaXMubWluLnogfHwgcG9pbnQueiA+IHRoaXMubWF4LnogPyBmYWxzZSA6IHRydWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbnRhaW5zQm94OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5taW4ueCA8PSBib3gubWluLnggJiYgYm94Lm1heC54IDw9IHRoaXMubWF4LnggJiZcclxuXHRcdFx0dGhpcy5taW4ueSA8PSBib3gubWluLnkgJiYgYm94Lm1heC55IDw9IHRoaXMubWF4LnkgJiZcclxuXHRcdFx0dGhpcy5taW4ueiA8PSBib3gubWluLnogJiYgYm94Lm1heC56IDw9IHRoaXMubWF4Lno7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldFBhcmFtZXRlcjogZnVuY3Rpb24gKCBwb2ludCwgdGFyZ2V0ICkge1xyXG5cclxuXHRcdC8vIFRoaXMgY2FuIHBvdGVudGlhbGx5IGhhdmUgYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgYm94XHJcblx0XHQvLyBoYXMgYSBzaXplIGRpbWVuc2lvbiBvZiAwLlxyXG5cclxuXHRcdGlmICggdGFyZ2V0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdDT09MLkJveDM6IC5nZXRQYXJhbWV0ZXIoKSB0YXJnZXQgaXMgbm93IHJlcXVpcmVkJyApO1xyXG5cdFx0XHR0YXJnZXQgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGFyZ2V0LnNldChcclxuXHRcdFx0KCBwb2ludC54IC0gdGhpcy5taW4ueCApIC8gKCB0aGlzLm1heC54IC0gdGhpcy5taW4ueCApLFxyXG5cdFx0XHQoIHBvaW50LnkgLSB0aGlzLm1pbi55ICkgLyAoIHRoaXMubWF4LnkgLSB0aGlzLm1pbi55ICksXHJcblx0XHRcdCggcG9pbnQueiAtIHRoaXMubWluLnogKSAvICggdGhpcy5tYXgueiAtIHRoaXMubWluLnogKVxyXG5cdFx0KTtcclxuXHJcblx0fSxcclxuXHJcblx0aW50ZXJzZWN0c0JveDogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0Ly8gdXNpbmcgNiBzcGxpdHRpbmcgcGxhbmVzIHRvIHJ1bGUgb3V0IGludGVyc2VjdGlvbnMuXHJcblx0XHRyZXR1cm4gYm94Lm1heC54IDwgdGhpcy5taW4ueCB8fCBib3gubWluLnggPiB0aGlzLm1heC54IHx8XHJcblx0XHRcdGJveC5tYXgueSA8IHRoaXMubWluLnkgfHwgYm94Lm1pbi55ID4gdGhpcy5tYXgueSB8fFxyXG5cdFx0XHRib3gubWF4LnogPCB0aGlzLm1pbi56IHx8IGJveC5taW4ueiA+IHRoaXMubWF4LnogPyBmYWxzZSA6IHRydWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGludGVyc2VjdHNTcGhlcmU6ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBjbG9zZXN0UG9pbnQgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSB7XHJcblxyXG5cdFx0XHQvLyBGaW5kIHRoZSBwb2ludCBvbiB0aGUgQUFCQiBjbG9zZXN0IHRvIHRoZSBzcGhlcmUgY2VudGVyLlxyXG5cdFx0XHR0aGlzLmNsYW1wUG9pbnQoIHNwaGVyZS5jZW50ZXIsIGNsb3Nlc3RQb2ludCApO1xyXG5cclxuXHRcdFx0Ly8gSWYgdGhhdCBwb2ludCBpcyBpbnNpZGUgdGhlIHNwaGVyZSwgdGhlIEFBQkIgYW5kIHNwaGVyZSBpbnRlcnNlY3QuXHJcblx0XHRcdHJldHVybiBjbG9zZXN0UG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQoIHNwaGVyZS5jZW50ZXIgKSA8PSAoIHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSApKCksXHJcblxyXG5cdGludGVyc2VjdHNQbGFuZTogZnVuY3Rpb24gKCBwbGFuZSApIHtcclxuXHJcblx0XHQvLyBXZSBjb21wdXRlIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGRvdCBwcm9kdWN0IHZhbHVlcy4gSWYgdGhvc2UgdmFsdWVzXHJcblx0XHQvLyBhcmUgb24gdGhlIHNhbWUgc2lkZSAoYmFjayBvciBmcm9udCkgb2YgdGhlIHBsYW5lLCB0aGVuIHRoZXJlIGlzIG5vIGludGVyc2VjdGlvbi5cclxuXHJcblx0XHR2YXIgbWluLCBtYXg7XHJcblxyXG5cdFx0aWYgKCBwbGFuZS5ub3JtYWwueCA+IDAgKSB7XHJcblxyXG5cdFx0XHRtaW4gPSBwbGFuZS5ub3JtYWwueCAqIHRoaXMubWluLng7XHJcblx0XHRcdG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0bWluID0gcGxhbmUubm9ybWFsLnggKiB0aGlzLm1heC54O1xyXG5cdFx0XHRtYXggPSBwbGFuZS5ub3JtYWwueCAqIHRoaXMubWluLng7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcGxhbmUubm9ybWFsLnkgPiAwICkge1xyXG5cclxuXHRcdFx0bWluICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5taW4ueTtcclxuXHRcdFx0bWF4ICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5tYXgueTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0bWluICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5tYXgueTtcclxuXHRcdFx0bWF4ICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5taW4ueTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBwbGFuZS5ub3JtYWwueiA+IDAgKSB7XHJcblxyXG5cdFx0XHRtaW4gKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1pbi56O1xyXG5cdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1heC56O1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRtaW4gKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1heC56O1xyXG5cdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1pbi56O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gKCBtaW4gPD0gLSBwbGFuZS5jb25zdGFudCAmJiBtYXggPj0gLSBwbGFuZS5jb25zdGFudCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbnRlcnNlY3RzVHJpYW5nbGU6ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHRyaWFuZ2xlIGNlbnRlcmVkIHZlcnRpY2VzXHJcblx0XHR2YXIgdjAgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHZhciB2MiA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0Ly8gdHJpYW5nbGUgZWRnZSB2ZWN0b3JzXHJcblx0XHR2YXIgZjAgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0dmFyIGYxID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHZhciBmMiA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0dmFyIHRlc3RBeGlzID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHR2YXIgY2VudGVyID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHZhciBleHRlbnRzID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHR2YXIgdHJpYW5nbGVOb3JtYWwgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdGZ1bmN0aW9uIHNhdEZvckF4ZXMoIGF4ZXMgKSB7XHJcblxyXG5cdFx0XHR2YXIgaSwgajtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwLCBqID0gYXhlcy5sZW5ndGggLSAzOyBpIDw9IGo7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0dGVzdEF4aXMuZnJvbUFycmF5KCBheGVzLCBpICk7XHJcblx0XHRcdFx0Ly8gcHJvamVjdCB0aGUgYWFiYiBvbnRvIHRoZSBzZXBlcmF0aW5nIGF4aXNcclxuXHRcdFx0XHR2YXIgciA9IGV4dGVudHMueCAqIE1hdGguYWJzKCB0ZXN0QXhpcy54ICkgKyBleHRlbnRzLnkgKiBNYXRoLmFicyggdGVzdEF4aXMueSApICsgZXh0ZW50cy56ICogTWF0aC5hYnMoIHRlc3RBeGlzLnogKTtcclxuXHRcdFx0XHQvLyBwcm9qZWN0IGFsbCAzIHZlcnRpY2VzIG9mIHRoZSB0cmlhbmdsZSBvbnRvIHRoZSBzZXBlcmF0aW5nIGF4aXNcclxuXHRcdFx0XHR2YXIgcDAgPSB2MC5kb3QoIHRlc3RBeGlzICk7XHJcblx0XHRcdFx0dmFyIHAxID0gdjEuZG90KCB0ZXN0QXhpcyApO1xyXG5cdFx0XHRcdHZhciBwMiA9IHYyLmRvdCggdGVzdEF4aXMgKTtcclxuXHRcdFx0XHQvLyBhY3R1YWwgdGVzdCwgYmFzaWNhbGx5IHNlZSBpZiBlaXRoZXIgb2YgdGhlIG1vc3QgZXh0cmVtZSBvZiB0aGUgdHJpYW5nbGUgcG9pbnRzIGludGVyc2VjdHMgclxyXG5cdFx0XHRcdGlmICggTWF0aC5tYXgoIC0gTWF0aC5tYXgoIHAwLCBwMSwgcDIgKSwgTWF0aC5taW4oIHAwLCBwMSwgcDIgKSApID4gciApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBwb2ludHMgb2YgdGhlIHByb2plY3RlZCB0cmlhbmdsZSBhcmUgb3V0c2lkZSB0aGUgcHJvamVjdGVkIGhhbGYtbGVuZ3RoIG9mIHRoZSBhYWJiXHJcblx0XHRcdFx0XHQvLyB0aGUgYXhpcyBpcyBzZXBlcmF0aW5nIGFuZCB3ZSBjYW4gZXhpdFxyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdHNUcmlhbmdsZSggdHJpYW5nbGUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuaXNFbXB0eSgpICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBjb21wdXRlIGJveCBjZW50ZXIgYW5kIGV4dGVudHNcclxuXHRcdFx0dGhpcy5nZXRDZW50ZXIoIGNlbnRlciApO1xyXG5cdFx0XHRleHRlbnRzLnN1YlZlY3RvcnMoIHRoaXMubWF4LCBjZW50ZXIgKTtcclxuXHJcblx0XHRcdC8vIHRyYW5zbGF0ZSB0cmlhbmdsZSB0byBhYWJiIG9yaWdpblxyXG5cdFx0XHR2MC5zdWJWZWN0b3JzKCB0cmlhbmdsZS5hLCBjZW50ZXIgKTtcclxuXHRcdFx0djEuc3ViVmVjdG9ycyggdHJpYW5nbGUuYiwgY2VudGVyICk7XHJcblx0XHRcdHYyLnN1YlZlY3RvcnMoIHRyaWFuZ2xlLmMsIGNlbnRlciApO1xyXG5cclxuXHRcdFx0Ly8gY29tcHV0ZSBlZGdlIHZlY3RvcnMgZm9yIHRyaWFuZ2xlXHJcblx0XHRcdGYwLnN1YlZlY3RvcnMoIHYxLCB2MCApO1xyXG5cdFx0XHRmMS5zdWJWZWN0b3JzKCB2MiwgdjEgKTtcclxuXHRcdFx0ZjIuc3ViVmVjdG9ycyggdjAsIHYyICk7XHJcblxyXG5cdFx0XHQvLyB0ZXN0IGFnYWluc3QgYXhlcyB0aGF0IGFyZSBnaXZlbiBieSBjcm9zcyBwcm9kdWN0IGNvbWJpbmF0aW9ucyBvZiB0aGUgZWRnZXMgb2YgdGhlIHRyaWFuZ2xlIGFuZCB0aGUgZWRnZXMgb2YgdGhlIGFhYmJcclxuXHRcdFx0Ly8gbWFrZSBhbiBheGlzIHRlc3Rpbmcgb2YgZWFjaCBvZiB0aGUgMyBzaWRlcyBvZiB0aGUgYWFiYiBhZ2FpbnN0IGVhY2ggb2YgdGhlIDMgc2lkZXMgb2YgdGhlIHRyaWFuZ2xlID0gOSBheGlzIG9mIHNlcGFyYXRpb25cclxuXHRcdFx0Ly8gYXhpc19paiA9IHVfaSB4IGZfaiAodTAsIHUxLCB1MiA9IGZhY2Ugbm9ybWFscyBvZiBhYWJiID0geCx5LHogYXhlcyB2ZWN0b3JzIHNpbmNlIGFhYmIgaXMgYXhpcyBhbGlnbmVkKVxyXG5cdFx0XHR2YXIgYXhlcyA9IFtcclxuXHRcdFx0XHQwLCAtIGYwLnosIGYwLnksIDAsIC0gZjEueiwgZjEueSwgMCwgLSBmMi56LCBmMi55LFxyXG5cdFx0XHRcdGYwLnosIDAsIC0gZjAueCwgZjEueiwgMCwgLSBmMS54LCBmMi56LCAwLCAtIGYyLngsXHJcblx0XHRcdFx0LSBmMC55LCBmMC54LCAwLCAtIGYxLnksIGYxLngsIDAsIC0gZjIueSwgZjIueCwgMFxyXG5cdFx0XHRdO1xyXG5cdFx0XHRpZiAoICEgc2F0Rm9yQXhlcyggYXhlcyApICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB0ZXN0IDMgZmFjZSBub3JtYWxzIGZyb20gdGhlIGFhYmJcclxuXHRcdFx0YXhlcyA9IFsgMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMSBdO1xyXG5cdFx0XHRpZiAoICEgc2F0Rm9yQXhlcyggYXhlcyApICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBmaW5hbGx5IHRlc3RpbmcgdGhlIGZhY2Ugbm9ybWFsIG9mIHRoZSB0cmlhbmdsZVxyXG5cdFx0XHQvLyB1c2UgYWxyZWFkeSBleGlzdGluZyB0cmlhbmdsZSBlZGdlIHZlY3RvcnMgaGVyZVxyXG5cdFx0XHR0cmlhbmdsZU5vcm1hbC5jcm9zc1ZlY3RvcnMoIGYwLCBmMSApO1xyXG5cdFx0XHRheGVzID0gWyB0cmlhbmdsZU5vcm1hbC54LCB0cmlhbmdsZU5vcm1hbC55LCB0cmlhbmdsZU5vcm1hbC56IF07XHJcblx0XHRcdHJldHVybiBzYXRGb3JBeGVzKCBheGVzICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSApKCksXHJcblxyXG5cdGNsYW1wUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIHRhcmdldCApIHtcclxuXHJcblx0XHRpZiAoIHRhcmdldCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5Cb3gzOiAuY2xhbXBQb2ludCgpIHRhcmdldCBpcyBub3cgcmVxdWlyZWQnICk7XHJcblx0XHRcdHRhcmdldCA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0YXJnZXQuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2xhbXBlZFBvaW50ID0gdjEuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XHJcblx0XHRcdHJldHVybiBjbGFtcGVkUG9pbnQuc3ViKCBwb2ludCApLmxlbmd0aCgpO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Z2V0Qm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRCb3VuZGluZ1NwaGVyZSggdGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0aWYgKCB0YXJnZXQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5Cb3gzOiAuZ2V0Qm91bmRpbmdTcGhlcmUoKSB0YXJnZXQgaXMgbm93IHJlcXVpcmVkJyApO1xyXG5cdFx0XHRcdHRhcmdldCA9IG5ldyBTcGhlcmUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZ2V0Q2VudGVyKCB0YXJnZXQuY2VudGVyICk7XHJcblxyXG5cdFx0XHR0YXJnZXQucmFkaXVzID0gdGhpcy5nZXRTaXplKCB2MSApLmxlbmd0aCgpICogMC41O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRhcmdldDtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGludGVyc2VjdDogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0dGhpcy5taW4ubWF4KCBib3gubWluICk7XHJcblx0XHR0aGlzLm1heC5taW4oIGJveC5tYXggKTtcclxuXHJcblx0XHQvLyBlbnN1cmUgdGhhdCBpZiB0aGVyZSBpcyBubyBvdmVybGFwLCB0aGUgcmVzdWx0IGlzIGZ1bGx5IGVtcHR5LCBub3Qgc2xpZ2h0bHkgZW1wdHkgd2l0aCBub24taW5mLytpbmYgdmFsdWVzIHRoYXQgd2lsbCBjYXVzZSBzdWJzZXF1ZW5jZSBpbnRlcnNlY3RzIHRvIGVycm9uZW91c2x5IHJldHVybiB2YWxpZCB2YWx1ZXMuXHJcblx0XHRpZiAoIHRoaXMuaXNFbXB0eSgpICkgdGhpcy5tYWtlRW1wdHkoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dW5pb246IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdHRoaXMubWluLm1pbiggYm94Lm1pbiApO1xyXG5cdFx0dGhpcy5tYXgubWF4KCBib3gubWF4ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBwb2ludHMgPSBbXHJcblx0XHRcdG5ldyBWZWN0b3IzKCksXHJcblx0XHRcdG5ldyBWZWN0b3IzKCksXHJcblx0XHRcdG5ldyBWZWN0b3IzKCksXHJcblx0XHRcdG5ldyBWZWN0b3IzKCksXHJcblx0XHRcdG5ldyBWZWN0b3IzKCksXHJcblx0XHRcdG5ldyBWZWN0b3IzKCksXHJcblx0XHRcdG5ldyBWZWN0b3IzKCksXHJcblx0XHRcdG5ldyBWZWN0b3IzKClcclxuXHRcdF07XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGFwcGx5TWF0cml4NCggbWF0cml4ICkge1xyXG5cclxuXHRcdFx0Ly8gdHJhbnNmb3JtIG9mIGVtcHR5IGJveCBpcyBhbiBlbXB0eSBib3guXHJcblx0XHRcdGlmICggdGhpcy5pc0VtcHR5KCkgKSByZXR1cm4gdGhpcztcclxuXHJcblx0XHRcdC8vIE5PVEU6IEkgYW0gdXNpbmcgYSBiaW5hcnkgcGF0dGVybiB0byBzcGVjaWZ5IGFsbCAyXjMgY29tYmluYXRpb25zIGJlbG93XHJcblx0XHRcdHBvaW50c1sgMCBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5taW4ueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAwMFxyXG5cdFx0XHRwb2ludHNbIDEgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWluLnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMDFcclxuXHRcdFx0cG9pbnRzWyAyIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1heC55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDEwXHJcblx0XHRcdHBvaW50c1sgMyBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAxMVxyXG5cdFx0XHRwb2ludHNbIDQgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWluLnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMDBcclxuXHRcdFx0cG9pbnRzWyA1IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTAxXHJcblx0XHRcdHBvaW50c1sgNiBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDExMFxyXG5cdFx0XHRwb2ludHNbIDcgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWF4LnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMTFcclxuXHJcblx0XHRcdHRoaXMuc2V0RnJvbVBvaW50cyggcG9pbnRzICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0dGhpcy5taW4uYWRkKCBvZmZzZXQgKTtcclxuXHRcdHRoaXMubWF4LmFkZCggb2Zmc2V0ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0cmV0dXJuIGJveC5taW4uZXF1YWxzKCB0aGlzLm1pbiApICYmIGJveC5tYXguZXF1YWxzKCB0aGlzLm1heCApO1xyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcblxyXG5cclxuZXhwb3J0IHsgQm94MyB9O1xyXG4iLCJpbXBvcnQgeyBCb3gzIH0gZnJvbSAnLi9Cb3gzLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4vVmVjdG9yMy5qcyc7XHJcblxyXG4vKipcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIFNwaGVyZSggY2VudGVyLCByYWRpdXMgKSB7XHJcblxyXG5cdHRoaXMuY2VudGVyID0gKCBjZW50ZXIgIT09IHVuZGVmaW5lZCApID8gY2VudGVyIDogbmV3IFZlY3RvcjMoKTtcclxuXHR0aGlzLnJhZGl1cyA9ICggcmFkaXVzICE9PSB1bmRlZmluZWQgKSA/IHJhZGl1cyA6IDA7XHJcblxyXG59XHJcblxyXG5PYmplY3QuYXNzaWduKCBTcGhlcmUucHJvdG90eXBlLCB7XHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCBjZW50ZXIsIHJhZGl1cyApIHtcclxuXHJcblx0XHR0aGlzLmNlbnRlci5jb3B5KCBjZW50ZXIgKTtcclxuXHRcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGJveCA9IG5ldyBCb3gzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHNldEZyb21Qb2ludHMoIHBvaW50cywgb3B0aW9uYWxDZW50ZXIgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2VudGVyID0gdGhpcy5jZW50ZXI7XHJcblxyXG5cdFx0XHRpZiAoIG9wdGlvbmFsQ2VudGVyICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNlbnRlci5jb3B5KCBvcHRpb25hbENlbnRlciApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ym94LnNldEZyb21Qb2ludHMoIHBvaW50cyApLmdldENlbnRlciggY2VudGVyICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgbWF4UmFkaXVzU3EgPSAwO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0bWF4UmFkaXVzU3EgPSBNYXRoLm1heCggbWF4UmFkaXVzU3EsIGNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnRzWyBpIF0gKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5yYWRpdXMgPSBNYXRoLnNxcnQoIG1heFJhZGl1c1NxICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcclxuXHJcblx0XHR0aGlzLmNlbnRlci5jb3B5KCBzcGhlcmUuY2VudGVyICk7XHJcblx0XHR0aGlzLnJhZGl1cyA9IHNwaGVyZS5yYWRpdXM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVtcHR5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuICggdGhpcy5yYWRpdXMgPD0gMCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuXHRcdHJldHVybiAoIHBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKCB0aGlzLmNlbnRlciApIDw9ICggdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHRyZXR1cm4gKCBwb2ludC5kaXN0YW5jZVRvKCB0aGlzLmNlbnRlciApIC0gdGhpcy5yYWRpdXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0aW50ZXJzZWN0c1NwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XHJcblxyXG5cdFx0dmFyIHJhZGl1c1N1bSA9IHRoaXMucmFkaXVzICsgc3BoZXJlLnJhZGl1cztcclxuXHJcblx0XHRyZXR1cm4gc3BoZXJlLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5jZW50ZXIgKSA8PSAoIHJhZGl1c1N1bSAqIHJhZGl1c1N1bSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbnRlcnNlY3RzQm94OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHRyZXR1cm4gYm94LmludGVyc2VjdHNTcGhlcmUoIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0aW50ZXJzZWN0c1BsYW5lOiBmdW5jdGlvbiAoIHBsYW5lICkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLmFicyggcGxhbmUuZGlzdGFuY2VUb1BvaW50KCB0aGlzLmNlbnRlciApICkgPD0gdGhpcy5yYWRpdXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsYW1wUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIHRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgZGVsdGFMZW5ndGhTcSA9IHRoaXMuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xyXG5cclxuXHRcdGlmICggdGFyZ2V0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdDT09MLlNwaGVyZTogLmNsYW1wUG9pbnQoKSB0YXJnZXQgaXMgbm93IHJlcXVpcmVkJyApO1xyXG5cdFx0XHR0YXJnZXQgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0YXJnZXQuY29weSggcG9pbnQgKTtcclxuXHJcblx0XHRpZiAoIGRlbHRhTGVuZ3RoU3EgPiAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApIHtcclxuXHJcblx0XHRcdHRhcmdldC5zdWIoIHRoaXMuY2VudGVyICkubm9ybWFsaXplKCk7XHJcblx0XHRcdHRhcmdldC5tdWx0aXBseVNjYWxhciggdGhpcy5yYWRpdXMgKS5hZGQoIHRoaXMuY2VudGVyICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0YXJnZXQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEJvdW5kaW5nQm94OiBmdW5jdGlvbiAoIHRhcmdldCApIHtcclxuXHJcblx0XHRpZiAoIHRhcmdldCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5TcGhlcmU6IC5nZXRCb3VuZGluZ0JveCgpIHRhcmdldCBpcyBub3cgcmVxdWlyZWQnICk7XHJcblx0XHRcdHRhcmdldCA9IG5ldyBCb3gzKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRhcmdldC5zZXQoIHRoaXMuY2VudGVyLCB0aGlzLmNlbnRlciApO1xyXG5cdFx0dGFyZ2V0LmV4cGFuZEJ5U2NhbGFyKCB0aGlzLnJhZGl1cyApO1xyXG5cclxuXHRcdHJldHVybiB0YXJnZXQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG5cdFx0dGhpcy5jZW50ZXIuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcclxuXHRcdHRoaXMucmFkaXVzID0gdGhpcy5yYWRpdXMgKiBtYXRyaXguZ2V0TWF4U2NhbGVPbkF4aXMoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcclxuXHJcblx0XHR0aGlzLmNlbnRlci5hZGQoIG9mZnNldCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggc3BoZXJlICkge1xyXG5cclxuXHRcdHJldHVybiBzcGhlcmUuY2VudGVyLmVxdWFscyggdGhpcy5jZW50ZXIgKSAmJiAoIHNwaGVyZS5yYWRpdXMgPT09IHRoaXMucmFkaXVzICk7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuXHJcblxyXG5leHBvcnQgeyBTcGhlcmUgfTtcclxuIiwiaW1wb3J0IHtWZWN0b3IzfSBmcm9tIFwiLi4vbWF0aC9WZWN0b3IzXCI7XHJcbmltcG9ydCB7U3BoZXJlfSBmcm9tIFwiLi4vbWF0aC9TcGhlcmVcIjtcclxuaW1wb3J0IHtCb3gzfSBmcm9tIFwiLi4vbWF0aC9Cb3gzXCI7XHJcblxyXG5jbGFzcyBHZW9tZXRyeSB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbSkge1xyXG4gICAgICAgIHBhcmFtID0gcGFyYW0gfHwge307XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBhIGN1YmVcclxuICAgICAgICAvLyAgICB2Ni0tLS0tIHY1XHJcbiAgICAgICAgLy8gICAvfCAgICAgIC98XHJcbiAgICAgICAgLy8gIHYxLS0tLS0tdjB8XHJcbiAgICAgICAgLy8gIHwgfCAgICAgfCB8XHJcbiAgICAgICAgLy8gIHwgfHY3LS0tfC18djRcclxuICAgICAgICAvLyAgfC8gICAgICB8L1xyXG4gICAgICAgIC8vICB2Mi0tLS0tLXYzXHJcblxyXG4gICAgICAgIHRoaXMudXYgPSBwYXJhbS51diB8fCBuZXcgRmxvYXQzMkFycmF5KFsgICAvLyBWZXJ0ZXggY29vcmRpbmF0ZXNcclxuXHJcbiAgICAgICAgICAgIDEsMSwgMCwxLCAwLDAsIDEsMCwgIC8vIHYwLXYxLXYyLXYzIGZyb250XHJcbiAgICAgICAgICAgIDAsMSwgMCwwLCAxLDAsIDEsMSwgIC8vIHYwLXYzLXY0LXY1IHJpZ2h0XHJcbiAgICAgICAgICAgIDEsMCwgMSwxLCAwLDEsIDAsMCwgIC8vIHYwLXY1LXY2LXYxIHVwXHJcbiAgICAgICAgICAgIDEsMSwgMCwxLCAwLDAsIDEsMCwgIC8vIHYxLXY2LXY3LXYyIGxlZnRcclxuICAgICAgICAgICAgMCwxLCAxLDEsIDEsMCwgMCwwLCAgLy8gdjctdjQtdjMtdjIgZG93blxyXG4gICAgICAgICAgICAxLDAsIDAsMCwgMCwxLCAxLDEgICAvLyB2NC12Ny12Ni12NSBiYWNrXHJcblxyXG4gICAgICAgIF0pO1xyXG5cclxuICAgICAgICB0aGlzLnZlcnRpY2VzID0gcGFyYW0udmVydGljZXMgfHwgbmV3IEZsb2F0MzJBcnJheShbICAgLy8gVmVydGV4IGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICAgIDAuNSwgMC41LCAwLjUsICAtMC41LCAwLjUsIDAuNSwgIC0wLjUsLTAuNSwgMC41LCAgIDAuNSwtMC41LCAwLjUsICAvLyB2MC12MS12Mi12MyBmcm9udFxyXG4gICAgICAgICAgICAwLjUsIDAuNSwgMC41LCAgIDAuNSwtMC41LCAwLjUsICAgMC41LC0wLjUsLTAuNSwgICAwLjUsIDAuNSwtMC41LCAgLy8gdjAtdjMtdjQtdjUgcmlnaHRcclxuICAgICAgICAgICAgMC41LCAwLjUsIDAuNSwgICAwLjUsIDAuNSwtMC41LCAgLTAuNSwgMC41LC0wLjUsICAtMC41LCAwLjUsIDAuNSwgIC8vIHYwLXY1LXY2LXYxIHVwXHJcbiAgICAgICAgICAgIC0wLjUsIDAuNSwgMC41LCAgLTAuNSwgMC41LC0wLjUsICAtMC41LC0wLjUsLTAuNSwgIC0wLjUsLTAuNSwgMC41LCAgLy8gdjEtdjYtdjctdjIgbGVmdFxyXG4gICAgICAgICAgICAtMC41LC0wLjUsLTAuNSwgICAwLjUsLTAuNSwtMC41LCAgIDAuNSwtMC41LCAwLjUsICAtMC41LC0wLjUsIDAuNSwgIC8vIHY3LXY0LXYzLXYyIGRvd25cclxuICAgICAgICAgICAgMC41LC0wLjUsLTAuNSwgIC0wLjUsLTAuNSwtMC41LCAgLTAuNSwgMC41LC0wLjUsICAgMC41LCAwLjUsLTAuNSAgIC8vIHY0LXY3LXY2LXY1IGJhY2tcclxuICAgICAgICBdKTtcclxuXHJcbiAgICAgICAgdGhpcy5ub3JtYWwgPSBwYXJhbS5ub3JtYWwgfHwgdGhpcy52ZXJ0aWNlcztcclxuXHJcbiAgICAgICAgaWYocGFyYW0uaW5kaWNlcyl7XHJcbiAgICAgICAgICAgIHRoaXMuaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShwYXJhbS5pbmRpY2VzKTtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgdmFyIGluZGljZXNBcnJheSA9IFtdO1xyXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxwYXJhbS52ZXJ0aWNlcy5sZW5ndGgvMzsgaSsrKXtcclxuICAgICAgICAgICAgICAgIGluZGljZXNBcnJheS5wdXNoKGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShpbmRpY2VzQXJyYXkpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIHRoaXMubW9ycGhBdHRyaWJ1dGVzID0gcGFyYW0ubW9ycGhBdHRyaWJ1dGVzO1xyXG5cclxuICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSgpO1xyXG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgQm94MygpO1xyXG4gICAgICAgIHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XHJcblxyXG4gICAgICAgIC8vIHRoaXMudXBkYXRlTm9ybWFsKCk7XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRhQnVmZmVyKCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0YUJ1ZmZlcigpe1xyXG4gICAgICAgIHZhciBidWZmZXIgPSBbXTtcclxuICAgICAgICB2YXIgdXYgPSB0aGlzLnV2O1xyXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XHJcbiAgICAgICAgdmFyIG5vcm1hbCA9IHRoaXMubm9ybWFsO1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHZlcnRpY2VzLmxlbmd0aDsgaSs9Myl7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKHZlcnRpY2VzW2krMF0pO1xyXG4gICAgICAgICAgICBidWZmZXIucHVzaCh2ZXJ0aWNlc1tpKzFdKTtcclxuICAgICAgICAgICAgYnVmZmVyLnB1c2godmVydGljZXNbaSsyXSk7XHJcblxyXG4gICAgICAgICAgICBidWZmZXIucHVzaChub3JtYWxbaSswXSk7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKG5vcm1hbFtpKzFdKTtcclxuICAgICAgICAgICAgYnVmZmVyLnB1c2gobm9ybWFsW2krMl0pO1xyXG5cclxuICAgICAgICAgICAgYnVmZmVyLnB1c2godXZbaS8zKjIrMF0pO1xyXG4gICAgICAgICAgICBidWZmZXIucHVzaCh1dltpLzMqMisxXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVOb3JtYWwoKXtcclxuICAgICAgICB2YXIgbm9ybWFsID0gW107XHJcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcclxuICAgICAgICBmb3IodmFyIGk9MDsgaTx2ZXJ0aWNlcy5sZW5ndGg7IGkrPTMqNCl7XHJcbiAgICAgICAgICAgIHZhciBsaW5lMSA9IG5ldyBWZWN0b3IzKCkuc3ViVmVjdG9ycyhcclxuICAgICAgICAgICAgICAgIG5ldyBWZWN0b3IzKHZlcnRpY2VzW2krMF0sIHZlcnRpY2VzW2krMV0sIHZlcnRpY2VzW2krMl0pLFxyXG4gICAgICAgICAgICAgICAgbmV3IFZlY3RvcjModmVydGljZXNbaSszXSwgdmVydGljZXNbaSs0XSwgdmVydGljZXNbaSs1XSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgdmFyIGxpbmUyID0gbmV3IFZlY3RvcjMoKS5zdWJWZWN0b3JzKFxyXG4gICAgICAgICAgICAgICAgbmV3IFZlY3RvcjModmVydGljZXNbaSszXSwgdmVydGljZXNbaSs0XSwgdmVydGljZXNbaSs1XSksXHJcbiAgICAgICAgICAgICAgICBuZXcgVmVjdG9yMyh2ZXJ0aWNlc1tpKzZdLCB2ZXJ0aWNlc1tpKzddLCB2ZXJ0aWNlc1tpKzhdKSxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgdmFyIGN1cl9ub3JtYWwgPSBuZXcgVmVjdG9yMygpLmNyb3NzVmVjdG9ycyhcclxuICAgICAgICAgICAgICAgIGxpbmUxLFxyXG4gICAgICAgICAgICAgICAgbGluZTJcclxuICAgICAgICAgICAgKS50b0FycmF5KCk7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaj0wIDtqPDQ7IGorKyl7XHJcbiAgICAgICAgICAgICAgICBub3JtYWwucHVzaChjdXJfbm9ybWFsWzBdLCBjdXJfbm9ybWFsWzFdLCBjdXJfbm9ybWFsWzJdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm5vcm1hbCA9IG5ldyBGbG9hdDMyQXJyYXkobm9ybWFsKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgY29tcHV0ZUJvdW5kaW5nQm94ICgpIHtcclxuICAgICAgICB2YXIgdmVydGljZXNWMyA9IFtdO1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHRoaXMudmVydGljZXMubGVuZ3RoOyBpKz0zKXtcclxuICAgICAgICAgICAgdmVydGljZXNWMy5wdXNoKG5ldyBWZWN0b3IzKHRoaXMudmVydGljZXNbaV0sIHRoaXMudmVydGljZXNbaSsxXSwgdGhpcy52ZXJ0aWNlc1tpKzJdKSlcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5zZXRGcm9tUG9pbnRzKHZlcnRpY2VzVjMpO1xyXG4gICAgfVxyXG5cclxuICAgIGNsb25lKCl7XHJcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5KHtcclxuICAgICAgICAgICAgdmVydGljZXM6IHRoaXMudmVydGljZXMuc2xpY2UoMCksXHJcbiAgICAgICAgICAgIGluZGljZXM6IHRoaXMuaW5kaWNlcy5zbGljZSgwKVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gZ2VvbWV0cnk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEdlb21ldHJ5O1xyXG4iLCJpbXBvcnQge1ZlY3RvcjN9IGZyb20gXCIuLi9tYXRoL1ZlY3RvcjNcIjtcclxuaW1wb3J0IHtTcGhlcmV9IGZyb20gXCIuLi9tYXRoL1NwaGVyZVwiO1xyXG5pbXBvcnQge0JveDN9IGZyb20gXCIuLi9tYXRoL0JveDNcIjtcclxuXHJcbmNsYXNzIEJveEdlb21ldHJ5IHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtKSB7XHJcbiAgICAgICAgcGFyYW0gPSBwYXJhbSB8fCB7fTtcclxuXHJcbiAgICAgICAgdGhpcy51diA9IHBhcmFtLnV2IHx8IG5ldyBGbG9hdDMyQXJyYXkoWyAgIC8vIFZlcnRleCBjb29yZGluYXRlc1xyXG5cclxuICAgICAgICAgICAgMSwxLCAwLDEsIDAsMCwgMSwwLCAgLy8gdjAtdjEtdjItdjMgZnJvbnRcclxuICAgICAgICAgICAgMCwxLCAwLDAsIDEsMCwgMSwxLCAgLy8gdjAtdjMtdjQtdjUgcmlnaHRcclxuICAgICAgICAgICAgMSwwLCAxLDEsIDAsMSwgMCwwLCAgLy8gdjAtdjUtdjYtdjEgdXBcclxuICAgICAgICAgICAgMSwxLCAwLDEsIDAsMCwgMSwwLCAgLy8gdjEtdjYtdjctdjIgbGVmdFxyXG4gICAgICAgICAgICAwLDEsIDEsMSwgMSwwLCAwLDAsICAvLyB2Ny12NC12My12MiBkb3duXHJcbiAgICAgICAgICAgIDEsMCwgMCwwLCAwLDEsIDEsMSAgIC8vIHY0LXY3LXY2LXY1IGJhY2tcclxuXHJcbiAgICAgICAgXSk7XHJcblxyXG4gICAgICAgIHRoaXMudmVydGljZXMgPSBwYXJhbS5pbmRpY2VzIHx8IG5ldyBGbG9hdDMyQXJyYXkoWyAgIC8vIFZlcnRleCBjb29yZGluYXRlc1xyXG4gICAgICAgICAgICAwLjUsIDAuNSwgMC41LCAgLTAuNSwgMC41LCAwLjUsICAtMC41LC0wLjUsIDAuNSwgICAwLjUsLTAuNSwgMC41LCAgLy8gdjAtdjEtdjItdjMgZnJvbnRcclxuICAgICAgICAgICAgMC41LCAwLjUsIDAuNSwgICAwLjUsLTAuNSwgMC41LCAgIDAuNSwtMC41LC0wLjUsICAgMC41LCAwLjUsLTAuNSwgIC8vIHYwLXYzLXY0LXY1IHJpZ2h0XHJcbiAgICAgICAgICAgIDAuNSwgMC41LCAwLjUsICAgMC41LCAwLjUsLTAuNSwgIC0wLjUsIDAuNSwtMC41LCAgLTAuNSwgMC41LCAwLjUsICAvLyB2MC12NS12Ni12MSB1cFxyXG4gICAgICAgICAgICAtMC41LCAwLjUsIDAuNSwgIC0wLjUsIDAuNSwtMC41LCAgLTAuNSwtMC41LC0wLjUsICAtMC41LC0wLjUsIDAuNSwgIC8vIHYxLXY2LXY3LXYyIGxlZnRcclxuICAgICAgICAgICAgLTAuNSwtMC41LC0wLjUsICAgMC41LC0wLjUsLTAuNSwgICAwLjUsLTAuNSwgMC41LCAgLTAuNSwtMC41LCAwLjUsICAvLyB2Ny12NC12My12MiBkb3duXHJcbiAgICAgICAgICAgIDAuNSwtMC41LC0wLjUsICAtMC41LC0wLjUsLTAuNSwgIC0wLjUsIDAuNSwtMC41LCAgIDAuNSwgMC41LC0wLjUgICAvLyB2NC12Ny12Ni12NSBiYWNrXHJcbiAgICAgICAgXSk7XHJcblxyXG4gICAgICAgIHRoaXMubm9ybWFsID0gcGFyYW0ubm9ybWFsIHx8IHRoaXMudmVydGljZXM7XHJcblxyXG4gICAgICAgIHRoaXMuaW5kaWNlcyA9IHBhcmFtLmluZGljZXMgfHwgbmV3IFVpbnQxNkFycmF5KFsgICAgICAgLy8gSW5kaWNlcyBvZiB0aGUgdmVydGljZXNcclxuICAgICAgICAgICAgMCwgMSwgMiwgICAwLCAyLCAzLCAgICAvLyBmcm9udFxyXG4gICAgICAgICAgICA0LCA1LCA2LCAgIDQsIDYsIDcsICAgIC8vIHJpZ2h0XHJcbiAgICAgICAgICAgIDgsIDksMTAsICAgOCwxMCwxMSwgICAgLy8gdXBcclxuICAgICAgICAgICAgMTIsMTMsMTQsICAxMiwxNCwxNSwgICAgLy8gbGVmdFxyXG4gICAgICAgICAgICAxNiwxNywxOCwgIDE2LDE4LDE5LCAgICAvLyBkb3duXHJcbiAgICAgICAgICAgIDIwLDIxLDIyLCAgMjAsMjIsMjMgICAgIC8vIGJhY2tcclxuICAgICAgICBdKTtcclxuXHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBTcGhlcmUoKTtcclxuICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gbmV3IEJveDMoKTtcclxuICAgICAgICB0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xyXG4gICAgICAgIC8vIHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlTm9ybWFsKCk7XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRhQnVmZmVyKCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0YUJ1ZmZlcigpe1xyXG4gICAgICAgIHZhciBidWZmZXIgPSBbXTtcclxuICAgICAgICB2YXIgdXYgPSB0aGlzLnV2O1xyXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XHJcbiAgICAgICAgdmFyIG5vcm1hbCA9IHRoaXMubm9ybWFsO1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHZlcnRpY2VzLmxlbmd0aDsgaSs9Myl7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKHZlcnRpY2VzW2krMF0pO1xyXG4gICAgICAgICAgICBidWZmZXIucHVzaCh2ZXJ0aWNlc1tpKzFdKTtcclxuICAgICAgICAgICAgYnVmZmVyLnB1c2godmVydGljZXNbaSsyXSk7XHJcblxyXG4gICAgICAgICAgICBidWZmZXIucHVzaChub3JtYWxbaSswXSk7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKG5vcm1hbFtpKzFdKTtcclxuICAgICAgICAgICAgYnVmZmVyLnB1c2gobm9ybWFsW2krMl0pO1xyXG5cclxuICAgICAgICAgICAgYnVmZmVyLnB1c2godXZbaS8zKjIrMF0pO1xyXG4gICAgICAgICAgICBidWZmZXIucHVzaCh1dltpLzMqMisxXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVOb3JtYWwoKXtcclxuICAgICAgICB2YXIgbm9ybWFsID0gW107XHJcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcclxuICAgICAgICBmb3IodmFyIGk9MDsgaTx2ZXJ0aWNlcy5sZW5ndGg7IGkrPTMqNCl7XHJcbiAgICAgICAgICAgIHZhciBsaW5lMSA9IG5ldyBWZWN0b3IzKCkuc3ViVmVjdG9ycyhcclxuICAgICAgICAgICAgICAgIG5ldyBWZWN0b3IzKHZlcnRpY2VzW2krMF0sIHZlcnRpY2VzW2krMV0sIHZlcnRpY2VzW2krMl0pLFxyXG4gICAgICAgICAgICAgICAgbmV3IFZlY3RvcjModmVydGljZXNbaSszXSwgdmVydGljZXNbaSs0XSwgdmVydGljZXNbaSs1XSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgdmFyIGxpbmUyID0gbmV3IFZlY3RvcjMoKS5zdWJWZWN0b3JzKFxyXG4gICAgICAgICAgICAgICAgbmV3IFZlY3RvcjModmVydGljZXNbaSszXSwgdmVydGljZXNbaSs0XSwgdmVydGljZXNbaSs1XSksXHJcbiAgICAgICAgICAgICAgICBuZXcgVmVjdG9yMyh2ZXJ0aWNlc1tpKzZdLCB2ZXJ0aWNlc1tpKzddLCB2ZXJ0aWNlc1tpKzhdKSxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgdmFyIGN1cl9ub3JtYWwgPSBuZXcgVmVjdG9yMygpLmNyb3NzVmVjdG9ycyhcclxuICAgICAgICAgICAgICAgIGxpbmUxLFxyXG4gICAgICAgICAgICAgICAgbGluZTJcclxuICAgICAgICAgICAgKS50b0FycmF5KCk7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaj0wIDtqPDQ7IGorKyl7XHJcbiAgICAgICAgICAgICAgICBub3JtYWwucHVzaChjdXJfbm9ybWFsWzBdLCBjdXJfbm9ybWFsWzFdLCBjdXJfbm9ybWFsWzJdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm5vcm1hbCA9IG5ldyBGbG9hdDMyQXJyYXkobm9ybWFsKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCl7XHJcblxyXG4gICAgICAgIC8vIGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcclxuICAgICAgICAvLyAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBTcGhlcmUoKTtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgLy8gdGhpcy5ib3VuZGluZ1NwaGVyZS5zZXRGcm9tUG9pbnRzKCB0aGlzLnZlcnRpY2VzICk7XHJcbiAgICB9XHJcblxyXG4gICAgY29tcHV0ZUJvdW5kaW5nQm94ICgpIHtcclxuICAgICAgICB2YXIgdmVydGljZXNWMyA9IFtdO1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHRoaXMudmVydGljZXMubGVuZ3RoOyBpKz0zKXtcclxuICAgICAgICAgICAgdmVydGljZXNWMy5wdXNoKG5ldyBWZWN0b3IzKHRoaXMudmVydGljZXNbaV0sIHRoaXMudmVydGljZXNbaSsxXSwgdGhpcy52ZXJ0aWNlc1tpKzJdKSlcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5zZXRGcm9tUG9pbnRzKHZlcnRpY2VzVjMpO1xyXG4gICAgfVxyXG5cclxuICAgIGNsb25lKCl7XHJcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gbmV3IEJveEdlb21ldHJ5KHtcclxuICAgICAgICAgICAgdmVydGljZXM6IHRoaXMudmVydGljZXMuc2xpY2UoMCksXHJcbiAgICAgICAgICAgIGluZGljZXM6IHRoaXMuaW5kaWNlcy5zbGljZSgwKVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gZ2VvbWV0cnk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJveEdlb21ldHJ5O1xyXG4iLCJcclxuY2xhc3MgTWF0ZXJpYWwge1xyXG4gICAgY29uc3RydWN0b3IocGFyYW0pIHtcclxuICAgICAgICBwYXJhbSA9IHBhcmFtIHx8IHt9O1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdNYXRlcmlhbCc7XHJcbiAgICAgICAgdGhpcy5tYXAgPSBwYXJhbS5tYXA7XHJcbiAgICAgICAgdGhpcy5lbnZNYXAgPSBwYXJhbS5lbnZNYXA7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IHBhcmFtLmNvbG9yIHx8IFsxLDEsMSwxXTtcclxuICAgICAgICB0aGlzLm9wYWNpdHkgPSB0aGlzLmNvbG9yWzNdO1xyXG4gICAgICAgIGlmKHRoaXMuY29sb3JbM10gJiYgdGhpcy5jb2xvclszXTwxKXtcclxuICAgICAgICAgICAgdGhpcy50cmFuc3BhcmVudCA9IHRydWU7XHJcbiAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zcGFyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubWV0YWxuZXNzID0gcGFyYW0ubWV0YWxuZXNzID09IHVuZGVmaW5lZCA/IDAuNSA6IHBhcmFtLm1ldGFsbmVzcztcclxuXHJcbiAgICAgICAgdGhpcy53aXJlZnJhbWUgPSBwYXJhbS53aXJlZnJhbWUgPT0gdW5kZWZpbmVkID8gZmFsc2UgOiBwYXJhbS53aXJlZnJhbWU7XHJcblxyXG4gICAgICAgIHZhciBWU0hBREVSX1NPVVJDRSA9XHJcblxyXG4gICAgICAgICAgICAncHJlY2lzaW9uIGhpZ2hwIGludDtcXG4nICtcclxuICAgICAgICAgICAgJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcclxuICAgICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWM0IGFfUG9zaXRpb247XFxuJyArXHJcbiAgICAgICAgICAgICd1bmlmb3JtIG1hdDQgdV9Ndk1hdHJpeDtcXG4nICtcclxuICAgICAgICAgICAgJ3VuaWZvcm0gbWF0NCB1X1BNYXRyaXg7XFxuJyArXHJcblxyXG4gICAgICAgICAgICAnI2lmZGVmIFVTRV9TaGFkb3dcXG4nICtcclxuICAgICAgICAgICAgJ3VuaWZvcm0gbWF0NCB1X1BNYXRyaXhGcm9tTGlnaHQ7XFxuJyArXHJcbiAgICAgICAgICAgICd2YXJ5aW5nIHZlYzQgdl9Qb3NpdGlvbkZyb21MaWdodDtcXG4nICtcclxuICAgICAgICAgICAgJyNlbmRpZlxcbicgK1xyXG5cclxuICAgICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfVGV4Q29vcmQ7XFxuJyArXHJcbiAgICAgICAgICAgICd2YXJ5aW5nIHZlYzIgdl9UZXhDb29yZDtcXG4nICtcclxuICAgICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMzIGFfTm9ybWFsO1xcbicgK1xyXG4gICAgICAgICAgICAndmFyeWluZyB2ZWMzIHZfTm9ybWFsO1xcbicgK1xyXG5cclxuICAgICAgICAgICAgJyNpZmRlZiBVU0VfU0NvbG9yXFxuJyArXHJcbiAgICAgICAgICAgICd2YXJ5aW5nIHZlYzMgdl9Qb3NpdGlvblYzO1xcbicgK1xyXG4gICAgICAgICAgICAnI2Vsc2VcXG4nICtcclxuICAgICAgICAgICAgJyAgICNpZmRlZiBVU0VfZW52TWFwXFxuJyArXHJcbiAgICAgICAgICAgICcgICB2YXJ5aW5nIHZlYzMgdl9Qb3NpdGlvblYzO1xcbicgK1xyXG4gICAgICAgICAgICAnICAgI2VuZGlmXFxuJyArXHJcbiAgICAgICAgICAgICcjZW5kaWZcXG4nICtcclxuXHJcbiAgICAgICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXHJcbiAgICAgICAgICAgICcgIHZlYzQgcG9zaXRpb25WNCA9IHVfUE1hdHJpeCAqIHVfTXZNYXRyaXggKiBhX1Bvc2l0aW9uO1xcbicgK1xyXG4gICAgICAgICAgICAnICBnbF9Qb3NpdGlvbiA9IHBvc2l0aW9uVjQ7XFxuJyArXHJcbiAgICAgICAgICAgICcgIHZfVGV4Q29vcmQgPSBhX1RleENvb3JkO1xcbicgK1xyXG4gICAgICAgICAgICAnICB2X05vcm1hbCA9IG1hdDModV9Ndk1hdHJpeCkgKiBhX05vcm1hbDtcXG4nICtcclxuICAgICAgICAgICAgLy8gJyAgdl9Ob3JtYWwgPSAodV9Ndk1hdHJpeCAqIHZlYzQoYV9Ob3JtYWwsIDAuMCkpLnh5ejtcXG4nICtcclxuICAgICAgICAgICAgLy8gJyAgdl9Ob3JtYWwgPSBhX05vcm1hbDtcXG4nICtcclxuXHJcbiAgICAgICAgICAgICcjaWZkZWYgVVNFX1NoYWRvd1xcbicgK1xyXG4gICAgICAgICAgICAnICB2X1Bvc2l0aW9uRnJvbUxpZ2h0ID0gdV9QTWF0cml4RnJvbUxpZ2h0ICogdV9Ndk1hdHJpeCAqIGFfUG9zaXRpb247XFxuJyArXHJcbiAgICAgICAgICAgICcjZW5kaWZcXG4nICtcclxuXHJcbiAgICAgICAgICAgICcjaWZkZWYgVVNFX1NDb2xvclxcbicgK1xyXG4gICAgICAgICAgICAnICB2ZWM0IHBvc2l0aW9uVjRSZWwgPSB1X012TWF0cml4ICogYV9Qb3NpdGlvbjtcXG4nICtcclxuICAgICAgICAgICAgJyAgdl9Qb3NpdGlvblYzID0gcG9zaXRpb25WNFJlbC54eXogLyBwb3NpdGlvblY0UmVsLnc7XFxuJyArXHJcbiAgICAgICAgICAgICcjZWxzZVxcbicgK1xyXG4gICAgICAgICAgICAnICAgI2lmZGVmIFVTRV9lbnZNYXBcXG4nICtcclxuICAgICAgICAgICAgJyAgIHZlYzQgcG9zaXRpb25WNFJlbCA9IHVfTXZNYXRyaXggKiBhX1Bvc2l0aW9uO1xcbicgK1xyXG4gICAgICAgICAgICAnICAgdl9Qb3NpdGlvblYzID0gcG9zaXRpb25WNFJlbC54eXogLyBwb3NpdGlvblY0UmVsLnc7XFxuJyArXHJcbiAgICAgICAgICAgICcgICAjZW5kaWZcXG4nICtcclxuICAgICAgICAgICAgJyNlbmRpZlxcbicgK1xyXG5cclxuICAgICAgICAgICAgJ31cXG4nO1xyXG5cclxuICAgICAgICB2YXIgRlNIQURFUl9TT1VSQ0UgPVxyXG4gICAgICAgICAgICAncHJlY2lzaW9uIGhpZ2hwIGludDtcXG4nICtcclxuICAgICAgICAgICAgJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcclxuICAgICAgICAgICAgJ3VuaWZvcm0gdmVjNCB1X0NvbG9yO1xcbicgK1xyXG4gICAgICAgICAgICAndmFyeWluZyB2ZWMyIHZfVGV4Q29vcmQ7XFxuJyArXHJcbiAgICAgICAgICAgICd2YXJ5aW5nIHZlYzMgdl9Ob3JtYWw7XFxuJyArXHJcblxyXG4gICAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1X01ldGFsbmVzcztcXG4nICtcclxuXHJcbiAgICAgICAgICAgICcjaWZkZWYgVVNFX01hcFxcbicgK1xyXG4gICAgICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdV9TYW1wbGVyO1xcbicgK1xyXG4gICAgICAgICAgICAnI2VuZGlmXFxuJyArXHJcblxyXG4gICAgICAgICAgICAnI2lmZGVmIFVTRV9lbnZNYXBcXG4nICtcclxuICAgICAgICAgICAgJ3VuaWZvcm0gc2FtcGxlckN1YmUgdV9lbnZNYXA7XFxuJyArXHJcbiAgICAgICAgICAgICcjZW5kaWZcXG4nICtcclxuXHJcbiAgICAgICAgICAgICcjaWZkZWYgVVNFX0FtYmllbnRMaWdodFxcbicgK1xyXG4gICAgICAgICAgICAndW5pZm9ybSB2ZWMzIHVfQW1iaWVudExpZ2h0X0NvbG9yO1xcbicgK1xyXG4gICAgICAgICAgICAnI2VuZGlmXFxuJyArXHJcblxyXG4gICAgICAgICAgICAnI2lmZGVmIFVTRV9EaXJlY3Rpb25hbExpZ2h0XFxuJyArXHJcbiAgICAgICAgICAgICd1bmlmb3JtIHZlYzMgdV9EaXJlY3Rpb25hbExpZ2h0X0RpcmVjdGlvbjtcXG4nICtcclxuICAgICAgICAgICAgJ3VuaWZvcm0gdmVjMyB1X0RpcmVjdGlvbmFsTGlnaHRfQ29sb3I7XFxuJyArXHJcbiAgICAgICAgICAgICcjZW5kaWZcXG4nICtcclxuXHJcbiAgICAgICAgICAgICcjaWZkZWYgVVNFX1NDb2xvclxcbicgK1xyXG4gICAgICAgICAgICAndW5pZm9ybSB2ZWMzIHVfQ2FtZXJhX1Bvc2l0aW9uO1xcbicgK1xyXG4gICAgICAgICAgICAndmFyeWluZyB2ZWMzIHZfUG9zaXRpb25WMztcXG4nICtcclxuICAgICAgICAgICAgJyNlbHNlXFxuJyArXHJcbiAgICAgICAgICAgICcgICAjaWZkZWYgVVNFX2Vudk1hcFxcbicgK1xyXG4gICAgICAgICAgICAnICAgdW5pZm9ybSB2ZWMzIHVfQ2FtZXJhX1Bvc2l0aW9uO1xcbicgK1xyXG4gICAgICAgICAgICAnICAgdmFyeWluZyB2ZWMzIHZfUG9zaXRpb25WMztcXG4nICtcclxuICAgICAgICAgICAgJyAgICNlbmRpZlxcbicgK1xyXG4gICAgICAgICAgICAnI2VuZGlmXFxuJyArXHJcblxyXG4gICAgICAgICAgICAnI2lmZGVmIFVTRV9TaGFkb3dcXG4nICtcclxuICAgICAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVfU2hhZG93TWFwO1xcbicgK1xyXG4gICAgICAgICAgICAndmFyeWluZyB2ZWM0IHZfUG9zaXRpb25Gcm9tTGlnaHQ7XFxuJyArXHJcblxyXG4gICAgICAgICAgICAnZmxvYXQgdW5wYWNrRGVwdGgoY29uc3QgaW4gdmVjNCByZ2JhRGVwdGgpIHtcXG4nICtcclxuICAgICAgICAgICAgJyAgY29uc3QgdmVjNCBiaXRTaGlmdCA9IHZlYzQoMS4wLCAxLjAvMjU2LjAsIDEuMC8oMjU2LjAqMjU2LjApLCAxLjAvKDI1Ni4wKjI1Ni4wKjI1Ni4wKSk7XFxuJyArXHJcbiAgICAgICAgICAgICcgIGZsb2F0IGRlcHRoID0gZG90KHJnYmFEZXB0aCwgYml0U2hpZnQpO1xcbicgKyAvLyBVc2UgZG90KCkgc2luY2UgdGhlIGNhbGN1bGF0aW9ucyBpcyBzYW1lXHJcbiAgICAgICAgICAgICcgIHJldHVybiBkZXB0aDtcXG4nICtcclxuICAgICAgICAgICAgJ31cXG4nICtcclxuXHJcbiAgICAgICAgICAgICcjZW5kaWZcXG4nICtcclxuXHJcbiAgICAgICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXHJcbiAgICAgICAgICAgICcgIHZlYzQgY29sb3IgPSB1X0NvbG9yO1xcbicgK1xyXG4gICAgICAgICAgICAnICB2ZWMzIHZfTm9ybWFsMCA9IG5vcm1hbGl6ZSh2X05vcm1hbCk7XFxuJyArXHJcblxyXG4gICAgICAgICAgICAnI2lmZGVmIFVTRV9NYXBcXG4nICtcclxuICAgICAgICAgICAgJyAgY29sb3IgPSB0ZXh0dXJlMkQodV9TYW1wbGVyLCB2X1RleENvb3JkKTtcXG4nICtcclxuICAgICAgICAgICAgJyNlbmRpZlxcbicgK1xyXG5cclxuICAgICAgICAgICAgJyAgdmVjMyBjb2xvclYzID0gY29sb3IucmdiO1xcbicgK1xyXG4gICAgICAgICAgICAnICBmbG9hdCB1c2VMaWdodCA9IDAuMDtcXG4nICtcclxuICAgICAgICAgICAgJyAgdmVjMyBmaW5hbENvbG9yVjMgPSBjb2xvclYzLnJnYjtcXG4nICtcclxuXHJcbiAgICAgICAgICAgICcjaWZkZWYgVVNFX0FtYmllbnRMaWdodFxcbicgK1xyXG4gICAgICAgICAgICAnICB2ZWMzIEFfY29sb3IgPSBjb2xvclYzICogdV9BbWJpZW50TGlnaHRfQ29sb3IgKiAwLjU7XFxuJyArXHJcbiAgICAgICAgICAgICcgIGZpbmFsQ29sb3JWMyA9IEFfY29sb3I7XFxuJyArXHJcbiAgICAgICAgICAgICcgIHVzZUxpZ2h0ID0gMS4wO1xcbicgK1xyXG4gICAgICAgICAgICAnI2VuZGlmXFxuJyArXHJcblxyXG4gICAgICAgICAgICAnI2lmZGVmIFVTRV9EaXJlY3Rpb25hbExpZ2h0XFxuJyArXHJcbiAgICAgICAgICAgICcgIGZsb2F0IERfd2VpZ2h0ID0gbWF4KGRvdCh1X0RpcmVjdGlvbmFsTGlnaHRfRGlyZWN0aW9uLCB2X05vcm1hbDApLCAwLjApO1xcbicgK1xyXG4gICAgICAgICAgICAnICB2ZWMzIERfY29sb3IgPSBjb2xvclYzICogdV9EaXJlY3Rpb25hbExpZ2h0X0NvbG9yICogRF93ZWlnaHQgKiAoMS4wIC0gdV9NZXRhbG5lc3MpO1xcbicgK1xyXG5cclxuICAgICAgICAgICAgJyAgaWYodXNlTGlnaHQ+MC41KXtcXG4nICtcclxuICAgICAgICAgICAgJyAgICBmaW5hbENvbG9yVjMgPSBmaW5hbENvbG9yVjMgKyBEX2NvbG9yO1xcbicgK1xyXG4gICAgICAgICAgICAnICB9ZWxzZXtcXG4nICtcclxuICAgICAgICAgICAgJyAgICBmaW5hbENvbG9yVjMgPSBEX2NvbG9yO1xcbicgK1xyXG4gICAgICAgICAgICAnICB9XFxuJyArXHJcbiAgICAgICAgICAgICcgIHVzZUxpZ2h0ID0gMS4wO1xcbicgK1xyXG4gICAgICAgICAgICAnI2VuZGlmXFxuJyArXHJcblxyXG4gICAgICAgICAgICAnI2lmZGVmIFVTRV9TQ29sb3JcXG4nICtcclxuICAgICAgICAgICAgJyAgdmVjMyByID0gbm9ybWFsaXplKCByZWZsZWN0KC11X0RpcmVjdGlvbmFsTGlnaHRfRGlyZWN0aW9uLCB2X05vcm1hbDApICk7XFxuJyArXHJcbiAgICAgICAgICAgICcgIHZlYzMgdiA9IG5vcm1hbGl6ZSggdV9DYW1lcmFfUG9zaXRpb24gLSB2X1Bvc2l0aW9uVjMgKTtcXG4nICtcclxuICAgICAgICAgICAgJyAgZmxvYXQgcmRvdHYgPSBtYXgoIGRvdChyICx2KSwgMC4wICk7XFxuJyArXHJcbiAgICAgICAgICAgICcgIGZsb2F0IFNfd2VpZ2h0ID0gcG93KCByZG90diwgMTAwLjAgKTtcXG4nICtcclxuICAgICAgICAgICAgJyAgdmVjMyBTX2NvbG9yID0gY29sb3JWMyAqIHVfRGlyZWN0aW9uYWxMaWdodF9Db2xvciAqIFNfd2VpZ2h0ICogdV9NZXRhbG5lc3M7XFxuJyArXHJcblxyXG4gICAgICAgICAgICAnICBpZih1c2VMaWdodD4wLjUpe1xcbicgK1xyXG4gICAgICAgICAgICAnICAgIGZpbmFsQ29sb3JWMyA9IGZpbmFsQ29sb3JWMyArIFNfY29sb3I7XFxuJyArXHJcbiAgICAgICAgICAgICcgIH1lbHNle1xcbicgK1xyXG4gICAgICAgICAgICAnICAgIGZpbmFsQ29sb3JWMyA9IFNfY29sb3I7XFxuJyArXHJcbiAgICAgICAgICAgICcgIH1cXG4nICtcclxuICAgICAgICAgICAgJyAgdXNlTGlnaHQgPSAxLjA7XFxuJyArXHJcbiAgICAgICAgICAgICcjZW5kaWZcXG4nICtcclxuXHJcbiAgICAgICAgICAgICcgIGNvbG9yID0gdmVjNChmaW5hbENvbG9yVjMsIGNvbG9yLmEpO1xcbicgK1xyXG5cclxuICAgICAgICAgICAgJyNpZmRlZiBVU0VfZW52TWFwXFxuJyArXHJcbiAgICAgICAgICAgIC8vICcgICB2ZWMzIHYxID0gbm9ybWFsaXplKCB1X0NhbWVyYV9Qb3NpdGlvbiAtIHZfUG9zaXRpb25WMyApO1xcbicgK1xyXG4gICAgICAgICAgICAvLyAnICAgdmVjMyByMSA9IG5vcm1hbGl6ZSggcmVmbGVjdCh2MSwgdl9Ob3JtYWwwKSApO1xcbicgK1xyXG4gICAgICAgICAgICAnICAgdmVjMyB2MSA9IHVfQ2FtZXJhX1Bvc2l0aW9uIC0gdl9Qb3NpdGlvblYzO1xcbicgK1xyXG4gICAgICAgICAgICAnICAgdmVjMyByMSA9IHJlZmxlY3QoLXYxLCB2X05vcm1hbDApO1xcbicgK1xyXG5cclxuICAgICAgICAgICAgJyAgIHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZSh1X2Vudk1hcCwgcjEpO1xcbicgK1xyXG4gICAgICAgICAgICAvLyAnICAgdmVjMyByZWYgPSB2MSAtIDIuMCAqIGRvdCh2X05vcm1hbDAsIHYxKSAqIHZfTm9ybWFsMDtcXG4nK1xyXG4gICAgICAgICAgICAvLyAnICAgdmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmVDdWJlKHVfZW52TWFwLCByZWYpO1xcbicgK1xyXG4gICAgICAgICAgICAnICAgY29sb3IgPSB2ZWM0KGVudk1hcENvbG9yLnJnYiwgY29sb3IuYSk7XFxuJyArXHJcbiAgICAgICAgICAgICcjZW5kaWZcXG4nICtcclxuXHJcblxyXG4gICAgICAgICAgICAnI2lmZGVmIFVTRV9TaGFkb3dcXG4nICtcclxuICAgICAgICAgICAgJyAgdmVjMyBzaGFkb3dDb29yZCA9ICh2X1Bvc2l0aW9uRnJvbUxpZ2h0Lnh5ei92X1Bvc2l0aW9uRnJvbUxpZ2h0LncpLzIuMCArIDAuNTtcXG4nICtcclxuICAgICAgICAgICAgJyAgdmVjNCByZ2JhRGVwdGggPSB0ZXh0dXJlMkQodV9TaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5KTtcXG4nICtcclxuICAgICAgICAgICAgJyAgZmxvYXQgZGVwdGggPSB1bnBhY2tEZXB0aChyZ2JhRGVwdGgpO1xcbicgK1xyXG4gICAgICAgICAgICAnICBmbG9hdCB2aXNpYmlsaXR5ID0gKHNoYWRvd0Nvb3JkLnogPiBkZXB0aCArIDAuMDAxNSkgPyAwLjcgOiAxLjA7XFxuJyArXHJcbiAgICAgICAgICAgICcgIGNvbG9yID0gdmVjNChjb2xvci5yZ2IgKiB2aXNpYmlsaXR5LCBjb2xvci5hKTtcXG4nICtcclxuICAgICAgICAgICAgJyNlbmRpZlxcbicgK1xyXG5cclxuICAgICAgICAgICAgJyAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXHJcblxyXG4gICAgICAgICAgICAnfVxcbic7XHJcblxyXG4gICAgICAgIHRoaXMudnNoYWRlclNvdXJjZSA9IFZTSEFERVJfU09VUkNFO1xyXG4gICAgICAgIHRoaXMuZnNoYWRlclNvdXJjZSA9IEZTSEFERVJfU09VUkNFO1xyXG4gICAgfVxyXG5cclxuICAgIHNldE9wYWNpdHkob3BhY2l0eSl7XHJcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuICAgICAgICB0aGlzLmNvbG9yWzNdID0gb3BhY2l0eTtcclxuICAgICAgICB0aGlzLnRyYW5zcGFyZW50ID0gb3BhY2l0eTwxO1xyXG4gICAgfVxyXG5cclxuICAgIGNsb25lKCl7XHJcblxyXG4gICAgICAgIHZhciBtYXRlcmlhbCA9IG5ldyBNYXRlcmlhbCh7XHJcbiAgICAgICAgICAgIG1hcDogdGhpcy5tYXAsXHJcbiAgICAgICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLnNsaWNlKDApXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBtYXRlcmlhbDtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1hdGVyaWFsO1xyXG4iLCJpbXBvcnQgeyBRdWF0ZXJuaW9uIH0gZnJvbSAnLi9RdWF0ZXJuaW9uLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4vVmVjdG9yMy5qcyc7XHJcbmltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuL01hdHJpeDQuanMnO1xyXG5pbXBvcnQgeyBfTWF0aCB9IGZyb20gJy4vTWF0aC5qcyc7XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICovXHJcblxyXG5mdW5jdGlvbiBFdWxlciggeCwgeSwgeiwgb3JkZXIgKSB7XHJcblxyXG5cdHRoaXMuX3ggPSB4IHx8IDA7XHJcblx0dGhpcy5feSA9IHkgfHwgMDtcclxuXHR0aGlzLl96ID0geiB8fCAwO1xyXG5cdHRoaXMuX29yZGVyID0gb3JkZXIgfHwgRXVsZXIuRGVmYXVsdE9yZGVyO1xyXG5cclxufVxyXG5cclxuRXVsZXIuUm90YXRpb25PcmRlcnMgPSBbICdYWVonLCAnWVpYJywgJ1pYWScsICdYWlknLCAnWVhaJywgJ1pZWCcgXTtcclxuXHJcbkV1bGVyLkRlZmF1bHRPcmRlciA9ICdYWVonO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEV1bGVyLnByb3RvdHlwZSwge1xyXG5cclxuXHR4OiB7XHJcblxyXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5feDtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdHRoaXMuX3ggPSB2YWx1ZTtcclxuXHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHR5OiB7XHJcblxyXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5feTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdHRoaXMuX3kgPSB2YWx1ZTtcclxuXHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHR6OiB7XHJcblxyXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5fejtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdHRoaXMuX3ogPSB2YWx1ZTtcclxuXHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRvcmRlcjoge1xyXG5cclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuX29yZGVyO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0dGhpcy5fb3JkZXIgPSB2YWx1ZTtcclxuXHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcblxyXG5PYmplY3QuYXNzaWduKCBFdWxlci5wcm90b3R5cGUsIHtcclxuXHJcblx0aXNFdWxlcjogdHJ1ZSxcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIHgsIHksIHosIG9yZGVyICkge1xyXG5cclxuXHRcdHRoaXMuX3ggPSB4O1xyXG5cdFx0dGhpcy5feSA9IHk7XHJcblx0XHR0aGlzLl96ID0gejtcclxuXHRcdHRoaXMuX29yZGVyID0gb3JkZXIgfHwgdGhpcy5fb3JkZXI7XHJcblxyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl9vcmRlciApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIGV1bGVyICkge1xyXG5cclxuXHRcdHRoaXMuX3ggPSBldWxlci5feDtcclxuXHRcdHRoaXMuX3kgPSBldWxlci5feTtcclxuXHRcdHRoaXMuX3ogPSBldWxlci5fejtcclxuXHRcdHRoaXMuX29yZGVyID0gZXVsZXIuX29yZGVyO1xyXG5cclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICggbSwgb3JkZXIsIHVwZGF0ZSApIHtcclxuXHJcblx0XHR2YXIgY2xhbXAgPSBfTWF0aC5jbGFtcDtcclxuXHJcblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxyXG5cclxuXHRcdHZhciB0ZSA9IG0uZWxlbWVudHM7XHJcblx0XHR2YXIgbTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXTtcclxuXHRcdHZhciBtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdO1xyXG5cdFx0dmFyIG0zMSA9IHRlWyAyIF0sIG0zMiA9IHRlWyA2IF0sIG0zMyA9IHRlWyAxMCBdO1xyXG5cclxuXHRcdG9yZGVyID0gb3JkZXIgfHwgdGhpcy5fb3JkZXI7XHJcblxyXG5cdFx0aWYgKCBvcmRlciA9PT0gJ1hZWicgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl95ID0gTWF0aC5hc2luKCBjbGFtcCggbTEzLCAtIDEsIDEgKSApO1xyXG5cclxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTEzICkgPCAwLjk5OTk5ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0zMyApO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTExICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcclxuXHRcdFx0XHR0aGlzLl96ID0gMDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1lYWicgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl94ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMjMsIC0gMSwgMSApICk7XHJcblxyXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBtMjMgKSA8IDAuOTk5OTkgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0zMyApO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0yMiApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMTEgKTtcclxuXHRcdFx0XHR0aGlzLl96ID0gMDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pYWScgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl94ID0gTWF0aC5hc2luKCBjbGFtcCggbTMyLCAtIDEsIDEgKSApO1xyXG5cclxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTMyICkgPCAwLjk5OTk5ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0zMyApO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTIyICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLl95ID0gMDtcclxuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMTEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pZWCcgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl95ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMzEsIC0gMSwgMSApICk7XHJcblxyXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBtMzEgKSA8IDAuOTk5OTkgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0zMyApO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0xMSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feCA9IDA7XHJcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMjIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1laWCcgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl96ID0gTWF0aC5hc2luKCBjbGFtcCggbTIxLCAtIDEsIDEgKSApO1xyXG5cclxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTIxICkgPCAwLjk5OTk5ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0yMiApO1xyXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTExICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLl94ID0gMDtcclxuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1haWScgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl96ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMTIsIC0gMSwgMSApICk7XHJcblxyXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBtMTIgKSA8IDAuOTk5OTkgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0yMiApO1xyXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0xMSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMzMgKTtcclxuXHRcdFx0XHR0aGlzLl95ID0gMDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5FdWxlcjogLnNldEZyb21Sb3RhdGlvbk1hdHJpeCgpIGdpdmVuIHVuc3VwcG9ydGVkIG9yZGVyOiAnICsgb3JkZXIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlcjtcclxuXHJcblx0XHRpZiAoIHVwZGF0ZSAhPT0gZmFsc2UgKSB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gc2V0RnJvbVF1YXRlcm5pb24oIHEsIG9yZGVyLCB1cGRhdGUgKSB7XHJcblxyXG5cdFx0XHRtYXRyaXgubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbWF0cml4LCBvcmRlciwgdXBkYXRlICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRzZXRGcm9tVmVjdG9yMzogZnVuY3Rpb24gKCB2LCBvcmRlciApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zZXQoIHYueCwgdi55LCB2LnosIG9yZGVyIHx8IHRoaXMuX29yZGVyICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJlb3JkZXI6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyBXQVJOSU5HOiB0aGlzIGRpc2NhcmRzIHJldm9sdXRpb24gaW5mb3JtYXRpb24gLWJob3VzdG9uXHJcblxyXG5cdFx0dmFyIHEgPSBuZXcgUXVhdGVybmlvbigpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiByZW9yZGVyKCBuZXdPcmRlciApIHtcclxuXHJcblx0XHRcdHEuc2V0RnJvbUV1bGVyKCB0aGlzICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tUXVhdGVybmlvbiggcSwgbmV3T3JkZXIgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCBldWxlciApIHtcclxuXHJcblx0XHRyZXR1cm4gKCBldWxlci5feCA9PT0gdGhpcy5feCApICYmICggZXVsZXIuX3kgPT09IHRoaXMuX3kgKSAmJiAoIGV1bGVyLl96ID09PSB0aGlzLl96ICkgJiYgKCBldWxlci5fb3JkZXIgPT09IHRoaXMuX29yZGVyICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcclxuXHJcblx0XHR0aGlzLl94ID0gYXJyYXlbIDAgXTtcclxuXHRcdHRoaXMuX3kgPSBhcnJheVsgMSBdO1xyXG5cdFx0dGhpcy5feiA9IGFycmF5WyAyIF07XHJcblx0XHRpZiAoIGFycmF5WyAzIF0gIT09IHVuZGVmaW5lZCApIHRoaXMuX29yZGVyID0gYXJyYXlbIDMgXTtcclxuXHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XHJcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLl94O1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuX3k7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5fejtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLl9vcmRlcjtcclxuXHJcblx0XHRyZXR1cm4gYXJyYXk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvVmVjdG9yMzogZnVuY3Rpb24gKCBvcHRpb25hbFJlc3VsdCApIHtcclxuXHJcblx0XHRpZiAoIG9wdGlvbmFsUmVzdWx0ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIG9wdGlvbmFsUmVzdWx0LnNldCggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbmV3IFZlY3RvcjMoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3ogKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdG9uQ2hhbmdlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xyXG5cclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRvbkNoYW5nZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7fVxyXG5cclxufSApO1xyXG5cclxuXHJcbmV4cG9ydCB7IEV1bGVyIH07XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xyXG4gKiBAYXV0aG9yIGVncmFldGhlciAvIGh0dHA6Ly9lZ3JhZXRoZXIuY29tL1xyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gVmVjdG9yMiggeCwgeSApIHtcclxuXHJcblx0dGhpcy54ID0geCB8fCAwO1xyXG5cdHRoaXMueSA9IHkgfHwgMDtcclxuXHJcbn1cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWZWN0b3IyLnByb3RvdHlwZSwge1xyXG5cclxuXHRcIndpZHRoXCI6IHtcclxuXHJcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLng7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSB2YWx1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdFwiaGVpZ2h0XCI6IHtcclxuXHJcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLnk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnkgPSB2YWx1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuXHJcbk9iamVjdC5hc3NpZ24oIFZlY3RvcjIucHJvdG90eXBlLCB7XHJcblxyXG5cdGlzVmVjdG9yMjogdHJ1ZSxcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIHgsIHkgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0geDtcclxuXHRcdHRoaXMueSA9IHk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gc2NhbGFyO1xyXG5cdFx0dGhpcy55ID0gc2NhbGFyO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRYOiBmdW5jdGlvbiAoIHggKSB7XHJcblxyXG5cdFx0dGhpcy54ID0geDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WTogZnVuY3Rpb24gKCB5ICkge1xyXG5cclxuXHRcdHRoaXMueSA9IHk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCwgdmFsdWUgKSB7XHJcblxyXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XHJcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRjYXNlIDA6IHJldHVybiB0aGlzLng7XHJcblx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcclxuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gdi54O1xyXG5cdFx0dGhpcy55ID0gdi55O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGQ6IGZ1bmN0aW9uICggdiwgdyApIHtcclxuXHJcblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ0NPT0wuVmVjdG9yMjogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnggKz0gdi54O1xyXG5cdFx0dGhpcy55ICs9IHYueTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9IHM7XHJcblx0XHR0aGlzLnkgKz0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHRoaXMueCA9IGEueCArIGIueDtcclxuXHRcdHRoaXMueSA9IGEueSArIGIueTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkU2NhbGVkVmVjdG9yOiBmdW5jdGlvbiAoIHYsIHMgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9IHYueCAqIHM7XHJcblx0XHR0aGlzLnkgKz0gdi55ICogcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c3ViOiBmdW5jdGlvbiAoIHYsIHcgKSB7XHJcblxyXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdDT09MLlZlY3RvcjI6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYsIHcgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy54IC09IHYueDtcclxuXHRcdHRoaXMueSAtPSB2Lnk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHN1YlNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMueCAtPSBzO1xyXG5cdFx0dGhpcy55IC09IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHN1YlZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBhLnggLSBiLng7XHJcblx0XHR0aGlzLnkgPSBhLnkgLSBiLnk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0dGhpcy54ICo9IHYueDtcclxuXHRcdHRoaXMueSAqPSB2Lnk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcclxuXHJcblx0XHR0aGlzLnggKj0gc2NhbGFyO1xyXG5cdFx0dGhpcy55ICo9IHNjYWxhcjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZGl2aWRlOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0dGhpcy54IC89IHYueDtcclxuXHRcdHRoaXMueSAvPSB2Lnk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpdmlkZVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBzY2FsYXIgKTtcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlNYXRyaXgzOiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnk7XHJcblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XHJcblxyXG5cdFx0dGhpcy54ID0gZVsgMCBdICogeCArIGVbIDMgXSAqIHkgKyBlWyA2IF07XHJcblx0XHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDcgXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWluOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5taW4oIHRoaXMueCwgdi54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLm1pbiggdGhpcy55LCB2LnkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWF4OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIHRoaXMueCwgdi54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggdGhpcy55LCB2LnkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG5cdFx0Ly8gYXNzdW1lcyBtaW4gPCBtYXgsIGNvbXBvbmVudHdpc2VcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLm1heCggbWluLngsIE1hdGgubWluKCBtYXgueCwgdGhpcy54ICkgKTtcclxuXHRcdHRoaXMueSA9IE1hdGgubWF4KCBtaW4ueSwgTWF0aC5taW4oIG1heC55LCB0aGlzLnkgKSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbGFtcFNjYWxhcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBtaW4gPSBuZXcgVmVjdG9yMigpO1xyXG5cdFx0dmFyIG1heCA9IG5ldyBWZWN0b3IyKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNsYW1wU2NhbGFyKCBtaW5WYWwsIG1heFZhbCApIHtcclxuXHJcblx0XHRcdG1pbi5zZXQoIG1pblZhbCwgbWluVmFsICk7XHJcblx0XHRcdG1heC5zZXQoIG1heFZhbCwgbWF4VmFsICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5jbGFtcCggbWluLCBtYXggKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGNsYW1wTGVuZ3RoOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xyXG5cclxuXHRcdHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggbGVuZ3RoIHx8IDEgKS5tdWx0aXBseVNjYWxhciggTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgbGVuZ3RoICkgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmbG9vcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNlaWw6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5jZWlsKCB0aGlzLnkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKCB0aGlzLnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyb3VuZFRvWmVybzogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9ICggdGhpcy54IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnggKSA6IE1hdGguZmxvb3IoIHRoaXMueCApO1xyXG5cdFx0dGhpcy55ID0gKCB0aGlzLnkgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueSApIDogTWF0aC5mbG9vciggdGhpcy55ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IC0gdGhpcy54O1xyXG5cdFx0dGhpcy55ID0gLSB0aGlzLnk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRvdDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2Lnk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNyb3NzOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMueCAqIHYueSAtIHRoaXMueSAqIHYueDtcclxuXHJcblx0fSxcclxuXHJcblx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55O1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bWFuaGF0dGFuTGVuZ3RoOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpIHx8IDEgKTtcclxuXHJcblx0fSxcclxuXHJcblx0YW5nbGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyBjb21wdXRlcyB0aGUgYW5nbGUgaW4gcmFkaWFucyB3aXRoIHJlc3BlY3QgdG8gdGhlIHBvc2l0aXZlIHgtYXhpc1xyXG5cclxuXHRcdHZhciBhbmdsZSA9IE1hdGguYXRhbjIoIHRoaXMueSwgdGhpcy54ICk7XHJcblxyXG5cdFx0aWYgKCBhbmdsZSA8IDAgKSBhbmdsZSArPSAyICogTWF0aC5QSTtcclxuXHJcblx0XHRyZXR1cm4gYW5nbGU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKCB2ICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUb1NxdWFyZWQ6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR2YXIgZHggPSB0aGlzLnggLSB2LngsIGR5ID0gdGhpcy55IC0gdi55O1xyXG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYW5oYXR0YW5EaXN0YW5jZVRvOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggLSB2LnggKSArIE1hdGguYWJzKCB0aGlzLnkgLSB2LnkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0TGVuZ3RoOiBmdW5jdGlvbiAoIGxlbmd0aCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggbGVuZ3RoICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlcnA6IGZ1bmN0aW9uICggdiwgYWxwaGEgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcclxuXHRcdHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlcnBWZWN0b3JzOiBmdW5jdGlvbiAoIHYxLCB2MiwgYWxwaGEgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdjIsIHYxICkubXVsdGlwbHlTY2FsYXIoIGFscGhhICkuYWRkKCB2MSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRyZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcclxuXHRcdHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xyXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcclxuXHJcblx0XHRyZXR1cm4gYXJyYXk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21CdWZmZXJBdHRyaWJ1dGU6IGZ1bmN0aW9uICggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGlmICggb2Zmc2V0ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdDT09MLlZlY3RvcjI6IG9mZnNldCBoYXMgYmVlbiByZW1vdmVkIGZyb20gLmZyb21CdWZmZXJBdHRyaWJ1dGUoKS4nICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMueCA9IGF0dHJpYnV0ZS5nZXRYKCBpbmRleCApO1xyXG5cdFx0dGhpcy55ID0gYXR0cmlidXRlLmdldFkoIGluZGV4ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdGF0ZUFyb3VuZDogZnVuY3Rpb24gKCBjZW50ZXIsIGFuZ2xlICkge1xyXG5cclxuXHRcdHZhciBjID0gTWF0aC5jb3MoIGFuZ2xlICksIHMgPSBNYXRoLnNpbiggYW5nbGUgKTtcclxuXHJcblx0XHR2YXIgeCA9IHRoaXMueCAtIGNlbnRlci54O1xyXG5cdFx0dmFyIHkgPSB0aGlzLnkgLSBjZW50ZXIueTtcclxuXHJcblx0XHR0aGlzLnggPSB4ICogYyAtIHkgKiBzICsgY2VudGVyLng7XHJcblx0XHR0aGlzLnkgPSB4ICogcyArIHkgKiBjICsgY2VudGVyLnk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuXHJcblxyXG5leHBvcnQgeyBWZWN0b3IyIH07XHJcbiIsImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuL1ZlY3RvcjMuanMnO1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICovXHJcblxyXG5mdW5jdGlvbiBSYXkoIG9yaWdpbiwgZGlyZWN0aW9uICkge1xyXG5cclxuXHR0aGlzLm9yaWdpbiA9ICggb3JpZ2luICE9PSB1bmRlZmluZWQgKSA/IG9yaWdpbiA6IG5ldyBWZWN0b3IzKCk7XHJcblx0dGhpcy5kaXJlY3Rpb24gPSAoIGRpcmVjdGlvbiAhPT0gdW5kZWZpbmVkICkgPyBkaXJlY3Rpb24gOiBuZXcgVmVjdG9yMygpO1xyXG5cclxufVxyXG5cclxuT2JqZWN0LmFzc2lnbiggUmF5LnByb3RvdHlwZSwge1xyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XHJcblxyXG5cdFx0dGhpcy5vcmlnaW4uY29weSggb3JpZ2luICk7XHJcblx0XHR0aGlzLmRpcmVjdGlvbi5jb3B5KCBkaXJlY3Rpb24gKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggcmF5ICkge1xyXG5cclxuXHRcdHRoaXMub3JpZ2luLmNvcHkoIHJheS5vcmlnaW4gKTtcclxuXHRcdHRoaXMuZGlyZWN0aW9uLmNvcHkoIHJheS5kaXJlY3Rpb24gKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YXQ6IGZ1bmN0aW9uICggdCwgdGFyZ2V0ICkge1xyXG5cclxuXHRcdGlmICggdGFyZ2V0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdDT09MLlJheTogLmF0KCkgdGFyZ2V0IGlzIG5vdyByZXF1aXJlZCcgKTtcclxuXHRcdFx0dGFyZ2V0ID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldC5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLm9yaWdpbiApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsb29rQXQ6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR0aGlzLmRpcmVjdGlvbi5jb3B5KCB2ICkuc3ViKCB0aGlzLm9yaWdpbiApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyZWNhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiByZWNhc3QoIHQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm9yaWdpbi5jb3B5KCB0aGlzLmF0KCB0LCB2MSApICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGNsb3Nlc3RQb2ludFRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIHRhcmdldCApIHtcclxuXHJcblx0XHRpZiAoIHRhcmdldCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5SYXk6IC5jbG9zZXN0UG9pbnRUb1BvaW50KCkgdGFyZ2V0IGlzIG5vdyByZXF1aXJlZCcgKTtcclxuXHRcdFx0dGFyZ2V0ID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGFyZ2V0LnN1YlZlY3RvcnMoIHBvaW50LCB0aGlzLm9yaWdpbiApO1xyXG5cclxuXHRcdHZhciBkaXJlY3Rpb25EaXN0YW5jZSA9IHRhcmdldC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XHJcblxyXG5cdFx0aWYgKCBkaXJlY3Rpb25EaXN0YW5jZSA8IDAgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIHRoaXMub3JpZ2luICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0YXJnZXQuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggZGlyZWN0aW9uRGlzdGFuY2UgKS5hZGQoIHRoaXMub3JpZ2luICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlU3FUb1BvaW50KCBwb2ludCApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3RhbmNlU3FUb1BvaW50OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gZGlzdGFuY2VTcVRvUG9pbnQoIHBvaW50ICkge1xyXG5cclxuXHRcdFx0dmFyIGRpcmVjdGlvbkRpc3RhbmNlID0gdjEuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMub3JpZ2luICkuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xyXG5cclxuXHRcdFx0Ly8gcG9pbnQgYmVoaW5kIHRoZSByYXlcclxuXHJcblx0XHRcdGlmICggZGlyZWN0aW9uRGlzdGFuY2UgPCAwICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5vcmlnaW4uZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2MS5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCBkaXJlY3Rpb25EaXN0YW5jZSApLmFkZCggdGhpcy5vcmlnaW4gKTtcclxuXHJcblx0XHRcdHJldHVybiB2MS5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGRpc3RhbmNlU3FUb1NlZ21lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgc2VnQ2VudGVyID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHZhciBzZWdEaXIgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0dmFyIGRpZmYgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBkaXN0YW5jZVNxVG9TZWdtZW50KCB2MCwgdjEsIG9wdGlvbmFsUG9pbnRPblJheSwgb3B0aW9uYWxQb2ludE9uU2VnbWVudCApIHtcclxuXHJcblx0XHRcdC8vIGZyb20gaHR0cDovL3d3dy5nZW9tZXRyaWN0b29scy5jb20vR1RFbmdpbmUvSW5jbHVkZS9NYXRoZW1hdGljcy9HdGVEaXN0UmF5U2VnbWVudC5oXHJcblx0XHRcdC8vIEl0IHJldHVybnMgdGhlIG1pbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZSByYXkgYW5kIHRoZSBzZWdtZW50XHJcblx0XHRcdC8vIGRlZmluZWQgYnkgdjAgYW5kIHYxXHJcblx0XHRcdC8vIEl0IGNhbiBhbHNvIHNldCB0d28gb3B0aW9uYWwgdGFyZ2V0cyA6XHJcblx0XHRcdC8vIC0gVGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIHJheVxyXG5cdFx0XHQvLyAtIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBzZWdtZW50XHJcblxyXG5cdFx0XHRzZWdDZW50ZXIuY29weSggdjAgKS5hZGQoIHYxICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG5cdFx0XHRzZWdEaXIuY29weSggdjEgKS5zdWIoIHYwICkubm9ybWFsaXplKCk7XHJcblx0XHRcdGRpZmYuY29weSggdGhpcy5vcmlnaW4gKS5zdWIoIHNlZ0NlbnRlciApO1xyXG5cclxuXHRcdFx0dmFyIHNlZ0V4dGVudCA9IHYwLmRpc3RhbmNlVG8oIHYxICkgKiAwLjU7XHJcblx0XHRcdHZhciBhMDEgPSAtIHRoaXMuZGlyZWN0aW9uLmRvdCggc2VnRGlyICk7XHJcblx0XHRcdHZhciBiMCA9IGRpZmYuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xyXG5cdFx0XHR2YXIgYjEgPSAtIGRpZmYuZG90KCBzZWdEaXIgKTtcclxuXHRcdFx0dmFyIGMgPSBkaWZmLmxlbmd0aFNxKCk7XHJcblx0XHRcdHZhciBkZXQgPSBNYXRoLmFicyggMSAtIGEwMSAqIGEwMSApO1xyXG5cdFx0XHR2YXIgczAsIHMxLCBzcXJEaXN0LCBleHREZXQ7XHJcblxyXG5cdFx0XHRpZiAoIGRldCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdC8vIFRoZSByYXkgYW5kIHNlZ21lbnQgYXJlIG5vdCBwYXJhbGxlbC5cclxuXHJcblx0XHRcdFx0czAgPSBhMDEgKiBiMSAtIGIwO1xyXG5cdFx0XHRcdHMxID0gYTAxICogYjAgLSBiMTtcclxuXHRcdFx0XHRleHREZXQgPSBzZWdFeHRlbnQgKiBkZXQ7XHJcblxyXG5cdFx0XHRcdGlmICggczAgPj0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHMxID49IC0gZXh0RGV0ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBzMSA8PSBleHREZXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIHJlZ2lvbiAwXHJcblx0XHRcdFx0XHRcdFx0Ly8gTWluaW11bSBhdCBpbnRlcmlvciBwb2ludHMgb2YgcmF5IGFuZCBzZWdtZW50LlxyXG5cclxuXHRcdFx0XHRcdFx0XHR2YXIgaW52RGV0ID0gMSAvIGRldDtcclxuXHRcdFx0XHRcdFx0XHRzMCAqPSBpbnZEZXQ7XHJcblx0XHRcdFx0XHRcdFx0czEgKj0gaW52RGV0O1xyXG5cdFx0XHRcdFx0XHRcdHNxckRpc3QgPSBzMCAqICggczAgKyBhMDEgKiBzMSArIDIgKiBiMCApICsgczEgKiAoIGEwMSAqIHMwICsgczEgKyAyICogYjEgKSArIGM7XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHQvLyByZWdpb24gMVxyXG5cclxuXHRcdFx0XHRcdFx0XHRzMSA9IHNlZ0V4dGVudDtcclxuXHRcdFx0XHRcdFx0XHRzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogczEgKyBiMCApICk7XHJcblx0XHRcdFx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDVcclxuXHJcblx0XHRcdFx0XHRcdHMxID0gLSBzZWdFeHRlbnQ7XHJcblx0XHRcdFx0XHRcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzMSArIGIwICkgKTtcclxuXHRcdFx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBzMSA8PSAtIGV4dERldCApIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIHJlZ2lvbiA0XHJcblxyXG5cdFx0XHRcdFx0XHRzMCA9IE1hdGgubWF4KCAwLCAtICggLSBhMDEgKiBzZWdFeHRlbnQgKyBiMCApICk7XHJcblx0XHRcdFx0XHRcdHMxID0gKCBzMCA+IDAgKSA/IC0gc2VnRXh0ZW50IDogTWF0aC5taW4oIE1hdGgubWF4KCAtIHNlZ0V4dGVudCwgLSBiMSApLCBzZWdFeHRlbnQgKTtcclxuXHRcdFx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBzMSA8PSBleHREZXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyByZWdpb24gM1xyXG5cclxuXHRcdFx0XHRcdFx0czAgPSAwO1xyXG5cdFx0XHRcdFx0XHRzMSA9IE1hdGgubWluKCBNYXRoLm1heCggLSBzZWdFeHRlbnQsIC0gYjEgKSwgc2VnRXh0ZW50ICk7XHJcblx0XHRcdFx0XHRcdHNxckRpc3QgPSBzMSAqICggczEgKyAyICogYjEgKSArIGM7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIHJlZ2lvbiAyXHJcblxyXG5cdFx0XHRcdFx0XHRzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogc2VnRXh0ZW50ICsgYjAgKSApO1xyXG5cdFx0XHRcdFx0XHRzMSA9ICggczAgPiAwICkgPyBzZWdFeHRlbnQgOiBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xyXG5cdFx0XHRcdFx0XHRzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gUmF5IGFuZCBzZWdtZW50IGFyZSBwYXJhbGxlbC5cclxuXHJcblx0XHRcdFx0czEgPSAoIGEwMSA+IDAgKSA/IC0gc2VnRXh0ZW50IDogc2VnRXh0ZW50O1xyXG5cdFx0XHRcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzMSArIGIwICkgKTtcclxuXHRcdFx0XHRzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBvcHRpb25hbFBvaW50T25SYXkgKSB7XHJcblxyXG5cdFx0XHRcdG9wdGlvbmFsUG9pbnRPblJheS5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCBzMCApLmFkZCggdGhpcy5vcmlnaW4gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggb3B0aW9uYWxQb2ludE9uU2VnbWVudCApIHtcclxuXHJcblx0XHRcdFx0b3B0aW9uYWxQb2ludE9uU2VnbWVudC5jb3B5KCBzZWdEaXIgKS5tdWx0aXBseVNjYWxhciggczEgKS5hZGQoIHNlZ0NlbnRlciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHNxckRpc3Q7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRpbnRlcnNlY3RTcGhlcmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RTcGhlcmUoIHNwaGVyZSwgdGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0djEuc3ViVmVjdG9ycyggc3BoZXJlLmNlbnRlciwgdGhpcy5vcmlnaW4gKTtcclxuXHRcdFx0dmFyIHRjYSA9IHYxLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcclxuXHRcdFx0dmFyIGQyID0gdjEuZG90KCB2MSApIC0gdGNhICogdGNhO1xyXG5cdFx0XHR2YXIgcmFkaXVzMiA9IHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzO1xyXG5cclxuXHRcdFx0aWYgKCBkMiA+IHJhZGl1czIgKSByZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdHZhciB0aGMgPSBNYXRoLnNxcnQoIHJhZGl1czIgLSBkMiApO1xyXG5cclxuXHRcdFx0Ly8gdDAgPSBmaXJzdCBpbnRlcnNlY3QgcG9pbnQgLSBlbnRyYW5jZSBvbiBmcm9udCBvZiBzcGhlcmVcclxuXHRcdFx0dmFyIHQwID0gdGNhIC0gdGhjO1xyXG5cclxuXHRcdFx0Ly8gdDEgPSBzZWNvbmQgaW50ZXJzZWN0IHBvaW50IC0gZXhpdCBwb2ludCBvbiBiYWNrIG9mIHNwaGVyZVxyXG5cdFx0XHR2YXIgdDEgPSB0Y2EgKyB0aGM7XHJcblxyXG5cdFx0XHQvLyB0ZXN0IHRvIHNlZSBpZiBib3RoIHQwIGFuZCB0MSBhcmUgYmVoaW5kIHRoZSByYXkgLSBpZiBzbywgcmV0dXJuIG51bGxcclxuXHRcdFx0aWYgKCB0MCA8IDAgJiYgdDEgPCAwICkgcmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHQvLyB0ZXN0IHRvIHNlZSBpZiB0MCBpcyBiZWhpbmQgdGhlIHJheTpcclxuXHRcdFx0Ly8gaWYgaXQgaXMsIHRoZSByYXkgaXMgaW5zaWRlIHRoZSBzcGhlcmUsIHNvIHJldHVybiB0aGUgc2Vjb25kIGV4aXQgcG9pbnQgc2NhbGVkIGJ5IHQxLFxyXG5cdFx0XHQvLyBpbiBvcmRlciB0byBhbHdheXMgcmV0dXJuIGFuIGludGVyc2VjdCBwb2ludCB0aGF0IGlzIGluIGZyb250IG9mIHRoZSByYXkuXHJcblx0XHRcdGlmICggdDAgPCAwICkgcmV0dXJuIHRoaXMuYXQoIHQxLCB0YXJnZXQgKTtcclxuXHJcblx0XHRcdC8vIGVsc2UgdDAgaXMgaW4gZnJvbnQgb2YgdGhlIHJheSwgc28gcmV0dXJuIHRoZSBmaXJzdCBjb2xsaXNpb24gcG9pbnQgc2NhbGVkIGJ5IHQwXHJcblx0XHRcdHJldHVybiB0aGlzLmF0KCB0MCwgdGFyZ2V0ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5kaXN0YW5jZVNxVG9Qb2ludCggc3BoZXJlLmNlbnRlciApIDw9ICggc3BoZXJlLnJhZGl1cyAqIHNwaGVyZS5yYWRpdXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUb1BsYW5lOiBmdW5jdGlvbiAoIHBsYW5lICkge1xyXG5cclxuXHRcdHZhciBkZW5vbWluYXRvciA9IHBsYW5lLm5vcm1hbC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XHJcblxyXG5cdFx0aWYgKCBkZW5vbWluYXRvciA9PT0gMCApIHtcclxuXHJcblx0XHRcdC8vIGxpbmUgaXMgY29wbGFuYXIsIHJldHVybiBvcmlnaW5cclxuXHRcdFx0aWYgKCBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHRoaXMub3JpZ2luICkgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiAwO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gTnVsbCBpcyBwcmVmZXJhYmxlIHRvIHVuZGVmaW5lZCBzaW5jZSB1bmRlZmluZWQgbWVhbnMuLi4uIGl0IGlzIHVuZGVmaW5lZFxyXG5cclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0ID0gLSAoIHRoaXMub3JpZ2luLmRvdCggcGxhbmUubm9ybWFsICkgKyBwbGFuZS5jb25zdGFudCApIC8gZGVub21pbmF0b3I7XHJcblxyXG5cdFx0Ly8gUmV0dXJuIGlmIHRoZSByYXkgbmV2ZXIgaW50ZXJzZWN0cyB0aGUgcGxhbmVcclxuXHJcblx0XHRyZXR1cm4gdCA+PSAwID8gdCA6IG51bGw7XHJcblxyXG5cdH0sXHJcblxyXG5cdGludGVyc2VjdFBsYW5lOiBmdW5jdGlvbiAoIHBsYW5lLCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHQgPSB0aGlzLmRpc3RhbmNlVG9QbGFuZSggcGxhbmUgKTtcclxuXHJcblx0XHRpZiAoIHQgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYXQoIHQsIHRhcmdldCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbnRlcnNlY3RzUGxhbmU6IGZ1bmN0aW9uICggcGxhbmUgKSB7XHJcblxyXG5cdFx0Ly8gY2hlY2sgaWYgdGhlIHJheSBsaWVzIG9uIHRoZSBwbGFuZSBmaXJzdFxyXG5cclxuXHRcdHZhciBkaXN0VG9Qb2ludCA9IHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggdGhpcy5vcmlnaW4gKTtcclxuXHJcblx0XHRpZiAoIGRpc3RUb1BvaW50ID09PSAwICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBkZW5vbWluYXRvciA9IHBsYW5lLm5vcm1hbC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XHJcblxyXG5cdFx0aWYgKCBkZW5vbWluYXRvciAqIGRpc3RUb1BvaW50IDwgMCApIHtcclxuXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyByYXkgb3JpZ2luIGlzIGJlaGluZCB0aGUgcGxhbmUgKGFuZCBpcyBwb2ludGluZyBiZWhpbmQgaXQpXHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbnRlcnNlY3RCb3g6IGZ1bmN0aW9uICggYm94LCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHRtaW4sIHRtYXgsIHR5bWluLCB0eW1heCwgdHptaW4sIHR6bWF4O1xyXG5cclxuXHRcdHZhciBpbnZkaXJ4ID0gMSAvIHRoaXMuZGlyZWN0aW9uLngsXHJcblx0XHRcdGludmRpcnkgPSAxIC8gdGhpcy5kaXJlY3Rpb24ueSxcclxuXHRcdFx0aW52ZGlyeiA9IDEgLyB0aGlzLmRpcmVjdGlvbi56O1xyXG5cclxuXHRcdHZhciBvcmlnaW4gPSB0aGlzLm9yaWdpbjtcclxuXHJcblx0XHRpZiAoIGludmRpcnggPj0gMCApIHtcclxuXHJcblx0XHRcdHRtaW4gPSAoIGJveC5taW4ueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xyXG5cdFx0XHR0bWF4ID0gKCBib3gubWF4LnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dG1pbiA9ICggYm94Lm1heC54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XHJcblx0XHRcdHRtYXggPSAoIGJveC5taW4ueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGludmRpcnkgPj0gMCApIHtcclxuXHJcblx0XHRcdHR5bWluID0gKCBib3gubWluLnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcclxuXHRcdFx0dHltYXggPSAoIGJveC5tYXgueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0eW1pbiA9ICggYm94Lm1heC55IC0gb3JpZ2luLnkgKSAqIGludmRpcnk7XHJcblx0XHRcdHR5bWF4ID0gKCBib3gubWluLnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCAoIHRtaW4gPiB0eW1heCApIHx8ICggdHltaW4gPiB0bWF4ICkgKSByZXR1cm4gbnVsbDtcclxuXHJcblx0XHQvLyBUaGVzZSBsaW5lcyBhbHNvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0bWluIG9yIHRtYXggaXMgTmFOXHJcblx0XHQvLyAocmVzdWx0IG9mIDAgKiBJbmZpbml0eSkuIHggIT09IHggcmV0dXJucyB0cnVlIGlmIHggaXMgTmFOXHJcblxyXG5cdFx0aWYgKCB0eW1pbiA+IHRtaW4gfHwgdG1pbiAhPT0gdG1pbiApIHRtaW4gPSB0eW1pbjtcclxuXHJcblx0XHRpZiAoIHR5bWF4IDwgdG1heCB8fCB0bWF4ICE9PSB0bWF4ICkgdG1heCA9IHR5bWF4O1xyXG5cclxuXHRcdGlmICggaW52ZGlyeiA+PSAwICkge1xyXG5cclxuXHRcdFx0dHptaW4gPSAoIGJveC5taW4ueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xyXG5cdFx0XHR0em1heCA9ICggYm94Lm1heC56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHR6bWluID0gKCBib3gubWF4LnogLSBvcmlnaW4ueiApICogaW52ZGlyejtcclxuXHRcdFx0dHptYXggPSAoIGJveC5taW4ueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoICggdG1pbiA+IHR6bWF4ICkgfHwgKCB0em1pbiA+IHRtYXggKSApIHJldHVybiBudWxsO1xyXG5cclxuXHRcdGlmICggdHptaW4gPiB0bWluIHx8IHRtaW4gIT09IHRtaW4gKSB0bWluID0gdHptaW47XHJcblxyXG5cdFx0aWYgKCB0em1heCA8IHRtYXggfHwgdG1heCAhPT0gdG1heCApIHRtYXggPSB0em1heDtcclxuXHJcblx0XHQvL3JldHVybiBwb2ludCBjbG9zZXN0IHRvIHRoZSByYXkgKHBvc2l0aXZlIHNpZGUpXHJcblxyXG5cdFx0aWYgKCB0bWF4IDwgMCApIHJldHVybiBudWxsO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmF0KCB0bWluID49IDAgPyB0bWluIDogdG1heCwgdGFyZ2V0ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGludGVyc2VjdHNCb3g6ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2ID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0c0JveCggYm94ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0Qm94KCBib3gsIHYgKSAhPT0gbnVsbDtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9ICkoKSxcclxuXHJcblx0aW50ZXJzZWN0VHJpYW5nbGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyBDb21wdXRlIHRoZSBvZmZzZXQgb3JpZ2luLCBlZGdlcywgYW5kIG5vcm1hbC5cclxuXHRcdHZhciBkaWZmID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHZhciBlZGdlMSA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHR2YXIgZWRnZTIgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0dmFyIG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdFRyaWFuZ2xlKCBhLCBiLCBjLCBiYWNrZmFjZUN1bGxpbmcsIHRhcmdldCApIHtcclxuXHJcblx0XHRcdC8vIGZyb20gaHR0cDovL3d3dy5nZW9tZXRyaWN0b29scy5jb20vR1RFbmdpbmUvSW5jbHVkZS9NYXRoZW1hdGljcy9HdGVJbnRyUmF5M1RyaWFuZ2xlMy5oXHJcblxyXG5cdFx0XHRlZGdlMS5zdWJWZWN0b3JzKCBiLCBhICk7XHJcblx0XHRcdGVkZ2UyLnN1YlZlY3RvcnMoIGMsIGEgKTtcclxuXHRcdFx0bm9ybWFsLmNyb3NzVmVjdG9ycyggZWRnZTEsIGVkZ2UyICk7XHJcblxyXG5cdFx0XHQvLyBTb2x2ZSBRICsgdCpEID0gYjEqRTEgKyBiMipFMiAoUSA9IGtEaWZmLCBEID0gcmF5IGRpcmVjdGlvbixcclxuXHRcdFx0Ly8gRTEgPSBrRWRnZTEsIEUyID0ga0VkZ2UyLCBOID0gQ3Jvc3MoRTEsRTIpKSBieVxyXG5cdFx0XHQvLyAgIHxEb3QoRCxOKXwqYjEgPSBzaWduKERvdChELE4pKSpEb3QoRCxDcm9zcyhRLEUyKSlcclxuXHRcdFx0Ly8gICB8RG90KEQsTil8KmIyID0gc2lnbihEb3QoRCxOKSkqRG90KEQsQ3Jvc3MoRTEsUSkpXHJcblx0XHRcdC8vICAgfERvdChELE4pfCp0ID0gLXNpZ24oRG90KEQsTikpKkRvdChRLE4pXHJcblx0XHRcdHZhciBEZE4gPSB0aGlzLmRpcmVjdGlvbi5kb3QoIG5vcm1hbCApO1xyXG5cdFx0XHR2YXIgc2lnbjtcclxuXHJcblx0XHRcdGlmICggRGROID4gMCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBiYWNrZmFjZUN1bGxpbmcgKSByZXR1cm4gbnVsbDtcclxuXHRcdFx0XHRzaWduID0gMTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIERkTiA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdHNpZ24gPSAtIDE7XHJcblx0XHRcdFx0RGROID0gLSBEZE47XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGRpZmYuc3ViVmVjdG9ycyggdGhpcy5vcmlnaW4sIGEgKTtcclxuXHRcdFx0dmFyIERkUXhFMiA9IHNpZ24gKiB0aGlzLmRpcmVjdGlvbi5kb3QoIGVkZ2UyLmNyb3NzVmVjdG9ycyggZGlmZiwgZWRnZTIgKSApO1xyXG5cclxuXHRcdFx0Ly8gYjEgPCAwLCBubyBpbnRlcnNlY3Rpb25cclxuXHRcdFx0aWYgKCBEZFF4RTIgPCAwICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBEZEUxeFEgPSBzaWduICogdGhpcy5kaXJlY3Rpb24uZG90KCBlZGdlMS5jcm9zcyggZGlmZiApICk7XHJcblxyXG5cdFx0XHQvLyBiMiA8IDAsIG5vIGludGVyc2VjdGlvblxyXG5cdFx0XHRpZiAoIERkRTF4USA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gYjErYjIgPiAxLCBubyBpbnRlcnNlY3Rpb25cclxuXHRcdFx0aWYgKCBEZFF4RTIgKyBEZEUxeFEgPiBEZE4gKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gTGluZSBpbnRlcnNlY3RzIHRyaWFuZ2xlLCBjaGVjayBpZiByYXkgZG9lcy5cclxuXHRcdFx0dmFyIFFkTiA9IC0gc2lnbiAqIGRpZmYuZG90KCBub3JtYWwgKTtcclxuXHJcblx0XHRcdC8vIHQgPCAwLCBubyBpbnRlcnNlY3Rpb25cclxuXHRcdFx0aWYgKCBRZE4gPCAwICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFJheSBpbnRlcnNlY3RzIHRyaWFuZ2xlLlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5hdCggUWROIC8gRGROLCB0YXJnZXQgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXg0ICkge1xyXG5cclxuXHRcdHRoaXMub3JpZ2luLmFwcGx5TWF0cml4NCggbWF0cml4NCApO1xyXG5cdFx0dGhpcy5kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKCBtYXRyaXg0ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCByYXkgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHJheS5vcmlnaW4uZXF1YWxzKCB0aGlzLm9yaWdpbiApICYmIHJheS5kaXJlY3Rpb24uZXF1YWxzKCB0aGlzLmRpcmVjdGlvbiApO1xyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcblxyXG5cclxuZXhwb3J0IHsgUmF5IH07XHJcbiIsImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuL1ZlY3RvcjMuanMnO1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5mdW5jdGlvbiBUcmlhbmdsZSggYSwgYiwgYyApIHtcclxuXHJcblx0dGhpcy5hID0gKCBhICE9PSB1bmRlZmluZWQgKSA/IGEgOiBuZXcgVmVjdG9yMygpO1xyXG5cdHRoaXMuYiA9ICggYiAhPT0gdW5kZWZpbmVkICkgPyBiIDogbmV3IFZlY3RvcjMoKTtcclxuXHR0aGlzLmMgPSAoIGMgIT09IHVuZGVmaW5lZCApID8gYyA6IG5ldyBWZWN0b3IzKCk7XHJcblxyXG59XHJcblxyXG5PYmplY3QuYXNzaWduKCBUcmlhbmdsZSwge1xyXG5cclxuXHRnZXROb3JtYWw6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjAgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXROb3JtYWwoIGEsIGIsIGMsIHRhcmdldCApIHtcclxuXHJcblx0XHRcdGlmICggdGFyZ2V0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ0NPT0wuVHJpYW5nbGU6IC5nZXROb3JtYWwoKSB0YXJnZXQgaXMgbm93IHJlcXVpcmVkJyApO1xyXG5cdFx0XHRcdHRhcmdldCA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0YXJnZXQuc3ViVmVjdG9ycyggYywgYiApO1xyXG5cdFx0XHR2MC5zdWJWZWN0b3JzKCBhLCBiICk7XHJcblx0XHRcdHRhcmdldC5jcm9zcyggdjAgKTtcclxuXHJcblx0XHRcdHZhciB0YXJnZXRMZW5ndGhTcSA9IHRhcmdldC5sZW5ndGhTcSgpO1xyXG5cdFx0XHRpZiAoIHRhcmdldExlbmd0aFNxID4gMCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRhcmdldC5tdWx0aXBseVNjYWxhciggMSAvIE1hdGguc3FydCggdGFyZ2V0TGVuZ3RoU3EgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRhcmdldC5zZXQoIDAsIDAsIDAgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdC8vIHN0YXRpYy9pbnN0YW5jZSBtZXRob2QgdG8gY2FsY3VsYXRlIGJhcnljZW50cmljIGNvb3JkaW5hdGVzXHJcblx0Ly8gYmFzZWQgb246IGh0dHA6Ly93d3cuYmxhY2twYXduLmNvbS90ZXh0cy9wb2ludGlucG9seS9kZWZhdWx0Lmh0bWxcclxuXHRnZXRCYXJ5Y29vcmQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjAgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHZhciB2MiA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGdldEJhcnljb29yZCggcG9pbnQsIGEsIGIsIGMsIHRhcmdldCApIHtcclxuXHJcblx0XHRcdHYwLnN1YlZlY3RvcnMoIGMsIGEgKTtcclxuXHRcdFx0djEuc3ViVmVjdG9ycyggYiwgYSApO1xyXG5cdFx0XHR2Mi5zdWJWZWN0b3JzKCBwb2ludCwgYSApO1xyXG5cclxuXHRcdFx0dmFyIGRvdDAwID0gdjAuZG90KCB2MCApO1xyXG5cdFx0XHR2YXIgZG90MDEgPSB2MC5kb3QoIHYxICk7XHJcblx0XHRcdHZhciBkb3QwMiA9IHYwLmRvdCggdjIgKTtcclxuXHRcdFx0dmFyIGRvdDExID0gdjEuZG90KCB2MSApO1xyXG5cdFx0XHR2YXIgZG90MTIgPSB2MS5kb3QoIHYyICk7XHJcblxyXG5cdFx0XHR2YXIgZGVub20gPSAoIGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxICk7XHJcblxyXG5cdFx0XHRpZiAoIHRhcmdldCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdDT09MLlRyaWFuZ2xlOiAuZ2V0QmFyeWNvb3JkKCkgdGFyZ2V0IGlzIG5vdyByZXF1aXJlZCcgKTtcclxuXHRcdFx0XHR0YXJnZXQgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gY29sbGluZWFyIG9yIHNpbmd1bGFyIHRyaWFuZ2xlXHJcblx0XHRcdGlmICggZGVub20gPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGFyYml0cmFyeSBsb2NhdGlvbiBvdXRzaWRlIG9mIHRyaWFuZ2xlP1xyXG5cdFx0XHRcdC8vIG5vdCBzdXJlIGlmIHRoaXMgaXMgdGhlIGJlc3QgaWRlYSwgbWF5YmUgc2hvdWxkIGJlIHJldHVybmluZyB1bmRlZmluZWRcclxuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0LnNldCggLSAyLCAtIDEsIC0gMSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGludkRlbm9tID0gMSAvIGRlbm9tO1xyXG5cdFx0XHR2YXIgdSA9ICggZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIgKSAqIGludkRlbm9tO1xyXG5cdFx0XHR2YXIgdiA9ICggZG90MDAgKiBkb3QxMiAtIGRvdDAxICogZG90MDIgKSAqIGludkRlbm9tO1xyXG5cclxuXHRcdFx0Ly8gYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXMgbXVzdCBhbHdheXMgc3VtIHRvIDFcclxuXHRcdFx0cmV0dXJuIHRhcmdldC5zZXQoIDEgLSB1IC0gdiwgdiwgdSApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNvbnRhaW5zUG9pbnQoIHBvaW50LCBhLCBiLCBjICkge1xyXG5cclxuXHRcdFx0VHJpYW5nbGUuZ2V0QmFyeWNvb3JkKCBwb2ludCwgYSwgYiwgYywgdjEgKTtcclxuXHJcblx0XHRcdHJldHVybiAoIHYxLnggPj0gMCApICYmICggdjEueSA+PSAwICkgJiYgKCAoIHYxLnggKyB2MS55ICkgPD0gMSApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Z2V0VVY6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgYmFyeWNvb3JkID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0VVYoIHBvaW50LCBwMSwgcDIsIHAzLCB1djEsIHV2MiwgdXYzLCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmdldEJhcnljb29yZCggcG9pbnQsIHAxLCBwMiwgcDMsIGJhcnljb29yZCApO1xyXG5cclxuXHRcdFx0dGFyZ2V0LnNldCggMCwgMCApO1xyXG5cdFx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCB1djEsIGJhcnljb29yZC54ICk7XHJcblx0XHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIHV2MiwgYmFyeWNvb3JkLnkgKTtcclxuXHRcdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3RvciggdXYzLCBiYXJ5Y29vcmQueiApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRhcmdldDtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KClcclxuXHJcbn0gKTtcclxuXHJcbk9iamVjdC5hc3NpZ24oIFRyaWFuZ2xlLnByb3RvdHlwZSwge1xyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggYSwgYiwgYyApIHtcclxuXHJcblx0XHR0aGlzLmEuY29weSggYSApO1xyXG5cdFx0dGhpcy5iLmNvcHkoIGIgKTtcclxuXHRcdHRoaXMuYy5jb3B5KCBjICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21Qb2ludHNBbmRJbmRpY2VzOiBmdW5jdGlvbiAoIHBvaW50cywgaTAsIGkxLCBpMiApIHtcclxuXHJcblx0XHR0aGlzLmEuY29weSggcG9pbnRzWyBpMCBdICk7XHJcblx0XHR0aGlzLmIuY29weSggcG9pbnRzWyBpMSBdICk7XHJcblx0XHR0aGlzLmMuY29weSggcG9pbnRzWyBpMiBdICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHRyaWFuZ2xlICkge1xyXG5cclxuXHRcdHRoaXMuYS5jb3B5KCB0cmlhbmdsZS5hICk7XHJcblx0XHR0aGlzLmIuY29weSggdHJpYW5nbGUuYiApO1xyXG5cdFx0dGhpcy5jLmNvcHkoIHRyaWFuZ2xlLmMgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0QXJlYTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MCA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRBcmVhKCkge1xyXG5cclxuXHRcdFx0djAuc3ViVmVjdG9ycyggdGhpcy5jLCB0aGlzLmIgKTtcclxuXHRcdFx0djEuc3ViVmVjdG9ycyggdGhpcy5hLCB0aGlzLmIgKTtcclxuXHJcblx0XHRcdHJldHVybiB2MC5jcm9zcyggdjEgKS5sZW5ndGgoKSAqIDAuNTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGdldE1pZHBvaW50OiBmdW5jdGlvbiAoIHRhcmdldCApIHtcclxuXHJcblx0XHRpZiAoIHRhcmdldCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5UcmlhbmdsZTogLmdldE1pZHBvaW50KCkgdGFyZ2V0IGlzIG5vdyByZXF1aXJlZCcgKTtcclxuXHRcdFx0dGFyZ2V0ID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldC5hZGRWZWN0b3JzKCB0aGlzLmEsIHRoaXMuYiApLmFkZCggdGhpcy5jICkubXVsdGlwbHlTY2FsYXIoIDEgLyAzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldE5vcm1hbDogZnVuY3Rpb24gKCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIFRyaWFuZ2xlLmdldE5vcm1hbCggdGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgdGFyZ2V0ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldFBsYW5lOiBmdW5jdGlvbiAoIHRhcmdldCApIHtcclxuXHJcblx0XHRpZiAoIHRhcmdldCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5UcmlhbmdsZTogLmdldFBsYW5lKCkgdGFyZ2V0IGlzIG5vdyByZXF1aXJlZCcgKTtcclxuXHRcdFx0dGFyZ2V0ID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldC5zZXRGcm9tQ29wbGFuYXJQb2ludHMoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0QmFyeWNvb3JkOiBmdW5jdGlvbiAoIHBvaW50LCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIFRyaWFuZ2xlLmdldEJhcnljb29yZCggcG9pbnQsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIHRhcmdldCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuXHRcdHJldHVybiBUcmlhbmdsZS5jb250YWluc1BvaW50KCBwb2ludCwgdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRVVjogZnVuY3Rpb24gKCBwb2ludCwgdXYxLCB1djIsIHV2MywgcmVzdWx0ICkge1xyXG5cclxuXHRcdHJldHVybiBUcmlhbmdsZS5nZXRVViggcG9pbnQsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIHV2MSwgdXYyLCB1djMsIHJlc3VsdCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbnRlcnNlY3RzQm94OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHRyZXR1cm4gYm94LmludGVyc2VjdHNUcmlhbmdsZSggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9zZXN0UG9pbnRUb1BvaW50OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHZhYiA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHR2YXIgdmFjID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHZhciB2YmMgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0dmFyIHZhcCA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHR2YXIgdmJwID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHZhciB2Y3AgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBjbG9zZXN0UG9pbnRUb1BvaW50KCBwLCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRhcmdldCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdDT09MLlRyaWFuZ2xlOiAuY2xvc2VzdFBvaW50VG9Qb2ludCgpIHRhcmdldCBpcyBub3cgcmVxdWlyZWQnICk7XHJcblx0XHRcdFx0dGFyZ2V0ID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBhID0gdGhpcy5hLCBiID0gdGhpcy5iLCBjID0gdGhpcy5jO1xyXG5cdFx0XHR2YXIgdiwgdztcclxuXHJcblx0XHRcdC8vIGFsZ29yaXRobSB0aGFua3MgdG8gUmVhbC1UaW1lIENvbGxpc2lvbiBEZXRlY3Rpb24gYnkgQ2hyaXN0ZXIgRXJpY3NvbixcclxuXHRcdFx0Ly8gcHVibGlzaGVkIGJ5IE1vcmdhbiBLYXVmbWFubiBQdWJsaXNoZXJzLCAoYykgMjAwNSBFbHNldmllciBJbmMuLFxyXG5cdFx0XHQvLyB1bmRlciB0aGUgYWNjb21wYW55aW5nIGxpY2Vuc2U7IHNlZSBjaGFwdGVyIDUuMS41IGZvciBkZXRhaWxlZCBleHBsYW5hdGlvbi5cclxuXHRcdFx0Ly8gYmFzaWNhbGx5LCB3ZSdyZSBkaXN0aW5ndWlzaGluZyB3aGljaCBvZiB0aGUgdm9yb25vaSByZWdpb25zIG9mIHRoZSB0cmlhbmdsZVxyXG5cdFx0XHQvLyB0aGUgcG9pbnQgbGllcyBpbiB3aXRoIHRoZSBtaW5pbXVtIGFtb3VudCBvZiByZWR1bmRhbnQgY29tcHV0YXRpb24uXHJcblxyXG5cdFx0XHR2YWIuc3ViVmVjdG9ycyggYiwgYSApO1xyXG5cdFx0XHR2YWMuc3ViVmVjdG9ycyggYywgYSApO1xyXG5cdFx0XHR2YXAuc3ViVmVjdG9ycyggcCwgYSApO1xyXG5cdFx0XHR2YXIgZDEgPSB2YWIuZG90KCB2YXAgKTtcclxuXHRcdFx0dmFyIGQyID0gdmFjLmRvdCggdmFwICk7XHJcblx0XHRcdGlmICggZDEgPD0gMCAmJiBkMiA8PSAwICkge1xyXG5cclxuXHRcdFx0XHQvLyB2ZXJ0ZXggcmVnaW9uIG9mIEE7IGJhcnljZW50cmljIGNvb3JkcyAoMSwgMCwgMClcclxuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIGEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZicC5zdWJWZWN0b3JzKCBwLCBiICk7XHJcblx0XHRcdHZhciBkMyA9IHZhYi5kb3QoIHZicCApO1xyXG5cdFx0XHR2YXIgZDQgPSB2YWMuZG90KCB2YnAgKTtcclxuXHRcdFx0aWYgKCBkMyA+PSAwICYmIGQ0IDw9IGQzICkge1xyXG5cclxuXHRcdFx0XHQvLyB2ZXJ0ZXggcmVnaW9uIG9mIEI7IGJhcnljZW50cmljIGNvb3JkcyAoMCwgMSwgMClcclxuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIGIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciB2YyA9IGQxICogZDQgLSBkMyAqIGQyO1xyXG5cdFx0XHRpZiAoIHZjIDw9IDAgJiYgZDEgPj0gMCAmJiBkMyA8PSAwICkge1xyXG5cclxuXHRcdFx0XHR2ID0gZDEgLyAoIGQxIC0gZDMgKTtcclxuXHRcdFx0XHQvLyBlZGdlIHJlZ2lvbiBvZiBBQjsgYmFyeWNlbnRyaWMgY29vcmRzICgxLXYsIHYsIDApXHJcblx0XHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBhICkuYWRkU2NhbGVkVmVjdG9yKCB2YWIsIHYgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZjcC5zdWJWZWN0b3JzKCBwLCBjICk7XHJcblx0XHRcdHZhciBkNSA9IHZhYi5kb3QoIHZjcCApO1xyXG5cdFx0XHR2YXIgZDYgPSB2YWMuZG90KCB2Y3AgKTtcclxuXHRcdFx0aWYgKCBkNiA+PSAwICYmIGQ1IDw9IGQ2ICkge1xyXG5cclxuXHRcdFx0XHQvLyB2ZXJ0ZXggcmVnaW9uIG9mIEM7IGJhcnljZW50cmljIGNvb3JkcyAoMCwgMCwgMSlcclxuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIGMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciB2YiA9IGQ1ICogZDIgLSBkMSAqIGQ2O1xyXG5cdFx0XHRpZiAoIHZiIDw9IDAgJiYgZDIgPj0gMCAmJiBkNiA8PSAwICkge1xyXG5cclxuXHRcdFx0XHR3ID0gZDIgLyAoIGQyIC0gZDYgKTtcclxuXHRcdFx0XHQvLyBlZGdlIHJlZ2lvbiBvZiBBQzsgYmFyeWNlbnRyaWMgY29vcmRzICgxLXcsIDAsIHcpXHJcblx0XHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBhICkuYWRkU2NhbGVkVmVjdG9yKCB2YWMsIHcgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciB2YSA9IGQzICogZDYgLSBkNSAqIGQ0O1xyXG5cdFx0XHRpZiAoIHZhIDw9IDAgJiYgKCBkNCAtIGQzICkgPj0gMCAmJiAoIGQ1IC0gZDYgKSA+PSAwICkge1xyXG5cclxuXHRcdFx0XHR2YmMuc3ViVmVjdG9ycyggYywgYiApO1xyXG5cdFx0XHRcdHcgPSAoIGQ0IC0gZDMgKSAvICggKCBkNCAtIGQzICkgKyAoIGQ1IC0gZDYgKSApO1xyXG5cdFx0XHRcdC8vIGVkZ2UgcmVnaW9uIG9mIEJDOyBiYXJ5Y2VudHJpYyBjb29yZHMgKDAsIDEtdywgdylcclxuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIGIgKS5hZGRTY2FsZWRWZWN0b3IoIHZiYywgdyApOyAvLyBlZGdlIHJlZ2lvbiBvZiBCQ1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZmFjZSByZWdpb25cclxuXHRcdFx0dmFyIGRlbm9tID0gMSAvICggdmEgKyB2YiArIHZjICk7XHJcblx0XHRcdC8vIHUgPSB2YSAqIGRlbm9tXHJcblx0XHRcdHYgPSB2YiAqIGRlbm9tO1xyXG5cdFx0XHR3ID0gdmMgKiBkZW5vbTtcclxuXHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBhICkuYWRkU2NhbGVkVmVjdG9yKCB2YWIsIHYgKS5hZGRTY2FsZWRWZWN0b3IoIHZhYywgdyApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHRyaWFuZ2xlICkge1xyXG5cclxuXHRcdHJldHVybiB0cmlhbmdsZS5hLmVxdWFscyggdGhpcy5hICkgJiYgdHJpYW5nbGUuYi5lcXVhbHMoIHRoaXMuYiApICYmIHRyaWFuZ2xlLmMuZXF1YWxzKCB0aGlzLmMgKTtcclxuXHJcblx0fVxyXG5cclxufSApO1xyXG5cclxuXHJcbmV4cG9ydCB7IFRyaWFuZ2xlIH07XHJcbiIsImltcG9ydCB7X01hdGh9IGZyb20gJy4vTWF0aC5qcyc7XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG52YXIgQ29sb3JLZXl3b3JkcyA9IHsgJ2FsaWNlYmx1ZSc6IDB4RjBGOEZGLCAnYW50aXF1ZXdoaXRlJzogMHhGQUVCRDcsICdhcXVhJzogMHgwMEZGRkYsICdhcXVhbWFyaW5lJzogMHg3RkZGRDQsICdhenVyZSc6IDB4RjBGRkZGLFxyXG5cdCdiZWlnZSc6IDB4RjVGNURDLCAnYmlzcXVlJzogMHhGRkU0QzQsICdibGFjayc6IDB4MDAwMDAwLCAnYmxhbmNoZWRhbG1vbmQnOiAweEZGRUJDRCwgJ2JsdWUnOiAweDAwMDBGRiwgJ2JsdWV2aW9sZXQnOiAweDhBMkJFMixcclxuXHQnYnJvd24nOiAweEE1MkEyQSwgJ2J1cmx5d29vZCc6IDB4REVCODg3LCAnY2FkZXRibHVlJzogMHg1RjlFQTAsICdjaGFydHJldXNlJzogMHg3RkZGMDAsICdjaG9jb2xhdGUnOiAweEQyNjkxRSwgJ2NvcmFsJzogMHhGRjdGNTAsXHJcblx0J2Nvcm5mbG93ZXJibHVlJzogMHg2NDk1RUQsICdjb3Juc2lsayc6IDB4RkZGOERDLCAnY3JpbXNvbic6IDB4REMxNDNDLCAnY3lhbic6IDB4MDBGRkZGLCAnZGFya2JsdWUnOiAweDAwMDA4QiwgJ2RhcmtjeWFuJzogMHgwMDhCOEIsXHJcblx0J2Rhcmtnb2xkZW5yb2QnOiAweEI4ODYwQiwgJ2RhcmtncmF5JzogMHhBOUE5QTksICdkYXJrZ3JlZW4nOiAweDAwNjQwMCwgJ2RhcmtncmV5JzogMHhBOUE5QTksICdkYXJra2hha2knOiAweEJEQjc2QiwgJ2RhcmttYWdlbnRhJzogMHg4QjAwOEIsXHJcblx0J2RhcmtvbGl2ZWdyZWVuJzogMHg1NTZCMkYsICdkYXJrb3JhbmdlJzogMHhGRjhDMDAsICdkYXJrb3JjaGlkJzogMHg5OTMyQ0MsICdkYXJrcmVkJzogMHg4QjAwMDAsICdkYXJrc2FsbW9uJzogMHhFOTk2N0EsICdkYXJrc2VhZ3JlZW4nOiAweDhGQkM4RixcclxuXHQnZGFya3NsYXRlYmx1ZSc6IDB4NDgzRDhCLCAnZGFya3NsYXRlZ3JheSc6IDB4MkY0RjRGLCAnZGFya3NsYXRlZ3JleSc6IDB4MkY0RjRGLCAnZGFya3R1cnF1b2lzZSc6IDB4MDBDRUQxLCAnZGFya3Zpb2xldCc6IDB4OTQwMEQzLFxyXG5cdCdkZWVwcGluayc6IDB4RkYxNDkzLCAnZGVlcHNreWJsdWUnOiAweDAwQkZGRiwgJ2RpbWdyYXknOiAweDY5Njk2OSwgJ2RpbWdyZXknOiAweDY5Njk2OSwgJ2RvZGdlcmJsdWUnOiAweDFFOTBGRiwgJ2ZpcmVicmljayc6IDB4QjIyMjIyLFxyXG5cdCdmbG9yYWx3aGl0ZSc6IDB4RkZGQUYwLCAnZm9yZXN0Z3JlZW4nOiAweDIyOEIyMiwgJ2Z1Y2hzaWEnOiAweEZGMDBGRiwgJ2dhaW5zYm9ybyc6IDB4RENEQ0RDLCAnZ2hvc3R3aGl0ZSc6IDB4RjhGOEZGLCAnZ29sZCc6IDB4RkZENzAwLFxyXG5cdCdnb2xkZW5yb2QnOiAweERBQTUyMCwgJ2dyYXknOiAweDgwODA4MCwgJ2dyZWVuJzogMHgwMDgwMDAsICdncmVlbnllbGxvdyc6IDB4QURGRjJGLCAnZ3JleSc6IDB4ODA4MDgwLCAnaG9uZXlkZXcnOiAweEYwRkZGMCwgJ2hvdHBpbmsnOiAweEZGNjlCNCxcclxuXHQnaW5kaWFucmVkJzogMHhDRDVDNUMsICdpbmRpZ28nOiAweDRCMDA4MiwgJ2l2b3J5JzogMHhGRkZGRjAsICdraGFraSc6IDB4RjBFNjhDLCAnbGF2ZW5kZXInOiAweEU2RTZGQSwgJ2xhdmVuZGVyYmx1c2gnOiAweEZGRjBGNSwgJ2xhd25ncmVlbic6IDB4N0NGQzAwLFxyXG5cdCdsZW1vbmNoaWZmb24nOiAweEZGRkFDRCwgJ2xpZ2h0Ymx1ZSc6IDB4QUREOEU2LCAnbGlnaHRjb3JhbCc6IDB4RjA4MDgwLCAnbGlnaHRjeWFuJzogMHhFMEZGRkYsICdsaWdodGdvbGRlbnJvZHllbGxvdyc6IDB4RkFGQUQyLCAnbGlnaHRncmF5JzogMHhEM0QzRDMsXHJcblx0J2xpZ2h0Z3JlZW4nOiAweDkwRUU5MCwgJ2xpZ2h0Z3JleSc6IDB4RDNEM0QzLCAnbGlnaHRwaW5rJzogMHhGRkI2QzEsICdsaWdodHNhbG1vbic6IDB4RkZBMDdBLCAnbGlnaHRzZWFncmVlbic6IDB4MjBCMkFBLCAnbGlnaHRza3libHVlJzogMHg4N0NFRkEsXHJcblx0J2xpZ2h0c2xhdGVncmF5JzogMHg3Nzg4OTksICdsaWdodHNsYXRlZ3JleSc6IDB4Nzc4ODk5LCAnbGlnaHRzdGVlbGJsdWUnOiAweEIwQzRERSwgJ2xpZ2h0eWVsbG93JzogMHhGRkZGRTAsICdsaW1lJzogMHgwMEZGMDAsICdsaW1lZ3JlZW4nOiAweDMyQ0QzMixcclxuXHQnbGluZW4nOiAweEZBRjBFNiwgJ21hZ2VudGEnOiAweEZGMDBGRiwgJ21hcm9vbic6IDB4ODAwMDAwLCAnbWVkaXVtYXF1YW1hcmluZSc6IDB4NjZDREFBLCAnbWVkaXVtYmx1ZSc6IDB4MDAwMENELCAnbWVkaXVtb3JjaGlkJzogMHhCQTU1RDMsXHJcblx0J21lZGl1bXB1cnBsZSc6IDB4OTM3MERCLCAnbWVkaXVtc2VhZ3JlZW4nOiAweDNDQjM3MSwgJ21lZGl1bXNsYXRlYmx1ZSc6IDB4N0I2OEVFLCAnbWVkaXVtc3ByaW5nZ3JlZW4nOiAweDAwRkE5QSwgJ21lZGl1bXR1cnF1b2lzZSc6IDB4NDhEMUNDLFxyXG5cdCdtZWRpdW12aW9sZXRyZWQnOiAweEM3MTU4NSwgJ21pZG5pZ2h0Ymx1ZSc6IDB4MTkxOTcwLCAnbWludGNyZWFtJzogMHhGNUZGRkEsICdtaXN0eXJvc2UnOiAweEZGRTRFMSwgJ21vY2Nhc2luJzogMHhGRkU0QjUsICduYXZham93aGl0ZSc6IDB4RkZERUFELFxyXG5cdCduYXZ5JzogMHgwMDAwODAsICdvbGRsYWNlJzogMHhGREY1RTYsICdvbGl2ZSc6IDB4ODA4MDAwLCAnb2xpdmVkcmFiJzogMHg2QjhFMjMsICdvcmFuZ2UnOiAweEZGQTUwMCwgJ29yYW5nZXJlZCc6IDB4RkY0NTAwLCAnb3JjaGlkJzogMHhEQTcwRDYsXHJcblx0J3BhbGVnb2xkZW5yb2QnOiAweEVFRThBQSwgJ3BhbGVncmVlbic6IDB4OThGQjk4LCAncGFsZXR1cnF1b2lzZSc6IDB4QUZFRUVFLCAncGFsZXZpb2xldHJlZCc6IDB4REI3MDkzLCAncGFwYXlhd2hpcCc6IDB4RkZFRkQ1LCAncGVhY2hwdWZmJzogMHhGRkRBQjksXHJcblx0J3BlcnUnOiAweENEODUzRiwgJ3BpbmsnOiAweEZGQzBDQiwgJ3BsdW0nOiAweEREQTBERCwgJ3Bvd2RlcmJsdWUnOiAweEIwRTBFNiwgJ3B1cnBsZSc6IDB4ODAwMDgwLCAncmViZWNjYXB1cnBsZSc6IDB4NjYzMzk5LCAncmVkJzogMHhGRjAwMDAsICdyb3N5YnJvd24nOiAweEJDOEY4RixcclxuXHQncm95YWxibHVlJzogMHg0MTY5RTEsICdzYWRkbGVicm93bic6IDB4OEI0NTEzLCAnc2FsbW9uJzogMHhGQTgwNzIsICdzYW5keWJyb3duJzogMHhGNEE0NjAsICdzZWFncmVlbic6IDB4MkU4QjU3LCAnc2Vhc2hlbGwnOiAweEZGRjVFRSxcclxuXHQnc2llbm5hJzogMHhBMDUyMkQsICdzaWx2ZXInOiAweEMwQzBDMCwgJ3NreWJsdWUnOiAweDg3Q0VFQiwgJ3NsYXRlYmx1ZSc6IDB4NkE1QUNELCAnc2xhdGVncmF5JzogMHg3MDgwOTAsICdzbGF0ZWdyZXknOiAweDcwODA5MCwgJ3Nub3cnOiAweEZGRkFGQSxcclxuXHQnc3ByaW5nZ3JlZW4nOiAweDAwRkY3RiwgJ3N0ZWVsYmx1ZSc6IDB4NDY4MkI0LCAndGFuJzogMHhEMkI0OEMsICd0ZWFsJzogMHgwMDgwODAsICd0aGlzdGxlJzogMHhEOEJGRDgsICd0b21hdG8nOiAweEZGNjM0NywgJ3R1cnF1b2lzZSc6IDB4NDBFMEQwLFxyXG5cdCd2aW9sZXQnOiAweEVFODJFRSwgJ3doZWF0JzogMHhGNURFQjMsICd3aGl0ZSc6IDB4RkZGRkZGLCAnd2hpdGVzbW9rZSc6IDB4RjVGNUY1LCAneWVsbG93JzogMHhGRkZGMDAsICd5ZWxsb3dncmVlbic6IDB4OUFDRDMyIH07XHJcblxyXG5mdW5jdGlvbiBDb2xvciggciwgZywgYiApIHtcclxuXHJcblx0aWYgKCBnID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdC8vIHIgaXMgQ09PTC5Db2xvciwgaGV4IG9yIHN0cmluZ1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0KCByICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXMuc2V0UkdCKCByLCBnLCBiICk7XHJcblxyXG59XHJcblxyXG5PYmplY3QuYXNzaWduKCBDb2xvci5wcm90b3R5cGUsIHtcclxuXHJcblx0aXNDb2xvcjogdHJ1ZSxcclxuXHJcblx0cjogMSwgZzogMSwgYjogMSxcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdGlmICggdmFsdWUgJiYgdmFsdWUuaXNDb2xvciApIHtcclxuXHJcblx0XHRcdHRoaXMuY29weSggdmFsdWUgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICkge1xyXG5cclxuXHRcdFx0dGhpcy5zZXRIZXgoIHZhbHVlICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyApIHtcclxuXHJcblx0XHRcdHRoaXMuc2V0U3R5bGUoIHZhbHVlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdHRoaXMuciA9IHNjYWxhcjtcclxuXHRcdHRoaXMuZyA9IHNjYWxhcjtcclxuXHRcdHRoaXMuYiA9IHNjYWxhcjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0SGV4OiBmdW5jdGlvbiAoIGhleCApIHtcclxuXHJcblx0XHRoZXggPSBNYXRoLmZsb29yKCBoZXggKTtcclxuXHJcblx0XHR0aGlzLnIgPSAoIGhleCA+PiAxNiAmIDI1NSApIC8gMjU1O1xyXG5cdFx0dGhpcy5nID0gKCBoZXggPj4gOCAmIDI1NSApIC8gMjU1O1xyXG5cdFx0dGhpcy5iID0gKCBoZXggJiAyNTUgKSAvIDI1NTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0UkdCOiBmdW5jdGlvbiAoIHIsIGcsIGIgKSB7XHJcblxyXG5cdFx0dGhpcy5yID0gcjtcclxuXHRcdHRoaXMuZyA9IGc7XHJcblx0XHR0aGlzLmIgPSBiO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRIU0w6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRmdW5jdGlvbiBodWUycmdiKCBwLCBxLCB0ICkge1xyXG5cclxuXHRcdFx0aWYgKCB0IDwgMCApIHQgKz0gMTtcclxuXHRcdFx0aWYgKCB0ID4gMSApIHQgLT0gMTtcclxuXHRcdFx0aWYgKCB0IDwgMSAvIDYgKSByZXR1cm4gcCArICggcSAtIHAgKSAqIDYgKiB0O1xyXG5cdFx0XHRpZiAoIHQgPCAxIC8gMiApIHJldHVybiBxO1xyXG5cdFx0XHRpZiAoIHQgPCAyIC8gMyApIHJldHVybiBwICsgKCBxIC0gcCApICogNiAqICggMiAvIDMgLSB0ICk7XHJcblx0XHRcdHJldHVybiBwO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gc2V0SFNMKCBoLCBzLCBsICkge1xyXG5cclxuXHRcdFx0Ly8gaCxzLGwgcmFuZ2VzIGFyZSBpbiAwLjAgLSAxLjBcclxuXHRcdFx0aCA9IF9NYXRoLmV1Y2xpZGVhbk1vZHVsbyggaCwgMSApO1xyXG5cdFx0XHRzID0gX01hdGguY2xhbXAoIHMsIDAsIDEgKTtcclxuXHRcdFx0bCA9IF9NYXRoLmNsYW1wKCBsLCAwLCAxICk7XHJcblxyXG5cdFx0XHRpZiAoIHMgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuciA9IHRoaXMuZyA9IHRoaXMuYiA9IGw7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR2YXIgcCA9IGwgPD0gMC41ID8gbCAqICggMSArIHMgKSA6IGwgKyBzIC0gKCBsICogcyApO1xyXG5cdFx0XHRcdHZhciBxID0gKCAyICogbCApIC0gcDtcclxuXHJcblx0XHRcdFx0dGhpcy5yID0gaHVlMnJnYiggcSwgcCwgaCArIDEgLyAzICk7XHJcblx0XHRcdFx0dGhpcy5nID0gaHVlMnJnYiggcSwgcCwgaCApO1xyXG5cdFx0XHRcdHRoaXMuYiA9IGh1ZTJyZ2IoIHEsIHAsIGggLSAxIC8gMyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKCBzdHlsZSApIHtcclxuXHJcblx0XHRmdW5jdGlvbiBoYW5kbGVBbHBoYSggc3RyaW5nICkge1xyXG5cclxuXHRcdFx0aWYgKCBzdHJpbmcgPT09IHVuZGVmaW5lZCApIHJldHVybjtcclxuXHJcblx0XHRcdGlmICggcGFyc2VGbG9hdCggc3RyaW5nICkgPCAxICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdDT09MLkNvbG9yOiBBbHBoYSBjb21wb25lbnQgb2YgJyArIHN0eWxlICsgJyB3aWxsIGJlIGlnbm9yZWQuJyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblxyXG5cdFx0dmFyIG07XHJcblxyXG5cdFx0aWYgKCBtID0gL14oKD86cmdifGhzbClhPylcXChcXHMqKFteXFwpXSopXFwpLy5leGVjKCBzdHlsZSApICkge1xyXG5cclxuXHRcdFx0Ly8gcmdiIC8gaHNsXHJcblxyXG5cdFx0XHR2YXIgY29sb3I7XHJcblx0XHRcdHZhciBuYW1lID0gbVsgMSBdO1xyXG5cdFx0XHR2YXIgY29tcG9uZW50cyA9IG1bIDIgXTtcclxuXHJcblx0XHRcdHN3aXRjaCAoIG5hbWUgKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ3JnYic6XHJcblx0XHRcdFx0Y2FzZSAncmdiYSc6XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBjb2xvciA9IC9eKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKigsXFxzKihbMC05XSpcXC4/WzAtOV0rKVxccyopPyQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIHJnYigyNTUsMCwwKSByZ2JhKDI1NSwwLDAsMC41KVxyXG5cdFx0XHRcdFx0XHR0aGlzLnIgPSBNYXRoLm1pbiggMjU1LCBwYXJzZUludCggY29sb3JbIDEgXSwgMTAgKSApIC8gMjU1O1xyXG5cdFx0XHRcdFx0XHR0aGlzLmcgPSBNYXRoLm1pbiggMjU1LCBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSApIC8gMjU1O1xyXG5cdFx0XHRcdFx0XHR0aGlzLmIgPSBNYXRoLm1pbiggMjU1LCBwYXJzZUludCggY29sb3JbIDMgXSwgMTAgKSApIC8gMjU1O1xyXG5cclxuXHRcdFx0XHRcdFx0aGFuZGxlQWxwaGEoIGNvbG9yWyA1IF0gKTtcclxuXHJcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoIGNvbG9yID0gL14oXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqKCxcXHMqKFswLTldKlxcLj9bMC05XSspXFxzKik/JC8uZXhlYyggY29tcG9uZW50cyApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gcmdiKDEwMCUsMCUsMCUpIHJnYmEoMTAwJSwwJSwwJSwwLjUpXHJcblx0XHRcdFx0XHRcdHRoaXMuciA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMSBdLCAxMCApICkgLyAxMDA7XHJcblx0XHRcdFx0XHRcdHRoaXMuZyA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMiBdLCAxMCApICkgLyAxMDA7XHJcblx0XHRcdFx0XHRcdHRoaXMuYiA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMyBdLCAxMCApICkgLyAxMDA7XHJcblxyXG5cdFx0XHRcdFx0XHRoYW5kbGVBbHBoYSggY29sb3JbIDUgXSApO1xyXG5cclxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdoc2wnOlxyXG5cdFx0XHRcdGNhc2UgJ2hzbGEnOlxyXG5cclxuXHRcdFx0XHRcdGlmICggY29sb3IgPSAvXihbMC05XSpcXC4/WzAtOV0rKVxccyosXFxzKihcXGQrKVxcJVxccyosXFxzKihcXGQrKVxcJVxccyooLFxccyooWzAtOV0qXFwuP1swLTldKylcXHMqKT8kLy5leGVjKCBjb21wb25lbnRzICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBoc2woMTIwLDUwJSw1MCUpIGhzbGEoMTIwLDUwJSw1MCUsMC41KVxyXG5cdFx0XHRcdFx0XHR2YXIgaCA9IHBhcnNlRmxvYXQoIGNvbG9yWyAxIF0gKSAvIDM2MDtcclxuXHRcdFx0XHRcdFx0dmFyIHMgPSBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSAvIDEwMDtcclxuXHRcdFx0XHRcdFx0dmFyIGwgPSBwYXJzZUludCggY29sb3JbIDMgXSwgMTAgKSAvIDEwMDtcclxuXHJcblx0XHRcdFx0XHRcdGhhbmRsZUFscGhhKCBjb2xvclsgNSBdICk7XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRIU0woIGgsIHMsIGwgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbSA9IC9eXFwjKFtBLUZhLWYwLTldKykkLy5leGVjKCBzdHlsZSApICkge1xyXG5cclxuXHRcdFx0Ly8gaGV4IGNvbG9yXHJcblxyXG5cdFx0XHR2YXIgaGV4ID0gbVsgMSBdO1xyXG5cdFx0XHR2YXIgc2l6ZSA9IGhleC5sZW5ndGg7XHJcblxyXG5cdFx0XHRpZiAoIHNpemUgPT09IDMgKSB7XHJcblxyXG5cdFx0XHRcdC8vICNmZjBcclxuXHRcdFx0XHR0aGlzLnIgPSBwYXJzZUludCggaGV4LmNoYXJBdCggMCApICsgaGV4LmNoYXJBdCggMCApLCAxNiApIC8gMjU1O1xyXG5cdFx0XHRcdHRoaXMuZyA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAxICkgKyBoZXguY2hhckF0KCAxICksIDE2ICkgLyAyNTU7XHJcblx0XHRcdFx0dGhpcy5iID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDIgKSArIGhleC5jaGFyQXQoIDIgKSwgMTYgKSAvIDI1NTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBzaXplID09PSA2ICkge1xyXG5cclxuXHRcdFx0XHQvLyAjZmYwMDAwXHJcblx0XHRcdFx0dGhpcy5yID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDAgKSArIGhleC5jaGFyQXQoIDEgKSwgMTYgKSAvIDI1NTtcclxuXHRcdFx0XHR0aGlzLmcgPSBwYXJzZUludCggaGV4LmNoYXJBdCggMiApICsgaGV4LmNoYXJBdCggMyApLCAxNiApIC8gMjU1O1xyXG5cdFx0XHRcdHRoaXMuYiA9IHBhcnNlSW50KCBoZXguY2hhckF0KCA0ICkgKyBoZXguY2hhckF0KCA1ICksIDE2ICkgLyAyNTU7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHN0eWxlICYmIHN0eWxlLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHQvLyBjb2xvciBrZXl3b3Jkc1xyXG5cdFx0XHR2YXIgaGV4ID0gQ29sb3JLZXl3b3Jkc1sgc3R5bGUgXTtcclxuXHJcblx0XHRcdGlmICggaGV4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdC8vIHJlZFxyXG5cdFx0XHRcdHRoaXMuc2V0SGV4KCBoZXggKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIHVua25vd24gY29sb3JcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdDT09MLkNvbG9yOiBVbmtub3duIGNvbG9yICcgKyBzdHlsZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuciwgdGhpcy5nLCB0aGlzLmIgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBjb2xvciApIHtcclxuXHJcblx0XHR0aGlzLnIgPSBjb2xvci5yO1xyXG5cdFx0dGhpcy5nID0gY29sb3IuZztcclxuXHRcdHRoaXMuYiA9IGNvbG9yLmI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHlHYW1tYVRvTGluZWFyOiBmdW5jdGlvbiAoIGNvbG9yLCBnYW1tYUZhY3RvciApIHtcclxuXHJcblx0XHRpZiAoIGdhbW1hRmFjdG9yID09PSB1bmRlZmluZWQgKSBnYW1tYUZhY3RvciA9IDIuMDtcclxuXHJcblx0XHR0aGlzLnIgPSBNYXRoLnBvdyggY29sb3IuciwgZ2FtbWFGYWN0b3IgKTtcclxuXHRcdHRoaXMuZyA9IE1hdGgucG93KCBjb2xvci5nLCBnYW1tYUZhY3RvciApO1xyXG5cdFx0dGhpcy5iID0gTWF0aC5wb3coIGNvbG9yLmIsIGdhbW1hRmFjdG9yICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHlMaW5lYXJUb0dhbW1hOiBmdW5jdGlvbiAoIGNvbG9yLCBnYW1tYUZhY3RvciApIHtcclxuXHJcblx0XHRpZiAoIGdhbW1hRmFjdG9yID09PSB1bmRlZmluZWQgKSBnYW1tYUZhY3RvciA9IDIuMDtcclxuXHJcblx0XHR2YXIgc2FmZUludmVyc2UgPSAoIGdhbW1hRmFjdG9yID4gMCApID8gKCAxLjAgLyBnYW1tYUZhY3RvciApIDogMS4wO1xyXG5cclxuXHRcdHRoaXMuciA9IE1hdGgucG93KCBjb2xvci5yLCBzYWZlSW52ZXJzZSApO1xyXG5cdFx0dGhpcy5nID0gTWF0aC5wb3coIGNvbG9yLmcsIHNhZmVJbnZlcnNlICk7XHJcblx0XHR0aGlzLmIgPSBNYXRoLnBvdyggY29sb3IuYiwgc2FmZUludmVyc2UgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29udmVydEdhbW1hVG9MaW5lYXI6IGZ1bmN0aW9uICggZ2FtbWFGYWN0b3IgKSB7XHJcblxyXG5cdFx0dGhpcy5jb3B5R2FtbWFUb0xpbmVhciggdGhpcywgZ2FtbWFGYWN0b3IgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29udmVydExpbmVhclRvR2FtbWE6IGZ1bmN0aW9uICggZ2FtbWFGYWN0b3IgKSB7XHJcblxyXG5cdFx0dGhpcy5jb3B5TGluZWFyVG9HYW1tYSggdGhpcywgZ2FtbWFGYWN0b3IgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weVNSR0JUb0xpbmVhcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGZ1bmN0aW9uIFNSR0JUb0xpbmVhciggYyApIHtcclxuXHJcblx0XHRcdHJldHVybiAoIGMgPCAwLjA0MDQ1ICkgPyBjICogMC4wNzczOTkzODA4IDogTWF0aC5wb3coIGMgKiAwLjk0Nzg2NzI5ODYgKyAwLjA1MjEzMjcwMTQsIDIuNCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gY29weVNSR0JUb0xpbmVhciggY29sb3IgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnIgPSBTUkdCVG9MaW5lYXIoIGNvbG9yLnIgKTtcclxuXHRcdFx0dGhpcy5nID0gU1JHQlRvTGluZWFyKCBjb2xvci5nICk7XHJcblx0XHRcdHRoaXMuYiA9IFNSR0JUb0xpbmVhciggY29sb3IuYiApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRjb3B5TGluZWFyVG9TUkdCOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0ZnVuY3Rpb24gTGluZWFyVG9TUkdCKCBjICkge1xyXG5cclxuXHRcdFx0cmV0dXJuICggYyA8IDAuMDAzMTMwOCApID8gYyAqIDEyLjkyIDogMS4wNTUgKiAoIE1hdGgucG93KCBjLCAwLjQxNjY2ICkgKSAtIDAuMDU1O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gY29weUxpbmVhclRvU1JHQiggY29sb3IgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnIgPSBMaW5lYXJUb1NSR0IoIGNvbG9yLnIgKTtcclxuXHRcdFx0dGhpcy5nID0gTGluZWFyVG9TUkdCKCBjb2xvci5nICk7XHJcblx0XHRcdHRoaXMuYiA9IExpbmVhclRvU1JHQiggY29sb3IuYiApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRjb252ZXJ0U1JHQlRvTGluZWFyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5jb3B5U1JHQlRvTGluZWFyKCB0aGlzICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbnZlcnRMaW5lYXJUb1NSR0I6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmNvcHlMaW5lYXJUb1NSR0IoIHRoaXMgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0SGV4OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuICggdGhpcy5yICogMjU1ICkgPDwgMTYgXiAoIHRoaXMuZyAqIDI1NSApIDw8IDggXiAoIHRoaXMuYiAqIDI1NSApIDw8IDA7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEhleFN0cmluZzogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiAoICcwMDAwMDAnICsgdGhpcy5nZXRIZXgoKS50b1N0cmluZyggMTYgKSApLnNsaWNlKCAtIDYgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0SFNMOiBmdW5jdGlvbiAoIHRhcmdldCApIHtcclxuXHJcblx0XHQvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxyXG5cclxuXHRcdGlmICggdGFyZ2V0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdDT09MLkNvbG9yOiAuZ2V0SFNMKCkgdGFyZ2V0IGlzIG5vdyByZXF1aXJlZCcgKTtcclxuXHRcdFx0dGFyZ2V0ID0geyBoOiAwLCBzOiAwLCBsOiAwIH07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciByID0gdGhpcy5yLCBnID0gdGhpcy5nLCBiID0gdGhpcy5iO1xyXG5cclxuXHRcdHZhciBtYXggPSBNYXRoLm1heCggciwgZywgYiApO1xyXG5cdFx0dmFyIG1pbiA9IE1hdGgubWluKCByLCBnLCBiICk7XHJcblxyXG5cdFx0dmFyIGh1ZSwgc2F0dXJhdGlvbjtcclxuXHRcdHZhciBsaWdodG5lc3MgPSAoIG1pbiArIG1heCApIC8gMi4wO1xyXG5cclxuXHRcdGlmICggbWluID09PSBtYXggKSB7XHJcblxyXG5cdFx0XHRodWUgPSAwO1xyXG5cdFx0XHRzYXR1cmF0aW9uID0gMDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dmFyIGRlbHRhID0gbWF4IC0gbWluO1xyXG5cclxuXHRcdFx0c2F0dXJhdGlvbiA9IGxpZ2h0bmVzcyA8PSAwLjUgPyBkZWx0YSAvICggbWF4ICsgbWluICkgOiBkZWx0YSAvICggMiAtIG1heCAtIG1pbiApO1xyXG5cclxuXHRcdFx0c3dpdGNoICggbWF4ICkge1xyXG5cclxuXHRcdFx0XHRjYXNlIHI6IGh1ZSA9ICggZyAtIGIgKSAvIGRlbHRhICsgKCBnIDwgYiA/IDYgOiAwICk7IGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgZzogaHVlID0gKCBiIC0gciApIC8gZGVsdGEgKyAyOyBicmVhaztcclxuXHRcdFx0XHRjYXNlIGI6IGh1ZSA9ICggciAtIGcgKSAvIGRlbHRhICsgNDsgYnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRodWUgLz0gNjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGFyZ2V0LmggPSBodWU7XHJcblx0XHR0YXJnZXQucyA9IHNhdHVyYXRpb247XHJcblx0XHR0YXJnZXQubCA9IGxpZ2h0bmVzcztcclxuXHJcblx0XHRyZXR1cm4gdGFyZ2V0O1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRTdHlsZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiAncmdiKCcgKyAoICggdGhpcy5yICogMjU1ICkgfCAwICkgKyAnLCcgKyAoICggdGhpcy5nICogMjU1ICkgfCAwICkgKyAnLCcgKyAoICggdGhpcy5iICogMjU1ICkgfCAwICkgKyAnKSc7XHJcblxyXG5cdH0sXHJcblxyXG5cdG9mZnNldEhTTDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBoc2wgPSB7fTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBoLCBzLCBsICkge1xyXG5cclxuXHRcdFx0dGhpcy5nZXRIU0woIGhzbCApO1xyXG5cclxuXHRcdFx0aHNsLmggKz0gaDsgaHNsLnMgKz0gczsgaHNsLmwgKz0gbDtcclxuXHJcblx0XHRcdHRoaXMuc2V0SFNMKCBoc2wuaCwgaHNsLnMsIGhzbC5sICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGFkZDogZnVuY3Rpb24gKCBjb2xvciApIHtcclxuXHJcblx0XHR0aGlzLnIgKz0gY29sb3IucjtcclxuXHRcdHRoaXMuZyArPSBjb2xvci5nO1xyXG5cdFx0dGhpcy5iICs9IGNvbG9yLmI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZENvbG9yczogZnVuY3Rpb24gKCBjb2xvcjEsIGNvbG9yMiApIHtcclxuXHJcblx0XHR0aGlzLnIgPSBjb2xvcjEuciArIGNvbG9yMi5yO1xyXG5cdFx0dGhpcy5nID0gY29sb3IxLmcgKyBjb2xvcjIuZztcclxuXHRcdHRoaXMuYiA9IGNvbG9yMS5iICsgY29sb3IyLmI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMuciArPSBzO1xyXG5cdFx0dGhpcy5nICs9IHM7XHJcblx0XHR0aGlzLmIgKz0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c3ViOiBmdW5jdGlvbiAoIGNvbG9yICkge1xyXG5cclxuXHRcdHRoaXMuciA9IE1hdGgubWF4KCAwLCB0aGlzLnIgLSBjb2xvci5yICk7XHJcblx0XHR0aGlzLmcgPSBNYXRoLm1heCggMCwgdGhpcy5nIC0gY29sb3IuZyApO1xyXG5cdFx0dGhpcy5iID0gTWF0aC5tYXgoIDAsIHRoaXMuYiAtIGNvbG9yLmIgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggY29sb3IgKSB7XHJcblxyXG5cdFx0dGhpcy5yICo9IGNvbG9yLnI7XHJcblx0XHR0aGlzLmcgKj0gY29sb3IuZztcclxuXHRcdHRoaXMuYiAqPSBjb2xvci5iO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMuciAqPSBzO1xyXG5cdFx0dGhpcy5nICo9IHM7XHJcblx0XHR0aGlzLmIgKj0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bGVycDogZnVuY3Rpb24gKCBjb2xvciwgYWxwaGEgKSB7XHJcblxyXG5cdFx0dGhpcy5yICs9ICggY29sb3IuciAtIHRoaXMuciApICogYWxwaGE7XHJcblx0XHR0aGlzLmcgKz0gKCBjb2xvci5nIC0gdGhpcy5nICkgKiBhbHBoYTtcclxuXHRcdHRoaXMuYiArPSAoIGNvbG9yLmIgLSB0aGlzLmIgKSAqIGFscGhhO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZXJwSFNMOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGhzbEEgPSB7IGg6IDAsIHM6IDAsIGw6IDAgfTtcclxuXHRcdHZhciBoc2xCID0geyBoOiAwLCBzOiAwLCBsOiAwIH07XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGxlcnBIU0woIGNvbG9yLCBhbHBoYSApIHtcclxuXHJcblx0XHRcdHRoaXMuZ2V0SFNMKCBoc2xBICk7XHJcblx0XHRcdGNvbG9yLmdldEhTTCggaHNsQiApO1xyXG5cclxuXHRcdFx0dmFyIGggPSBfTWF0aC5sZXJwKCBoc2xBLmgsIGhzbEIuaCwgYWxwaGEgKTtcclxuXHRcdFx0dmFyIHMgPSBfTWF0aC5sZXJwKCBoc2xBLnMsIGhzbEIucywgYWxwaGEgKTtcclxuXHRcdFx0dmFyIGwgPSBfTWF0aC5sZXJwKCBoc2xBLmwsIGhzbEIubCwgYWxwaGEgKTtcclxuXHJcblx0XHRcdHRoaXMuc2V0SFNMKCBoLCBzLCBsICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCBjICkge1xyXG5cclxuXHRcdHJldHVybiAoIGMuciA9PT0gdGhpcy5yICkgJiYgKCBjLmcgPT09IHRoaXMuZyApICYmICggYy5iID09PSB0aGlzLmIgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0dGhpcy5yID0gYXJyYXlbIG9mZnNldCBdO1xyXG5cdFx0dGhpcy5nID0gYXJyYXlbIG9mZnNldCArIDEgXTtcclxuXHRcdHRoaXMuYiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xyXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5yO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuZztcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLmI7XHJcblxyXG5cdFx0cmV0dXJuIGFycmF5O1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0pTT046IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5nZXRIZXgoKTtcclxuXHJcblx0fVxyXG5cclxufSApO1xyXG5cclxuXHJcbmV4cG9ydCB7IENvbG9yIH07XHJcbiIsImltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vbWF0aC9Db2xvci5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gRmFjZTMoIGEsIGIsIGMsIG5vcm1hbCwgY29sb3IsIG1hdGVyaWFsSW5kZXggKSB7XHJcblxyXG5cdHRoaXMuYSA9IGE7XHJcblx0dGhpcy5iID0gYjtcclxuXHR0aGlzLmMgPSBjO1xyXG5cclxuXHR0aGlzLm5vcm1hbCA9ICggbm9ybWFsICYmIG5vcm1hbC5pc1ZlY3RvcjMgKSA/IG5vcm1hbCA6IG5ldyBWZWN0b3IzKCk7XHJcblx0dGhpcy52ZXJ0ZXhOb3JtYWxzID0gQXJyYXkuaXNBcnJheSggbm9ybWFsICkgPyBub3JtYWwgOiBbXTtcclxuXHJcblx0dGhpcy5jb2xvciA9ICggY29sb3IgJiYgY29sb3IuaXNDb2xvciApID8gY29sb3IgOiBuZXcgQ29sb3IoKTtcclxuXHR0aGlzLnZlcnRleENvbG9ycyA9IEFycmF5LmlzQXJyYXkoIGNvbG9yICkgPyBjb2xvciA6IFtdO1xyXG5cclxuXHR0aGlzLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4ICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbEluZGV4IDogMDtcclxuXHJcbn1cclxuXHJcbk9iamVjdC5hc3NpZ24oIEZhY2UzLnByb3RvdHlwZSwge1xyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0dGhpcy5hID0gc291cmNlLmE7XHJcblx0XHR0aGlzLmIgPSBzb3VyY2UuYjtcclxuXHRcdHRoaXMuYyA9IHNvdXJjZS5jO1xyXG5cclxuXHRcdHRoaXMubm9ybWFsLmNvcHkoIHNvdXJjZS5ub3JtYWwgKTtcclxuXHRcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XHJcblxyXG5cdFx0dGhpcy5tYXRlcmlhbEluZGV4ID0gc291cmNlLm1hdGVyaWFsSW5kZXg7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHNvdXJjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dGhpcy52ZXJ0ZXhOb3JtYWxzWyBpIF0gPSBzb3VyY2UudmVydGV4Tm9ybWFsc1sgaSBdLmNsb25lKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBzb3VyY2UudmVydGV4Q29sb3JzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dGhpcy52ZXJ0ZXhDb2xvcnNbIGkgXSA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnNbIGkgXS5jbG9uZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxufSApO1xyXG5cclxuXHJcbmV4cG9ydCB7IEZhY2UzIH07XHJcbiIsImltcG9ydCBCb3hHZW9tZXRyeSBmcm9tIFwiLi9Cb3hHZW9tZXRyeS5qc1wiO1xyXG5pbXBvcnQgTWF0ZXJpYWwgZnJvbSBcIi4uL21hdGVyaWFsL01hdGVyaWFsLmpzXCI7XHJcbmltcG9ydCB7TWF0cml4NH0gZnJvbSBcIi4uL21hdGgvTWF0cml4NFwiO1xyXG5pbXBvcnQge0V1bGVyfSBmcm9tIFwiLi4vbWF0aC9FdWxlclwiO1xyXG5pbXBvcnQge1F1YXRlcm5pb259IGZyb20gXCIuLi9tYXRoL1F1YXRlcm5pb25cIjtcclxuaW1wb3J0IHtWZWN0b3IzfSBmcm9tIFwiLi4vbWF0aC9WZWN0b3IzXCI7XHJcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQge1JheX0gZnJvbSBcIi4uL21hdGgvUmF5XCI7XHJcblxyXG5pbXBvcnQgeyBTcGhlcmUgfSBmcm9tICcuLi9tYXRoL1NwaGVyZS5qcyc7XHJcbmltcG9ydCB7IFRyaWFuZ2xlIH0gZnJvbSAnLi4vbWF0aC9UcmlhbmdsZS5qcyc7XHJcbmltcG9ydCB7IEZhY2UzIH0gZnJvbSAnLi4vY29yZS9GYWNlMy5qcyc7XHJcbmltcG9ydCB7Qm94M30gZnJvbSBcIi4uL21hdGgvQm94M1wiO1xyXG5cclxuXHJcblxyXG5jbGFzcyBNZXNoIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtKSB7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ01lc2gnO1xyXG4gICAgICAgIHBhcmFtID0gcGFyYW0gfHwge307XHJcbiAgICAgICAgdGhpcy5nZW9tZXRyeSA9IHBhcmFtLmdlb21ldHJ5O1xyXG4gICAgICAgIHRoaXMubWF0ZXJpYWwgPSBwYXJhbS5tYXRlcmlhbCB8fCBuZXcgTWF0ZXJpYWwoKTtcclxuXHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBhcmFtLnBvc2l0aW9uIHx8IFswLDAsMF07XHJcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IHBhcmFtLnJvdGF0aW9uIHx8IG5ldyBFdWxlcigpO1xyXG4gICAgICAgIHRoaXMuc2NhbGUgPSBwYXJhbS5zY2FsZSB8fCBbMSwxLDFdO1xyXG5cclxuICAgICAgICB0aGlzLnF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpLnNldEZyb21FdWxlciggdGhpcy5yb3RhdGlvbiwgZmFsc2UgKTtcclxuXHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcclxuXHJcbiAgICAgICAgdGhpcy5tYXRyaXggPSBuZXcgTWF0cml4NCgpO1xyXG4gICAgICAgIHRoaXMubWF0cml4V29ybGQgPSBuZXcgTWF0cml4NCgpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlTWF0cml4KCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHNldFBvc2l0aW9uKHBvc2l0aW9uKXtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICAgICAgdGhpcy51cGRhdGVNYXRyaXgoKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRSb3RhdGlvbihyb3RhdGlvbkFycmF5KXtcclxuICAgICAgICB0aGlzLnJvdGF0aW9uID0gbmV3IEV1bGVyKCkuZnJvbUFycmF5KHJvdGF0aW9uQXJyYXkpO1xyXG4gICAgICAgIHZhciBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKS5zZXRGcm9tRXVsZXIoIHRoaXMucm90YXRpb24sIGZhbHNlICk7XHJcbiAgICAgICAgdGhpcy5zZXRRdWF0ZXJuaW9uKHF1YXRlcm5pb24pO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFF1YXRlcm5pb24ocXVhdGVybmlvbil7XHJcblxyXG4gICAgICAgIHRoaXMucXVhdGVybmlvbiA9IHF1YXRlcm5pb247XHJcbiAgICAgICAgdGhpcy5yb3RhdGlvbi5zZXRGcm9tUXVhdGVybmlvbiggcXVhdGVybmlvbiwgdW5kZWZpbmVkLCBmYWxzZSApO1xyXG4gICAgICAgIHRoaXMudXBkYXRlTWF0cml4KCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0U2NhbGUoc2NhbGVBcnJheSl7XHJcbiAgICAgICAgdGhpcy5zY2FsZSA9IHNjYWxlQXJyYXk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVNYXRyaXgoKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVNYXRyaXgoKXtcclxuICAgICAgICB0aGlzLm1hdHJpeC5jb21wb3NlKCBuZXcgVmVjdG9yMygpLmZyb21BcnJheSh0aGlzLnBvc2l0aW9uKSwgdGhpcy5xdWF0ZXJuaW9uLCBuZXcgVmVjdG9yMygpLmZyb21BcnJheSh0aGlzLnNjYWxlKSApO1xyXG4gICAgICAgIHRoaXMudXBkYXRlTWF0cml4V29ybGQgKCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0TWF0cml4KG1hdHJpeCl7XHJcbiAgICAgICAgdGhpcy5tYXRyaXggPSBtYXRyaXg7XHJcbiAgICAgICAgdGhpcy51cGRhdGVNYXRyaXhXb3JsZCAoKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVNYXRyaXhXb3JsZCAoKSB7XHJcblxyXG4gICAgICAgIC8vIHRoaXMudXBkYXRlTWF0cml4KCk7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5wYXJlbnQgPT09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLm1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXguY2xvbmUoKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyggdGhpcy5wYXJlbnQubWF0cml4V29ybGQsIHRoaXMubWF0cml4ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGVDaGlsZHJlbk1hdHJpeFdvcmxkKCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGdldFdvcmxkUG9zaXRpb24oKSB7XHJcblxyXG4gICAgICAgIHZhciB0YXJnZXQgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuICAgICAgICAvLyB0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0YXJnZXQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZUNoaWxkcmVuTWF0cml4V29ybGQoKXtcclxuXHJcbiAgICAgICAgZm9yKHZhciBpIGluIHRoaXMuY2hpbGRyZW4pe1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBjbG9uZSgpe1xyXG4gICAgICAgIHZhciBtZXNoID0gbmV3IE1lc2goe1xyXG4gICAgICAgICAgICBnZW9tZXRyeTogdGhpcy5nZW9tZXRyeS5jbG9uZSgpLFxyXG4gICAgICAgICAgICBtYXRlcmlhbDogdGhpcy5tYXRlcmlhbC5jbG9uZSgpLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5wb3NpdGlvbi5zbGljZSgwKSxcclxuICAgICAgICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb24uY2xvbmUoKSxcclxuICAgICAgICAgICAgc2NhbGU6IHRoaXMuc2NhbGUuc2xpY2UoMClcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG1lc2g7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkKG1lc2gpe1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChtZXNoKTtcclxuICAgICAgICBtZXNoLnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgbWVzaC51cGRhdGVNYXRyaXgoKTtcclxuICAgIH1cclxuXHJcbiAgICByb3RhdGVPbkF4aXMgKGF4aXMsIGFuZ2xlKSB7XHJcblxyXG4gICAgICAgIHZhciBxMSA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcbiAgICAgICAgcTEuc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcclxuICAgICAgICB2YXIgcXVhdGVybmlvbiA9IHRoaXMucXVhdGVybmlvbi5tdWx0aXBseSggcTEgKTtcclxuICAgICAgICB0aGlzLnNldFF1YXRlcm5pb24ocXVhdGVybmlvbik7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJvdGF0ZVggKGFuZ2xlKSB7XHJcblxyXG4gICAgICAgIHRoaXMucm90YXRlT25BeGlzKCBuZXcgVmVjdG9yMygxLDAsMCksIGFuZ2xlICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJvdGF0ZVkgKGFuZ2xlKSB7XHJcblxyXG4gICAgICAgIHRoaXMucm90YXRlT25BeGlzKCBuZXcgVmVjdG9yMygwLDEsMCksIGFuZ2xlICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJvdGF0ZVogKGFuZ2xlKSB7XHJcblxyXG4gICAgICAgIHRoaXMucm90YXRlT25BeGlzKCBuZXcgVmVjdG9yMygwLDAsMSksIGFuZ2xlICk7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xyXG5cclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgICAgIHZhciBpbnZlcnNlTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcclxuICAgICAgICB2YXIgcmF5ID0gbmV3IFJheSgpO1xyXG4gICAgICAgIHZhciBzcGhlcmUgPSBuZXcgU3BoZXJlKCk7XHJcblxyXG4gICAgICAgIHZhciB2QSA9IG5ldyBWZWN0b3IzKCk7XHJcbiAgICAgICAgdmFyIHZCID0gbmV3IFZlY3RvcjMoKTtcclxuICAgICAgICB2YXIgdkMgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuICAgICAgICB2YXIgdGVtcEEgPSBuZXcgVmVjdG9yMygpO1xyXG4gICAgICAgIHZhciB0ZW1wQiA9IG5ldyBWZWN0b3IzKCk7XHJcbiAgICAgICAgdmFyIHRlbXBDID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgdmFyIHV2QSA9IG5ldyBWZWN0b3IyKCk7XHJcbiAgICAgICAgdmFyIHV2QiA9IG5ldyBWZWN0b3IyKCk7XHJcbiAgICAgICAgdmFyIHV2QyA9IG5ldyBWZWN0b3IyKCk7XHJcblxyXG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb25Qb2ludCA9IG5ldyBWZWN0b3IzKCk7XHJcbiAgICAgICAgdmFyIGludGVyc2VjdGlvblBvaW50V29ybGQgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBjaGVja0ludGVyc2VjdGlvbiggb2JqZWN0LCBtYXRlcmlhbCwgcmF5Y2FzdGVyLCByYXksIHBBLCBwQiwgcEMsIHBvaW50ICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGludGVyc2VjdDtcclxuXHJcbiAgICAgICAgICAgIGlmICggbWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKCBwQywgcEIsIHBBLCB0cnVlLCBwb2ludCApO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3QgPSByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIHBBLCBwQiwgcEMsIG1hdGVyaWFsLnNpZGUgIT09IERvdWJsZVNpZGUsIHBvaW50ICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIGludGVyc2VjdCA9PT0gbnVsbCApIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRXb3JsZC5jb3B5KCBwb2ludCApO1xyXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlLFxyXG4gICAgICAgICAgICAgICAgcG9pbnQ6IGludGVyc2VjdGlvblBvaW50V29ybGQuY2xvbmUoKSxcclxuICAgICAgICAgICAgICAgIG9iamVjdDogb2JqZWN0XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gY2hlY2tCdWZmZXJHZW9tZXRyeUludGVyc2VjdGlvbiggb2JqZWN0LCBtYXRlcmlhbCwgcmF5Y2FzdGVyLCByYXksIHBvc2l0aW9uLCB1diwgYSwgYiwgYyApIHtcclxuXHJcbiAgICAgICAgICAgIHZBLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBhICk7XHJcbiAgICAgICAgICAgIHZCLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBiICk7XHJcbiAgICAgICAgICAgIHZDLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBjICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gY2hlY2tJbnRlcnNlY3Rpb24oIG9iamVjdCwgbWF0ZXJpYWwsIHJheWNhc3RlciwgcmF5LCB2QSwgdkIsIHZDLCBpbnRlcnNlY3Rpb25Qb2ludCApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBpbnRlcnNlY3Rpb24gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCB1diApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdXZBLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2LCBhICk7XHJcbiAgICAgICAgICAgICAgICAgICAgdXZCLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2LCBiICk7XHJcbiAgICAgICAgICAgICAgICAgICAgdXZDLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2LCBjICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbi51diA9IFRyaWFuZ2xlLmdldFVWKCBpbnRlcnNlY3Rpb25Qb2ludCwgdkEsIHZCLCB2QywgdXZBLCB1dkIsIHV2QywgbmV3IFZlY3RvcjIoKSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZmFjZSA9IG5ldyBGYWNlMyggYSwgYiwgYyApO1xyXG4gICAgICAgICAgICAgICAgVHJpYW5nbGUuZ2V0Tm9ybWFsKCB2QSwgdkIsIHZDLCBmYWNlLm5vcm1hbCApO1xyXG5cclxuICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbi5mYWNlID0gZmFjZTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBpbnRlcnNlY3Rpb247XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcclxuICAgICAgICB2YXIgbWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xyXG4gICAgICAgIHZhciBtYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XHJcblxyXG4gICAgICAgIGlmICggbWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2tpbmcgYm91bmRpbmdTcGhlcmUgZGlzdGFuY2UgdG8gcmF5XHJcblxyXG4gICAgICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcclxuXHJcbiAgICAgICAgc3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XHJcbiAgICAgICAgc3BoZXJlLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcclxuXHJcbiAgICAgICAgdmFyIGJveDMgPSBuZXcgQm94MygpLmNvcHkoZ2VvbWV0cnkuYm91bmRpbmdCb3gpO1xyXG4gICAgICAgIGJveDMuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xyXG5cclxuICAgICAgICAvLyByYXljYXN0ZXIucmF5LmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApIHx8XHJcbiAgICAgICAgaWYgKCByYXljYXN0ZXIucmF5LmludGVyc2VjdHNCb3goIGJveDMgKSApIHtcclxuICAgICAgICAgICAgdmFyIHdvcmxkUG9zaXRpb24gPSBuZXcgVmVjdG9yMygpLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xyXG4gICAgICAgICAgICB0aGF0LmRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggd29ybGRQb3NpdGlvbiApO1xyXG4gICAgICAgICAgICBpbnRlcnNlY3RzLnB1c2godGhhdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIGludmVyc2VNYXRyaXguZ2V0SW52ZXJzZSggbWF0cml4V29ybGQgKTtcclxuICAgICAgICAvLyByYXkuY29weSggcmF5Y2FzdGVyLnJheSApLmFwcGx5TWF0cml4NCggaW52ZXJzZU1hdHJpeCApO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gLy8gQ2hlY2sgYm91bmRpbmdCb3ggYmVmb3JlIGNvbnRpbnVpbmdcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgaWYgKCByYXkuaW50ZXJzZWN0c0JveCggZ2VvbWV0cnkuYm91bmRpbmdCb3ggKSA9PT0gZmFsc2UgKSByZXR1cm47XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyB2YXIgaW50ZXJzZWN0aW9uO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gaWYgKCBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICkge1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgIHZhciBhLCBiLCBjO1xyXG4gICAgICAgIC8vICAgICB2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcclxuICAgICAgICAvLyAgICAgdmFyIHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuICAgICAgICAvLyAgICAgdmFyIHV2ID0gZ2VvbWV0cnkuYXR0cmlidXRlcy51djtcclxuICAgICAgICAvLyAgICAgdmFyIGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcclxuICAgICAgICAvLyAgICAgdmFyIGRyYXdSYW5nZSA9IGdlb21ldHJ5LmRyYXdSYW5nZTtcclxuICAgICAgICAvLyAgICAgdmFyIGksIGosIGlsLCBqbDtcclxuICAgICAgICAvLyAgICAgdmFyIGdyb3VwLCBncm91cE1hdGVyaWFsO1xyXG4gICAgICAgIC8vICAgICB2YXIgc3RhcnQsIGVuZDtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICBpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAvLyBpbmRleGVkIGJ1ZmZlciBnZW9tZXRyeVxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkoIG1hdGVyaWFsICkgKSB7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICBmb3IgKCBpID0gMCwgaWwgPSBncm91cHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgZ3JvdXAgPSBncm91cHNbIGkgXTtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsWyBncm91cC5tYXRlcmlhbEluZGV4IF07XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1heCggZ3JvdXAuc3RhcnQsIGRyYXdSYW5nZS5zdGFydCApO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICBlbmQgPSBNYXRoLm1pbiggKCBncm91cC5zdGFydCArIGdyb3VwLmNvdW50ICksICggZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50ICkgKTtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICBmb3IgKCBqID0gc3RhcnQsIGpsID0gZW5kOyBqIDwgamw7IGogKz0gMyApIHtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgYSA9IGluZGV4LmdldFgoIGogKTtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIGIgPSBpbmRleC5nZXRYKCBqICsgMSApO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgYyA9IGluZGV4LmdldFgoIGogKyAyICk7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbiA9IGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24oIHRoaXMsIGdyb3VwTWF0ZXJpYWwsIHJheWNhc3RlciwgcmF5LCBwb3NpdGlvbiwgdXYsIGEsIGIsIGMgKTtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgaWYgKCBpbnRlcnNlY3Rpb24gKSB7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gTWF0aC5mbG9vciggaiAvIDMgKTsgLy8gdHJpYW5nbGUgbnVtYmVyIGluIGluZGV4ZWQgYnVmZmVyIHNlbWFudGljc1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0aW9uICk7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICB9XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICBzdGFydCA9IE1hdGgubWF4KCAwLCBkcmF3UmFuZ2Uuc3RhcnQgKTtcclxuICAgICAgICAvLyAgICAgICAgICAgICBlbmQgPSBNYXRoLm1pbiggaW5kZXguY291bnQsICggZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50ICkgKTtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIGZvciAoIGkgPSBzdGFydCwgaWwgPSBlbmQ7IGkgPCBpbDsgaSArPSAzICkge1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIGEgPSBpbmRleC5nZXRYKCBpICk7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIGIgPSBpbmRleC5nZXRYKCBpICsgMSApO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICBjID0gaW5kZXguZ2V0WCggaSArIDIgKTtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb24gPSBjaGVja0J1ZmZlckdlb21ldHJ5SW50ZXJzZWN0aW9uKCB0aGlzLCBtYXRlcmlhbCwgcmF5Y2FzdGVyLCByYXksIHBvc2l0aW9uLCB1diwgYSwgYiwgYyApO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIGlmICggaW50ZXJzZWN0aW9uICkge1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gTWF0aC5mbG9vciggaSAvIDMgKTsgLy8gdHJpYW5nbGUgbnVtYmVyIGluIGluZGV4ZWQgYnVmZmVyIHNlbWFudGljc1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3Rpb24gKTtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICB9XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgIH1cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICB9IGVsc2UgaWYgKCBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAvLyBub24taW5kZXhlZCBidWZmZXIgZ2VvbWV0cnlcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KCBtYXRlcmlhbCApICkge1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgZm9yICggaSA9IDAsIGlsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIGdyb3VwID0gZ3JvdXBzWyBpIF07XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbFsgZ3JvdXAubWF0ZXJpYWxJbmRleCBdO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoIGdyb3VwLnN0YXJ0LCBkcmF3UmFuZ2Uuc3RhcnQgKTtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgZW5kID0gTWF0aC5taW4oICggZ3JvdXAuc3RhcnQgKyBncm91cC5jb3VudCApLCAoIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCApICk7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgZm9yICggaiA9IHN0YXJ0LCBqbCA9IGVuZDsgaiA8IGpsOyBqICs9IDMgKSB7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIGEgPSBqO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgYiA9IGogKyAxO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgYyA9IGogKyAyO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb24gPSBjaGVja0J1ZmZlckdlb21ldHJ5SW50ZXJzZWN0aW9uKCB0aGlzLCBncm91cE1hdGVyaWFsLCByYXljYXN0ZXIsIHJheSwgcG9zaXRpb24sIHV2LCBhLCBiLCBjICk7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIGlmICggaW50ZXJzZWN0aW9uICkge1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IE1hdGguZmxvb3IoIGogLyAzICk7IC8vIHRyaWFuZ2xlIG51bWJlciBpbiBub24taW5kZXhlZCBidWZmZXIgc2VtYW50aWNzXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3Rpb24gKTtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIH1cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoIDAsIGRyYXdSYW5nZS5zdGFydCApO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKCBwb3NpdGlvbi5jb3VudCwgKCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQgKSApO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgZm9yICggaSA9IHN0YXJ0LCBpbCA9IGVuZDsgaSA8IGlsOyBpICs9IDMgKSB7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgYSA9IGk7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIGIgPSBpICsgMTtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgYyA9IGkgKyAyO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbiA9IGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24oIHRoaXMsIG1hdGVyaWFsLCByYXljYXN0ZXIsIHJheSwgcG9zaXRpb24sIHV2LCBhLCBiLCBjICk7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgaWYgKCBpbnRlcnNlY3Rpb24gKSB7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbi5mYWNlSW5kZXggPSBNYXRoLmZsb29yKCBpIC8gMyApOyAvLyB0cmlhbmdsZSBudW1iZXIgaW4gbm9uLWluZGV4ZWQgYnVmZmVyIHNlbWFudGljc1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3Rpb24gKTtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICB9XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgIH1cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyB9IGVsc2UgaWYgKCBnZW9tZXRyeS5pc0dlb21ldHJ5ICkge1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgIHZhciBmdkEsIGZ2QiwgZnZDO1xyXG4gICAgICAgIC8vICAgICB2YXIgaXNNdWx0aU1hdGVyaWFsID0gQXJyYXkuaXNBcnJheSggbWF0ZXJpYWwgKTtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcclxuICAgICAgICAvLyAgICAgdmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XHJcbiAgICAgICAgLy8gICAgIHZhciB1dnM7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgdmFyIGZhY2VWZXJ0ZXhVdnMgPSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyAwIF07XHJcbiAgICAgICAgLy8gICAgIGlmICggZmFjZVZlcnRleFV2cy5sZW5ndGggPiAwICkgdXZzID0gZmFjZVZlcnRleFV2cztcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICBmb3IgKCB2YXIgZiA9IDAsIGZsID0gZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgIHZhciBmYWNlID0gZmFjZXNbIGYgXTtcclxuICAgICAgICAvLyAgICAgICAgIHZhciBmYWNlTWF0ZXJpYWwgPSBpc011bHRpTWF0ZXJpYWwgPyBtYXRlcmlhbFsgZmFjZS5tYXRlcmlhbEluZGV4IF0gOiBtYXRlcmlhbDtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgaWYgKCBmYWNlTWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICBmdkEgPSB2ZXJ0aWNlc1sgZmFjZS5hIF07XHJcbiAgICAgICAgLy8gICAgICAgICBmdkIgPSB2ZXJ0aWNlc1sgZmFjZS5iIF07XHJcbiAgICAgICAgLy8gICAgICAgICBmdkMgPSB2ZXJ0aWNlc1sgZmFjZS5jIF07XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgIGlmICggZmFjZU1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9PT0gdHJ1ZSApIHtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIHZhciBtb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHM7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgdmFyIG1vcnBoSW5mbHVlbmNlcyA9IHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgdkEuc2V0KCAwLCAwLCAwICk7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgdkIuc2V0KCAwLCAwLCAwICk7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgdkMuc2V0KCAwLCAwLCAwICk7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICBmb3IgKCB2YXIgdCA9IDAsIHRsID0gbW9ycGhUYXJnZXRzLmxlbmd0aDsgdCA8IHRsOyB0ICsrICkge1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHZhciBpbmZsdWVuY2UgPSBtb3JwaEluZmx1ZW5jZXNbIHQgXTtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICBpZiAoIGluZmx1ZW5jZSA9PT0gMCApIGNvbnRpbnVlO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHZhciB0YXJnZXRzID0gbW9ycGhUYXJnZXRzWyB0IF0udmVydGljZXM7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgdkEuYWRkU2NhbGVkVmVjdG9yKCB0ZW1wQS5zdWJWZWN0b3JzKCB0YXJnZXRzWyBmYWNlLmEgXSwgZnZBICksIGluZmx1ZW5jZSApO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB2Qi5hZGRTY2FsZWRWZWN0b3IoIHRlbXBCLnN1YlZlY3RvcnMoIHRhcmdldHNbIGZhY2UuYiBdLCBmdkIgKSwgaW5mbHVlbmNlICk7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHZDLmFkZFNjYWxlZFZlY3RvciggdGVtcEMuc3ViVmVjdG9ycyggdGFyZ2V0c1sgZmFjZS5jIF0sIGZ2QyApLCBpbmZsdWVuY2UgKTtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIH1cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIHZBLmFkZCggZnZBICk7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgdkIuYWRkKCBmdkIgKTtcclxuICAgICAgICAvLyAgICAgICAgICAgICB2Qy5hZGQoIGZ2QyApO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgZnZBID0gdkE7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgZnZCID0gdkI7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgZnZDID0gdkM7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgIH1cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgaW50ZXJzZWN0aW9uID0gY2hlY2tJbnRlcnNlY3Rpb24oIHRoaXMsIGZhY2VNYXRlcmlhbCwgcmF5Y2FzdGVyLCByYXksIGZ2QSwgZnZCLCBmdkMsIGludGVyc2VjdGlvblBvaW50ICk7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgIGlmICggaW50ZXJzZWN0aW9uICkge1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgaWYgKCB1dnMgJiYgdXZzWyBmIF0gKSB7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgdmFyIHV2c19mID0gdXZzWyBmIF07XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHV2QS5jb3B5KCB1dnNfZlsgMCBdICk7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHV2Qi5jb3B5KCB1dnNfZlsgMSBdICk7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHV2Qy5jb3B5KCB1dnNfZlsgMiBdICk7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uLnV2ID0gVHJpYW5nbGUuZ2V0VVYoIGludGVyc2VjdGlvblBvaW50LCBmdkEsIGZ2QiwgZnZDLCB1dkEsIHV2QiwgdXZDLCBuZXcgVmVjdG9yMigpICk7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICB9XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICBpbnRlcnNlY3Rpb24uZmFjZSA9IGZhY2U7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgaW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IGY7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgaW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3Rpb24gKTtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgfVxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIH1cclxuXHJcbiAgICB9XHJcblxyXG5cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1lc2g7XHJcbiIsIlxyXG5pbXBvcnQge01hdHJpeDR9IGZyb20gXCIuLi9tYXRoL01hdHJpeDRcIjtcclxuaW1wb3J0IHtWZWN0b3IzfSBmcm9tIFwiLi4vbWF0aC9WZWN0b3IzXCI7XHJcbmltcG9ydCB7UXVhdGVybmlvbn0gZnJvbSBcIi4uL21hdGgvUXVhdGVybmlvblwiO1xyXG5cclxuY2xhc3MgQ2FtZXJhIHtcclxuICAgIGNvbnN0cnVjdG9yKGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIpIHtcclxuICAgICAgICB0aGlzLmZvdiA9IGZvdjtcclxuICAgICAgICB0aGlzLmFzcGVjdCA9IGFzcGVjdDtcclxuICAgICAgICB0aGlzLm5lYXIgPSBuZWFyO1xyXG4gICAgICAgIHRoaXMuZmFyID0gZmFyO1xyXG5cclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gWzAsIDAsIDEwXTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IFswLDAsMF07XHJcbiAgICAgICAgdGhpcy51cCA9IFswLDEsMF07XHJcblxyXG4gICAgICAgIHRoaXMuVlBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xyXG5cclxuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IFswLDAsLTFdO1xyXG4gICAgICAgIHRoaXMucmlnaHQgPSBbMSwwLDBdO1xyXG5cclxuICAgICAgICB0aGlzLnNjYWxlID0gWzEsMSwxXTtcclxuICAgICAgICB0aGlzLnF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xyXG4gICAgICAgIHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcclxuICAgICAgICB0aGlzLm1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXg7XHJcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGVBbGwoKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVBbGwoKXtcclxuICAgICAgICB0aGlzLnVwZGF0ZU9wdGlvbigpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlTWF0cml4KCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVWUE1hdHJpeCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZU1hdHJpeCgpe1xyXG4gICAgICAgIHZhciBxdWF0ZXJuaW9uRCA9IG5ldyBRdWF0ZXJuaW9uKCkuc2V0RnJvbVVuaXRWZWN0b3JzKG5ldyBWZWN0b3IzKDAsMCwtMSksIG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KHRoaXMuZGlyZWN0aW9uKSk7XHJcbiAgICAgICAgdmFyIHJpZ2h0MiA9IG5ldyBWZWN0b3IzKDEsMCwwKS5hcHBseVF1YXRlcm5pb24ocXVhdGVybmlvbkQpO1xyXG4gICAgICAgIHZhciBxdWF0ZXJuaW9uUiA9IG5ldyBRdWF0ZXJuaW9uKCkuc2V0RnJvbVVuaXRWZWN0b3JzKHJpZ2h0MiwgbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkodGhpcy5yaWdodCkpO1xyXG4gICAgICAgIHZhciBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKS5tdWx0aXBseVF1YXRlcm5pb25zKHF1YXRlcm5pb25SLCBxdWF0ZXJuaW9uRCk7XHJcbiAgICAgICAgdGhpcy5xdWF0ZXJuaW9uID0gcXVhdGVybmlvbjtcclxuXHJcbiAgICAgICAgdGhpcy5tYXRyaXguY29tcG9zZSggbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkodGhpcy5wb3NpdGlvbiksIHRoaXMucXVhdGVybmlvbiwgbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkodGhpcy5zY2FsZSkgKTtcclxuICAgICAgICB0aGlzLnByb2plY3Rpb25NYXRyaXggPSBuZXcgTWF0cml4NCgpLnNldFBlcnNwZWN0aXZlKHRoaXMuZm92LCB0aGlzLmFzcGVjdCwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XHJcbiAgICAgICAgLy8gdGhpcy51cGRhdGVNYXRyaXhXb3JsZCAoKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVPcHRpb24oKXtcclxuICAgICAgICB2YXIgdGFyZ2V0VjMgPSBuZXcgVmVjdG9yMygpLmZyb21BcnJheSh0aGlzLnRhcmdldCk7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uVjMgPSBuZXcgVmVjdG9yMygpLmZyb21BcnJheSh0aGlzLnBvc2l0aW9uKTtcclxuICAgICAgICB2YXIgdXBWMyA9IG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KHRoaXMudXApO1xyXG5cclxuICAgICAgICB2YXIgZGlyZWN0aW9uVjMgPSBuZXcgVmVjdG9yMygpLnN1YlZlY3RvcnModGFyZ2V0VjMsIHBvc2l0aW9uVjMpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uVjMudG9BcnJheSgpO1xyXG5cclxuICAgICAgICB2YXIgcmlnaHRWMyA9IG5ldyBWZWN0b3IzKCkuY3Jvc3NWZWN0b3JzKGRpcmVjdGlvblYzLCB1cFYzKS5ub3JtYWxpemUoKTtcclxuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHRWMy50b0FycmF5KCk7XHJcblxyXG4gICAgICAgIC8vIHRoaXMudXAgPSBuZXcgVmVjdG9yMygpLmNyb3NzVmVjdG9ycyhyaWdodFYzLCBkaXJlY3Rpb25WMykubm9ybWFsaXplKCkudG9BcnJheSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFBvc2l0aW9uKHBvc2l0aW9uKXtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICAgICAgdGhpcy51cGRhdGVBbGwoKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRUYXJnZXQodGFyZ2V0KXtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aGlzLnVwZGF0ZUFsbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFVwKHVwKXtcclxuICAgICAgICB0aGlzLnVwID0gbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkodXApLm5vcm1hbGl6ZSgpLnRvQXJyYXkoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUFsbCgpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgdXBkYXRlVlBNYXRyaXgoKXtcclxuICAgICAgICB0aGlzLlZQbWF0cml4ID0gbmV3IE1hdHJpeDQoKS5zZXRQZXJzcGVjdGl2ZSh0aGlzLmZvdiwgdGhpcy5hc3BlY3QsIHRoaXMubmVhciwgdGhpcy5mYXIpO1xyXG4gICAgICAgIHZhciBWbWF0cml4ID0gbmV3IE1hdHJpeDQoKS5nZXRJbnZlcnNlKHRoaXMubWF0cml4KTtcclxuICAgICAgICB0aGlzLlZQbWF0cml4LmNvbmNhdChWbWF0cml4KTtcclxuICAgICAgICAvL+etieS7t1xyXG4gICAgICAgIC8vIHRoaXMuVlBtYXRyaXgubG9va0F0Mih0aGlzLnBvc2l0aW9uWzBdLHRoaXMucG9zaXRpb25bMV0sdGhpcy5wb3NpdGlvblsyXSwgdGhpcy50YXJnZXRbMF0sdGhpcy50YXJnZXRbMV0sdGhpcy50YXJnZXRbMl0sIHRoaXMudXBbMF0sdGhpcy51cFsxXSx0aGlzLnVwWzJdKTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IENhbWVyYTtcclxuXHJcbiIsIi8qXHJcbiAqIENvcHlyaWdodCAyMDEwLCBHb29nbGUgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcclxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxyXG4gKiBtZXQ6XHJcbiAqXHJcbiAqICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XHJcbiAqIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuICogICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxyXG4gKiBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyXHJcbiAqIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcclxuICogZGlzdHJpYnV0aW9uLlxyXG4gKiAgICAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdvb2dsZSBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzXHJcbiAqIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXHJcbiAqIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXHJcbiAqXHJcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcclxuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxyXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcclxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcclxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXHJcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcclxuICogTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXHJcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxyXG4gKiBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXHJcbiAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxyXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG4gKi9cclxuXHJcblxyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBUaGlzIGZpbGUgY29udGFpbnMgZnVuY3Rpb25zIGV2ZXJ5IHdlYmdsIHByb2dyYW0gd2lsbCBuZWVkXHJcbiAqIGEgdmVyc2lvbiBvZiBvbmUgd2F5IG9yIGFub3RoZXIuXHJcbiAqXHJcbiAqIEluc3RlYWQgb2Ygc2V0dGluZyB1cCBhIGNvbnRleHQgbWFudWFsbHkgaXQgaXMgcmVjb21tZW5kZWQgdG9cclxuICogdXNlLiBUaGlzIHdpbGwgY2hlY2sgZm9yIHN1Y2Nlc3Mgb3IgZmFpbHVyZS4gT24gZmFpbHVyZSBpdFxyXG4gKiB3aWxsIGF0dGVtcHQgdG8gcHJlc2VudCBhbiBhcHByb3JpYXRlIG1lc3NhZ2UgdG8gdGhlIHVzZXIuXHJcbiAqXHJcbiAqICAgICAgIGdsID0gV2ViR0xVdGlscy5zZXR1cFdlYkdMKGNhbnZhcyk7XHJcbiAqXHJcbiAqIEZvciBhbmltYXRlZCBXZWJHTCBhcHBzIHVzZSBvZiBzZXRUaW1lb3V0IG9yIHNldEludGVydmFsIGFyZVxyXG4gKiBkaXNjb3VyYWdlZC4gSXQgaXMgcmVjb21tZW5kZWQgeW91IHN0cnVjdHVyZSB5b3VyIHJlbmRlcmluZ1xyXG4gKiBsb29wIGxpa2UgdGhpcy5cclxuICpcclxuICogICAgICAgZnVuY3Rpb24gcmVuZGVyKCkge1xyXG4gKiAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyLCBjYW52YXMpO1xyXG4gKlxyXG4gKiAgICAgICAgIC8vIGRvIHJlbmRlcmluZ1xyXG4gKiAgICAgICAgIC4uLlxyXG4gKiAgICAgICB9XHJcbiAqICAgICAgIHJlbmRlcigpO1xyXG4gKlxyXG4gKiBUaGlzIHdpbGwgY2FsbCB5b3VyIHJlbmRlcmluZyBmdW5jdGlvbiB1cCB0byB0aGUgcmVmcmVzaCByYXRlXHJcbiAqIG9mIHlvdXIgZGlzcGxheSBidXQgd2lsbCBzdG9wIHJlbmRlcmluZyBpZiB5b3VyIGFwcCBpcyBub3RcclxuICogdmlzaWJsZS5cclxuICovXHJcblxyXG52YXIgV2ViR0xVdGlscyA9IGZ1bmN0aW9uKCkge1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgdGhlIEhUTE0gZm9yIGEgZmFpbHVyZSBtZXNzYWdlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjYW52YXNDb250YWluZXJJZCBpZCBvZiBjb250YWluZXIgb2YgdGhcclxuICogICAgICAgIGNhbnZhcy5cclxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgaHRtbC5cclxuICovXHJcbnZhciBtYWtlRmFpbEhUTUwgPSBmdW5jdGlvbihtc2cpIHtcclxuICByZXR1cm4gJycgK1xyXG4gICAgICAgICc8ZGl2IHN0eWxlPVwibWFyZ2luOiBhdXRvOyB3aWR0aDo1MDBweDt6LWluZGV4OjEwMDAwO21hcmdpbi10b3A6MjBlbTt0ZXh0LWFsaWduOmNlbnRlcjtcIj4nICsgbXNnICsgJzwvZGl2Pic7XHJcbiAgcmV0dXJuICcnICtcclxuICAgICc8dGFibGUgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOiAjOENFOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlO1wiPjx0cj4nICtcclxuICAgICc8dGQgYWxpZ249XCJjZW50ZXJcIj4nICtcclxuICAgICc8ZGl2IHN0eWxlPVwiZGlzcGxheTogdGFibGUtY2VsbDsgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcIj4nICtcclxuICAgICc8ZGl2IHN0eWxlPVwiXCI+JyArIG1zZyArICc8L2Rpdj4nICtcclxuICAgICc8L2Rpdj4nICtcclxuICAgICc8L3RkPjwvdHI+PC90YWJsZT4nO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1lc2FzZ2UgZm9yIGdldHRpbmcgYSB3ZWJnbCBicm93c2VyXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xyXG52YXIgR0VUX0FfV0VCR0xfQlJPV1NFUiA9ICcnICtcclxuICAnVGhpcyBwYWdlIHJlcXVpcmVzIGEgYnJvd3NlciB0aGF0IHN1cHBvcnRzIFdlYkdMLjxici8+JyArXHJcbiAgJzxhIGhyZWY9XCJodHRwOi8vZ2V0LndlYmdsLm9yZ1wiPkNsaWNrIGhlcmUgdG8gdXBncmFkZSB5b3VyIGJyb3dzZXIuPC9hPic7XHJcblxyXG4vKipcclxuICogTWVzYXNnZSBmb3IgbmVlZCBiZXR0ZXIgaGFyZHdhcmVcclxuICogQHR5cGUge3N0cmluZ31cclxuICovXHJcbnZhciBPVEhFUl9QUk9CTEVNID0gJycgK1xyXG4gIFwiSXQgZG9lc24ndCBhcHBlYXIgeW91ciBjb21wdXRlciBjYW4gc3VwcG9ydCBXZWJHTC48YnIvPlwiICtcclxuICAnPGEgaHJlZj1cImh0dHA6Ly9nZXQud2ViZ2wub3JnXCI+Q2xpY2sgaGVyZSBmb3IgbW9yZSBpbmZvcm1hdGlvbi48L2E+JztcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgd2ViZ2wgY29udGV4dC4gSWYgY3JlYXRpb24gZmFpbHMgaXQgd2lsbFxyXG4gKiBjaGFuZ2UgdGhlIGNvbnRlbnRzIG9mIHRoZSBjb250YWluZXIgb2YgdGhlIDxjYW52YXM+XHJcbiAqIHRhZyB0byBhbiBlcnJvciBtZXNzYWdlIHdpdGggdGhlIGNvcnJlY3QgbGlua3MgZm9yIFdlYkdMLlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNhbnZhcy4gVGhlIGNhbnZhcyBlbGVtZW50IHRvIGNyZWF0ZSBhXHJcbiAqICAgICBjb250ZXh0IGZyb20uXHJcbiAqIEBwYXJhbSB7V2ViR0xDb250ZXh0Q3JlYXRpb25BdHRpcmJ1dGVzfSBvcHRfYXR0cmlicyBBbnlcclxuICogICAgIGNyZWF0aW9uIGF0dHJpYnV0ZXMgeW91IHdhbnQgdG8gcGFzcyBpbi5cclxuICogQHBhcmFtIHtmdW5jdGlvbjoobXNnKX0gb3B0X29uRXJyb3IgQW4gZnVuY3Rpb24gdG8gY2FsbFxyXG4gKiAgICAgaWYgdGhlcmUgaXMgYW4gZXJyb3IgZHVyaW5nIGNyZWF0aW9uLlxyXG4gKiBAcmV0dXJuIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjcmVhdGVkIGNvbnRleHQuXHJcbiAqL1xyXG52YXIgc2V0dXBXZWJHTCA9IGZ1bmN0aW9uKGNhbnZhcywgb3B0X2F0dHJpYnMsIG9wdF9vbkVycm9yKSB7XHJcbiAgZnVuY3Rpb24gaGFuZGxlQ3JlYXRpb25FcnJvcihtc2cpIHtcclxuICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYm9keVwiKVswXTtcclxuICAgIC8vdmFyIGNvbnRhaW5lciA9IGNhbnZhcy5wYXJlbnROb2RlO1xyXG4gICAgaWYgKGNvbnRhaW5lcikge1xyXG4gICAgICB2YXIgc3RyID0gd2luZG93LldlYkdMUmVuZGVyaW5nQ29udGV4dCA/XHJcbiAgICAgICAgICAgT1RIRVJfUFJPQkxFTSA6XHJcbiAgICAgICAgICAgR0VUX0FfV0VCR0xfQlJPV1NFUjtcclxuICAgICAgaWYgKG1zZykge1xyXG4gICAgICAgIHN0ciArPSBcIjxici8+PGJyLz5TdGF0dXM6IFwiICsgbXNnO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBtYWtlRmFpbEhUTUwoc3RyKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBvcHRfb25FcnJvciA9IG9wdF9vbkVycm9yIHx8IGhhbmRsZUNyZWF0aW9uRXJyb3I7XHJcblxyXG4gIGlmIChjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcikge1xyXG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRjcmVhdGlvbmVycm9yXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgICBvcHRfb25FcnJvcihldmVudC5zdGF0dXNNZXNzYWdlKTtcclxuICAgICAgICB9LCBmYWxzZSk7XHJcbiAgfVxyXG4gIHZhciBjb250ZXh0ID0gY3JlYXRlM0RDb250ZXh0KGNhbnZhcywgb3B0X2F0dHJpYnMpO1xyXG4gIGlmICghY29udGV4dCkge1xyXG4gICAgaWYgKCF3aW5kb3cuV2ViR0xSZW5kZXJpbmdDb250ZXh0KSB7XHJcbiAgICAgIG9wdF9vbkVycm9yKFwiXCIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgb3B0X29uRXJyb3IoXCJcIik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gY29udGV4dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgd2ViZ2wgY29udGV4dC5cclxuICogQHBhcmFtIHshQ2FudmFzfSBjYW52YXMgVGhlIGNhbnZhcyB0YWcgdG8gZ2V0IGNvbnRleHRcclxuICogICAgIGZyb20uIElmIG9uZSBpcyBub3QgcGFzc2VkIGluIG9uZSB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAqIEByZXR1cm4geyFXZWJHTENvbnRleHR9IFRoZSBjcmVhdGVkIGNvbnRleHQuXHJcbiAqL1xyXG52YXIgY3JlYXRlM0RDb250ZXh0ID0gZnVuY3Rpb24oY2FudmFzLCBvcHRfYXR0cmlicykge1xyXG4gIHZhciBuYW1lcyA9IFtcIndlYmdsXCIsIFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsIFwid2Via2l0LTNkXCIsIFwibW96LXdlYmdsXCJdO1xyXG4gIHZhciBjb250ZXh0ID0gbnVsbDtcclxuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbmFtZXMubGVuZ3RoOyArK2lpKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQobmFtZXNbaWldLCBvcHRfYXR0cmlicyk7XHJcbiAgICB9IGNhdGNoKGUpIHt9XHJcbiAgICBpZiAoY29udGV4dCkge1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGNvbnRleHQ7XHJcbn1cclxuXHJcbnJldHVybiB7XHJcbiAgY3JlYXRlM0RDb250ZXh0OiBjcmVhdGUzRENvbnRleHQsXHJcbiAgc2V0dXBXZWJHTDogc2V0dXBXZWJHTFxyXG59O1xyXG59KCk7XHJcblxyXG4vKipcclxuICogUHJvdmlkZXMgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGluIGEgY3Jvc3MgYnJvd3NlclxyXG4gKiB3YXkuXHJcbiAqL1xyXG5pZiAoIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcclxuICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuICAgICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XHJcbiAgICAgICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICAgICAgIHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XHJcbiAgICAgICAgICAgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XHJcbiAgICAgICAgICAgZnVuY3Rpb24oLyogZnVuY3Rpb24gRnJhbWVSZXF1ZXN0Q2FsbGJhY2sgKi8gY2FsbGJhY2ssIC8qIERPTUVsZW1lbnQgRWxlbWVudCAqLyBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMC82MCk7XHJcbiAgICAgICAgICAgfTtcclxuICB9KSgpO1xyXG59XHJcblxyXG4vKiogKiBFUlJBVEE6ICdjYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnIHJlbmFtZWQgdG8gJ2NhbmNlbEFuaW1hdGlvbkZyYW1lJyB0byByZWZsZWN0IGFuIHVwZGF0ZSB0byB0aGUgVzNDIEFuaW1hdGlvbi1UaW1pbmcgU3BlYy4gXHJcbiAqIFxyXG4gKiBDYW5jZWxzIGFuIGFuaW1hdGlvbiBmcmFtZSByZXF1ZXN0LiBcclxuICogQ2hlY2tzIGZvciBjcm9zcy1icm93c2VyIHN1cHBvcnQsIGZhbGxzIGJhY2sgdG8gY2xlYXJUaW1lb3V0LiBcclxuICogQHBhcmFtIHtudW1iZXJ9ICBBbmltYXRpb24gZnJhbWUgcmVxdWVzdC4gKi9cclxuaWYgKCF3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcclxuICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSAod2luZG93LmNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdENhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1vekNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubXNDYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm9DYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cub0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgV2ViR0xVdGlsczsiLCIvL0NvcHlyaWdodCAoYykgMjAwOSBUaGUgQ2hyb21pdW0gQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy9Vc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXHJcbi8vZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZS5cclxuXHJcbi8vIFZhcmlvdXMgZnVuY3Rpb25zIGZvciBoZWxwaW5nIGRlYnVnIFdlYkdMIGFwcHMuXHJcblxyXG52YXIgV2ViR0xEZWJ1Z1V0aWxzID0gZnVuY3Rpb24oKSB7XHJcblxyXG4vKipcclxuICogV3JhcHBlZCBsb2dnaW5nIGZ1bmN0aW9uLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbXNnIE1lc3NhZ2UgdG8gbG9nLlxyXG4gKi9cclxudmFyIGxvZyA9IGZ1bmN0aW9uKG1zZykge1xyXG4gIGlmICh3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS5sb2cpIHtcclxuICAgIHdpbmRvdy5jb25zb2xlLmxvZyhtc2cpO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBXaGljaCBhcmd1ZW1lbnRzIGFyZSBlbnVtcy5cclxuICogQHR5cGUgeyFPYmplY3QuPG51bWJlciwgc3RyaW5nPn1cclxuICovXHJcbnZhciBnbFZhbGlkRW51bUNvbnRleHRzID0ge1xyXG5cclxuICAvLyBHZW5lcmljIHNldHRlcnMgYW5kIGdldHRlcnNcclxuXHJcbiAgJ2VuYWJsZSc6IHsgMDp0cnVlIH0sXHJcbiAgJ2Rpc2FibGUnOiB7IDA6dHJ1ZSB9LFxyXG4gICdnZXRQYXJhbWV0ZXInOiB7IDA6dHJ1ZSB9LFxyXG5cclxuICAvLyBSZW5kZXJpbmdcclxuXHJcbiAgJ2RyYXdBcnJheXMnOiB7IDA6dHJ1ZSB9LFxyXG4gICdkcmF3RWxlbWVudHMnOiB7IDA6dHJ1ZSwgMjp0cnVlIH0sXHJcblxyXG4gIC8vIFNoYWRlcnNcclxuXHJcbiAgJ2NyZWF0ZVNoYWRlcic6IHsgMDp0cnVlIH0sXHJcbiAgJ2dldFNoYWRlclBhcmFtZXRlcic6IHsgMTp0cnVlIH0sXHJcbiAgJ2dldFByb2dyYW1QYXJhbWV0ZXInOiB7IDE6dHJ1ZSB9LFxyXG5cclxuICAvLyBWZXJ0ZXggYXR0cmlidXRlc1xyXG5cclxuICAnZ2V0VmVydGV4QXR0cmliJzogeyAxOnRydWUgfSxcclxuICAndmVydGV4QXR0cmliUG9pbnRlcic6IHsgMjp0cnVlIH0sXHJcblxyXG4gIC8vIFRleHR1cmVzXHJcblxyXG4gICdiaW5kVGV4dHVyZSc6IHsgMDp0cnVlIH0sXHJcbiAgJ2FjdGl2ZVRleHR1cmUnOiB7IDA6dHJ1ZSB9LFxyXG4gICdnZXRUZXhQYXJhbWV0ZXInOiB7IDA6dHJ1ZSwgMTp0cnVlIH0sXHJcbiAgJ3RleFBhcmFtZXRlcmYnOiB7IDA6dHJ1ZSwgMTp0cnVlIH0sXHJcbiAgJ3RleFBhcmFtZXRlcmknOiB7IDA6dHJ1ZSwgMTp0cnVlLCAyOnRydWUgfSxcclxuICAndGV4SW1hZ2UyRCc6IHsgMDp0cnVlLCAyOnRydWUsIDY6dHJ1ZSwgNzp0cnVlIH0sXHJcbiAgJ3RleFN1YkltYWdlMkQnOiB7IDA6dHJ1ZSwgNjp0cnVlLCA3OnRydWUgfSxcclxuICAnY29weVRleEltYWdlMkQnOiB7IDA6dHJ1ZSwgMjp0cnVlIH0sXHJcbiAgJ2NvcHlUZXhTdWJJbWFnZTJEJzogeyAwOnRydWUgfSxcclxuICAnZ2VuZXJhdGVNaXBtYXAnOiB7IDA6dHJ1ZSB9LFxyXG5cclxuICAvLyBCdWZmZXIgb2JqZWN0c1xyXG5cclxuICAnYmluZEJ1ZmZlcic6IHsgMDp0cnVlIH0sXHJcbiAgJ2J1ZmZlckRhdGEnOiB7IDA6dHJ1ZSwgMjp0cnVlIH0sXHJcbiAgJ2J1ZmZlclN1YkRhdGEnOiB7IDA6dHJ1ZSB9LFxyXG4gICdnZXRCdWZmZXJQYXJhbWV0ZXInOiB7IDA6dHJ1ZSwgMTp0cnVlIH0sXHJcblxyXG4gIC8vIFJlbmRlcmJ1ZmZlcnMgYW5kIGZyYW1lYnVmZmVyc1xyXG5cclxuICAncGl4ZWxTdG9yZWknOiB7IDA6dHJ1ZSwgMTp0cnVlIH0sXHJcbiAgJ3JlYWRQaXhlbHMnOiB7IDQ6dHJ1ZSwgNTp0cnVlIH0sXHJcbiAgJ2JpbmRSZW5kZXJidWZmZXInOiB7IDA6dHJ1ZSB9LFxyXG4gICdiaW5kRnJhbWVidWZmZXInOiB7IDA6dHJ1ZSB9LFxyXG4gICdjaGVja0ZyYW1lYnVmZmVyU3RhdHVzJzogeyAwOnRydWUgfSxcclxuICAnZnJhbWVidWZmZXJSZW5kZXJidWZmZXInOiB7IDA6dHJ1ZSwgMTp0cnVlLCAyOnRydWUgfSxcclxuICAnZnJhbWVidWZmZXJUZXh0dXJlMkQnOiB7IDA6dHJ1ZSwgMTp0cnVlLCAyOnRydWUgfSxcclxuICAnZ2V0RnJhbWVidWZmZXJBdHRhY2htZW50UGFyYW1ldGVyJzogeyAwOnRydWUsIDE6dHJ1ZSwgMjp0cnVlIH0sXHJcbiAgJ2dldFJlbmRlcmJ1ZmZlclBhcmFtZXRlcic6IHsgMDp0cnVlLCAxOnRydWUgfSxcclxuICAncmVuZGVyYnVmZmVyU3RvcmFnZSc6IHsgMDp0cnVlLCAxOnRydWUgfSxcclxuXHJcbiAgLy8gRnJhbWUgYnVmZmVyIG9wZXJhdGlvbnMgKGNsZWFyLCBibGVuZCwgZGVwdGggdGVzdCwgc3RlbmNpbClcclxuXHJcbiAgJ2NsZWFyJzogeyAwOnRydWUgfSxcclxuICAnZGVwdGhGdW5jJzogeyAwOnRydWUgfSxcclxuICAnYmxlbmRGdW5jJzogeyAwOnRydWUsIDE6dHJ1ZSB9LFxyXG4gICdibGVuZEZ1bmNTZXBhcmF0ZSc6IHsgMDp0cnVlLCAxOnRydWUsIDI6dHJ1ZSwgMzp0cnVlIH0sXHJcbiAgJ2JsZW5kRXF1YXRpb24nOiB7IDA6dHJ1ZSB9LFxyXG4gICdibGVuZEVxdWF0aW9uU2VwYXJhdGUnOiB7IDA6dHJ1ZSwgMTp0cnVlIH0sXHJcbiAgJ3N0ZW5jaWxGdW5jJzogeyAwOnRydWUgfSxcclxuICAnc3RlbmNpbEZ1bmNTZXBhcmF0ZSc6IHsgMDp0cnVlLCAxOnRydWUgfSxcclxuICAnc3RlbmNpbE1hc2tTZXBhcmF0ZSc6IHsgMDp0cnVlIH0sXHJcbiAgJ3N0ZW5jaWxPcCc6IHsgMDp0cnVlLCAxOnRydWUsIDI6dHJ1ZSB9LFxyXG4gICdzdGVuY2lsT3BTZXBhcmF0ZSc6IHsgMDp0cnVlLCAxOnRydWUsIDI6dHJ1ZSwgMzp0cnVlIH0sXHJcblxyXG4gIC8vIEN1bGxpbmdcclxuXHJcbiAgJ2N1bGxGYWNlJzogeyAwOnRydWUgfSxcclxuICAnZnJvbnRGYWNlJzogeyAwOnRydWUgfSxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNYXAgb2YgbnVtYmVycyB0byBuYW1lcy5cclxuICogQHR5cGUge09iamVjdH1cclxuICovXHJcbnZhciBnbEVudW1zID0gbnVsbDtcclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplcyB0aGlzIG1vZHVsZS4gU2FmZSB0byBjYWxsIG1vcmUgdGhhbiBvbmNlLlxyXG4gKiBAcGFyYW0geyFXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGN0eCBBIFdlYkdMIGNvbnRleHQuIElmXHJcbiAqICAgIHlvdSBoYXZlIG1vcmUgdGhhbiBvbmUgY29udGV4dCBpdCBkb2Vzbid0IG1hdHRlciB3aGljaCBvbmVcclxuICogICAgeW91IHBhc3MgaW4sIGl0IGlzIG9ubHkgdXNlZCB0byBwdWxsIG91dCBjb25zdGFudHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBpbml0KGN0eCkge1xyXG4gIGlmIChnbEVudW1zID09IG51bGwpIHtcclxuICAgIGdsRW51bXMgPSB7IH07XHJcbiAgICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gY3R4KSB7XHJcbiAgICAgIGlmICh0eXBlb2YgY3R4W3Byb3BlcnR5TmFtZV0gPT0gJ251bWJlcicpIHtcclxuICAgICAgICBnbEVudW1zW2N0eFtwcm9wZXJ0eU5hbWVdXSA9IHByb3BlcnR5TmFtZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyB0aGUgdXRpbHMgaGF2ZSBiZWVuIGluaXRpYWxpemVkLlxyXG4gKi9cclxuZnVuY3Rpb24gY2hlY2tJbml0KCkge1xyXG4gIGlmIChnbEVudW1zID09IG51bGwpIHtcclxuICAgIHRocm93ICdXZWJHTERlYnVnVXRpbHMuaW5pdChjdHgpIG5vdCBjYWxsZWQnO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBvciBmYWxzZSBpZiB2YWx1ZSBtYXRjaGVzIGFueSBXZWJHTCBlbnVtXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gY2hlY2sgaWYgaXQgbWlnaHQgYmUgYW4gZW51bS5cclxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBtYXRjaGVzIG9uZSBvZiB0aGUgV2ViR0wgZGVmaW5lZCBlbnVtc1xyXG4gKi9cclxuZnVuY3Rpb24gbWlnaHRCZUVudW0odmFsdWUpIHtcclxuICBjaGVja0luaXQoKTtcclxuICByZXR1cm4gKGdsRW51bXNbdmFsdWVdICE9PSB1bmRlZmluZWQpO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyBhbiBzdHJpbmcgdmVyc2lvbiBvZiBhbiBXZWJHTCBlbnVtLlxyXG4gKlxyXG4gKiBFeGFtcGxlOlxyXG4gKiAgIHZhciBzdHIgPSBXZWJHTERlYnVnVXRpbC5nbEVudW1Ub1N0cmluZyhjdHguZ2V0RXJyb3IoKSk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byByZXR1cm4gYW4gZW51bSBmb3JcclxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5nIHZlcnNpb24gb2YgdGhlIGVudW0uXHJcbiAqL1xyXG5mdW5jdGlvbiBnbEVudW1Ub1N0cmluZyh2YWx1ZSkge1xyXG4gIGNoZWNrSW5pdCgpO1xyXG4gIHZhciBuYW1lID0gZ2xFbnVtc1t2YWx1ZV07XHJcbiAgcmV0dXJuIChuYW1lICE9PSB1bmRlZmluZWQpID8gbmFtZSA6XHJcbiAgICAgIChcIipVTktOT1dOIFdlYkdMIEVOVU0gKDB4XCIgKyB2YWx1ZS50b1N0cmluZygxNikgKyBcIilcIik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBzdHJpbmcgdmVyc2lvbiBvZiBhIFdlYkdMIGFyZ3VtZW50LlxyXG4gKiBBdHRlbXB0cyB0byBjb252ZXJ0IGVudW0gYXJndW1lbnRzIHRvIHN0cmluZ3MuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jdGlvbk5hbWUgdGhlIG5hbWUgb2YgdGhlIFdlYkdMIGZ1bmN0aW9uLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gYXJndW1lbnRJbmR4IHRoZSBpbmRleCBvZiB0aGUgYXJndW1lbnQuXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBhcmd1bWVudC5cclxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgdmFsdWUgYXMgYSBzdHJpbmcuXHJcbiAqL1xyXG5mdW5jdGlvbiBnbEZ1bmN0aW9uQXJnVG9TdHJpbmcoZnVuY3Rpb25OYW1lLCBhcmd1bWVudEluZGV4LCB2YWx1ZSkge1xyXG4gIHZhciBmdW5jSW5mbyA9IGdsVmFsaWRFbnVtQ29udGV4dHNbZnVuY3Rpb25OYW1lXTtcclxuICBpZiAoZnVuY0luZm8gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgaWYgKGZ1bmNJbmZvW2FyZ3VtZW50SW5kZXhdKSB7XHJcbiAgICAgIHJldHVybiBnbEVudW1Ub1N0cmluZyh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xyXG59XHJcblxyXG4vKipcclxuICogR2l2ZW4gYSBXZWJHTCBjb250ZXh0IHJldHVybnMgYSB3cmFwcGVkIGNvbnRleHQgdGhhdCBjYWxsc1xyXG4gKiBnbC5nZXRFcnJvciBhZnRlciBldmVyeSBjb21tYW5kIGFuZCBjYWxscyBhIGZ1bmN0aW9uIGlmIHRoZVxyXG4gKiByZXN1bHQgaXMgbm90IGdsLk5PX0VSUk9SLlxyXG4gKlxyXG4gKiBAcGFyYW0geyFXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGN0eCBUaGUgd2ViZ2wgY29udGV4dCB0b1xyXG4gKiAgICAgICAgd3JhcC5cclxuICogQHBhcmFtIHshZnVuY3Rpb24oZXJyLCBmdW5jTmFtZSwgYXJncyk6IHZvaWR9IG9wdF9vbkVycm9yRnVuY1xyXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBnbC5nZXRFcnJvciByZXR1cm5zIGFuXHJcbiAqICAgICAgICBlcnJvci4gSWYgbm90IHNwZWNpZmllZCB0aGUgZGVmYXVsdCBmdW5jdGlvbiBjYWxsc1xyXG4gKiAgICAgICAgY29uc29sZS5sb2cgd2l0aCBhIG1lc3NhZ2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBtYWtlRGVidWdDb250ZXh0KGN0eCwgb3B0X29uRXJyb3JGdW5jKSB7XHJcbiAgaW5pdChjdHgpO1xyXG4gIG9wdF9vbkVycm9yRnVuYyA9IG9wdF9vbkVycm9yRnVuYyB8fCBmdW5jdGlvbihlcnIsIGZ1bmN0aW9uTmFtZSwgYXJncykge1xyXG4gICAgICAgIC8vIGFwcGFyZW50bHkgd2UgY2FuJ3QgZG8gYXJncy5qb2luKFwiLFwiKTtcclxuICAgICAgICB2YXIgYXJnU3RyID0gXCJcIjtcclxuICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgYXJncy5sZW5ndGg7ICsraWkpIHtcclxuICAgICAgICAgIGFyZ1N0ciArPSAoKGlpID09IDApID8gJycgOiAnLCAnKSArXHJcbiAgICAgICAgICAgICAgZ2xGdW5jdGlvbkFyZ1RvU3RyaW5nKGZ1bmN0aW9uTmFtZSwgaWksIGFyZ3NbaWldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbG9nKFwiV2ViR0wgZXJyb3IgXCIrIGdsRW51bVRvU3RyaW5nKGVycikgKyBcIiBpbiBcIisgZnVuY3Rpb25OYW1lICtcclxuICAgICAgICAgICAgXCIoXCIgKyBhcmdTdHIgKyBcIilcIik7XHJcbiAgICAgIH07XHJcblxyXG4gIC8vIEhvbGRzIGJvb2xlYW5zIGZvciBlYWNoIEdMIGVycm9yIHNvIGFmdGVyIHdlIGdldCB0aGUgZXJyb3Igb3Vyc2VsdmVzXHJcbiAgLy8gd2UgY2FuIHN0aWxsIHJldHVybiBpdCB0byB0aGUgY2xpZW50IGFwcC5cclxuICB2YXIgZ2xFcnJvclNoYWRvdyA9IHsgfTtcclxuXHJcbiAgLy8gTWFrZXMgYSBmdW5jdGlvbiB0aGF0IGNhbGxzIGEgV2ViR0wgZnVuY3Rpb24gYW5kIHRoZW4gY2FsbHMgZ2V0RXJyb3IuXHJcbiAgZnVuY3Rpb24gbWFrZUVycm9yV3JhcHBlcihjdHgsIGZ1bmN0aW9uTmFtZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgcmVzdWx0ID0gY3R4W2Z1bmN0aW9uTmFtZV0uYXBwbHkoY3R4LCBhcmd1bWVudHMpO1xyXG4gICAgICB2YXIgZXJyID0gY3R4LmdldEVycm9yKCk7XHJcbiAgICAgIGlmIChlcnIgIT0gMCkge1xyXG4gICAgICAgIGdsRXJyb3JTaGFkb3dbZXJyXSA9IHRydWU7XHJcbiAgICAgICAgb3B0X29uRXJyb3JGdW5jKGVyciwgZnVuY3Rpb25OYW1lLCBhcmd1bWVudHMpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gTWFrZSBhIGFuIG9iamVjdCB0aGF0IGhhcyBhIGNvcHkgb2YgZXZlcnkgcHJvcGVydHkgb2YgdGhlIFdlYkdMIGNvbnRleHRcclxuICAvLyBidXQgd3JhcHMgYWxsIGZ1bmN0aW9ucy5cclxuICB2YXIgd3JhcHBlciA9IHt9O1xyXG4gIGZvciAodmFyIHByb3BlcnR5TmFtZSBpbiBjdHgpIHtcclxuICAgIGlmICh0eXBlb2YgY3R4W3Byb3BlcnR5TmFtZV0gPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgd3JhcHBlcltwcm9wZXJ0eU5hbWVdID0gbWFrZUVycm9yV3JhcHBlcihjdHgsIHByb3BlcnR5TmFtZSk7XHJcbiAgICAgfSBlbHNlIHtcclxuICAgICAgIHdyYXBwZXJbcHJvcGVydHlOYW1lXSA9IGN0eFtwcm9wZXJ0eU5hbWVdO1xyXG4gICAgIH1cclxuICB9XHJcblxyXG4gIC8vIE92ZXJyaWRlIHRoZSBnZXRFcnJvciBmdW5jdGlvbiB3aXRoIG9uZSB0aGF0IHJldHVybnMgb3VyIHNhdmVkIHJlc3VsdHMuXHJcbiAgd3JhcHBlci5nZXRFcnJvciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgZm9yICh2YXIgZXJyIGluIGdsRXJyb3JTaGFkb3cpIHtcclxuICAgICAgaWYgKGdsRXJyb3JTaGFkb3dbZXJyXSkge1xyXG4gICAgICAgIGdsRXJyb3JTaGFkb3dbZXJyXSA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiBlcnI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjdHguTk9fRVJST1I7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHdyYXBwZXI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlc2V0VG9Jbml0aWFsU3RhdGUoY3R4KSB7XHJcbiAgdmFyIG51bUF0dHJpYnMgPSBjdHguZ2V0UGFyYW1ldGVyKGN0eC5NQVhfVkVSVEVYX0FUVFJJQlMpO1xyXG4gIHZhciB0bXAgPSBjdHguY3JlYXRlQnVmZmVyKCk7XHJcbiAgY3R4LmJpbmRCdWZmZXIoY3R4LkFSUkFZX0JVRkZFUiwgdG1wKTtcclxuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbnVtQXR0cmliczsgKytpaSkge1xyXG4gICAgY3R4LmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShpaSk7XHJcbiAgICBjdHgudmVydGV4QXR0cmliUG9pbnRlcihpaSwgNCwgY3R4LkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcbiAgICBjdHgudmVydGV4QXR0cmliMWYoaWksIDApO1xyXG4gIH1cclxuICBjdHguZGVsZXRlQnVmZmVyKHRtcCk7XHJcblxyXG4gIHZhciBudW1UZXh0dXJlVW5pdHMgPSBjdHguZ2V0UGFyYW1ldGVyKGN0eC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyk7XHJcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG51bVRleHR1cmVVbml0czsgKytpaSkge1xyXG4gICAgY3R4LmFjdGl2ZVRleHR1cmUoY3R4LlRFWFRVUkUwICsgaWkpO1xyXG4gICAgY3R4LmJpbmRUZXh0dXJlKGN0eC5URVhUVVJFX0NVQkVfTUFQLCBudWxsKTtcclxuICAgIGN0eC5iaW5kVGV4dHVyZShjdHguVEVYVFVSRV8yRCwgbnVsbCk7XHJcbiAgfVxyXG5cclxuICBjdHguYWN0aXZlVGV4dHVyZShjdHguVEVYVFVSRTApO1xyXG4gIGN0eC51c2VQcm9ncmFtKG51bGwpO1xyXG4gIGN0eC5iaW5kQnVmZmVyKGN0eC5BUlJBWV9CVUZGRVIsIG51bGwpO1xyXG4gIGN0eC5iaW5kQnVmZmVyKGN0eC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbnVsbCk7XHJcbiAgY3R4LmJpbmRGcmFtZWJ1ZmZlcihjdHguRlJBTUVCVUZGRVIsIG51bGwpO1xyXG4gIGN0eC5iaW5kUmVuZGVyYnVmZmVyKGN0eC5SRU5ERVJCVUZGRVIsIG51bGwpO1xyXG4gIGN0eC5kaXNhYmxlKGN0eC5CTEVORCk7XHJcbiAgY3R4LmRpc2FibGUoY3R4LkNVTExfRkFDRSk7XHJcbiAgY3R4LmRpc2FibGUoY3R4LkRFUFRIX1RFU1QpO1xyXG4gIGN0eC5kaXNhYmxlKGN0eC5ESVRIRVIpO1xyXG4gIGN0eC5kaXNhYmxlKGN0eC5TQ0lTU09SX1RFU1QpO1xyXG4gIGN0eC5ibGVuZENvbG9yKDAsIDAsIDAsIDApO1xyXG4gIGN0eC5ibGVuZEVxdWF0aW9uKGN0eC5GVU5DX0FERCk7XHJcbiAgY3R4LmJsZW5kRnVuYyhjdHguT05FLCBjdHguWkVSTyk7XHJcbiAgY3R4LmNsZWFyQ29sb3IoMCwgMCwgMCwgMCk7XHJcbiAgY3R4LmNsZWFyRGVwdGgoMSk7XHJcbiAgY3R4LmNsZWFyU3RlbmNpbCgtMSk7XHJcbiAgY3R4LmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcclxuICBjdHguY3VsbEZhY2UoY3R4LkJBQ0spO1xyXG4gIGN0eC5kZXB0aEZ1bmMoY3R4LkxFU1MpO1xyXG4gIGN0eC5kZXB0aE1hc2sodHJ1ZSk7XHJcbiAgY3R4LmRlcHRoUmFuZ2UoMCwgMSk7XHJcbiAgY3R4LmZyb250RmFjZShjdHguQ0NXKTtcclxuICBjdHguaGludChjdHguR0VORVJBVEVfTUlQTUFQX0hJTlQsIGN0eC5ET05UX0NBUkUpO1xyXG4gIGN0eC5saW5lV2lkdGgoMSk7XHJcbiAgY3R4LnBpeGVsU3RvcmVpKGN0eC5QQUNLX0FMSUdOTUVOVCwgNCk7XHJcbiAgY3R4LnBpeGVsU3RvcmVpKGN0eC5VTlBBQ0tfQUxJR05NRU5ULCA0KTtcclxuICBjdHgucGl4ZWxTdG9yZWkoY3R4LlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcclxuICBjdHgucGl4ZWxTdG9yZWkoY3R4LlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgZmFsc2UpO1xyXG4gIC8vIFRPRE86IERlbGV0ZSB0aGlzIElGLlxyXG4gIGlmIChjdHguVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTCkge1xyXG4gICAgY3R4LnBpeGVsU3RvcmVpKGN0eC5VTlBBQ0tfQ09MT1JTUEFDRV9DT05WRVJTSU9OX1dFQkdMLCBjdHguQlJPV1NFUl9ERUZBVUxUX1dFQkdMKTtcclxuICB9XHJcbiAgY3R4LnBvbHlnb25PZmZzZXQoMCwgMCk7XHJcbiAgY3R4LnNhbXBsZUNvdmVyYWdlKDEsIGZhbHNlKTtcclxuICBjdHguc2Npc3NvcigwLCAwLCBjdHguY2FudmFzLndpZHRoLCBjdHguY2FudmFzLmhlaWdodCk7XHJcbiAgY3R4LnN0ZW5jaWxGdW5jKGN0eC5BTFdBWVMsIDAsIDB4RkZGRkZGRkYpO1xyXG4gIGN0eC5zdGVuY2lsTWFzaygweEZGRkZGRkZGKTtcclxuICBjdHguc3RlbmNpbE9wKGN0eC5LRUVQLCBjdHguS0VFUCwgY3R4LktFRVApO1xyXG4gIGN0eC52aWV3cG9ydCgwLCAwLCBjdHguY2FudmFzLmNsaWVudFdpZHRoLCBjdHguY2FudmFzLmNsaWVudEhlaWdodCk7XHJcbiAgY3R4LmNsZWFyKGN0eC5DT0xPUl9CVUZGRVJfQklUIHwgY3R4LkRFUFRIX0JVRkZFUl9CSVQgfCBjdHguU1RFTkNJTF9CVUZGRVJfQklUKTtcclxuXHJcbiAgLy8gVE9ETzogVGhpcyBzaG91bGQgTk9UIGJlIG5lZWRlZCBidXQgRmlyZWZveCBmYWlscyB3aXRoICdoaW50J1xyXG4gIHdoaWxlKGN0eC5nZXRFcnJvcigpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbWFrZUxvc3RDb250ZXh0U2ltdWxhdGluZ0NvbnRleHQoY3R4KSB7XHJcbiAgdmFyIHdyYXBwZXJfID0ge307XHJcbiAgdmFyIGNvbnRleHRJZF8gPSAxO1xyXG4gIHZhciBjb250ZXh0TG9zdF8gPSBmYWxzZTtcclxuICB2YXIgcmVzb3VyY2VJZF8gPSAwO1xyXG4gIHZhciByZXNvdXJjZURiXyA9IFtdO1xyXG4gIHZhciBvbkxvc3RfID0gdW5kZWZpbmVkO1xyXG4gIHZhciBvblJlc3RvcmVkXyA9IHVuZGVmaW5lZDtcclxuICB2YXIgbmV4dE9uUmVzdG9yZWRfID0gdW5kZWZpbmVkO1xyXG5cclxuICAvLyBIb2xkcyBib29sZWFucyBmb3IgZWFjaCBHTCBlcnJvciBzbyBjYW4gc2ltdWxhdGUgZXJyb3JzLlxyXG4gIHZhciBnbEVycm9yU2hhZG93XyA9IHsgfTtcclxuXHJcbiAgZnVuY3Rpb24gaXNXZWJHTE9iamVjdChvYmopIHtcclxuICAgIC8vcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuIChvYmogaW5zdGFuY2VvZiBXZWJHTEJ1ZmZlciB8fFxyXG4gICAgICAgICAgICBvYmogaW5zdGFuY2VvZiBXZWJHTEZyYW1lYnVmZmVyIHx8XHJcbiAgICAgICAgICAgIG9iaiBpbnN0YW5jZW9mIFdlYkdMUHJvZ3JhbSB8fFxyXG4gICAgICAgICAgICBvYmogaW5zdGFuY2VvZiBXZWJHTFJlbmRlcmJ1ZmZlciB8fFxyXG4gICAgICAgICAgICBvYmogaW5zdGFuY2VvZiBXZWJHTFNoYWRlciB8fFxyXG4gICAgICAgICAgICBvYmogaW5zdGFuY2VvZiBXZWJHTFRleHR1cmUpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY2hlY2tSZXNvdXJjZXMoYXJncykge1xyXG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGFyZ3MubGVuZ3RoOyArK2lpKSB7XHJcbiAgICAgIHZhciBhcmcgPSBhcmdzW2lpXTtcclxuICAgICAgaWYgKGlzV2ViR0xPYmplY3QoYXJnKSkge1xyXG4gICAgICAgIHJldHVybiBhcmcuX193ZWJnbERlYnVnQ29udGV4dExvc3RJZF9fID09IGNvbnRleHRJZF87XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY2xlYXJFcnJvcnMoKSB7XHJcbiAgICB2YXIgayA9IE9iamVjdC5rZXlzKGdsRXJyb3JTaGFkb3dfKTtcclxuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBrLmxlbmd0aDsgKytpaSkge1xyXG4gICAgICBkZWxldGUgZ2xFcnJvclNoZG93X1trXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIE1ha2VzIGEgZnVuY3Rpb24gdGhhdCBzaW11bGF0ZXMgV2ViR0wgd2hlbiBvdXQgb2YgY29udGV4dC5cclxuICBmdW5jdGlvbiBtYWtlTG9zdENvbnRleHRXcmFwcGVyKGN0eCwgZnVuY3Rpb25OYW1lKSB7XHJcbiAgICB2YXIgZiA9IGN0eFtmdW5jdGlvbk5hbWVdO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAvLyBPbmx5IGNhbGwgdGhlIGZ1bmN0aW9ucyBpZiB0aGUgY29udGV4dCBpcyBub3QgbG9zdC5cclxuICAgICAgaWYgKCFjb250ZXh0TG9zdF8pIHtcclxuICAgICAgICBpZiAoIWNoZWNrUmVzb3VyY2VzKGFyZ3VtZW50cykpIHtcclxuICAgICAgICAgIGdsRXJyb3JTaGFkb3dfW2N0eC5JTlZBTElEX09QRVJBVElPTl0gPSB0cnVlO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gZi5hcHBseShjdHgsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGZvciAodmFyIHByb3BlcnR5TmFtZSBpbiBjdHgpIHtcclxuICAgIGlmICh0eXBlb2YgY3R4W3Byb3BlcnR5TmFtZV0gPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgd3JhcHBlcl9bcHJvcGVydHlOYW1lXSA9IG1ha2VMb3N0Q29udGV4dFdyYXBwZXIoY3R4LCBwcm9wZXJ0eU5hbWUpO1xyXG4gICAgIH0gZWxzZSB7XHJcbiAgICAgICB3cmFwcGVyX1twcm9wZXJ0eU5hbWVdID0gY3R4W3Byb3BlcnR5TmFtZV07XHJcbiAgICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbWFrZVdlYkdMQ29udGV4dEV2ZW50KHN0YXR1c01lc3NhZ2UpIHtcclxuICAgIHJldHVybiB7c3RhdHVzTWVzc2FnZTogc3RhdHVzTWVzc2FnZX07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmcmVlUmVzb3VyY2VzKCkge1xyXG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHJlc291cmNlRGJfLmxlbmd0aDsgKytpaSkge1xyXG4gICAgICB2YXIgcmVzb3VyY2UgPSByZXNvdXJjZURiX1tpaV07XHJcbiAgICAgIGlmIChyZXNvdXJjZSBpbnN0YW5jZW9mIFdlYkdMQnVmZmVyKSB7XHJcbiAgICAgICAgY3R4LmRlbGV0ZUJ1ZmZlcihyZXNvdXJjZSk7XHJcbiAgICAgIH0gZWxzZSBpZiAocmVzb3VyY2UgaW5zdGFuY2VvZiBXZWJjdHhGcmFtZWJ1ZmZlcikge1xyXG4gICAgICAgIGN0eC5kZWxldGVGcmFtZWJ1ZmZlcihyZXNvdXJjZSk7XHJcbiAgICAgIH0gZWxzZSBpZiAocmVzb3VyY2UgaW5zdGFuY2VvZiBXZWJjdHhQcm9ncmFtKSB7XHJcbiAgICAgICAgY3R4LmRlbGV0ZVByb2dyYW0ocmVzb3VyY2UpO1xyXG4gICAgICB9IGVsc2UgaWYgKHJlc291cmNlIGluc3RhbmNlb2YgV2ViY3R4UmVuZGVyYnVmZmVyKSB7XHJcbiAgICAgICAgY3R4LmRlbGV0ZVJlbmRlcmJ1ZmZlcihyZXNvdXJjZSk7XHJcbiAgICAgIH0gZWxzZSBpZiAocmVzb3VyY2UgaW5zdGFuY2VvZiBXZWJjdHhTaGFkZXIpIHtcclxuICAgICAgICBjdHguZGVsZXRlU2hhZGVyKHJlc291cmNlKTtcclxuICAgICAgfSBlbHNlIGlmIChyZXNvdXJjZSBpbnN0YW5jZW9mIFdlYmN0eFRleHR1cmUpIHtcclxuICAgICAgICBjdHguZGVsZXRlVGV4dHVyZShyZXNvdXJjZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHdyYXBwZXJfLmxvc2VDb250ZXh0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAoIWNvbnRleHRMb3N0Xykge1xyXG4gICAgICBjb250ZXh0TG9zdF8gPSB0cnVlO1xyXG4gICAgICArK2NvbnRleHRJZF87XHJcbiAgICAgIHdoaWxlIChjdHguZ2V0RXJyb3IoKSk7XHJcbiAgICAgIGNsZWFyRXJyb3JzKCk7XHJcbiAgICAgIGdsRXJyb3JTaGFkb3dfW2N0eC5DT05URVhUX0xPU1RfV0VCR0xdID0gdHJ1ZTtcclxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGlmIChvbkxvc3RfKSB7XHJcbiAgICAgICAgICAgIG9uTG9zdF8obWFrZVdlYkdMQ29udGV4dEV2ZW50KFwiY29udGV4dCBsb3N0XCIpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LCAwKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICB3cmFwcGVyXy5yZXN0b3JlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKGNvbnRleHRMb3N0Xykge1xyXG4gICAgICBpZiAob25SZXN0b3JlZF8pIHtcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBmcmVlUmVzb3VyY2VzKCk7XHJcbiAgICAgICAgICAgIHJlc2V0VG9Jbml0aWFsU3RhdGUoY3R4KTtcclxuICAgICAgICAgICAgY29udGV4dExvc3RfID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChvblJlc3RvcmVkXykge1xyXG4gICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IG9uUmVzdG9yZWRfO1xyXG4gICAgICAgICAgICAgIG9uUmVzdG9yZWRfID0gbmV4dE9uUmVzdG9yZWRfO1xyXG4gICAgICAgICAgICAgIG5leHRPblJlc3RvcmVkXyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICBjYWxsYmFjayhtYWtlV2ViR0xDb250ZXh0RXZlbnQoXCJjb250ZXh0IHJlc3RvcmVkXCIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSwgMCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgXCJZb3UgY2FuIG5vdCByZXN0b3JlIHRoZSBjb250ZXh0IHdpdGhvdXQgYSBsaXN0ZW5lclwiXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBXcmFwIGEgZmV3IGZ1bmN0aW9ucyBzcGVjaWFsbHkuXHJcbiAgd3JhcHBlcl8uZ2V0RXJyb3IgPSBmdW5jdGlvbigpIHtcclxuICAgIGlmICghY29udGV4dExvc3RfKSB7XHJcbiAgICAgIHZhciBlcnI7XHJcbiAgICAgIHdoaWxlIChlcnIgPSBjdHguZ2V0RXJyb3IoKSkge1xyXG4gICAgICAgIGdsRXJyb3JTaGFkb3dfW2Vycl0gPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBlcnIgaW4gZ2xFcnJvclNoYWRvd18pIHtcclxuICAgICAgaWYgKGdsRXJyb3JTaGFkb3dfW2Vycl0pIHtcclxuICAgICAgICBkZWxldGUgZ2xFcnJvclNoYWRvd19bZXJyXTtcclxuICAgICAgICByZXR1cm4gZXJyO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3R4Lk5PX0VSUk9SO1xyXG4gIH07XHJcblxyXG4gIHZhciBjcmVhdGlvbkZ1bmN0aW9ucyA9IFtcclxuICAgIFwiY3JlYXRlQnVmZmVyXCIsXHJcbiAgICBcImNyZWF0ZUZyYW1lYnVmZmVyXCIsXHJcbiAgICBcImNyZWF0ZVByb2dyYW1cIixcclxuICAgIFwiY3JlYXRlUmVuZGVyYnVmZmVyXCIsXHJcbiAgICBcImNyZWF0ZVNoYWRlclwiLFxyXG4gICAgXCJjcmVhdGVUZXh0dXJlXCJcclxuICBdO1xyXG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBjcmVhdGlvbkZ1bmN0aW9ucy5sZW5ndGg7ICsraWkpIHtcclxuICAgIHZhciBmdW5jdGlvbk5hbWUgPSBjcmVhdGlvbkZ1bmN0aW9uc1tpaV07XHJcbiAgICB3cmFwcGVyX1tmdW5jdGlvbk5hbWVdID0gZnVuY3Rpb24oZikge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKGNvbnRleHRMb3N0Xykge1xyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvYmogPSBmLmFwcGx5KGN0eCwgYXJndW1lbnRzKTtcclxuICAgICAgICBvYmouX193ZWJnbERlYnVnQ29udGV4dExvc3RJZF9fID0gY29udGV4dElkXztcclxuICAgICAgICByZXNvdXJjZURiXy5wdXNoKG9iaik7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgfTtcclxuICAgIH0oY3R4W2Z1bmN0aW9uTmFtZV0pO1xyXG4gIH1cclxuXHJcbiAgdmFyIGZ1bmN0aW9uc1RoYXRTaG91bGRSZXR1cm5OdWxsID0gW1xyXG4gICAgXCJnZXRBY3RpdmVBdHRyaWJcIixcclxuICAgIFwiZ2V0QWN0aXZlVW5pZm9ybVwiLFxyXG4gICAgXCJnZXRCdWZmZXJQYXJhbWV0ZXJcIixcclxuICAgIFwiZ2V0Q29udGV4dEF0dHJpYnV0ZXNcIixcclxuICAgIFwiZ2V0QXR0YWNoZWRTaGFkZXJzXCIsXHJcbiAgICBcImdldEZyYW1lYnVmZmVyQXR0YWNobWVudFBhcmFtZXRlclwiLFxyXG4gICAgXCJnZXRQYXJhbWV0ZXJcIixcclxuICAgIFwiZ2V0UHJvZ3JhbVBhcmFtZXRlclwiLFxyXG4gICAgXCJnZXRQcm9ncmFtSW5mb0xvZ1wiLFxyXG4gICAgXCJnZXRSZW5kZXJidWZmZXJQYXJhbWV0ZXJcIixcclxuICAgIFwiZ2V0U2hhZGVyUGFyYW1ldGVyXCIsXHJcbiAgICBcImdldFNoYWRlckluZm9Mb2dcIixcclxuICAgIFwiZ2V0U2hhZGVyU291cmNlXCIsXHJcbiAgICBcImdldFRleFBhcmFtZXRlclwiLFxyXG4gICAgXCJnZXRVbmlmb3JtXCIsXHJcbiAgICBcImdldFVuaWZvcm1Mb2NhdGlvblwiLFxyXG4gICAgXCJnZXRWZXJ0ZXhBdHRyaWJcIlxyXG4gIF07XHJcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGZ1bmN0aW9uc1RoYXRTaG91bGRSZXR1cm5OdWxsLmxlbmd0aDsgKytpaSkge1xyXG4gICAgdmFyIGZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uc1RoYXRTaG91bGRSZXR1cm5OdWxsW2lpXTtcclxuICAgIHdyYXBwZXJfW2Z1bmN0aW9uTmFtZV0gPSBmdW5jdGlvbihmKSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoY29udGV4dExvc3RfKSB7XHJcbiAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGYuYXBwbHkoY3R4LCBhcmd1bWVudHMpO1xyXG4gICAgICB9XHJcbiAgICB9KHdyYXBwZXJfW2Z1bmN0aW9uTmFtZV0pO1xyXG4gIH1cclxuXHJcbiAgdmFyIGlzRnVuY3Rpb25zID0gW1xyXG4gICAgXCJpc0J1ZmZlclwiLFxyXG4gICAgXCJpc0VuYWJsZWRcIixcclxuICAgIFwiaXNGcmFtZWJ1ZmZlclwiLFxyXG4gICAgXCJpc1Byb2dyYW1cIixcclxuICAgIFwiaXNSZW5kZXJidWZmZXJcIixcclxuICAgIFwiaXNTaGFkZXJcIixcclxuICAgIFwiaXNUZXh0dXJlXCJcclxuICBdO1xyXG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBpc0Z1bmN0aW9ucy5sZW5ndGg7ICsraWkpIHtcclxuICAgIHZhciBmdW5jdGlvbk5hbWUgPSBpc0Z1bmN0aW9uc1tpaV07XHJcbiAgICB3cmFwcGVyX1tmdW5jdGlvbk5hbWVdID0gZnVuY3Rpb24oZikge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKGNvbnRleHRMb3N0Xykge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZi5hcHBseShjdHgsIGFyZ3VtZW50cyk7XHJcbiAgICAgIH1cclxuICAgIH0od3JhcHBlcl9bZnVuY3Rpb25OYW1lXSk7XHJcbiAgfVxyXG5cclxuICB3cmFwcGVyXy5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzID0gZnVuY3Rpb24oZikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAoY29udGV4dExvc3RfKSB7XHJcbiAgICAgICAgcmV0dXJuIGN0eC5GUkFNRUJVRkZFUl9VTlNVUFBPUlRFRDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZi5hcHBseShjdHgsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gIH0od3JhcHBlcl8uY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyk7XHJcblxyXG4gIHdyYXBwZXJfLmdldEF0dHJpYkxvY2F0aW9uID0gZnVuY3Rpb24oZikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAoY29udGV4dExvc3RfKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmLmFwcGx5KGN0eCwgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgfSh3cmFwcGVyXy5nZXRBdHRyaWJMb2NhdGlvbik7XHJcblxyXG4gIHdyYXBwZXJfLmdldFZlcnRleEF0dHJpYk9mZnNldCA9IGZ1bmN0aW9uKGYpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKGNvbnRleHRMb3N0Xykge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmLmFwcGx5KGN0eCwgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgfSh3cmFwcGVyXy5nZXRWZXJ0ZXhBdHRyaWJPZmZzZXQpO1xyXG5cclxuICB3cmFwcGVyXy5pc0NvbnRleHRMb3N0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gY29udGV4dExvc3RfO1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIHdyYXBFdmVudChsaXN0ZW5lcikge1xyXG4gICAgaWYgKHR5cGVvZihsaXN0ZW5lcikgPT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgIHJldHVybiBsaXN0ZW5lcjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbihpbmZvKSB7XHJcbiAgICAgICAgbGlzdGVuZXIuaGFuZGxlRXZlbnQoaW5mbyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHdyYXBwZXJfLnJlZ2lzdGVyT25Db250ZXh0TG9zdExpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcclxuICAgIG9uTG9zdF8gPSB3cmFwRXZlbnQobGlzdGVuZXIpO1xyXG4gIH07XHJcblxyXG4gIHdyYXBwZXJfLnJlZ2lzdGVyT25Db250ZXh0UmVzdG9yZWRMaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XHJcbiAgICBpZiAoY29udGV4dExvc3RfKSB7XHJcbiAgICAgIG5leHRPblJlc3RvcmVkXyA9IHdyYXBFdmVudChsaXN0ZW5lcik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBvblJlc3RvcmVkXyA9IHdyYXBFdmVudChsaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gd3JhcHBlcl87XHJcbn1cclxuXHJcbnJldHVybiB7XHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZXMgdGhpcyBtb2R1bGUuIFNhZmUgdG8gY2FsbCBtb3JlIHRoYW4gb25jZS5cclxuICAgKiBAcGFyYW0geyFXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGN0eCBBIFdlYkdMIGNvbnRleHQuIElmXHJcbiAgICogICAgeW91IGhhdmUgbW9yZSB0aGFuIG9uZSBjb250ZXh0IGl0IGRvZXNuJ3QgbWF0dGVyIHdoaWNoIG9uZVxyXG4gICAqICAgIHlvdSBwYXNzIGluLCBpdCBpcyBvbmx5IHVzZWQgdG8gcHVsbCBvdXQgY29uc3RhbnRzLlxyXG4gICAqL1xyXG4gICdpbml0JzogaW5pdCxcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIGlmIHZhbHVlIG1hdGNoZXMgYW55IFdlYkdMIGVudW1cclxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGNoZWNrIGlmIGl0IG1pZ2h0IGJlIGFuIGVudW0uXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBtYXRjaGVzIG9uZSBvZiB0aGUgV2ViR0wgZGVmaW5lZCBlbnVtc1xyXG4gICAqL1xyXG4gICdtaWdodEJlRW51bSc6IG1pZ2h0QmVFbnVtLFxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGFuIHN0cmluZyB2ZXJzaW9uIG9mIGFuIFdlYkdMIGVudW0uXHJcbiAgICpcclxuICAgKiBFeGFtcGxlOlxyXG4gICAqICAgV2ViR0xEZWJ1Z1V0aWwuaW5pdChjdHgpO1xyXG4gICAqICAgdmFyIHN0ciA9IFdlYkdMRGVidWdVdGlsLmdsRW51bVRvU3RyaW5nKGN0eC5nZXRFcnJvcigpKTtcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byByZXR1cm4gYW4gZW51bSBmb3JcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmcgdmVyc2lvbiBvZiB0aGUgZW51bS5cclxuICAgKi9cclxuICAnZ2xFbnVtVG9TdHJpbmcnOiBnbEVudW1Ub1N0cmluZyxcclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydHMgdGhlIGFyZ3VtZW50IG9mIGEgV2ViR0wgZnVuY3Rpb24gdG8gYSBzdHJpbmcuXHJcbiAgICogQXR0ZW1wdHMgdG8gY29udmVydCBlbnVtIGFyZ3VtZW50cyB0byBzdHJpbmdzLlxyXG4gICAqXHJcbiAgICogRXhhbXBsZTpcclxuICAgKiAgIFdlYkdMRGVidWdVdGlsLmluaXQoY3R4KTtcclxuICAgKiAgIHZhciBzdHIgPSBXZWJHTERlYnVnVXRpbC5nbEZ1bmN0aW9uQXJnVG9TdHJpbmcoJ2JpbmRUZXh0dXJlJywgMCwgZ2wuVEVYVFVSRV8yRCk7XHJcbiAgICpcclxuICAgKiB3b3VsZCByZXR1cm4gJ1RFWFRVUkVfMkQnXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25OYW1lIHRoZSBuYW1lIG9mIHRoZSBXZWJHTCBmdW5jdGlvbi5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gYXJndW1lbnRJbmR4IHRoZSBpbmRleCBvZiB0aGUgYXJndW1lbnQuXHJcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGFyZ3VtZW50LlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHZhbHVlIGFzIGEgc3RyaW5nLlxyXG4gICAqL1xyXG4gICdnbEZ1bmN0aW9uQXJnVG9TdHJpbmcnOiBnbEZ1bmN0aW9uQXJnVG9TdHJpbmcsXHJcblxyXG4gIC8qKlxyXG4gICAqIEdpdmVuIGEgV2ViR0wgY29udGV4dCByZXR1cm5zIGEgd3JhcHBlZCBjb250ZXh0IHRoYXQgY2FsbHNcclxuICAgKiBnbC5nZXRFcnJvciBhZnRlciBldmVyeSBjb21tYW5kIGFuZCBjYWxscyBhIGZ1bmN0aW9uIGlmIHRoZVxyXG4gICAqIHJlc3VsdCBpcyBub3QgTk9fRVJST1IuXHJcbiAgICpcclxuICAgKiBZb3UgY2FuIHN1cHBseSB5b3VyIG93biBmdW5jdGlvbiBpZiB5b3Ugd2FudC4gRm9yIGV4YW1wbGUsIGlmIHlvdSdkIGxpa2VcclxuICAgKiBhbiBleGNlcHRpb24gdGhyb3duIG9uIGFueSBHTCBlcnJvciB5b3UgY291bGQgZG8gdGhpc1xyXG4gICAqXHJcbiAgICogICAgZnVuY3Rpb24gdGhyb3dPbkdMRXJyb3IoZXJyLCBmdW5jTmFtZSwgYXJncykge1xyXG4gICAqICAgICAgdGhyb3cgV2ViR0xEZWJ1Z1V0aWxzLmdsRW51bVRvU3RyaW5nKGVycikgKyBcIiB3YXMgY2F1c2VkIGJ5IGNhbGwgdG9cIiArXHJcbiAgICogICAgICAgICAgICBmdW5jTmFtZTtcclxuICAgKiAgICB9O1xyXG4gICAqXHJcbiAgICogICAgY3R4ID0gV2ViR0xEZWJ1Z1V0aWxzLm1ha2VEZWJ1Z0NvbnRleHQoXHJcbiAgICogICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2xcIiksIHRocm93T25HTEVycm9yKTtcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7IVdlYkdMUmVuZGVyaW5nQ29udGV4dH0gY3R4IFRoZSB3ZWJnbCBjb250ZXh0IHRvIHdyYXAuXHJcbiAgICogQHBhcmFtIHshZnVuY3Rpb24oZXJyLCBmdW5jTmFtZSwgYXJncyk6IHZvaWR9IG9wdF9vbkVycm9yRnVuYyBUaGUgZnVuY3Rpb25cclxuICAgKiAgICAgdG8gY2FsbCB3aGVuIGdsLmdldEVycm9yIHJldHVybnMgYW4gZXJyb3IuIElmIG5vdCBzcGVjaWZpZWQgdGhlIGRlZmF1bHRcclxuICAgKiAgICAgZnVuY3Rpb24gY2FsbHMgY29uc29sZS5sb2cgd2l0aCBhIG1lc3NhZ2UuXHJcbiAgICovXHJcbiAgJ21ha2VEZWJ1Z0NvbnRleHQnOiBtYWtlRGVidWdDb250ZXh0LFxyXG5cclxuICAvKipcclxuICAgKiBHaXZlbiBhIFdlYkdMIGNvbnRleHQgcmV0dXJucyBhIHdyYXBwZWQgY29udGV4dCB0aGF0IGFkZHMgNFxyXG4gICAqIGZ1bmN0aW9ucy5cclxuICAgKlxyXG4gICAqIGN0eC5sb3NlQ29udGV4dDpcclxuICAgKiAgIHNpbXVsYXRlcyBhIGxvc3QgY29udGV4dCBldmVudC5cclxuICAgKlxyXG4gICAqIGN0eC5yZXN0b3JlQ29udGV4dDpcclxuICAgKiAgIHNpbXVsYXRlcyB0aGUgY29udGV4dCBiZWluZyByZXN0b3JlZC5cclxuICAgKlxyXG4gICAqIGN0eC5yZWdpc3Rlck9uQ29udGV4dExvc3RMaXN0ZW5lcihsaXN0ZW5lcik6XHJcbiAgICogICBsZXRzIHlvdSByZWdpc3RlciBhIGxpc3RlbmVyIGZvciBjb250ZXh0IGxvc3QuIFVzZSBpbnN0ZWFkXHJcbiAgICogICBvZiBhZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRsb3N0ZXZlbnQnLCBsaXN0ZW5lcik7XHJcbiAgICpcclxuICAgKiBjdHgucmVnaXN0ZXJPbkNvbnRleHRSZXN0b3JlZExpc3RlbmVyKGxpc3RlbmVyKTpcclxuICAgKiAgIGxldHMgeW91IHJlZ2lzdGVyIGEgbGlzdGVuZXIgZm9yIGNvbnRleHQgcmVzdG9yZWQuIFVzZVxyXG4gICAqICAgaW5zdGVhZCBvZiBhZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsXHJcbiAgICogICBsaXN0ZW5lcik7XHJcbiAgICpcclxuICAgKiBAcGFyYW0geyFXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGN0eCBUaGUgd2ViZ2wgY29udGV4dCB0byB3cmFwLlxyXG4gICAqL1xyXG4gICdtYWtlTG9zdENvbnRleHRTaW11bGF0aW5nQ29udGV4dCc6IG1ha2VMb3N0Q29udGV4dFNpbXVsYXRpbmdDb250ZXh0LFxyXG5cclxuICAvKipcclxuICAgKiBSZXNldHMgYSBjb250ZXh0IHRvIHRoZSBpbml0aWFsIHN0YXRlLlxyXG4gICAqIEBwYXJhbSB7IVdlYkdMUmVuZGVyaW5nQ29udGV4dH0gY3R4IFRoZSB3ZWJnbCBjb250ZXh0IHRvXHJcbiAgICogICAgIHJlc2V0LlxyXG4gICAqL1xyXG4gICdyZXNldFRvSW5pdGlhbFN0YXRlJzogcmVzZXRUb0luaXRpYWxTdGF0ZVxyXG59O1xyXG5cclxufSgpO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgV2ViR0xEZWJ1Z1V0aWxzOyIsImltcG9ydCBXZWJHTFV0aWxzIGZyb20gXCIuL3dlYmdsLXV0aWxzLmpzXCI7XHJcbmltcG9ydCBXZWJHTERlYnVnVXRpbHMgZnJvbSBcIi4vd2ViZ2wtZGVidWcuanNcIjtcclxuXHJcbmNvbnN0IFV0aWwgPSB7XHJcbiAgICBpbml0U2hhZGVyczogZnVuY3Rpb24oZ2wsIHZzaGFkZXIsIGZzaGFkZXIpIHtcclxuICAgICAgICB2YXIgcHJvZ3JhbSA9IFV0aWwuY3JlYXRlUHJvZ3JhbShnbCwgdnNoYWRlciwgZnNoYWRlcik7XHJcbiAgICAgICAgaWYgKCFwcm9ncmFtKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGYWlsZWQgdG8gY3JlYXRlIHByb2dyYW0nKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgICAgICBnbC5wcm9ncmFtID0gcHJvZ3JhbTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZVByb2dyYW06IGZ1bmN0aW9uKGdsLCB2c2hhZGVyLCBmc2hhZGVyKSB7XHJcbiAgICAgICAgLy8gQ3JlYXRlIHNoYWRlciBvYmplY3RcclxuICAgICAgICB2YXIgdmVydGV4U2hhZGVyID0gVXRpbC5sb2FkU2hhZGVyKGdsLCBnbC5WRVJURVhfU0hBREVSLCB2c2hhZGVyKTtcclxuICAgICAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBVdGlsLmxvYWRTaGFkZXIoZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgZnNoYWRlcik7XHJcbiAgICAgICAgaWYgKCF2ZXJ0ZXhTaGFkZXIgfHwgIWZyYWdtZW50U2hhZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgcHJvZ3JhbSBvYmplY3RcclxuICAgICAgICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcclxuICAgICAgICBpZiAoIXByb2dyYW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBdHRhY2ggdGhlIHNoYWRlciBvYmplY3RzXHJcbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XHJcbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcclxuXHJcbiAgICAgICAgLy8gTGluayB0aGUgcHJvZ3JhbSBvYmplY3RcclxuICAgICAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhlIHJlc3VsdCBvZiBsaW5raW5nXHJcbiAgICAgICAgdmFyIGxpbmtlZCA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpO1xyXG4gICAgICAgIGlmICghbGlua2VkKSB7XHJcbiAgICAgICAgICAgIHZhciBlcnJvciA9IGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRmFpbGVkIHRvIGxpbmsgcHJvZ3JhbTogJyArIGVycm9yKTtcclxuICAgICAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgICAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcclxuICAgICAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKHZlcnRleFNoYWRlcik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJvZ3JhbTtcclxuICAgIH0sXHJcblxyXG4gICAgbG9hZFNoYWRlcjogZnVuY3Rpb24oZ2wsIHR5cGUsIHNvdXJjZSkge1xyXG4gICAgICAgIC8vIENyZWF0ZSBzaGFkZXIgb2JqZWN0XHJcbiAgICAgICAgdmFyIHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcclxuICAgICAgICBpZiAoc2hhZGVyID09IG51bGwpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ3VuYWJsZSB0byBjcmVhdGUgc2hhZGVyJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSBzaGFkZXIgcHJvZ3JhbVxyXG4gICAgICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNvdXJjZSk7XHJcblxyXG4gICAgICAgIC8vIENvbXBpbGUgdGhlIHNoYWRlclxyXG4gICAgICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhlIHJlc3VsdCBvZiBjb21waWxhdGlvblxyXG4gICAgICAgIHZhciBjb21waWxlZCA9IGdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKTtcclxuICAgICAgICBpZiAoIWNvbXBpbGVkKSB7XHJcbiAgICAgICAgICAgIHZhciBlcnJvciA9IGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZhaWxlZCB0byBjb21waWxlIHNoYWRlcjogJyArIGVycm9yKTtcclxuICAgICAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHNoYWRlcjtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0V2ViR0xDb250ZXh0OiBmdW5jdGlvbihjYW52YXMsIG9wdF9kZWJ1Zykge1xyXG4gICAgICAgIC8vIEdldCB0aGUgcmVuZGVyaW5nIGNvbnRleHQgZm9yIFdlYkdMXHJcbiAgICAgICAgdmFyIGdsID0gV2ViR0xVdGlscy5zZXR1cFdlYkdMKGNhbnZhcyk7XHJcbiAgICAgICAgaWYgKCFnbCkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIC8vIGlmIG9wdF9kZWJ1ZyBpcyBleHBsaWNpdGx5IGZhbHNlLCBjcmVhdGUgdGhlIGNvbnRleHQgZm9yIGRlYnVnZ2luZ1xyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMiB8fCBvcHRfZGVidWcpIHtcclxuICAgICAgICAgICAgZ2wgPSBXZWJHTERlYnVnVXRpbHMubWFrZURlYnVnQ29udGV4dChnbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZ2w7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZTNEQ29udGV4dCA6IGZ1bmN0aW9uKGNhbnZhcywgb3B0X2F0dHJpYnMpIHtcclxuICAgICAgICB2YXIgbmFtZXMgPSBbXCJ3ZWJnbFwiLCBcImV4cGVyaW1lbnRhbC13ZWJnbFwiLCBcIndlYmtpdC0zZFwiLCBcIm1vei13ZWJnbFwiXTtcclxuICAgICAgICB2YXIgY29udGV4dCA9IG51bGw7XHJcbiAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG5hbWVzLmxlbmd0aDsgKytpaSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KG5hbWVzW2lpXSwgb3B0X2F0dHJpYnMpO1xyXG4gICAgICAgICAgICB9IGNhdGNoKGUpIHt9XHJcbiAgICAgICAgICAgIGlmIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29udGV4dDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgVXRpbDsiLCJcclxuY2xhc3MgTGlnaHQge1xyXG4gICAgY29uc3RydWN0b3IocGFyYW0pIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnTGlnaHQnO1xyXG5cclxuICAgICAgICBwYXJhbSA9IHBhcmFtIHx8IHt9O1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBwYXJhbS5jb2xvciB8fCBbMSwxLDFdO1xyXG4gICAgICAgIHRoaXMuaW50ZW5zaXR5ID0gcGFyYW0uaW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgPyBwYXJhbS5pbnRlbnNpdHkgOiAxO1xyXG4gICAgICAgIHRoaXMuY2FzdFNoYWRvdyA9IHBhcmFtLmNhc3RTaGFkb3c7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IExpZ2h0O1xyXG4iLCJpbXBvcnQgTGlnaHQgZnJvbSBcIi4vTGlnaHRcIjtcclxuXHJcbmNsYXNzIEFtYmllbnRMaWdodCBleHRlbmRzIExpZ2h0e1xyXG4gICAgY29uc3RydWN0b3IocGFyYW0pIHtcclxuICAgICAgICBzdXBlcihwYXJhbSk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ0FtYmllbnRMaWdodCc7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFtYmllbnRMaWdodDtcclxuIiwiaW1wb3J0IExpZ2h0IGZyb20gXCIuL0xpZ2h0XCI7XHJcbmltcG9ydCB7VmVjdG9yM30gZnJvbSBcIi4uL21hdGgvVmVjdG9yM1wiO1xyXG5cclxuY2xhc3MgRGlyZWN0aW9uYWxMaWdodCBleHRlbmRzIExpZ2h0e1xyXG4gICAgY29uc3RydWN0b3IocGFyYW0pIHtcclxuICAgICAgICBzdXBlcihwYXJhbSk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ0RpcmVjdGlvbmFsTGlnaHQnO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gWzEsMSwxXTtcclxuICAgICAgICB0aGlzLnNldERpcmVjdGlvbihwYXJhbS5kaXJlY3Rpb24gfHwgWzEsMSwxXSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0RGlyZWN0aW9uKGRpcmVjdGlvbil7XHJcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSAgbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkoZGlyZWN0aW9uKS5ub3JtYWxpemUoKS50b0FycmF5KCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IERpcmVjdGlvbmFsTGlnaHQ7XHJcbiIsImNsYXNzIENvbXBvc2Vye1xyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICB0aGlzLnZlcnRleFNoYWRlciA9IFtcclxuICAgICAgICAgICAgJ3ByZWNpc2lvbiBoaWdocCBpbnQ7JyxcclxuICAgICAgICAgICAgJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDsnLFxyXG4gICAgICAgICAgICAnYXR0cmlidXRlIHZlYzQgYV9Qb3NpdGlvbjsnLFxyXG4gICAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgYV9UZXhDb29yZDsnLFxyXG4gICAgICAgICAgICBcInZhcnlpbmcgdmVjMiB2VXY7XCIsXHJcblxyXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcclxuXHJcbiAgICAgICAgICAgIFwidlV2ID0gYV9UZXhDb29yZDtcIixcclxuICAgICAgICAgICAgXCJnbF9Qb3NpdGlvbiA9IGFfUG9zaXRpb247XCIsXHJcbiAgICAgICAgICAgIFwiZ2xfUG9zaXRpb24ueiA9IDAuMDtcIixcclxuXHJcbiAgICAgICAgICAgIFwifVwiXHJcblxyXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApO1xyXG5cclxuICAgICAgICB0aGlzLmZyYWdtZW50U2hhZGVyID0gW1xyXG5cclxuICAgICAgICAgICAgJyNkZWZpbmUgbGluZVdpZHRoIDInLFxyXG4gICAgICAgICAgICAncHJlY2lzaW9uIGhpZ2hwIGludDsnLFxyXG4gICAgICAgICAgICAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0OycsXHJcbiAgICAgICAgICAgIFwidW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XCIsXHJcblxyXG4gICAgICAgICAgICBcInZhcnlpbmcgdmVjMiB2VXY7XCIsXHJcblxyXG4gICAgICAgICAgICBcImZsb2F0IGdldEdyYXkodmVjNCBjb2xvcil7XCIsXHJcbiAgICAgICAgICAgIFwiXHRyZXR1cm4gKGNvbG9yLnIgKyBjb2xvci5nICsgY29sb3IuYikvMy4wO1wiLFxyXG4gICAgICAgICAgICAvLyBcIlx0cmV0dXJuIGNvbG9yLnIqMC4yOTkgKyBjb2xvci5nKjAuNTg3ICsgY29sb3IuYiowLjExNDtcIixcclxuICAgICAgICAgICAgXCJ9XCIsXHJcblxyXG4gICAgICAgICAgICBcImZsb2F0IGdldEVkZ2VHcmF5KHZlYzIgdXYpe1wiLFxyXG4gICAgICAgICAgICBcIlx0ZmxvYXQgc3RlcCA9IDEuMC82MDAuMDtcIixcclxuICAgICAgICAgICAgXCJcdGZsb2F0IGdyYXkgPSAwLjA7XCIsXHJcblxyXG4gICAgICAgICAgICBcIlx0Z3JheSArPSAtMS4wICogZ2V0R3JheSh0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKHV2Lngtc3RlcCwgdXYueS1zdGVwKSApKTtcIixcclxuICAgICAgICAgICAgXCJcdGdyYXkgKz0gLTEuMCAqIGdldEdyYXkodGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMih1di54LCB1di55LXN0ZXApICkpO1wiLFxyXG4gICAgICAgICAgICBcIlx0Z3JheSArPSAtMS4wICogZ2V0R3JheSh0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKHV2Lngrc3RlcCwgdXYueS1zdGVwKSApKTtcIixcclxuXHJcbiAgICAgICAgICAgIFwiXHRncmF5ICs9IC0xLjAgKiBnZXRHcmF5KHRleHR1cmUyRCggdERpZmZ1c2UsIHZlYzIodXYueC1zdGVwLCB1di55KSApKTtcIixcclxuICAgICAgICAgICAgXCJcdGdyYXkgKz0gOC4wICogZ2V0R3JheSh0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKHV2LngsIHV2LnkpICkpO1wiLFxyXG4gICAgICAgICAgICBcIlx0Z3JheSArPSAtMS4wICogZ2V0R3JheSh0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKHV2Lngrc3RlcCwgdXYueSkgKSk7XCIsXHJcblxyXG4gICAgICAgICAgICBcIlx0Z3JheSArPSAtMS4wICogZ2V0R3JheSh0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKHV2Lngtc3RlcCwgdXYueStzdGVwKSApKTtcIixcclxuICAgICAgICAgICAgXCJcdGdyYXkgKz0gLTEuMCAqIGdldEdyYXkodGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMih1di54LCB1di55K3N0ZXApICkpO1wiLFxyXG4gICAgICAgICAgICBcIlx0Z3JheSArPSAtMS4wICogZ2V0R3JheSh0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKHV2Lngrc3RlcCwgdXYueStzdGVwKSApKTtcIixcclxuXHJcbiAgICAgICAgICAgIFwiXHRyZXR1cm4gZmxvb3IoZ3JheSswLjUpO1wiLFxyXG4gICAgICAgICAgICBcIn1cIixcclxuXHJcbiAgICAgICAgICAgIFwiZmxvYXQgZ2V0RmluYWxHcmF5KHZlYzIgdXYpe1wiLFxyXG4gICAgICAgICAgICBcIlx0ZmxvYXQgc3RlcCA9IDEuMC82MDAuMDtcIixcclxuICAgICAgICAgICAgXCJcdGZvcihpbnQgaT0tbGluZVdpZHRoOyBpPGxpbmVXaWR0aDsgaSsrKXtcIixcclxuICAgICAgICAgICAgXCJcdCAgICBmb3IoaW50IGo9LWxpbmVXaWR0aDsgajxsaW5lV2lkdGg7IGorKyl7XCIsXHJcbiAgICAgICAgICAgIFwiXHQgICAgICAgIGlmKGdldEVkZ2VHcmF5KHZlYzIodXYueCtzdGVwKmZsb2F0KGkpLCB1di55K3N0ZXAqZmxvYXQoaikpKT4wLjUpe1wiLFxyXG4gICAgICAgICAgICBcIlx0ICAgICAgICAgICAgcmV0dXJuIDEuMDtcIixcclxuICAgICAgICAgICAgXCJcdCAgICAgICAgfVwiLFxyXG4gICAgICAgICAgICBcIlx0ICAgIH1cIixcclxuICAgICAgICAgICAgXCJcdH1cIixcclxuICAgICAgICAgICAgXCJcdHJldHVybiAwLjA7XCIsXHJcbiAgICAgICAgICAgIFwifVwiLFxyXG5cclxuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG4gICAgICAgICAgICBcInZlYzQgdGV4ZWwgPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2VXYgKTtcIixcclxuICAgICAgICAgICAgXCJmbG9hdCBncmF5ID0gZ2V0RmluYWxHcmF5KHZVdik7XCIsXHJcblxyXG4gICAgICAgICAgICBcInZlYzQgZmluYWxDb2xvciA9IHZlYzQoMCwwLDEsMSkgKiBncmF5O1wiLFxyXG5cclxuICAgICAgICAgICAgXCJnbF9GcmFnQ29sb3IgPSBmaW5hbENvbG9yO1wiLFxyXG5cclxuICAgICAgICAgICAgXCJ9XCJcclxuXHJcbiAgICAgICAgXS5qb2luKCBcIlxcblwiICk7XHJcblxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDb21wb3NlcjtcclxuIiwiaW1wb3J0IENvbXBvc2VyIGZyb20gXCIuL0NvbXBvc2VyXCI7XHJcblxyXG5jbGFzcyBDb21wb3Nlck90aGVycyBleHRlbmRzIENvbXBvc2Vye1xyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICBzdXBlcigpO1xyXG5cclxuICAgICAgICB0aGlzLnZlcnRleFNoYWRlciA9XHJcbiAgICAgICAgICAgICdwcmVjaXNpb24gaGlnaHAgaW50O1xcbicgK1xyXG4gICAgICAgICAgICAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xyXG4gICAgICAgICAgICAnYXR0cmlidXRlIHZlYzQgYV9Qb3NpdGlvbjtcXG4nICtcclxuICAgICAgICAgICAgJ3VuaWZvcm0gbWF0NCB1X012TWF0cml4O1xcbicgK1xyXG4gICAgICAgICAgICAndW5pZm9ybSBtYXQ0IHVfUE1hdHJpeDtcXG4nICtcclxuICAgICAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcclxuICAgICAgICAgICAgJyAgZ2xfUG9zaXRpb24gPSB1X1BNYXRyaXggKiB1X012TWF0cml4ICogYV9Qb3NpdGlvbjtcXG4nICtcclxuICAgICAgICAgICAgJ31cXG4nO1xyXG5cclxuICAgICAgICB0aGlzLmZyYWdtZW50U2hhZGVyID0gJ3ByZWNpc2lvbiBoaWdocCBpbnQ7XFxuJyArXHJcbiAgICAgICAgICAgICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXHJcbiAgICAgICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXHJcbiAgICAgICAgICAgICcgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMCwwLDAsMCk7XFxuJyArXHJcbiAgICAgICAgICAgICd9XFxuJztcclxuXHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IENvbXBvc2VyT3RoZXJzO1xyXG4iLCJpbXBvcnQgQ29tcG9zZXIgZnJvbSBcIi4vQ29tcG9zZXJcIjtcclxuXHJcbmNsYXNzIENvbXBvc2VyU2NoZW1lIGV4dGVuZHMgQ29tcG9zZXJ7XHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHN1cGVyKCk7XHJcblxyXG4gICAgICAgIHRoaXMudmVydGV4U2hhZGVyID1cclxuICAgICAgICAgICAgJ3ByZWNpc2lvbiBoaWdocCBpbnQ7XFxuJyArXHJcbiAgICAgICAgICAgICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXHJcbiAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjNCBhX1Bvc2l0aW9uO1xcbicgK1xyXG4gICAgICAgICAgICAndW5pZm9ybSBtYXQ0IHVfTXZNYXRyaXg7XFxuJyArXHJcbiAgICAgICAgICAgICd1bmlmb3JtIG1hdDQgdV9QTWF0cml4O1xcbicgK1xyXG4gICAgICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xyXG4gICAgICAgICAgICAnICBnbF9Qb3NpdGlvbiA9IHVfUE1hdHJpeCAqIHVfTXZNYXRyaXggKiBhX1Bvc2l0aW9uO1xcbicgK1xyXG4gICAgICAgICAgICAnfVxcbic7XHJcblxyXG4gICAgICAgIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSAncHJlY2lzaW9uIGhpZ2hwIGludDtcXG4nICtcclxuICAgICAgICAgICAgJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcclxuICAgICAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcclxuICAgICAgICAgICAgJyAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgxLDEsMSwxKTtcXG4nICtcclxuICAgICAgICAgICAgJ31cXG4nO1xyXG5cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ29tcG9zZXJTY2hlbWU7XHJcbiIsImltcG9ydCBHZW9tZXRyeSBmcm9tIFwiLi9HZW9tZXRyeS5qc1wiO1xyXG5pbXBvcnQgTWVzaCBmcm9tIFwiLi9NZXNoLmpzXCI7XHJcbmltcG9ydCB7TWF0cml4NH0gZnJvbSBcIi4uL21hdGgvTWF0cml4NC5qc1wiO1xyXG5pbXBvcnQgQ2FtZXJhIGZyb20gXCIuLi9jYW1lcmEvQ2FtZXJhXCI7XHJcbmltcG9ydCBVdGlsIGZyb20gXCIuLi91dGlsL1V0aWxcIjtcclxuaW1wb3J0IEFtYmllbnRMaWdodCBmcm9tIFwiLi4vbGlnaHQvQW1iaWVudExpZ2h0XCI7XHJcbmltcG9ydCBEaXJlY3Rpb25hbExpZ2h0IGZyb20gXCIuLi9saWdodC9EaXJlY3Rpb25hbExpZ2h0XCI7XHJcbmltcG9ydCB7VmVjdG9yM30gZnJvbSBcIi4uL21hdGgvVmVjdG9yM1wiO1xyXG5pbXBvcnQgQ29tcG9zZXIgZnJvbSBcIi4uL2NvbXBvc2VyL0NvbXBvc2VyXCI7XHJcbmltcG9ydCBDb21wb3Nlck90aGVycyBmcm9tIFwiLi4vY29tcG9zZXIvQ29tcG9zZXJPdGhlcnNcIjtcclxuaW1wb3J0IENvbXBvc2VyU2NoZW1lIGZyb20gXCIuLi9jb21wb3Nlci9Db21wb3NlclNjaGVtZVwiO1xyXG5cclxuLy8gaW1wb3J0IG1kNSBmcm9tICdqcy1tZDUnO1xyXG5cclxuY2xhc3MgUmVuZGVyZXIge1xyXG4gICAgY29uc3RydWN0b3IocGFyYW0pIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgcGFyYW0gPSBwYXJhbSB8fCB7fTtcclxuICAgICAgICB0aGlzLmJ1ZmZlckxpc3QgPSBbXTtcclxuXHJcbiAgICAgICAgLy8gdGhpcy5wcm9ncmFtTGlzdCA9IFtdO1xyXG4gICAgICAgIHRoaXMucHJvZ3JhbUxpc3QgPSB7fTtcclxuXHJcbiAgICAgICAgdGhpcy5jdXJDYW1lcmFQb3NpdGlvbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJMaXN0ID0ge1xyXG4gICAgICAgICAgICBvcGFjaXR5TGlzdDpbXSxcclxuICAgICAgICAgICAgdHJhbnNwYXJlbnRMaXN0OltdXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3ZWJnbCcpO1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnKTtcclxuXHJcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgIGdsLmVuYWJsZShnbC5DVUxMX0ZBQ0UpO1xyXG4gICAgICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcclxuICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcclxuICAgICAgICAvLyBnbC5ibGVuZEZ1bmMoZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcclxuICAgICAgICBnbC5jbGVhckNvbG9yKDAuMCwgMC4wLCAwLjAsIDEuMCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGdldFByb2dyYW1CeVZGKHYsIGYpe1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgZ2wgPSB0aGF0LmdsO1xyXG5cclxuICAgICAgICB2YXIgdmVydGV4U2hhZGVyID0gdGhpcy52c2hhZGVyID0gVXRpbC5sb2FkU2hhZGVyKGdsLCBnbC5WRVJURVhfU0hBREVSLCB2KTtcclxuICAgICAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmZzaGFkZXIgPSBVdGlsLmxvYWRTaGFkZXIoZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgZik7XHJcbiAgICAgICAgaWYgKCF2ZXJ0ZXhTaGFkZXIgfHwgIWZyYWdtZW50U2hhZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XHJcbiAgICAgICAgaWYgKCFwcm9ncmFtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XHJcbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcclxuXHJcbiAgICAgICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgdmFyIGxpbmtlZCA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpO1xyXG4gICAgICAgIGlmICghbGlua2VkKSB7XHJcbiAgICAgICAgICAgIHZhciBlcnJvciA9IGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRmFpbGVkIHRvIGxpbmsgcHJvZ3JhbTogJyArIGVycm9yKTtcclxuICAgICAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgICAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcclxuICAgICAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKHZlcnRleFNoYWRlcik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHByb2dyYW07XHJcbiAgICB9XHJcblxyXG4gICAgc2V0UHJvZ3JhbSh2LCBmKXtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGdsID0gdGhhdC5nbDtcclxuXHJcbiAgICAgICAgLy8gaWYgKCFVdGlsLmluaXRTaGFkZXJzKGdsLCB2LCBmKSkge1xyXG4gICAgICAgIC8vICAgICBjb25zb2xlLmxvZygnRmFpbGVkIHRvIGludGlhbGl6ZSBzaGFkZXJzLicpO1xyXG4gICAgICAgIC8vICAgICByZXR1cm47XHJcbiAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICB2YXIgbWQ1dmYgPSAoditmKTtcclxuICAgICAgICB2YXIgcHJvZyA9IHRoYXQucHJvZ3JhbUxpc3RbbWQ1dmZdO1xyXG4gICAgICAgIGlmKHByb2cpe1xyXG4gICAgICAgICAgICBnbC51c2VQcm9ncmFtKHByb2cpO1xyXG4gICAgICAgICAgICBnbC5wcm9ncmFtID0gcHJvZztcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHByb2dyYW0gPSB0aGF0LmdldFByb2dyYW1CeVZGKHYsZik7XHJcblxyXG4gICAgICAgIHRoYXQucHJvZ3JhbUxpc3RbbWQ1dmZdID0gcHJvZ3JhbTtcclxuXHJcbiAgICAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgICAgICBnbC5wcm9ncmFtID0gcHJvZ3JhbTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRDYW1lcmFMaWdodChkaXJlY3Rpb25hbExpZ2h0KXtcclxuICAgICAgICB2YXIgY2FtZXJhTGlnaHQgPSBuZXcgQ09PTC5PcnRob0NhbWVyYSgtMTAwLCAxMDAsIC0xMDAsIDEwMCwgMCwgMzAwKTtcclxuICAgICAgICAvLyB2YXIgY2FtZXJhTGlnaHQgPSBuZXcgQ09PTC5DYW1lcmEoMzAsMSwxLDEwKTtcclxuICAgICAgICB2YXIgY2FQb3MgPSBkaXJlY3Rpb25hbExpZ2h0LmRpcmVjdGlvbjtcclxuICAgICAgICBjYVBvcyA9IGNhUG9zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaXRlbSAqIDEwMDtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjYW1lcmFMaWdodC5zZXRQb3NpdGlvbihjYVBvcyk7XHJcbiAgICAgICAgY2FtZXJhTGlnaHQuc2V0VGFyZ2V0KFswLDAsMF0pO1xyXG5cclxuICAgICAgICByZXR1cm4gY2FtZXJhTGlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKHNjZW5lLCBjYW1lcmEpe1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB0aGF0LmN1ckNhbWVyYVBvc2l0aW9uID0gY2FtZXJhLnBvc2l0aW9uO1xyXG5cclxuICAgICAgICB2YXIgcmVuZGVyTGlzdCA9IHRoYXQuc29ydFJlbmRlckxpc3Qoc2NlbmUpO1xyXG5cclxuICAgICAgICB2YXIgZ2wgPSB0aGF0LmdsO1xyXG4gICAgICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcclxuXHJcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IGdsLkRFUFRIX0JVRkZFUl9CSVQpO1xyXG4gICAgICAgIGlmKHRoYXQudXNlU2t5Qm94KXtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJTa3lCb3goY2FtZXJhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBhbWJpZW50TGlnaHQgPSBudWxsO1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb25hbExpZ2h0ID0gbnVsbDtcclxuXHJcbiAgICAgICAgZm9yKHZhciBpIGluIHNjZW5lLmxpZ2h0cyl7XHJcbiAgICAgICAgICAgIGlmKHNjZW5lLmxpZ2h0c1tpXS50eXBlID09ICdEaXJlY3Rpb25hbExpZ2h0Jyl7XHJcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb25hbExpZ2h0ID0gc2NlbmUubGlnaHRzW2ldO1xyXG4gICAgICAgICAgICB9ZWxzZSBpZihzY2VuZS5saWdodHNbaV0udHlwZSA9PSAnQW1iaWVudExpZ2h0Jyl7XHJcbiAgICAgICAgICAgICAgICBhbWJpZW50TGlnaHQgPSBzY2VuZS5saWdodHNbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGFtYmllbnRMaWdodCA9IGFtYmllbnRMaWdodCB8fCBuZXcgQW1iaWVudExpZ2h0KHtpbnRlbnNpdHk6MH0pO1xyXG4gICAgICAgIGRpcmVjdGlvbmFsTGlnaHQgPSBkaXJlY3Rpb25hbExpZ2h0IHx8IG5ldyBEaXJlY3Rpb25hbExpZ2h0KHtpbnRlbnNpdHk6MH0pO1xyXG5cclxuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xyXG4gICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIDYwMCwgNjAwKTtcclxuICAgICAgICBnbC5lbmFibGUgKGdsLkJMRU5EKTtcclxuICAgICAgICAvLyBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUIHwgZ2wuREVQVEhfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgZm9yKHZhciBpIGluIHJlbmRlckxpc3Qpe1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlck9uZU1lc2gocmVuZGVyTGlzdFtpXSwgY2FtZXJhLCBhbWJpZW50TGlnaHQsIGRpcmVjdGlvbmFsTGlnaHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyT25lTWVzaChtZXNoLCBjYW1lcmEsIGFtYmllbnRMaWdodCwgZGlyZWN0aW9uYWxMaWdodCl7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuICAgICAgICB2YXIgbWVzaCA9IG1lc2ggfHwgbmV3IE1lc2goKTtcclxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBtZXNoLmdlb21ldHJ5O1xyXG4gICAgICAgIHZhciBtYXRlcmlhbCA9IG1lc2gubWF0ZXJpYWw7XHJcbiAgICAgICAgdmFyIG1hcCA9IG1hdGVyaWFsLm1hcDtcclxuICAgICAgICB2YXIgZW52TWFwID0gbWF0ZXJpYWwuZW52TWFwO1xyXG4gICAgICAgIHZhciBjb2xvciA9IG1hdGVyaWFsLmNvbG9yO1xyXG5cclxuICAgICAgICB2YXIgdiA9IG1hdGVyaWFsLnZzaGFkZXJTb3VyY2U7XHJcbiAgICAgICAgdmFyIGYgPSBtYXRlcmlhbC5mc2hhZGVyU291cmNlO1xyXG5cclxuICAgICAgICB2YXIgdkRlZiA9ICcnO1xyXG4gICAgICAgIHZhciBmRGVmID0gJyc7XHJcbiAgICAgICAgaWYobWF0ZXJpYWwudHlwZSA9PSAnTWVzaExhbWJlcnRNYXRlcmlhbCcpe1xyXG4gICAgICAgICAgICBmRGVmICs9ICcjZGVmaW5lIFVTRV9BbWJpZW50TGlnaHRcXG4nO1xyXG4gICAgICAgICAgICBmRGVmICs9ICcjZGVmaW5lIFVTRV9EaXJlY3Rpb25hbExpZ2h0XFxuJztcclxuXHJcbiAgICAgICAgfWVsc2UgaWYobWF0ZXJpYWwudHlwZSA9PSAnTWVzaFN0YW5kYXJkTWF0ZXJpYWwnKXtcclxuXHJcbiAgICAgICAgICAgIGZEZWYgKz0gJyNkZWZpbmUgVVNFX0FtYmllbnRMaWdodFxcbic7XHJcblxyXG4gICAgICAgICAgICB2RGVmICs9ICcjZGVmaW5lIFVTRV9TQ29sb3JcXG4nO1xyXG5cclxuICAgICAgICAgICAgZkRlZiArPSAnI2RlZmluZSBVU0VfRGlyZWN0aW9uYWxMaWdodFxcbic7XHJcbiAgICAgICAgICAgIGZEZWYgKz0gJyNkZWZpbmUgVVNFX1NDb2xvclxcbic7XHJcblxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKG1hcCAmJiBtYXAuaW1hZ2UgJiYgbWFwLmltYWdlLndpZHRoICAmJiBtYXAuaW1hZ2UuaGVpZ2h0KXtcclxuICAgICAgICAgICAgZkRlZiArPSAnI2RlZmluZSBVU0VfTWFwXFxuJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKGVudk1hcCAmJiBlbnZNYXAuaW1nUmVhZHkpe1xyXG4gICAgICAgICAgICB2RGVmICs9ICcjZGVmaW5lIFVTRV9lbnZNYXBcXG4nO1xyXG4gICAgICAgICAgICBmRGVmICs9ICcjZGVmaW5lIFVTRV9lbnZNYXBcXG4nO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodGhhdC51c2VTaGFkb3cpe1xyXG4gICAgICAgICAgICB2RGVmICs9ICcjZGVmaW5lIFVTRV9TaGFkb3dcXG4nO1xyXG4gICAgICAgICAgICBmRGVmICs9ICcjZGVmaW5lIFVTRV9TaGFkb3dcXG4nO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdiA9IHZEZWYgKyB2O1xyXG4gICAgICAgIGYgPSBmRGVmICsgZjtcclxuXHJcbiAgICAgICAgdGhpcy5zZXRQcm9ncmFtKHYsZik7XHJcblxyXG4gICAgICAgIHZhciBnbCA9IHRoYXQuZ2w7XHJcblxyXG4gICAgICAgIHZhciBidWZmZXJNZXNoID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlck1lc2gpO1xyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeS5idWZmZXIsIGdsLlNUQVRJQ19EUkFXKTtcclxuICAgICAgICB2YXIgYnVmZmVyRlNJWkUgPSBnZW9tZXRyeS5idWZmZXIuQllURVNfUEVSX0VMRU1FTlQ7XHJcblxyXG4gICAgICAgIHZhciBhX1Bvc2l0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24oZ2wucHJvZ3JhbSwgJ2FfUG9zaXRpb24nKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFfUG9zaXRpb24sIDMsIGdsLkZMT0FULCBmYWxzZSwgYnVmZmVyRlNJWkUgKiA4LCBidWZmZXJGU0laRSAqIDApO1xyXG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFfUG9zaXRpb24pO1xyXG5cclxuICAgICAgICB2YXIgYV9Ob3JtYWwgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihnbC5wcm9ncmFtLCAnYV9Ob3JtYWwnKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFfTm9ybWFsLCAzLCBnbC5GTE9BVCwgZmFsc2UsIGJ1ZmZlckZTSVpFICogOCwgYnVmZmVyRlNJWkUgKiAzKTtcclxuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhX05vcm1hbCk7XHJcblxyXG4gICAgICAgIHZhciBhX1RleENvb3JkID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24oZ2wucHJvZ3JhbSwgJ2FfVGV4Q29vcmQnKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFfVGV4Q29vcmQsIDIsIGdsLkZMT0FULCBmYWxzZSwgYnVmZmVyRlNJWkUgKiA4LCBidWZmZXJGU0laRSAqIDYpO1xyXG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFfVGV4Q29vcmQpO1xyXG5cclxuXHJcbiAgICAgICAgdmFyIGluZGV4QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kZXhCdWZmZXIpO1xyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGdlb21ldHJ5LmluZGljZXMsIGdsLlNUQVRJQ19EUkFXKTtcclxuXHJcbiAgICAgICAgdmFyIHVfQ29sb3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oZ2wucHJvZ3JhbSwgJ3VfQ29sb3InKTtcclxuICAgICAgICBnbC51bmlmb3JtNGYodV9Db2xvciwgY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgY29sb3JbM10pO1xyXG5cclxuICAgICAgICB2YXIgdV9NZXRhbG5lc3MgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oZ2wucHJvZ3JhbSwgJ3VfTWV0YWxuZXNzJyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybTFmKHVfTWV0YWxuZXNzLCBtYXRlcmlhbC5tZXRhbG5lc3MpO1xyXG5cclxuICAgICAgICBpZihmLmluZGV4T2YoJyNkZWZpbmUgVVNFX1NDb2xvcicpIT0tMSB8fCBmLmluZGV4T2YoJyNkZWZpbmUgVVNFX2Vudk1hcCcpIT0tMSl7XHJcbiAgICAgICAgICAgIHZhciB1X0NhbWVyYV9Qb3NpdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihnbC5wcm9ncmFtLCAndV9DYW1lcmFfUG9zaXRpb24nKTtcclxuICAgICAgICAgICAgZ2wudW5pZm9ybTNmKHVfQ2FtZXJhX1Bvc2l0aW9uLCBjYW1lcmEucG9zaXRpb25bMF0sIGNhbWVyYS5wb3NpdGlvblsxXSwgY2FtZXJhLnBvc2l0aW9uWzJdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKGYuaW5kZXhPZignI2RlZmluZSBVU0VfQW1iaWVudExpZ2h0JykhPS0xKXtcclxuICAgICAgICAgICAgdmFyIHVfQW1iaWVudExpZ2h0X0NvbG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKGdsLnByb2dyYW0sICd1X0FtYmllbnRMaWdodF9Db2xvcicpO1xyXG4gICAgICAgICAgICB2YXIgYW1iaWVudExpZ2h0Q29sb3IgPSBhbWJpZW50TGlnaHQuY29sb3I7XHJcbiAgICAgICAgICAgIGFtYmllbnRMaWdodENvbG9yID0gYW1iaWVudExpZ2h0Q29sb3IubWFwKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYW1iaWVudExpZ2h0LmludGVuc2l0eSAqIGl0ZW07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBnbC51bmlmb3JtM2YodV9BbWJpZW50TGlnaHRfQ29sb3IsIGFtYmllbnRMaWdodENvbG9yWzBdLCBhbWJpZW50TGlnaHRDb2xvclsxXSwgYW1iaWVudExpZ2h0Q29sb3JbMl0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoZi5pbmRleE9mKCcjZGVmaW5lIFVTRV9EaXJlY3Rpb25hbExpZ2h0JykhPS0xKXtcclxuICAgICAgICAgICAgdmFyIHVfRGlyZWN0aW9uYWxMaWdodF9EaXJlY3Rpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oZ2wucHJvZ3JhbSwgJ3VfRGlyZWN0aW9uYWxMaWdodF9EaXJlY3Rpb24nKTtcclxuICAgICAgICAgICAgdmFyIGRpcmVjdGlvbmFsTGlnaHRfRGlyZWN0aW9uID0gZGlyZWN0aW9uYWxMaWdodC5kaXJlY3Rpb247XHJcbiAgICAgICAgICAgIGdsLnVuaWZvcm0zZih1X0RpcmVjdGlvbmFsTGlnaHRfRGlyZWN0aW9uLCBkaXJlY3Rpb25hbExpZ2h0X0RpcmVjdGlvblswXSwgZGlyZWN0aW9uYWxMaWdodF9EaXJlY3Rpb25bMV0sIGRpcmVjdGlvbmFsTGlnaHRfRGlyZWN0aW9uWzJdKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB1X0RpcmVjdGlvbmFsTGlnaHRfQ29sb3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oZ2wucHJvZ3JhbSwgJ3VfRGlyZWN0aW9uYWxMaWdodF9Db2xvcicpO1xyXG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uYWxMaWdodF9Db2xvciA9IGRpcmVjdGlvbmFsTGlnaHQuY29sb3I7XHJcbiAgICAgICAgICAgIGRpcmVjdGlvbmFsTGlnaHRfQ29sb3IgPSBkaXJlY3Rpb25hbExpZ2h0X0NvbG9yLm1hcChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbmFsTGlnaHQuaW50ZW5zaXR5ICogaXRlbTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGdsLnVuaWZvcm0zZih1X0RpcmVjdGlvbmFsTGlnaHRfQ29sb3IsIGRpcmVjdGlvbmFsTGlnaHRfQ29sb3JbMF0sIGRpcmVjdGlvbmFsTGlnaHRfQ29sb3JbMV0sIGRpcmVjdGlvbmFsTGlnaHRfQ29sb3JbMl0pO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIHZhciB1X012TWF0cml4ID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKGdsLnByb2dyYW0sICd1X012TWF0cml4Jyk7XHJcbiAgICAgICAgdmFyIG12TWF0cml4ID0gbWVzaC5tYXRyaXhXb3JsZDtcclxuICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHVfTXZNYXRyaXgsIGZhbHNlLCBtdk1hdHJpeC5lbGVtZW50cyk7XHJcblxyXG4gICAgICAgIHZhciB1X1BNYXRyaXggPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oZ2wucHJvZ3JhbSwgJ3VfUE1hdHJpeCcpO1xyXG4gICAgICAgIHZhciBQTWF0cml4ID0gY2FtZXJhLlZQbWF0cml4O1xyXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodV9QTWF0cml4LCBmYWxzZSwgUE1hdHJpeC5lbGVtZW50cyk7XHJcblxyXG4gICAgICAgIGlmKHYuaW5kZXhPZignI2RlZmluZSBVU0VfU2hhZG93JykhPS0xKXtcclxuICAgICAgICAgICAgdmFyIGNhID0gdGhhdC5nZXRDYW1lcmFMaWdodChkaXJlY3Rpb25hbExpZ2h0KTtcclxuICAgICAgICAgICAgdmFyIHVfUE1hdHJpeEZyb21MaWdodCA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihnbC5wcm9ncmFtLCAndV9QTWF0cml4RnJvbUxpZ2h0Jyk7XHJcbiAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodV9QTWF0cml4RnJvbUxpZ2h0LCBmYWxzZSwgY2EuVlBtYXRyaXguZWxlbWVudHMpO1xyXG5cclxuICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XHJcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoYXQuc2hhZG93X2Ziby50ZXh0dXJlKTtcclxuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIENPT0wuTElORUFSKTtcclxuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIENPT0wuTElORUFSKTtcclxuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgQ09PTC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgQ09PTC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICAgICAgdmFyIHVfU2hhZG93TWFwID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKGdsLnByb2dyYW0sICd1X1NoYWRvd01hcCcpO1xyXG4gICAgICAgICAgICBnbC51bmlmb3JtMWkodV9TaGFkb3dNYXAsIDApO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgaWYoZi5pbmRleE9mKCcjZGVmaW5lIFVTRV9NYXAnKSE9LTEpe1xyXG5cclxuICAgICAgICAgICAgdmFyIHRleHR1cmUgPSB0aGF0LnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7ICAgLy8gQ3JlYXRlIGEgdGV4dHVyZSBvYmplY3RcclxuICAgICAgICAgICAgLy8gZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgMSk7IC8vIEZsaXAgdGhlIGltYWdlJ3MgeSBheGlzXHJcblxyXG4gICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUxKTsgLy/lv4XpobvlnKhiaW5kVGV4dHVyZeS5i+WJjVxyXG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB1X1NhbXBsZXIgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oZ2wucHJvZ3JhbSwgJ3VfU2FtcGxlcicpO1xyXG4gICAgICAgICAgICBnbC51bmlmb3JtMWkodV9TYW1wbGVyLCAxKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNldCB0aGUgdGV4dHVyZSBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBtYXAubWFnRmlsdGVyKTtcclxuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIG1hcC5taW5GaWx0ZXIpO1xyXG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBtYXAud3JhcFMpO1xyXG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBtYXAud3JhcFQpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2V0IHRoZSB0ZXh0dXJlIGltYWdlXHJcbiAgICAgICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCLCBnbC5SR0IsIGdsLlVOU0lHTkVEX0JZVEUsIG1hcC5pbWFnZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihmLmluZGV4T2YoJyNkZWZpbmUgVVNFX2Vudk1hcCcpIT0tMSl7XHJcblxyXG4gICAgICAgICAgICB2YXIgdGV4dHVyZSA9IHRoYXQuZW52X3RleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XHJcbiAgICAgICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTcpO1xyXG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBpbWFnZXMgPSBlbnZNYXAuaW1hZ2VzO1xyXG4gICAgICAgICAgICB2YXIgZmFjZUluZm9zID0gW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YLFxyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlOmltYWdlc1swXSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBnbC5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1gsXHJcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2U6aW1hZ2VzWzFdLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWSxcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZTppbWFnZXNbMl0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZLFxyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlOmltYWdlc1szXSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1osXHJcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2U6aW1hZ2VzWzRdLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGdsLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWixcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZTppbWFnZXNbNV0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBdO1xyXG5cclxuICAgICAgICAgICAgZmFjZUluZm9zLmZvckVhY2goKGZhY2VJbmZvKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7dGFyZ2V0LCBpbWFnZX0gPSBmYWNlSW5mbztcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBsZXZlbCA9IDA7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHQkE7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmb3JtYXQgPSBnbC5SR0JBO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7XHJcblxyXG4gICAgICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZSk7XHJcbiAgICAgICAgICAgICAgICBnbC50ZXhJbWFnZTJEKHRhcmdldCwgbGV2ZWwsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUsIGltYWdlKTtcclxuXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGVudk1hcC5tYWdGaWx0ZXIpO1xyXG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZW52TWFwLm1pbkZpbHRlcik7XHJcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGVudk1hcC53cmFwUyk7XHJcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGVudk1hcC53cmFwVCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdV9lbnZNYXAgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oZ2wucHJvZ3JhbSwgXCJ1X2Vudk1hcFwiKTtcclxuICAgICAgICAgICAgZ2wudW5pZm9ybTFpKHVfZW52TWFwLCA3KTtcclxuXHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG1vZGVsID0gbWF0ZXJpYWwud2lyZWZyYW1lID8gZ2wuTElORV9TVFJJUCA6IGdsLlRSSUFOR0xFUztcclxuICAgICAgICBnbC5kcmF3RWxlbWVudHMobW9kZWwsIGdlb21ldHJ5LmluZGljZXMubGVuZ3RoLCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XHJcblxyXG4gICAgICAgIGlmKHRoYXQudGV4dHVyZSl7XHJcbiAgICAgICAgICAgIGdsLmRlbGV0ZVRleHR1cmUodGhhdC50ZXh0dXJlKTtcclxuICAgICAgICAgICAgdGhhdC50ZXh0dXJlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYodGhhdC5lbnZfdGV4dHVyZSl7XHJcbiAgICAgICAgICAgIGdsLmRlbGV0ZVRleHR1cmUodGhhdC5lbnZfdGV4dHVyZSk7XHJcbiAgICAgICAgICAgIHRoYXQuZW52X3RleHR1cmUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gZ2wuZGVsZXRlQnVmZmVyKGJ1ZmZlck1lc2gpO1xyXG4gICAgICAgIHRoYXQuYWRkQnVmZmVyKGJ1ZmZlck1lc2gpO1xyXG4gICAgICAgIGdsLmRlbGV0ZUJ1ZmZlcihpbmRleEJ1ZmZlcik7XHJcblxyXG4gICAgICAgIGdsLmRlbGV0ZVNoYWRlcih0aGF0LnZzaGFkZXIpO1xyXG4gICAgICAgIGdsLmRlbGV0ZVNoYWRlcih0aGF0LmZzaGFkZXIpO1xyXG4gICAgICAgIC8vIGdsLmRlbGV0ZVByb2dyYW0oZ2wucHJvZ3JhbSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGFkZEJ1ZmZlcihidWZmZXIpe1xyXG4gICAgICAgIC8v6L+Z5LiqYnVmZmVy5LiN6IO956uL5Y2z5Yig6Zmk77yM5Yig5LqG5LiL5LiA5bin5rKh5rex5bqm5Zu+77yM5pyq6Kej5LmL6LCcXHJcbiAgICAgICAgdGhpcy5idWZmZXJMaXN0LnB1c2goYnVmZmVyKTtcclxuICAgICAgICBpZih0aGlzLmJ1ZmZlckxpc3QubGVuZ3RoID4gMSl7XHJcbiAgICAgICAgICAgIHZhciBiYiA9IHRoaXMuYnVmZmVyTGlzdC5zaGlmdCgpO1xyXG4gICAgICAgICAgICB0aGlzLmdsLmRlbGV0ZUJ1ZmZlcihiYik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGdldEFsbE9iakxpc3Qob2JqLCBhbGxPYmpMaXN0KXtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgZm9yKHZhciBpIGluIG9iai5jaGlsZHJlbil7XHJcbiAgICAgICAgICAgIGlmKG9iai5jaGlsZHJlbltpXS5nZW9tZXRyeSl7XHJcbiAgICAgICAgICAgICAgICBhbGxPYmpMaXN0LnB1c2gob2JqLmNoaWxkcmVuW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGF0LmdldEFsbE9iakxpc3Qob2JqLmNoaWxkcmVuW2ldLGFsbE9iakxpc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYWxsT2JqTGlzdDtcclxuICAgIH1cclxuXHJcbiAgICBzb3J0UmVuZGVyTGlzdChzY2VuZSl7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuICAgICAgICB2YXIgYWxsT2JqTGlzdCA9IHRoYXQuZ2V0QWxsT2JqTGlzdChzY2VuZSAsW10pO1xyXG5cclxuICAgICAgICBmb3IodmFyIGkgaW4gYWxsT2JqTGlzdCl7XHJcbiAgICAgICAgICAgIHZhciBwYSA9IGFsbE9iakxpc3RbaV0uZ2V0V29ybGRQb3NpdGlvbigpO1xyXG4gICAgICAgICAgICB2YXIgcGMgPSBuZXcgVmVjdG9yMygpLmZyb21BcnJheSh0aGF0LmN1ckNhbWVyYVBvc2l0aW9uKTtcclxuICAgICAgICAgICAgdmFyIGRhID0gcGMuZGlzdGFuY2VUbyhwYSk7XHJcbiAgICAgICAgICAgIGFsbE9iakxpc3RbaV0uZGlzdGFuY2VUb0NhbWVyYSA9IGRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYWxsT2JqU29ydGVkTGlzdCA9IGFsbE9iakxpc3Quc29ydCh0aGF0LnNvcnRGdW4pO1xyXG4gICAgICAgIC8vIHZhciBvcGFjaXR5TGlzdCA9IFtdO1xyXG4gICAgICAgIC8vIHZhciB0cmFuc3BhcmVudExpc3QgPSBbXTtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIGZvcih2YXIgaSBpbiBhbGxPYmpTb3J0ZWRMaXN0KXtcclxuICAgICAgICAvLyAgICAgaWYoYWxsT2JqU29ydGVkTGlzdFtpXS5tYXRlcmlhbC50cmFuc3BhcmVudCl7XHJcbiAgICAgICAgLy8gICAgICAgICB0cmFuc3BhcmVudExpc3QucHVzaChhbGxPYmpTb3J0ZWRMaXN0W2ldKTtcclxuICAgICAgICAvLyAgICAgfWVsc2Uge1xyXG4gICAgICAgIC8vICAgICAgICAgb3BhY2l0eUxpc3QucHVzaChhbGxPYmpTb3J0ZWRMaXN0W2ldKTtcclxuICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIHRoYXQucmVuZGVyTGlzdCA9IHtcclxuICAgICAgICAvLyAgICAgb3BhY2l0eUxpc3Q6IG9wYWNpdHlMaXN0LFxyXG4gICAgICAgIC8vICAgICB0cmFuc3BhcmVudExpc3Q6IHRyYW5zcGFyZW50TGlzdFxyXG4gICAgICAgIC8vIH07XHJcblxyXG4gICAgICAgIHJldHVybiBhbGxPYmpTb3J0ZWRMaXN0O1xyXG4gICAgfVxyXG5cclxuICAgIHNvcnRGdW4oYSwgYil7XHJcbiAgICAgICAgcmV0dXJuIGIuZGlzdGFuY2VUb0NhbWVyYSAtIGEuZGlzdGFuY2VUb0NhbWVyYTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFJlbmRlcmVyO1xyXG4iLCJcclxuaW1wb3J0IHtWZWN0b3IzfSBmcm9tIFwiLi4vbWF0aC9WZWN0b3IzXCI7XHJcblxyXG5jbGFzcyBDYW1lcmFDb250cm9sbGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNhbWVyYSkge1xyXG4gICAgICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xyXG5cclxuICAgICAgICB0aGlzLm1vdXNlMFN0YXRlID0gJ3VwJztcclxuICAgICAgICB0aGlzLm1vdXNlMVN0YXRlID0gJ3VwJztcclxuICAgICAgICB0aGlzLm1vdXNlMlN0YXRlID0gJ3VwJztcclxuXHJcbiAgICAgICAgdGhpcy54ID0gLTE7XHJcbiAgICAgICAgdGhpcy55ID0gLTE7XHJcblxyXG4gICAgICAgIHRoaXMubWluVGlsdCA9IDAuMTtcclxuICAgICAgICB0aGlzLm1heFRpbHQgPSAzLjA0O1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZSgpe1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuXHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coZS5idXR0b24rJyBkb3duICcrZS5jbGllbnRYKycsJytlLmNsaWVudFkpO1xyXG4gICAgICAgICAgICB2YXIgZG9tID0gIHdpbmRvdy5kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY2FudmFzJylbMF07XHJcbiAgICAgICAgICAgIGlmKCFkb20pe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByZWN0ID0gZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICBpZihlLmNsaWVudFggPCByZWN0LmxlZnQgfHwgZS5jbGllbnRYID4gcmVjdC5yaWdodCB8fCBlLmNsaWVudFkgPCByZWN0LnRvcCB8fCBlLmNsaWVudFkgPiByZWN0LmJvdHRvbSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoZS5idXR0b24gPT0gMCl7XHJcbiAgICAgICAgICAgICAgICB0aGF0Lm1vdXNlMFN0YXRlID0gJ2Rvd24nO1xyXG4gICAgICAgICAgICB9ZWxzZSBpZihlLmJ1dHRvbiA9PSAxKXtcclxuICAgICAgICAgICAgICAgIHRoYXQubW91c2UxU3RhdGUgPSAnZG93bic7XHJcbiAgICAgICAgICAgIH1lbHNlIGlmKGUuYnV0dG9uID09IDIpe1xyXG4gICAgICAgICAgICAgICAgdGhhdC5tb3VzZTJTdGF0ZSA9ICdkb3duJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coZS5idXR0b24rJyB1cCAnK2UuY2xpZW50WCsnLCcrZS5jbGllbnRZKTtcclxuICAgICAgICAgICAgaWYoZS5idXR0b24gPT0gMCl7XHJcbiAgICAgICAgICAgICAgICB0aGF0Lm1vdXNlMFN0YXRlID0gJ3VwJztcclxuICAgICAgICAgICAgfWVsc2UgaWYoZS5idXR0b24gPT0gMSl7XHJcbiAgICAgICAgICAgICAgICB0aGF0Lm1vdXNlMVN0YXRlID0gJ3VwJztcclxuICAgICAgICAgICAgfWVsc2UgaWYoZS5idXR0b24gPT0gMil7XHJcbiAgICAgICAgICAgICAgICB0aGF0Lm1vdXNlMlN0YXRlID0gJ3VwJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJyxmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhlLmJ1dHRvbisnIG1vdmUgJytlLmNsaWVudFgrJywnK2UuY2xpZW50WSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgY2FtZXJhID0gdGhhdC5jYW1lcmE7XHJcbiAgICAgICAgICAgIGlmKHRoYXQubW91c2UwU3RhdGUgPT0gJ2Rvd24nKXtcclxuICAgICAgICAgICAgICAgIHZhciBkZWx0YVggPSBlLmNsaWVudFggLSB0aGF0Lng7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGFZID0gZS5jbGllbnRZIC0gdGhhdC55O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHZhciBhbmdsZSA9IE1hdGguc3FydChkZWx0YVgqZGVsdGFYICsgZGVsdGFZKmRlbHRhWSkvODA7XHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gdmFyIHVwVjMgPSBuZXcgVmVjdG9yMyhjYW1lcmEudXApO1xyXG4gICAgICAgICAgICAgICAgLy8gdmFyIHJpZ2h0VjMgPSBuZXcgVmVjdG9yMyhjYW1lcmEucmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vIHZhciBheGlzVjMgPSBuZXcgVmVjdG9yMygpLmFkZFZlY3RvcnMoIG5ldyBWZWN0b3IzKCkuc2NhbGVWZWN0b3JzKHVwVjMsZGVsdGFYKSAsIG5ldyBWZWN0b3IzKCkuc2NhbGVWZWN0b3JzKHJpZ2h0VjMsZGVsdGFZKSkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gdmFyIG9sZFBvc2l0aW9uVjMgPSBuZXcgVmVjdG9yMyhjYW1lcmEucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgLy8gdmFyIG5ld1Bvc2l0aW9uVjMgPSBuZXcgVmVjdG9yMygpLnJvdGF0ZUJ5VmVjdG9yKG9sZFBvc2l0aW9uVjMsIGF4aXNWMywgYW5nbGUpO1xyXG4gICAgICAgICAgICAgICAgLy8gdmFyIG5ld1Bvc2l0aW9uID0gbmV3UG9zaXRpb25WMy50b0FycmF5KCk7XHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gY2FtZXJhLnNldFBvc2l0aW9uKG5ld1Bvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgYXhpc1lWMyA9IG5ldyBWZWN0b3IzKDAsMSwwKTtcclxuICAgICAgICAgICAgICAgIHZhciBhbmdsZVkgPSBkZWx0YVgvMjAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9sZFBvc2l0aW9uVjMgPSBuZXcgVmVjdG9yMygpLmZyb21BcnJheShjYW1lcmEucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld1Bvc2l0aW9uVjMgPSBuZXcgVmVjdG9yMygpLnJvdGF0ZUJ5VmVjdG9yKG9sZFBvc2l0aW9uVjMsIGF4aXNZVjMsIGFuZ2xlWSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3UG9zaXRpb24gPSBuZXdQb3NpdGlvblYzLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIGNhbWVyYS5zZXRQb3NpdGlvbihuZXdQb3NpdGlvbik7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBhbmdsZVggPSBkZWx0YVkvMjAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRpbHQgPSB0aGF0LmdldFRpbHQoKTtcclxuICAgICAgICAgICAgICAgIHZhciBlbmRUaWx0ID0gdGlsdCAtIGFuZ2xlWDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihlbmRUaWx0PHRoYXQubWF4VGlsdCAmJiBlbmRUaWx0PnRoYXQubWluVGlsdCl7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBheGlzWFYzID0gbmV3IFZlY3RvcjMoY2FtZXJhLnJpZ2h0WzBdLCBjYW1lcmEucmlnaHRbMV0sIGNhbWVyYS5yaWdodFsyXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgb2xkUG9zaXRpb25WMyA9IG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KGNhbWVyYS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UG9zaXRpb25WMyA9IG5ldyBWZWN0b3IzKCkucm90YXRlQnlWZWN0b3Iob2xkUG9zaXRpb25WMywgYXhpc1hWMywgYW5nbGVYKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdQb3NpdGlvbiA9IG5ld1Bvc2l0aW9uVjMudG9BcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbWVyYS5zZXRQb3NpdGlvbihuZXdQb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZih0aGF0Lm1vdXNlMlN0YXRlID09ICdkb3duJyl7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGFYID0gZS5jbGllbnRYIC0gdGhhdC54O1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhWSA9IGUuY2xpZW50WSAtIHRoYXQueTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdGVtcFVwID0gbmV3IFZlY3RvcjMoKS5jcm9zc1ZlY3RvcnMobmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkoY2FtZXJhLnJpZ2h0KSwgbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkoY2FtZXJhLmRpcmVjdGlvbikpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGF4aXNZVjMgPSB0ZW1wVXA7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG9sZFRhcmdldFYzID0gbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkoY2FtZXJhLnRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3VGFyZ2V0VjMgPSBuZXcgVmVjdG9yMygpLmFkZFZlY3RvcnMob2xkVGFyZ2V0VjMsIG5ldyBWZWN0b3IzKCkuc2NhbGVWZWN0b3JzKGF4aXNZVjMsIGRlbHRhWS8zMCkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld1RhcmdldFYzID0gbmV3VGFyZ2V0VjMudG9BcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgY2FtZXJhLnNldFRhcmdldChuZXdUYXJnZXRWMyk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG9sZFBvc2l0aW9uVjMgPSBuZXcgVmVjdG9yMygpLmZyb21BcnJheShjYW1lcmEucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld1Bvc2l0aW9uVjMgPSBuZXcgVmVjdG9yMygpLmFkZFZlY3RvcnMob2xkUG9zaXRpb25WMywgbmV3IFZlY3RvcjMoKS5zY2FsZVZlY3RvcnMoYXhpc1lWMywgZGVsdGFZLzMwKSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3UG9zaXRpb24gPSBuZXdQb3NpdGlvblYzLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIGNhbWVyYS5zZXRQb3NpdGlvbihuZXdQb3NpdGlvbik7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGF4aXNYVjMgPSBuZXcgVmVjdG9yMygpLmZyb21BcnJheShjYW1lcmEucmlnaHQpO1xyXG5cclxuICAgICAgICAgICAgICAgIG9sZFRhcmdldFYzID0gbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkoY2FtZXJhLnRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICBuZXdUYXJnZXRWMyA9IG5ldyBWZWN0b3IzKCkuYWRkVmVjdG9ycyhvbGRUYXJnZXRWMywgbmV3IFZlY3RvcjMoKS5zY2FsZVZlY3RvcnMoYXhpc1hWMywgLWRlbHRhWC8zMCkpO1xyXG4gICAgICAgICAgICAgICAgbmV3VGFyZ2V0VjMgPSBuZXdUYXJnZXRWMy50b0FycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBjYW1lcmEuc2V0VGFyZ2V0KG5ld1RhcmdldFYzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBvbGRQb3NpdGlvblYzID0gbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkoY2FtZXJhLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdQb3NpdGlvblYzID0gbmV3IFZlY3RvcjMoKS5hZGRWZWN0b3JzKG9sZFBvc2l0aW9uVjMsIG5ldyBWZWN0b3IzKCkuc2NhbGVWZWN0b3JzKGF4aXNYVjMsIC1kZWx0YVgvMzApKTtcclxuICAgICAgICAgICAgICAgIG5ld1Bvc2l0aW9uID0gbmV3UG9zaXRpb25WMy50b0FycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBjYW1lcmEuc2V0UG9zaXRpb24obmV3UG9zaXRpb24pO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhhdC54ID0gZS5jbGllbnRYO1xyXG4gICAgICAgICAgICB0aGF0LnkgPSBlLmNsaWVudFk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJyxmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhlLmJ1dHRvbisnIHdoZWVsICcrZS53aGVlbERlbHRhKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjYW1lcmEgPSB0aGF0LmNhbWVyYTtcclxuXHJcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IGUud2hlZWxEZWx0YTtcclxuXHJcbiAgICAgICAgICAgIGlmKGRlbHRhID09IDAgfHwgdHlwZW9mKGRlbHRhKSAhPSAnbnVtYmVyJyl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVsdGEgPSBNYXRoLmFicyhkZWx0YSkvZGVsdGE7XHJcblxyXG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uVjMgPSBuZXcgVmVjdG9yMygpLmZyb21BcnJheShjYW1lcmEuZGlyZWN0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBvbGRQb3NpdGlvblYzID0gbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkoY2FtZXJhLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgdmFyIGRpcyA9IG9sZFBvc2l0aW9uVjMubGVuZ3RoU3EoKTtcclxuICAgICAgICAgICAgZGlzID0gTWF0aC5zcXJ0KGRpcyk7XHJcbiAgICAgICAgICAgIHZhciBuZXdQb3NpdGlvblYzID0gbmV3IFZlY3RvcjMoKS5hZGRWZWN0b3JzKG9sZFBvc2l0aW9uVjMsIG5ldyBWZWN0b3IzKCkuc2NhbGVWZWN0b3JzKGRpcmVjdGlvblYzLCBkaXMvMTAqZGVsdGEpKTtcclxuICAgICAgICAgICAgdmFyIG5ld1Bvc2l0aW9uID0gbmV3UG9zaXRpb25WMy50b0FycmF5KCk7XHJcblxyXG4gICAgICAgICAgICBjYW1lcmEuc2V0UG9zaXRpb24obmV3UG9zaXRpb24pO1xyXG5cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRUaWx0KCl7XHJcbiAgICAgICAgdmFyIGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xyXG4gICAgICAgIHZhciBkaXIgPSBjYW1lcmEuZGlyZWN0aW9uO1xyXG4gICAgICAgIHZhciBheGl4WSA9IG5ldyBWZWN0b3IzKDAsLTEsMCk7XHJcbiAgICAgICAgdmFyIGRpclYzID0gbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkoZGlyKTtcclxuXHJcbiAgICAgICAgdmFyIHRpbHQgPSBheGl4WS5hbmdsZVRvKGRpclYzKTtcclxuICAgICAgICByZXR1cm4gdGlsdDtcclxuXHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IENhbWVyYUNvbnRyb2xsZXI7XHJcbiIsImltcG9ydCBNZXNoIGZyb20gXCIuL01lc2guanNcIjtcclxuaW1wb3J0IEFtYmllbnRMaWdodCBmcm9tIFwiLi4vbGlnaHQvQW1iaWVudExpZ2h0XCI7XHJcblxyXG5jbGFzcyBTY2VuZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbSkge1xyXG4gICAgICAgIHBhcmFtID0gcGFyYW0gfHwge307XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgIHRoaXMubGlnaHRzID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgYWRkKG9iail7XHJcbiAgICAgICAgaWYob2JqLnR5cGUgPT0gJ01lc2gnKXtcclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKG9iaik7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHRoaXMubGlnaHRzLnB1c2gob2JqKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNjZW5lOyIsIlxyXG5jbGFzcyBUZXh0dXJlIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtKSB7XHJcbiAgICAgICAgcGFyYW0gPSBwYXJhbSB8fCB7fTtcclxuICAgICAgICB0aGlzLmltYWdlID0gcGFyYW0uaW1hZ2UgfHwgbmV3IEltYWdlKCk7XHJcbiAgICAgICAgdGhpcy53cmFwUyA9IHBhcmFtLndyYXBTIHx8IENPT0wuUkVQRUFUO1xyXG4gICAgICAgIHRoaXMud3JhcFQgPSBwYXJhbS53cmFwVCB8fCBDT09MLlJFUEVBVDtcclxuICAgICAgICB0aGlzLm1hZ0ZpbHRlciA9IHBhcmFtLm1hZ0ZpbHRlciB8fCBDT09MLk5FQVJFU1Q7XHJcbiAgICAgICAgdGhpcy5taW5GaWx0ZXIgPSBwYXJhbS5taW5GaWx0ZXIgfHwgQ09PTC5ORUFSRVNUO1xyXG4gICAgfVxyXG5cclxuICAgIGNsb25lKCl7XHJcblxyXG4gICAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgIGltYWdlLnNyYyA9IHRoaXMuaW1hZ2Uuc3JjO1xyXG5cclxuICAgICAgICB2YXIgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKHtcclxuICAgICAgICAgICAgaW1hZ2U6IGltYWdlLFxyXG4gICAgICAgICAgICB3cmFwUzogdGhpcy53cmFwUyxcclxuICAgICAgICAgICAgd3JhcFQ6IHRoaXMud3JhcFQsXHJcbiAgICAgICAgICAgIG1hZ0ZpbHRlcjogdGhpcy5tYWdGaWx0ZXIsXHJcbiAgICAgICAgICAgIG1pbkZpbHRlcjogdGhpcy5taW5GaWx0ZXJcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUZXh0dXJlO1xyXG4iLCJpbXBvcnQgTWF0ZXJpYWwgZnJvbSBcIi4vTWF0ZXJpYWxcIjtcclxuXHJcbmNsYXNzIE1lc2hCYXNpY01hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWx7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnTWVzaEJhc2ljTWF0ZXJpYWwnO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTWVzaEJhc2ljTWF0ZXJpYWw7XHJcbiIsImltcG9ydCBNYXRlcmlhbCBmcm9tIFwiLi9NYXRlcmlhbFwiO1xyXG5cclxuY2xhc3MgTWVzaExhbWJlcnRNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFse1xyXG4gICAgY29uc3RydWN0b3IocGFyYW0pIHtcclxuICAgICAgICBzdXBlcihwYXJhbSk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ01lc2hMYW1iZXJ0TWF0ZXJpYWwnO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTWVzaExhbWJlcnRNYXRlcmlhbDtcclxuIiwiaW1wb3J0IE1hdGVyaWFsIGZyb20gXCIuL01hdGVyaWFsXCI7XHJcblxyXG5jbGFzcyBNZXNoU3RhbmRhcmRNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFse1xyXG4gICAgY29uc3RydWN0b3IocGFyYW0pIHtcclxuICAgICAgICBzdXBlcihwYXJhbSk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ01lc2hTdGFuZGFyZE1hdGVyaWFsJztcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1lc2hTdGFuZGFyZE1hdGVyaWFsO1xyXG4iLCJpbXBvcnQge1ZlY3RvcjN9IGZyb20gXCIuLi9tYXRoL1ZlY3RvcjNcIjtcclxuaW1wb3J0IHtTcGhlcmV9IGZyb20gXCIuLi9tYXRoL1NwaGVyZVwiO1xyXG5pbXBvcnQge0JveDN9IGZyb20gXCIuLi9tYXRoL0JveDNcIjtcclxuXHJcbmNsYXNzIFNwaGVyZUdlb21ldHJ5IHtcclxuICAgIGNvbnN0cnVjdG9yKCByYWRpdXMsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcclxuXHJcbiAgICAgICAgcmFkaXVzID0gcmFkaXVzIHx8IDE7XHJcblxyXG4gICAgICAgIHdpZHRoU2VnbWVudHMgPSBNYXRoLm1heCggMywgTWF0aC5mbG9vciggd2lkdGhTZWdtZW50cyApIHx8IDggKTtcclxuICAgICAgICBoZWlnaHRTZWdtZW50cyA9IE1hdGgubWF4KCAyLCBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApIHx8IDYgKTtcclxuXHJcbiAgICAgICAgcGhpU3RhcnQgPSBwaGlTdGFydCAhPT0gdW5kZWZpbmVkID8gcGhpU3RhcnQgOiAwO1xyXG4gICAgICAgIHBoaUxlbmd0aCA9IHBoaUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gcGhpTGVuZ3RoIDogTWF0aC5QSSAqIDI7XHJcblxyXG4gICAgICAgIHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcclxuICAgICAgICB0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEk7XHJcblxyXG4gICAgICAgIHZhciB0aGV0YUVuZCA9IHRoZXRhU3RhcnQgKyB0aGV0YUxlbmd0aDtcclxuXHJcbiAgICAgICAgdmFyIGl4LCBpeTtcclxuXHJcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcclxuICAgICAgICB2YXIgZ3JpZCA9IFtdO1xyXG5cclxuICAgICAgICB2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcclxuICAgICAgICB2YXIgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgLy8gYnVmZmVyc1xyXG5cclxuICAgICAgICB2YXIgaW5kaWNlcyA9IFtdO1xyXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IFtdO1xyXG4gICAgICAgIHZhciBub3JtYWxzID0gW107XHJcbiAgICAgICAgdmFyIHV2cyA9IFtdO1xyXG5cclxuICAgICAgICAvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXHJcblxyXG4gICAgICAgIGZvciAoIGl5ID0gMDsgaXkgPD0gaGVpZ2h0U2VnbWVudHM7IGl5ICsrICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHZlcnRpY2VzUm93ID0gW107XHJcblxyXG4gICAgICAgICAgICB2YXIgdiA9IGl5IC8gaGVpZ2h0U2VnbWVudHM7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCBpeCA9IDA7IGl4IDw9IHdpZHRoU2VnbWVudHM7IGl4ICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB1ID0gaXggLyB3aWR0aFNlZ21lbnRzO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHZlcnRleFxyXG5cclxuICAgICAgICAgICAgICAgIHZlcnRleCA9IG5ldyBWZWN0b3IzKFxyXG4gICAgICAgICAgICAgICAgICAgIC0gcmFkaXVzICogTWF0aC5jb3MoIHBoaVN0YXJ0ICsgdSAqIHBoaUxlbmd0aCApICogTWF0aC5zaW4oIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKSxcclxuICAgICAgICAgICAgICAgICAgICByYWRpdXMgKiBNYXRoLmNvcyggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApLFxyXG4gICAgICAgICAgICAgICAgICAgIHJhZGl1cyAqIE1hdGguc2luKCBwaGlTdGFydCArIHUgKiBwaGlMZW5ndGggKSAqIE1hdGguc2luKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoIClcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG5vcm1hbFxyXG5cclxuICAgICAgICAgICAgICAgIG5vcm1hbCA9IHZlcnRleC5jbG9uZSgpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgbm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gdXZcclxuXHJcbiAgICAgICAgICAgICAgICB1dnMucHVzaCggdSwgMSAtIHYgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1Jvdy5wdXNoKCBpbmRleCArKyApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZ3JpZC5wdXNoKCB2ZXJ0aWNlc1JvdyApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGluZGljZXNcclxuXHJcbiAgICAgICAgZm9yICggaXkgPSAwOyBpeSA8IGhlaWdodFNlZ21lbnRzOyBpeSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIGl4ID0gMDsgaXggPCB3aWR0aFNlZ21lbnRzOyBpeCArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgYSA9IGdyaWRbIGl5IF1bIGl4ICsgMSBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGIgPSBncmlkWyBpeSBdWyBpeCBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBncmlkWyBpeSArIDEgXVsgaXggXTtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gZ3JpZFsgaXkgKyAxIF1bIGl4ICsgMSBdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggaXkgIT09IDAgfHwgdGhldGFTdGFydCA+IDAgKSBpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcclxuICAgICAgICAgICAgICAgIGlmICggaXkgIT09IGhlaWdodFNlZ21lbnRzIC0gMSB8fCB0aGV0YUVuZCA8IE1hdGguUEkgKSBpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0aWNlcyk7XHJcbiAgICAgICAgdGhpcy5ub3JtYWwgPSBuZXcgRmxvYXQzMkFycmF5KG5vcm1hbHMpO1xyXG4gICAgICAgIHRoaXMudXYgPSBuZXcgRmxvYXQzMkFycmF5KHV2cyk7XHJcblxyXG4gICAgICAgIHRoaXMuaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShpbmRpY2VzKTtcclxuXHJcbiAgICAgICAgdmFyIGJ1ZmZlciA9IFtdO1xyXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XHJcbiAgICAgICAgdmFyIG5vcm1hbCA9IHRoaXMubm9ybWFsO1xyXG4gICAgICAgIHZhciB1diA9IHRoaXMudXY7XHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8dmVydGljZXMubGVuZ3RoOyBpKz0zKXtcclxuICAgICAgICAgICAgYnVmZmVyLnB1c2godmVydGljZXNbaSswXSk7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKHZlcnRpY2VzW2krMV0pO1xyXG4gICAgICAgICAgICBidWZmZXIucHVzaCh2ZXJ0aWNlc1tpKzJdKTtcclxuXHJcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKG5vcm1hbFtpKzBdKTtcclxuICAgICAgICAgICAgYnVmZmVyLnB1c2gobm9ybWFsW2krMV0pO1xyXG4gICAgICAgICAgICBidWZmZXIucHVzaChub3JtYWxbaSsyXSk7XHJcblxyXG4gICAgICAgICAgICBidWZmZXIucHVzaCh1dltpLzMqMiswXSk7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKHV2W2kvMyoyKzFdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xyXG5cclxuICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSgpO1xyXG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgQm94MygpO1xyXG4gICAgICAgIHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGNvbXB1dGVCb3VuZGluZ0JveCAoKSB7XHJcbiAgICAgICAgdmFyIHZlcnRpY2VzVjMgPSBbXTtcclxuICAgICAgICBmb3IodmFyIGk9MDsgaTx0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSs9Myl7XHJcbiAgICAgICAgICAgIHZlcnRpY2VzVjMucHVzaChuZXcgVmVjdG9yMyh0aGlzLnZlcnRpY2VzW2ldLCB0aGlzLnZlcnRpY2VzW2krMV0sIHRoaXMudmVydGljZXNbaSsyXSkpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3guc2V0RnJvbVBvaW50cyh2ZXJ0aWNlc1YzKTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNwaGVyZUdlb21ldHJ5O1xyXG4iLCJpbXBvcnQgU2NlbmUgZnJvbSBcIi4vU2NlbmVcIjtcclxuaW1wb3J0IE1lc2ggZnJvbSBcIi4vTWVzaFwiO1xyXG5pbXBvcnQgR2VvbWV0cnkgZnJvbSBcIi4vR2VvbWV0cnlcIjtcclxuaW1wb3J0IE1lc2hMYW1iZXJ0TWF0ZXJpYWwgZnJvbSBcIi4uL21hdGVyaWFsL01lc2hMYW1iZXJ0TWF0ZXJpYWxcIjtcclxuaW1wb3J0IHtRdWF0ZXJuaW9ufSBmcm9tIFwiLi4vbWF0aC9RdWF0ZXJuaW9uXCI7XHJcbmltcG9ydCB7TWF0cml4NH0gZnJvbSBcIi4uL21hdGgvTWF0cml4NFwiO1xyXG5cclxuY2xhc3MgR0xURkxvYWRlcntcclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgdGhpcy5nbHRmT2JqID0gbnVsbDtcclxuICAgICAgICB0aGlzLnVybEJhc2UgPSBudWxsO1xyXG5cclxuICAgICAgICB0aGlzLmFycmF5QnVmZmVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuYXJyYXlCdWZmZXJDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5kYXRhVXJpUmVnZXggPSAvXmRhdGE6KC4qPykoO2Jhc2U2NCk/LCguKikkLztcclxuICAgIH1cclxuXHJcbiAgICBsb2FkKHVybCwgb25Mb2FkU3VjY2Vzcyl7XHJcbiAgICAgICAgdGhpcy5nbHRmT2JqID0gbnVsbDtcclxuICAgICAgICB0aGlzLnVybEJhc2UgPSBudWxsO1xyXG5cclxuICAgICAgICB0aGlzLmFycmF5QnVmZmVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuYXJyYXlCdWZmZXJDb3VudCA9IDA7XHJcblxyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgdXJsQXJyYXkgPSB1cmwuc3BsaXQoJy8nKTtcclxuICAgICAgICB2YXIganNvbk5hbWUgPSB1cmxBcnJheVt1cmxBcnJheS5sZW5ndGgtMV07XHJcbiAgICAgICAgdGhhdC51cmxCYXNlID0gdXJsLnNwbGl0KGpzb25OYW1lKVswXTtcclxuXHJcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICByZXF1ZXN0Lm9wZW4oXCJnZXRcIiwgdXJsKTtcclxuICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09IDIwMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGdsdGZPYmogPSBKU09OLnBhcnNlKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcclxuICAgICAgICAgICAgICAgIHRoYXQuZ2x0Zk9iaiA9IGdsdGZPYmo7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhnbHRmT2JqKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGF0LmFycmF5QnVmZmVyQ291bnQgPSBnbHRmT2JqLmJ1ZmZlcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxvYWRCdWZmZXJDb3VudCA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpIGluIGdsdGZPYmouYnVmZmVycyl7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBidWZmZXIgPSBnbHRmT2JqLmJ1ZmZlcnNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhVXJpUmVnZXhSZXN1bHQgPSBidWZmZXIudXJpLm1hdGNoKCB0aGF0LmRhdGFVcmlSZWdleCApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGRhdGFVcmlSZWdleFJlc3VsdCl7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gdGhhdC5iYXNlNjRUb0FycmF5QnVmZmVyKGRhdGFVcmlSZWdleFJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGJ1ZmZlcil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmFycmF5QnVmZmVyc1tpXSA9IGJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRCdWZmZXJDb3VudCArKztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihsb2FkQnVmZmVyQ291bnQgPSB0aGF0LmFycmF5QnVmZmVyQ291bnQpe1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NlbmVPYmogPSBnbHRmT2JqLnNjZW5lc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NlbmUgPSBuZXcgU2NlbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIG5vZGVpbmRleCBpbiBzY2VuZU9iai5ub2Rlcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2Rlc0luZGV4ID0gc2NlbmVPYmoubm9kZXNbbm9kZWluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVzT2JqID0gZ2x0Zk9iai5ub2Rlc1tub2Rlc0luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cl9tZXNoID0gdGhhdC5ub2RlVG9NZXNoKG5vZGVzT2JqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NlbmUuYWRkKGN1cl9tZXNoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Mb2FkU3VjY2VzcyhzY2VuZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBidWZmZXJEYXRhVXJpID0gdGhhdC51cmxCYXNlICsgYnVmZmVyLnVyaTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4oICdHRVQnLCBidWZmZXJEYXRhVXJpLCB0cnVlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMucmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmFycmF5QnVmZmVyc1tpXSA9IGJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRCdWZmZXJDb3VudCArKztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihsb2FkQnVmZmVyQ291bnQgPSB0aGF0LmFycmF5QnVmZmVyQ291bnQpe1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NlbmVPYmogPSBnbHRmT2JqLnNjZW5lc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NlbmUgPSBuZXcgU2NlbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIG5vZGVpbmRleCBpbiBzY2VuZU9iai5ub2Rlcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2Rlc0luZGV4ID0gc2NlbmVPYmoubm9kZXNbbm9kZWluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVzT2JqID0gZ2x0Zk9iai5ub2Rlc1tub2Rlc0luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cl9tZXNoID0gdGhhdC5ub2RlVG9NZXNoKG5vZGVzT2JqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NlbmUuYWRkKGN1cl9tZXNoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Mb2FkU3VjY2VzcyhzY2VuZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZhbHNlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2VuZCggbnVsbCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXF1ZXN0LnNlbmQobnVsbCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIG5vZGVUb01lc2gobm9kZSl7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuICAgICAgICB2YXIgbWVzaEluZGV4ID0gbm9kZS5tZXNoO1xyXG4gICAgICAgIHZhciBtZXNoID0gbnVsbDtcclxuXHJcbiAgICAgICAgaWYobWVzaEluZGV4ICE9IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIHZhciBtZXNoT2JqID0gdGhhdC5nbHRmT2JqLm1lc2hlc1ttZXNoSW5kZXhdO1xyXG4gICAgICAgICAgICB2YXIgZ2VvbWV0cnlBbmRNYXRlcmlhbCA9IHRoYXQubWVzaFRvR2VvbWV0cnkobWVzaE9iaik7XHJcbiAgICAgICAgICAgIG1lc2ggPSBuZXcgTWVzaCh7XHJcbiAgICAgICAgICAgICAgICBnZW9tZXRyeTpnZW9tZXRyeUFuZE1hdGVyaWFsWzBdLFxyXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWw6Z2VvbWV0cnlBbmRNYXRlcmlhbFsxXVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgbWVzaCA9IG5ldyBNZXNoKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc2NhbGUgPSBub2RlLnNjYWxlO1xyXG4gICAgICAgIGlmKHNjYWxlKXtcclxuICAgICAgICAgICAgbWVzaC5zZXRTY2FsZShzY2FsZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcm90YXRpb24gPSBub2RlLnJvdGF0aW9uO1xyXG4gICAgICAgIGlmKHJvdGF0aW9uKXtcclxuICAgICAgICAgICAgdmFyIHF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpLmZyb21BcnJheShyb3RhdGlvbik7XHJcbiAgICAgICAgICAgIG1lc2guc2V0UXVhdGVybmlvbihxdWF0ZXJuaW9uKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0cmFuc2xhdGlvbiA9IG5vZGUudHJhbnNsYXRpb247XHJcbiAgICAgICAgaWYodHJhbnNsYXRpb24pe1xyXG4gICAgICAgICAgICBtZXNoLnNldFBvc2l0aW9uKHRyYW5zbGF0aW9uKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBtYXRyaXggPSBub2RlLm1hdHJpeDtcclxuICAgICAgICBpZihtYXRyaXgpe1xyXG4gICAgICAgICAgICBtZXNoLnNldE1hdHJpeChuZXcgTWF0cml4NCgpLmZyb21BcnJheShtYXRyaXgpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvcih2YXIgaSBpbiBub2RlLmNoaWxkcmVuKXtcclxuICAgICAgICAgICAgdmFyIG5vZGVDaGlsZCA9IHRoYXQuZ2x0Zk9iai5ub2Rlc1tub2RlLmNoaWxkcmVuW2ldXTtcclxuICAgICAgICAgICAgdmFyIG1lc2hDaGlsZCA9IHRoYXQubm9kZVRvTWVzaChub2RlQ2hpbGQpO1xyXG4gICAgICAgICAgICBtZXNoLmFkZChtZXNoQ2hpbGQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG1lc2g7XHJcbiAgICB9XHJcblxyXG4gICAgbWVzaFRvR2VvbWV0cnkobWVzaCl7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuICAgICAgICB2YXIgcHJpbWl0aXZlMCA9IG1lc2gucHJpbWl0aXZlc1swXTtcclxuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHByaW1pdGl2ZTAuYXR0cmlidXRlcztcclxuXHJcbiAgICAgICAgdmFyIHBvc2l0aW9uQWNjZXNzb3JJbmRleCA9IGF0dHJpYnV0ZXMuUE9TSVRJT047XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uQWNjZXNzb3IgPSB0aGF0LmdsdGZPYmouYWNjZXNzb3JzW3Bvc2l0aW9uQWNjZXNzb3JJbmRleF07XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uQnVmZmVyVmlld0luZGV4ID0gcG9zaXRpb25BY2Nlc3Nvci5idWZmZXJWaWV3O1xyXG4gICAgICAgIHZhciBwb3NpdGlvbkJ1ZmZlclZpZXcgPSB0aGF0LmdsdGZPYmouYnVmZmVyVmlld3NbcG9zaXRpb25CdWZmZXJWaWV3SW5kZXhdO1xyXG4gICAgICAgIHZhciBwb3NpdGlvbkRhdGEgPSB0aGF0LmdldERhdGFCeUJ1ZmZlclZpZXcocG9zaXRpb25CdWZmZXJWaWV3LHBvc2l0aW9uQWNjZXNzb3IpO1xyXG5cclxuICAgICAgICB2YXIgbm9ybWFsQWNjZXNzb3JJbmRleCA9IGF0dHJpYnV0ZXMuTk9STUFMO1xyXG4gICAgICAgIHZhciBub3JtYWxBY2Nlc3NvciA9IHRoYXQuZ2x0Zk9iai5hY2Nlc3NvcnNbbm9ybWFsQWNjZXNzb3JJbmRleF07XHJcbiAgICAgICAgdmFyIG5vcm1hbEJ1ZmZlclZpZXdJbmRleCA9IG5vcm1hbEFjY2Vzc29yLmJ1ZmZlclZpZXc7XHJcbiAgICAgICAgdmFyIG5vcm1hbEJ1ZmZlclZpZXcgPSB0aGF0LmdsdGZPYmouYnVmZmVyVmlld3Nbbm9ybWFsQnVmZmVyVmlld0luZGV4XTtcclxuICAgICAgICB2YXIgbm9ybWFsRGF0YSA9IHRoYXQuZ2V0RGF0YUJ5QnVmZmVyVmlldyhub3JtYWxCdWZmZXJWaWV3LG5vcm1hbEFjY2Vzc29yKTtcclxuXHJcbiAgICAgICAgLy9URVhDT09SRF8wXHJcbiAgICAgICAgdmFyIHV2MEFjY2Vzc29ySW5kZXggPSBhdHRyaWJ1dGVzLlRFWENPT1JEXzA7XHJcbiAgICAgICAgdmFyIHV2MEFjY2Vzc29yID0gdGhhdC5nbHRmT2JqLmFjY2Vzc29yc1t1djBBY2Nlc3NvckluZGV4XTtcclxuICAgICAgICB2YXIgdXYwQnVmZmVyVmlld0luZGV4ID0gdXYwQWNjZXNzb3IuYnVmZmVyVmlldztcclxuICAgICAgICB2YXIgdXYwQnVmZmVyVmlldyA9IHRoYXQuZ2x0Zk9iai5idWZmZXJWaWV3c1t1djBCdWZmZXJWaWV3SW5kZXhdO1xyXG4gICAgICAgIHZhciB1djBEYXRhID0gdGhhdC5nZXREYXRhQnlCdWZmZXJWaWV3KHV2MEJ1ZmZlclZpZXcsdXYwQWNjZXNzb3IpO1xyXG5cclxuICAgICAgICB2YXIgaW5kaWNlc0RhdGEgPSBudWxsO1xyXG4gICAgICAgIHZhciBpbmRpY2VzQWNjZXNzb3JJbmRleCA9IHByaW1pdGl2ZTAuaW5kaWNlcztcclxuXHJcbiAgICAgICAgaWYoaW5kaWNlc0FjY2Vzc29ySW5kZXggIT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgdmFyIGluZGljZXNBY2Nlc3NvciA9IHRoYXQuZ2x0Zk9iai5hY2Nlc3NvcnNbaW5kaWNlc0FjY2Vzc29ySW5kZXhdO1xyXG4gICAgICAgICAgICB2YXIgaW5kaWNlc0J1ZmZlclZpZXdJbmRleCA9IGluZGljZXNBY2Nlc3Nvci5idWZmZXJWaWV3O1xyXG4gICAgICAgICAgICB2YXIgaW5kaWNlc0J1ZmZlclZpZXcgPSB0aGF0LmdsdGZPYmouYnVmZmVyVmlld3NbaW5kaWNlc0J1ZmZlclZpZXdJbmRleF07XHJcbiAgICAgICAgICAgIGluZGljZXNEYXRhID0gdGhhdC5nZXREYXRhQnlCdWZmZXJWaWV3KGluZGljZXNCdWZmZXJWaWV3LGluZGljZXNBY2Nlc3Nvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbWF0ZXJpYWxJbmRleCA9IHByaW1pdGl2ZTAubWF0ZXJpYWw7XHJcbiAgICAgICAgdmFyIG1hdGVyaWFsT2JqID0gdGhhdC5nbHRmT2JqLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcclxuXHJcbiAgICAgICAgaWYobWF0ZXJpYWxPYmoucGJyTWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZSl7XHJcbiAgICAgICAgICAgIHZhciBiYXNlQ29sb3JUZXh0dXJlSW5kZXggPSBtYXRlcmlhbE9iai5wYnJNZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlLmluZGV4O1xyXG4gICAgICAgICAgICB2YXIgdGV4dHVyZU9iaiA9IHRoYXQuZ2x0Zk9iai50ZXh0dXJlc1tiYXNlQ29sb3JUZXh0dXJlSW5kZXhdO1xyXG4gICAgICAgICAgICB2YXIgaW1hZ2VJbmRleCA9IHRleHR1cmVPYmouc291cmNlO1xyXG4gICAgICAgICAgICB2YXIgaW1hZ2VPYmogPSB0aGF0LmdsdGZPYmouaW1hZ2VzW2ltYWdlSW5kZXhdO1xyXG4gICAgICAgICAgICB2YXIgaW1hZ2VVcmkgPSBpbWFnZU9iai51cmk7XHJcblxyXG4gICAgICAgICAgICB2YXIgZGF0YVVyaVJlZ2V4UmVzdWx0ID0gaW1hZ2VPYmoudXJpLm1hdGNoKCB0aGF0LmRhdGFVcmlSZWdleCApO1xyXG4gICAgICAgICAgICBpZighZGF0YVVyaVJlZ2V4UmVzdWx0KXtcclxuICAgICAgICAgICAgICAgIGltYWdlVXJpID0gdGhhdC51cmxCYXNlICsgaW1hZ2VPYmoudXJpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgc2FtcGxlckluZGV4ID0gdGV4dHVyZU9iai5zYW1wbGVyO1xyXG4gICAgICAgICAgICB2YXIgc2FtcGxlciA9IHRoYXQuZ2x0Zk9iai5zYW1wbGVyc1tzYW1wbGVySW5kZXhdO1xyXG5cclxuICAgICAgICAgICAgdmFyIGltYWdlID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gXCJhbm9ueW1vdXNcIjtcclxuICAgICAgICAgICAgaW1hZ2Uuc3JjPSBpbWFnZVVyaTtcclxuXHJcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gbmV3IENPT0wuVGV4dHVyZSh7XHJcbiAgICAgICAgICAgICAgICBpbWFnZTppbWFnZSxcclxuICAgICAgICAgICAgICAgIC8v6L+Z5Lik5Liq5Y+C5pWw5pyJ6Zeu6aKY77yM5pyJ55qEOTcyOSA5OTg25piv5LuA5LmI5Lic6KW/XHJcbiAgICAgICAgICAgICAgICAvLyBtYWdGaWx0ZXI6IHNhbXBsZXIubWFnRmlsdGVyLFxyXG4gICAgICAgICAgICAgICAgLy8gbWluRmlsdGVyOiBzYW1wbGVyLm1pbkZpbHRlcixcclxuICAgICAgICAgICAgICAgIHdyYXBTOiBzYW1wbGVyLndyYXBTLFxyXG4gICAgICAgICAgICAgICAgd3JhcFQ6IHNhbXBsZXIud3JhcFQsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIHZhciBtYXRlcmlhbCA9IG5ldyBDT09MLk1lc2hMYW1iZXJ0TWF0ZXJpYWwoe21hcDp0ZXh0dXJlfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIG5ldyBHZW9tZXRyeSh7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlczogcG9zaXRpb25EYXRhLFxyXG4gICAgICAgICAgICAgICAgaW5kaWNlczogaW5kaWNlc0RhdGEsXHJcbiAgICAgICAgICAgICAgICBub3JtYWw6bm9ybWFsRGF0YSxcclxuICAgICAgICAgICAgICAgIHV2OnV2MERhdGFcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIG1hdGVyaWFsXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuXHJcbiAgICBnZXREYXRhQnlCdWZmZXJWaWV3KGJ1ZmZlclZpZXcsIGFjY2Vzc29yKXtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGJ1ZmZlckluZGV4ID0gYnVmZmVyVmlldy5idWZmZXI7XHJcblxyXG4gICAgICAgIHZhciBieXRlTGVuZ3RoID0gYnVmZmVyVmlldy5ieXRlTGVuZ3RoIHx8IDA7XHJcbiAgICAgICAgdmFyIGJ5dGVPZmZzZXQgPSBidWZmZXJWaWV3LmJ5dGVPZmZzZXQgfHwgMDtcclxuXHJcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoYXQuZ2x0Zk9iai5idWZmZXJzW2J1ZmZlckluZGV4XTtcclxuICAgICAgICB2YXIgYnVmZmVyRGF0YVVyaSA9IHRoYXQudXJsQmFzZSArIGJ1ZmZlci51cmk7XHJcblxyXG4gICAgICAgIHZhciBhcnJheUJ1ZmZlciA9IHRoYXQuYXJyYXlCdWZmZXJzW2J1ZmZlckluZGV4XTtcclxuXHJcbiAgICAgICAgdmFyIGN1cl9idWZmZXIgPSBhcnJheUJ1ZmZlci5zbGljZSggYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIGJ5dGVMZW5ndGggKTtcclxuXHJcbiAgICAgICAgdmFyIGFycmF5ID0gbnVsbDtcclxuICAgICAgICB2YXIgaXRlbVNpemUgPSBudWxsO1xyXG5cclxuICAgICAgICB2YXIgYWNjZXNzb3JCeXRlT2Zmc2V0ID0gYWNjZXNzb3IuYnl0ZU9mZnNldCB8fCAwO1xyXG5cclxuICAgICAgICBpZihhY2Nlc3Nvci50eXBlID09ICdTQ0FMQVInKXtcclxuICAgICAgICAgICAgaXRlbVNpemUgPSAxO1xyXG4gICAgICAgIH1lbHNlIGlmKGFjY2Vzc29yLnR5cGUgPT0gJ1ZFQzInKXtcclxuICAgICAgICAgICAgaXRlbVNpemUgPSAyO1xyXG4gICAgICAgIH1lbHNlIGlmKGFjY2Vzc29yLnR5cGUgPT0gJ1ZFQzMnKXtcclxuICAgICAgICAgICAgaXRlbVNpemUgPSAzO1xyXG4gICAgICAgIH1lbHNlIGlmKGFjY2Vzc29yLnR5cGUgPT0gJ1ZFQzQnKXtcclxuICAgICAgICAgICAgaXRlbVNpemUgPSA0O1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FjY2Vzc29yLnR5cGUgdW5kZWZpbmVkJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihhY2Nlc3Nvci5jb21wb25lbnRUeXBlID09IDUxMjYpe1xyXG4gICAgICAgICAgICBhcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIGN1cl9idWZmZXIsIGFjY2Vzc29yQnl0ZU9mZnNldCwgYWNjZXNzb3IuY291bnQgKiBpdGVtU2l6ZSApO1xyXG4gICAgICAgIH1lbHNlIGlmKGFjY2Vzc29yLmNvbXBvbmVudFR5cGUgPT0gNTEyMyl7XHJcbiAgICAgICAgICAgIGFycmF5ID0gbmV3IFVpbnQxNkFycmF5KCBjdXJfYnVmZmVyLCBhY2Nlc3NvckJ5dGVPZmZzZXQsIGFjY2Vzc29yLmNvdW50ICogaXRlbVNpemUgKTtcclxuICAgICAgICB9ZWxzZSBpZihhY2Nlc3Nvci5jb21wb25lbnRUeXBlID09IDUxMjApe1xyXG4gICAgICAgICAgICBhcnJheSA9IG5ldyBJbnQ4QXJyYXkoIGN1cl9idWZmZXIsIGFjY2Vzc29yQnl0ZU9mZnNldCwgYWNjZXNzb3IuY291bnQgKiBpdGVtU2l6ZSApO1xyXG4gICAgICAgIH1lbHNlIGlmKGFjY2Vzc29yLmNvbXBvbmVudFR5cGUgPT0gNTEyMSl7XHJcbiAgICAgICAgICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoIGN1cl9idWZmZXIsIGFjY2Vzc29yQnl0ZU9mZnNldCwgYWNjZXNzb3IuY291bnQgKiBpdGVtU2l6ZSApO1xyXG4gICAgICAgIH1lbHNlIGlmKGFjY2Vzc29yLmNvbXBvbmVudFR5cGUgPT0gNTEyMil7XHJcbiAgICAgICAgICAgIGFycmF5ID0gbmV3IEludDE2QXJyYXkoIGN1cl9idWZmZXIsIGFjY2Vzc29yQnl0ZU9mZnNldCwgYWNjZXNzb3IuY291bnQgKiBpdGVtU2l6ZSApO1xyXG4gICAgICAgIH1lbHNlIGlmKGFjY2Vzc29yLmNvbXBvbmVudFR5cGUgPT0gNTEyNSl7XHJcbiAgICAgICAgICAgIGFycmF5ID0gbmV3IFVpbnQzMkFycmF5KCBjdXJfYnVmZmVyLCBhY2Nlc3NvckJ5dGVPZmZzZXQsIGFjY2Vzc29yLmNvdW50ICogaXRlbVNpemUgKTtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdhY2Nlc3Nvci5jb21wb25lbnRUeXBlIHVuZGVmaW5lZCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGFycmF5O1xyXG5cclxuXHJcbiAgICB9XHJcblxyXG4gICAgYmFzZTY0VG9BcnJheUJ1ZmZlcihkYXRhVXJpUmVnZXhSZXN1bHQpe1xyXG5cclxuICAgICAgICB2YXIgZGF0YSA9IGRhdGFVcmlSZWdleFJlc3VsdFsgMyBdO1xyXG4gICAgICAgIGRhdGEgPSBkZWNvZGVVUklDb21wb25lbnQoIGRhdGEgKTtcclxuICAgICAgICBkYXRhID0gYXRvYiggZGF0YSApO1xyXG5cclxuICAgICAgICB0cnkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheSggZGF0YS5sZW5ndGggKTtcclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKysgKSB7XHJcbiAgICAgICAgICAgICAgICB2aWV3WyBpIF0gPSBkYXRhLmNoYXJDb2RlQXQoIGkgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGFycmF5QnVmZmVyID0gdmlldy5idWZmZXI7XHJcbiAgICAgICAgICAgIHJldHVybiBhcnJheUJ1ZmZlcjtcclxuXHJcbiAgICAgICAgfSBjYXRjaCAoIGVycm9yICkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBHTFRGTG9hZGVyO1xyXG4iLCJcclxuaW1wb3J0IHtNYXRyaXg0fSBmcm9tIFwiLi4vbWF0aC9NYXRyaXg0XCI7XHJcbmltcG9ydCB7VmVjdG9yM30gZnJvbSBcIi4uL21hdGgvVmVjdG9yM1wiO1xyXG5cclxuY2xhc3MgT3J0aG9DYW1lcmEge1xyXG4gICAgY29uc3RydWN0b3IobGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcclxuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xyXG4gICAgICAgIHRoaXMuX3JpZ2h0ID0gcmlnaHQ7XHJcbiAgICAgICAgdGhpcy5ib3R0b20gPSBib3R0b207XHJcbiAgICAgICAgdGhpcy50b3AgPSB0b3A7XHJcbiAgICAgICAgdGhpcy5uZWFyID0gbmVhcjtcclxuICAgICAgICB0aGlzLmZhciA9IGZhcjtcclxuXHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFswLCAwLCAxMF07XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSBbMCwwLDBdO1xyXG4gICAgICAgIHRoaXMudXAgPSBbMCwxLDBdO1xyXG5cclxuICAgICAgICB0aGlzLlZQbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBbMCwwLC0xXTtcclxuICAgICAgICB0aGlzLnJpZ2h0ID0gWzEsMCwwXTtcclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGVBbGwoKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVBbGwoKXtcclxuICAgICAgICB0aGlzLnVwZGF0ZU9wdGlvbigpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlVlBNYXRyaXgoKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVPcHRpb24oKXtcclxuICAgICAgICB2YXIgdGFyZ2V0VjMgPSBuZXcgVmVjdG9yMygpLmZyb21BcnJheSh0aGlzLnRhcmdldCk7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uVjMgPSBuZXcgVmVjdG9yMygpLmZyb21BcnJheSh0aGlzLnBvc2l0aW9uKTtcclxuICAgICAgICB2YXIgdXBWMyA9IG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KHRoaXMudXApO1xyXG5cclxuICAgICAgICB2YXIgZGlyZWN0aW9uVjMgPSBuZXcgVmVjdG9yMygpLnN1YlZlY3RvcnModGFyZ2V0VjMsIHBvc2l0aW9uVjMpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uVjMudG9BcnJheSgpO1xyXG5cclxuICAgICAgICB2YXIgcmlnaHRWMyA9IG5ldyBWZWN0b3IzKCkuY3Jvc3NWZWN0b3JzKGRpcmVjdGlvblYzLCB1cFYzKS5ub3JtYWxpemUoKTtcclxuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHRWMy50b0FycmF5KCk7XHJcblxyXG4gICAgICAgIC8vIHRoaXMudXAgPSBuZXcgVmVjdG9yMygpLmNyb3NzVmVjdG9ycyhyaWdodFYzLCBkaXJlY3Rpb25WMykubm9ybWFsaXplKCkudG9BcnJheSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFBvc2l0aW9uKHBvc2l0aW9uKXtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICAgICAgdGhpcy51cGRhdGVBbGwoKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRUYXJnZXQodGFyZ2V0KXtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aGlzLnVwZGF0ZUFsbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFVwKHVwKXtcclxuICAgICAgICB0aGlzLnVwID0gbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkodXApLm5vcm1hbGl6ZSgpLnRvQXJyYXkoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUFsbCgpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgdXBkYXRlVlBNYXRyaXgoKXtcclxuICAgICAgICB0aGlzLlZQbWF0cml4ID0gbmV3IE1hdHJpeDQoKS5zZXRPcnRobyh0aGlzLmxlZnQsIHRoaXMuX3JpZ2h0LCB0aGlzLmJvdHRvbSwgdGhpcy50b3AsIHRoaXMubmVhciwgdGhpcy5mYXIpO1xyXG4gICAgICAgIHRoaXMuVlBtYXRyaXgubG9va0F0Mih0aGlzLnBvc2l0aW9uWzBdLHRoaXMucG9zaXRpb25bMV0sdGhpcy5wb3NpdGlvblsyXSwgdGhpcy50YXJnZXRbMF0sdGhpcy50YXJnZXRbMV0sdGhpcy50YXJnZXRbMl0sIHRoaXMudXBbMF0sdGhpcy51cFsxXSx0aGlzLnVwWzJdKTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE9ydGhvQ2FtZXJhO1xyXG5cclxuIiwiaW1wb3J0IE1lc2ggZnJvbSBcIi4uL2NvcmUvTWVzaFwiO1xyXG5cclxuY2xhc3MgQW5pbWF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKG1lc2gpe1xyXG4gICAgICAgIHRoaXMubWVzaCA9IG1lc2ggfHwgbmV3IE1lc2goKTtcclxuICAgICAgICB0aGlzLnRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICB0aGlzLmluZGV4ID0gMDtcclxuICAgICAgICB0aGlzLmZyYW1lQ291bnQgPSB0aGlzLm1lc2guZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICBwbGF5KCl7XHJcbiAgICAgICAgdGhpcy50aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25Mb29wKCk7XHJcbiAgICB9XHJcblxyXG4gICAgYW5pbWF0aW9uTG9vcCgpe1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgY3VyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgIHZhciBjdXJJbmRleCA9IE1hdGguZmxvb3IoKGN1clRpbWUgLSB0aGlzLnRpbWUpLzEwMDAqMjApJXRoaXMuZnJhbWVDb3VudDtcclxuICAgICAgICBpZihjdXJJbmRleCAhPSB0aGlzLmluZGV4KXtcclxuICAgICAgICAgICAgdGhpcy5tZXNoLmdlb21ldHJ5LnZlcnRpY2VzID0gdGhpcy5tZXNoLmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbltjdXJJbmRleF0uYXJyYXk7XHJcbiAgICAgICAgICAgIHRoaXMubWVzaC5nZW9tZXRyeS51cGRhdGFCdWZmZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5pbmRleCA9IGN1ckluZGV4O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGF0LmFuaW1hdGlvbkxvb3AoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFuaW1hdGlvbjtcclxuIiwiaW1wb3J0IHsgUmF5IH0gZnJvbSAnLi4vbWF0aC9SYXkuanMnO1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXHJcbiAqIEBhdXRob3Igc3RlcGhvbWkgLyBodHRwOi8vc3RlcGhhbmVnaW5pZXIuY29tL1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIFJheWNhc3Rlciggb3JpZ2luLCBkaXJlY3Rpb24sIG5lYXIsIGZhciApIHtcclxuXHJcblx0dGhpcy5yYXkgPSBuZXcgUmF5KCBvcmlnaW4sIGRpcmVjdGlvbiApO1xyXG5cdC8vIGRpcmVjdGlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgKGZvciBhY2N1cmF0ZSBkaXN0YW5jZSBjYWxjdWxhdGlvbnMpXHJcblxyXG5cdHRoaXMubmVhciA9IG5lYXIgfHwgMDtcclxuXHR0aGlzLmZhciA9IGZhciB8fCBJbmZpbml0eTtcclxuXHJcblx0dGhpcy5wYXJhbXMgPSB7XHJcblx0XHRNZXNoOiB7fSxcclxuXHRcdExpbmU6IHt9LFxyXG5cdFx0TE9EOiB7fSxcclxuXHRcdFBvaW50czogeyB0aHJlc2hvbGQ6IDEgfSxcclxuXHRcdFNwcml0ZToge31cclxuXHR9O1xyXG5cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcy5wYXJhbXMsIHtcclxuXHRcdFBvaW50Q2xvdWQ6IHtcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ0NPT0wuUmF5Y2FzdGVyOiBwYXJhbXMuUG9pbnRDbG91ZCBoYXMgYmVlbiByZW5hbWVkIHRvIHBhcmFtcy5Qb2ludHMuJyApO1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLlBvaW50cztcclxuXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9ICk7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBhc2NTb3J0KCBhLCBiICkge1xyXG5cclxuXHRyZXR1cm4gYS5kaXN0YW5jZSAtIGIuZGlzdGFuY2U7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBpbnRlcnNlY3RPYmplY3QoIG9iamVjdCwgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKSB7XHJcblxyXG5cdGlmICggb2JqZWN0LnZpc2libGUgPT09IGZhbHNlKSByZXR1cm47XHJcblxyXG5cdGlmKG9iamVjdC5nZW9tZXRyeSl7XHJcbiAgICAgICAgb2JqZWN0LnJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApO1xyXG5cdH1cclxuXHJcblx0aWYgKCByZWN1cnNpdmUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0dmFyIGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRpbnRlcnNlY3RPYmplY3QoIGNoaWxkcmVuWyBpIF0sIHJheWNhc3RlciwgaW50ZXJzZWN0cywgdHJ1ZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuT2JqZWN0LmFzc2lnbiggUmF5Y2FzdGVyLnByb3RvdHlwZSwge1xyXG5cclxuXHRsaW5lUHJlY2lzaW9uOiAxLFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XHJcblxyXG5cdFx0Ly8gZGlyZWN0aW9uIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZCAoZm9yIGFjY3VyYXRlIGRpc3RhbmNlIGNhbGN1bGF0aW9ucylcclxuXHJcblx0XHR0aGlzLnJheS5zZXQoIG9yaWdpbiwgZGlyZWN0aW9uICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21DYW1lcmE6IGZ1bmN0aW9uICggY29vcmRzLCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0aWYgKCB0cnVlICkge1xyXG5cclxuXHRcdFx0dGhpcy5yYXkub3JpZ2luLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdHRoaXMucmF5LmRpcmVjdGlvbi5zZXQoIGNvb3Jkcy54LCBjb29yZHMueSwgMC41ICkudW5wcm9qZWN0KCBjYW1lcmEgKS5zdWIoIHRoaXMucmF5Lm9yaWdpbiApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdH1cclxuXHRcdC8vIGVsc2UgaWYgKCAoIGNhbWVyYSAmJiBjYW1lcmEuaXNPcnRob2dyYXBoaWNDYW1lcmEgKSApIHtcclxuXHRcdC8vXHJcblx0XHQvLyBcdHRoaXMucmF5Lm9yaWdpbi5zZXQoIGNvb3Jkcy54LCBjb29yZHMueSwgKCBjYW1lcmEubmVhciArIGNhbWVyYS5mYXIgKSAvICggY2FtZXJhLm5lYXIgLSBjYW1lcmEuZmFyICkgKS51bnByb2plY3QoIGNhbWVyYSApOyAvLyBzZXQgb3JpZ2luIGluIHBsYW5lIG9mIGNhbWVyYVxyXG5cdFx0Ly8gXHR0aGlzLnJheS5kaXJlY3Rpb24uc2V0KCAwLCAwLCAtIDEgKS50cmFuc2Zvcm1EaXJlY3Rpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xyXG5cdFx0Ly9cclxuXHRcdC8vIH0gZWxzZSB7XHJcblx0XHQvL1xyXG5cdFx0Ly8gXHRjb25zb2xlLmVycm9yKCAnQ09PTC5SYXljYXN0ZXI6IFVuc3VwcG9ydGVkIGNhbWVyYSB0eXBlLicgKTtcclxuXHRcdC8vXHJcblx0XHQvLyB9XHJcblxyXG5cdH0sXHJcblxyXG5cdGludGVyc2VjdE9iamVjdDogZnVuY3Rpb24gKCBvYmplY3QsIHJlY3Vyc2l2ZSwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIGludGVyc2VjdHMgPSBvcHRpb25hbFRhcmdldCB8fCBbXTtcclxuXHJcblx0XHRpbnRlcnNlY3RPYmplY3QoIG9iamVjdCwgdGhpcywgaW50ZXJzZWN0cywgcmVjdXJzaXZlICk7XHJcblxyXG5cdFx0aW50ZXJzZWN0cy5zb3J0KCBhc2NTb3J0ICk7XHJcblxyXG5cdFx0cmV0dXJuIGludGVyc2VjdHM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGludGVyc2VjdE9iamVjdHM6IGZ1bmN0aW9uICggb2JqZWN0cywgcmVjdXJzaXZlLCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgaW50ZXJzZWN0cyA9IG9wdGlvbmFsVGFyZ2V0IHx8IFtdO1xyXG5cclxuXHRcdGlmICggQXJyYXkuaXNBcnJheSggb2JqZWN0cyApID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ0NPT0wuUmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdHM6IG9iamVjdHMgaXMgbm90IGFuIEFycmF5LicgKTtcclxuXHRcdFx0cmV0dXJuIGludGVyc2VjdHM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGludGVyc2VjdE9iamVjdCggb2JqZWN0c1sgaSBdLCB0aGlzLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aW50ZXJzZWN0cy5zb3J0KCBhc2NTb3J0ICk7XHJcblxyXG5cdFx0cmV0dXJuIGludGVyc2VjdHM7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuXHJcblxyXG5leHBvcnQgeyBSYXljYXN0ZXIgfTtcclxuIiwiLyoqXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvZXZlbnRkaXNwYXRjaGVyLmpzL1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEV2ZW50RGlzcGF0Y2hlcigpIHt9XHJcblxyXG5PYmplY3QuYXNzaWduKCBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLCB7XHJcblxyXG5cdGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xyXG5cclxuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XHJcblxyXG5cdFx0aWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0bGlzdGVuZXJzWyB0eXBlIF0gPSBbXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApID09PSAtIDEgKSB7XHJcblxyXG5cdFx0XHRsaXN0ZW5lcnNbIHR5cGUgXS5wdXNoKCBsaXN0ZW5lciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0aGFzRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XHJcblxyXG5cdFx0cmV0dXJuIGxpc3RlbmVyc1sgdHlwZSBdICE9PSB1bmRlZmluZWQgJiYgbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSAhPT0gLSAxO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm47XHJcblxyXG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcclxuXHRcdHZhciBsaXN0ZW5lckFycmF5ID0gbGlzdGVuZXJzWyB0eXBlIF07XHJcblxyXG5cdFx0aWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR2YXIgaW5kZXggPSBsaXN0ZW5lckFycmF5LmluZGV4T2YoIGxpc3RlbmVyICk7XHJcblxyXG5cdFx0XHRpZiAoIGluZGV4ICE9PSAtIDEgKSB7XHJcblxyXG5cdFx0XHRcdGxpc3RlbmVyQXJyYXkuc3BsaWNlKCBpbmRleCwgMSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0ZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gKCBldmVudCApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xyXG5cclxuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XHJcblx0XHR2YXIgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgZXZlbnQudHlwZSBdO1xyXG5cclxuXHRcdGlmICggbGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gdGhpcztcclxuXHJcblx0XHRcdHZhciBhcnJheSA9IGxpc3RlbmVyQXJyYXkuc2xpY2UoIDAgKTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGFycmF5WyBpIF0uY2FsbCggdGhpcywgZXZlbnQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuXHJcblxyXG5leHBvcnQgeyBFdmVudERpc3BhdGNoZXIgfTtcclxuIiwiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi9tYXRoL0NvbG9yLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5mdW5jdGlvbiBGYWNlMyggYSwgYiwgYywgbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxJbmRleCApIHtcclxuXHJcblx0dGhpcy5hID0gYTtcclxuXHR0aGlzLmIgPSBiO1xyXG5cdHRoaXMuYyA9IGM7XHJcblxyXG5cdHRoaXMubm9ybWFsID0gKCBub3JtYWwgJiYgbm9ybWFsLmlzVmVjdG9yMyApID8gbm9ybWFsIDogbmV3IFZlY3RvcjMoKTtcclxuXHR0aGlzLnZlcnRleE5vcm1hbHMgPSBBcnJheS5pc0FycmF5KCBub3JtYWwgKSA/IG5vcm1hbCA6IFtdO1xyXG5cclxuXHR0aGlzLmNvbG9yID0gKCBjb2xvciAmJiBjb2xvci5pc0NvbG9yICkgPyBjb2xvciA6IG5ldyBDb2xvcigpO1xyXG5cdHRoaXMudmVydGV4Q29sb3JzID0gQXJyYXkuaXNBcnJheSggY29sb3IgKSA/IGNvbG9yIDogW107XHJcblxyXG5cdHRoaXMubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXggIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsSW5kZXggOiAwO1xyXG5cclxufVxyXG5cclxuT2JqZWN0LmFzc2lnbiggRmFjZTMucHJvdG90eXBlLCB7XHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0XHR0aGlzLmEgPSBzb3VyY2UuYTtcclxuXHRcdHRoaXMuYiA9IHNvdXJjZS5iO1xyXG5cdFx0dGhpcy5jID0gc291cmNlLmM7XHJcblxyXG5cdFx0dGhpcy5ub3JtYWwuY29weSggc291cmNlLm5vcm1hbCApO1xyXG5cdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcclxuXHJcblx0XHR0aGlzLm1hdGVyaWFsSW5kZXggPSBzb3VyY2UubWF0ZXJpYWxJbmRleDtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gc291cmNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnZlcnRleE5vcm1hbHNbIGkgXSA9IHNvdXJjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0uY2xvbmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnZlcnRleENvbG9yc1sgaSBdID0gc291cmNlLnZlcnRleENvbG9yc1sgaSBdLmNsb25lKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcblxyXG5cclxuZXhwb3J0IHsgRmFjZTMgfTtcclxuIiwiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4vVmVjdG9yMy5qcyc7XHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICogQGF1dGhvciB0c2Nod1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIE1hdHJpeDMoKSB7XHJcblxyXG5cdHRoaXMuZWxlbWVudHMgPSBbXHJcblxyXG5cdFx0MSwgMCwgMCxcclxuXHRcdDAsIDEsIDAsXHJcblx0XHQwLCAwLCAxXHJcblxyXG5cdF07XHJcblxyXG5cdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0Y29uc29sZS5lcnJvciggJ0NPT0wuTWF0cml4MzogdGhlIGNvbnN0cnVjdG9yIG5vIGxvbmdlciByZWFkcyBhcmd1bWVudHMuIHVzZSAuc2V0KCkgaW5zdGVhZC4nICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbk9iamVjdC5hc3NpZ24oIE1hdHJpeDMucHJvdG90eXBlLCB7XHJcblxyXG5cdGlzTWF0cml4MzogdHJ1ZSxcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIG4xMSwgbjEyLCBuMTMsIG4yMSwgbjIyLCBuMjMsIG4zMSwgbjMyLCBuMzMgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR0ZVsgMCBdID0gbjExOyB0ZVsgMSBdID0gbjIxOyB0ZVsgMiBdID0gbjMxO1xyXG5cdFx0dGVbIDMgXSA9IG4xMjsgdGVbIDQgXSA9IG4yMjsgdGVbIDUgXSA9IG4zMjtcclxuXHRcdHRlWyA2IF0gPSBuMTM7IHRlWyA3IF0gPSBuMjM7IHRlWyA4IF0gPSBuMzM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGlkZW50aXR5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHQxLCAwLCAwLFxyXG5cdFx0XHQwLCAxLCAwLFxyXG5cdFx0XHQwLCAwLCAxXHJcblxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5mcm9tQXJyYXkoIHRoaXMuZWxlbWVudHMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRlWyAwIF0gPSBtZVsgMCBdOyB0ZVsgMSBdID0gbWVbIDEgXTsgdGVbIDIgXSA9IG1lWyAyIF07XHJcblx0XHR0ZVsgMyBdID0gbWVbIDMgXTsgdGVbIDQgXSA9IG1lWyA0IF07IHRlWyA1IF0gPSBtZVsgNSBdO1xyXG5cdFx0dGVbIDYgXSA9IG1lWyA2IF07IHRlWyA3IF0gPSBtZVsgNyBdOyB0ZVsgOCBdID0gbWVbIDggXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbU1hdHJpeDQ6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0bWVbIDAgXSwgbWVbIDQgXSwgbWVbIDggXSxcclxuXHRcdFx0bWVbIDEgXSwgbWVbIDUgXSwgbWVbIDkgXSxcclxuXHRcdFx0bWVbIDIgXSwgbWVbIDYgXSwgbWVbIDEwIF1cclxuXHJcblx0XHQpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhcHBseVRvQnVmZmVyQXR0cmlidXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gYXBwbHlUb0J1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYXR0cmlidXRlLmNvdW50OyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0djEueCA9IGF0dHJpYnV0ZS5nZXRYKCBpICk7XHJcblx0XHRcdFx0djEueSA9IGF0dHJpYnV0ZS5nZXRZKCBpICk7XHJcblx0XHRcdFx0djEueiA9IGF0dHJpYnV0ZS5nZXRaKCBpICk7XHJcblxyXG5cdFx0XHRcdHYxLmFwcGx5TWF0cml4MyggdGhpcyApO1xyXG5cclxuXHRcdFx0XHRhdHRyaWJ1dGUuc2V0WFlaKCBpLCB2MS54LCB2MS55LCB2MS56ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gYXR0cmlidXRlO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLCBtICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHByZW11bHRpcGx5OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggbSwgdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseU1hdHJpY2VzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0dmFyIGFlID0gYS5lbGVtZW50cztcclxuXHRcdHZhciBiZSA9IGIuZWxlbWVudHM7XHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHZhciBhMTEgPSBhZVsgMCBdLCBhMTIgPSBhZVsgMyBdLCBhMTMgPSBhZVsgNiBdO1xyXG5cdFx0dmFyIGEyMSA9IGFlWyAxIF0sIGEyMiA9IGFlWyA0IF0sIGEyMyA9IGFlWyA3IF07XHJcblx0XHR2YXIgYTMxID0gYWVbIDIgXSwgYTMyID0gYWVbIDUgXSwgYTMzID0gYWVbIDggXTtcclxuXHJcblx0XHR2YXIgYjExID0gYmVbIDAgXSwgYjEyID0gYmVbIDMgXSwgYjEzID0gYmVbIDYgXTtcclxuXHRcdHZhciBiMjEgPSBiZVsgMSBdLCBiMjIgPSBiZVsgNCBdLCBiMjMgPSBiZVsgNyBdO1xyXG5cdFx0dmFyIGIzMSA9IGJlWyAyIF0sIGIzMiA9IGJlWyA1IF0sIGIzMyA9IGJlWyA4IF07XHJcblxyXG5cdFx0dGVbIDAgXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMTtcclxuXHRcdHRlWyAzIF0gPSBhMTEgKiBiMTIgKyBhMTIgKiBiMjIgKyBhMTMgKiBiMzI7XHJcblx0XHR0ZVsgNiBdID0gYTExICogYjEzICsgYTEyICogYjIzICsgYTEzICogYjMzO1xyXG5cclxuXHRcdHRlWyAxIF0gPSBhMjEgKiBiMTEgKyBhMjIgKiBiMjEgKyBhMjMgKiBiMzE7XHJcblx0XHR0ZVsgNCBdID0gYTIxICogYjEyICsgYTIyICogYjIyICsgYTIzICogYjMyO1xyXG5cdFx0dGVbIDcgXSA9IGEyMSAqIGIxMyArIGEyMiAqIGIyMyArIGEyMyAqIGIzMztcclxuXHJcblx0XHR0ZVsgMiBdID0gYTMxICogYjExICsgYTMyICogYjIxICsgYTMzICogYjMxO1xyXG5cdFx0dGVbIDUgXSA9IGEzMSAqIGIxMiArIGEzMiAqIGIyMiArIGEzMyAqIGIzMjtcclxuXHRcdHRlWyA4IF0gPSBhMzEgKiBiMTMgKyBhMzIgKiBiMjMgKyBhMzMgKiBiMzM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR0ZVsgMCBdICo9IHM7IHRlWyAzIF0gKj0gczsgdGVbIDYgXSAqPSBzO1xyXG5cdFx0dGVbIDEgXSAqPSBzOyB0ZVsgNCBdICo9IHM7IHRlWyA3IF0gKj0gcztcclxuXHRcdHRlWyAyIF0gKj0gczsgdGVbIDUgXSAqPSBzOyB0ZVsgOCBdICo9IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRldGVybWluYW50OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR2YXIgYSA9IHRlWyAwIF0sIGIgPSB0ZVsgMSBdLCBjID0gdGVbIDIgXSxcclxuXHRcdFx0ZCA9IHRlWyAzIF0sIGUgPSB0ZVsgNCBdLCBmID0gdGVbIDUgXSxcclxuXHRcdFx0ZyA9IHRlWyA2IF0sIGggPSB0ZVsgNyBdLCBpID0gdGVbIDggXTtcclxuXHJcblx0XHRyZXR1cm4gYSAqIGUgKiBpIC0gYSAqIGYgKiBoIC0gYiAqIGQgKiBpICsgYiAqIGYgKiBnICsgYyAqIGQgKiBoIC0gYyAqIGUgKiBnO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRJbnZlcnNlOiBmdW5jdGlvbiAoIG1hdHJpeCwgdGhyb3dPbkRlZ2VuZXJhdGUgKSB7XHJcblxyXG5cdFx0aWYgKCBtYXRyaXggJiYgbWF0cml4LmlzTWF0cml4NCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiQ09PTC5NYXRyaXgzOiAuZ2V0SW52ZXJzZSgpIG5vIGxvbmdlciB0YWtlcyBhIE1hdHJpeDQgYXJndW1lbnQuXCIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG1lID0gbWF0cml4LmVsZW1lbnRzLFxyXG5cdFx0XHR0ZSA9IHRoaXMuZWxlbWVudHMsXHJcblxyXG5cdFx0XHRuMTEgPSBtZVsgMCBdLCBuMjEgPSBtZVsgMSBdLCBuMzEgPSBtZVsgMiBdLFxyXG5cdFx0XHRuMTIgPSBtZVsgMyBdLCBuMjIgPSBtZVsgNCBdLCBuMzIgPSBtZVsgNSBdLFxyXG5cdFx0XHRuMTMgPSBtZVsgNiBdLCBuMjMgPSBtZVsgNyBdLCBuMzMgPSBtZVsgOCBdLFxyXG5cclxuXHRcdFx0dDExID0gbjMzICogbjIyIC0gbjMyICogbjIzLFxyXG5cdFx0XHR0MTIgPSBuMzIgKiBuMTMgLSBuMzMgKiBuMTIsXHJcblx0XHRcdHQxMyA9IG4yMyAqIG4xMiAtIG4yMiAqIG4xMyxcclxuXHJcblx0XHRcdGRldCA9IG4xMSAqIHQxMSArIG4yMSAqIHQxMiArIG4zMSAqIHQxMztcclxuXHJcblx0XHRpZiAoIGRldCA9PT0gMCApIHtcclxuXHJcblx0XHRcdHZhciBtc2cgPSBcIkNPT0wuTWF0cml4MzogLmdldEludmVyc2UoKSBjYW4ndCBpbnZlcnQgbWF0cml4LCBkZXRlcm1pbmFudCBpcyAwXCI7XHJcblxyXG5cdFx0XHRpZiAoIHRocm93T25EZWdlbmVyYXRlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCBtc2cgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmlkZW50aXR5KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBkZXRJbnYgPSAxIC8gZGV0O1xyXG5cclxuXHRcdHRlWyAwIF0gPSB0MTEgKiBkZXRJbnY7XHJcblx0XHR0ZVsgMSBdID0gKCBuMzEgKiBuMjMgLSBuMzMgKiBuMjEgKSAqIGRldEludjtcclxuXHRcdHRlWyAyIF0gPSAoIG4zMiAqIG4yMSAtIG4zMSAqIG4yMiApICogZGV0SW52O1xyXG5cclxuXHRcdHRlWyAzIF0gPSB0MTIgKiBkZXRJbnY7XHJcblx0XHR0ZVsgNCBdID0gKCBuMzMgKiBuMTEgLSBuMzEgKiBuMTMgKSAqIGRldEludjtcclxuXHRcdHRlWyA1IF0gPSAoIG4zMSAqIG4xMiAtIG4zMiAqIG4xMSApICogZGV0SW52O1xyXG5cclxuXHRcdHRlWyA2IF0gPSB0MTMgKiBkZXRJbnY7XHJcblx0XHR0ZVsgNyBdID0gKCBuMjEgKiBuMTMgLSBuMjMgKiBuMTEgKSAqIGRldEludjtcclxuXHRcdHRlWyA4IF0gPSAoIG4yMiAqIG4xMSAtIG4yMSAqIG4xMiApICogZGV0SW52O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0cmFuc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdG1wLCBtID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR0bXAgPSBtWyAxIF07IG1bIDEgXSA9IG1bIDMgXTsgbVsgMyBdID0gdG1wO1xyXG5cdFx0dG1wID0gbVsgMiBdOyBtWyAyIF0gPSBtWyA2IF07IG1bIDYgXSA9IHRtcDtcclxuXHRcdHRtcCA9IG1bIDUgXTsgbVsgNSBdID0gbVsgNyBdOyBtWyA3IF0gPSB0bXA7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldE5vcm1hbE1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXg0ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnNldEZyb21NYXRyaXg0KCBtYXRyaXg0ICkuZ2V0SW52ZXJzZSggdGhpcyApLnRyYW5zcG9zZSgpO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0cmFuc3Bvc2VJbnRvQXJyYXk6IGZ1bmN0aW9uICggciApIHtcclxuXHJcblx0XHR2YXIgbSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0clsgMCBdID0gbVsgMCBdO1xyXG5cdFx0clsgMSBdID0gbVsgMyBdO1xyXG5cdFx0clsgMiBdID0gbVsgNiBdO1xyXG5cdFx0clsgMyBdID0gbVsgMSBdO1xyXG5cdFx0clsgNCBdID0gbVsgNCBdO1xyXG5cdFx0clsgNSBdID0gbVsgNyBdO1xyXG5cdFx0clsgNiBdID0gbVsgMiBdO1xyXG5cdFx0clsgNyBdID0gbVsgNSBdO1xyXG5cdFx0clsgOCBdID0gbVsgOCBdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRVdlRyYW5zZm9ybTogZnVuY3Rpb24gKCB0eCwgdHksIHN4LCBzeSwgcm90YXRpb24sIGN4LCBjeSApIHtcclxuXHJcblx0XHR2YXIgYyA9IE1hdGguY29zKCByb3RhdGlvbiApO1xyXG5cdFx0dmFyIHMgPSBNYXRoLnNpbiggcm90YXRpb24gKTtcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHRcdFx0c3ggKiBjLCBzeCAqIHMsIC0gc3ggKiAoIGMgKiBjeCArIHMgKiBjeSApICsgY3ggKyB0eCxcclxuXHRcdFx0LSBzeSAqIHMsIHN5ICogYywgLSBzeSAqICggLSBzICogY3ggKyBjICogY3kgKSArIGN5ICsgdHksXHJcblx0XHRcdDAsIDAsIDFcclxuXHRcdCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNjYWxlOiBmdW5jdGlvbiAoIHN4LCBzeSApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRlWyAwIF0gKj0gc3g7IHRlWyAzIF0gKj0gc3g7IHRlWyA2IF0gKj0gc3g7XHJcblx0XHR0ZVsgMSBdICo9IHN5OyB0ZVsgNCBdICo9IHN5OyB0ZVsgNyBdICo9IHN5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyb3RhdGU6IGZ1bmN0aW9uICggdGhldGEgKSB7XHJcblxyXG5cdFx0dmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKTtcclxuXHRcdHZhciBzID0gTWF0aC5zaW4oIHRoZXRhICk7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR2YXIgYTExID0gdGVbIDAgXSwgYTEyID0gdGVbIDMgXSwgYTEzID0gdGVbIDYgXTtcclxuXHRcdHZhciBhMjEgPSB0ZVsgMSBdLCBhMjIgPSB0ZVsgNCBdLCBhMjMgPSB0ZVsgNyBdO1xyXG5cclxuXHRcdHRlWyAwIF0gPSBjICogYTExICsgcyAqIGEyMTtcclxuXHRcdHRlWyAzIF0gPSBjICogYTEyICsgcyAqIGEyMjtcclxuXHRcdHRlWyA2IF0gPSBjICogYTEzICsgcyAqIGEyMztcclxuXHJcblx0XHR0ZVsgMSBdID0gLSBzICogYTExICsgYyAqIGEyMTtcclxuXHRcdHRlWyA0IF0gPSAtIHMgKiBhMTIgKyBjICogYTIyO1xyXG5cdFx0dGVbIDcgXSA9IC0gcyAqIGExMyArIGMgKiBhMjM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCB0eCwgdHkgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR0ZVsgMCBdICs9IHR4ICogdGVbIDIgXTsgdGVbIDMgXSArPSB0eCAqIHRlWyA1IF07IHRlWyA2IF0gKz0gdHggKiB0ZVsgOCBdO1xyXG5cdFx0dGVbIDEgXSArPSB0eSAqIHRlWyAyIF07IHRlWyA0IF0gKz0gdHkgKiB0ZVsgNSBdOyB0ZVsgNyBdICs9IHR5ICogdGVbIDggXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0dmFyIG1lID0gbWF0cml4LmVsZW1lbnRzO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDk7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRlWyBpIF0gIT09IG1lWyBpIF0gKSByZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA5OyBpICsrICkge1xyXG5cclxuXHRcdFx0dGhpcy5lbGVtZW50c1sgaSBdID0gYXJyYXlbIGkgKyBvZmZzZXQgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xyXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0ZVsgMCBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRlWyAxIF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGVbIDIgXTtcclxuXHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGVbIDMgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyA0IF0gPSB0ZVsgNCBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDUgXSA9IHRlWyA1IF07XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCArIDYgXSA9IHRlWyA2IF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgNyBdID0gdGVbIDcgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyA4IF0gPSB0ZVsgOCBdO1xyXG5cclxuXHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0fVxyXG5cclxufSApO1xyXG5cclxuXHJcbmV4cG9ydCB7IE1hdHJpeDMgfTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gTGF5ZXJzKCkge1xyXG5cclxuXHR0aGlzLm1hc2sgPSAxIHwgMDtcclxuXHJcbn1cclxuXHJcbk9iamVjdC5hc3NpZ24oIExheWVycy5wcm90b3R5cGUsIHtcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIGNoYW5uZWwgKSB7XHJcblxyXG5cdFx0dGhpcy5tYXNrID0gMSA8PCBjaGFubmVsIHwgMDtcclxuXHJcblx0fSxcclxuXHJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoIGNoYW5uZWwgKSB7XHJcblxyXG5cdFx0dGhpcy5tYXNrIHw9IDEgPDwgY2hhbm5lbCB8IDA7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvZ2dsZTogZnVuY3Rpb24gKCBjaGFubmVsICkge1xyXG5cclxuXHRcdHRoaXMubWFzayBePSAxIDw8IGNoYW5uZWwgfCAwO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoIGNoYW5uZWwgKSB7XHJcblxyXG5cdFx0dGhpcy5tYXNrICY9IH4gKCAxIDw8IGNoYW5uZWwgfCAwICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRlc3Q6IGZ1bmN0aW9uICggbGF5ZXJzICkge1xyXG5cclxuXHRcdHJldHVybiAoIHRoaXMubWFzayAmIGxheWVycy5tYXNrICkgIT09IDA7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuXHJcblxyXG5leHBvcnQgeyBMYXllcnMgfTtcclxuIiwiaW1wb3J0IHtRdWF0ZXJuaW9ufSBmcm9tICcuLi9tYXRoL1F1YXRlcm5pb24uanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcclxuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uL21hdGgvTWF0cml4NC5qcyc7XHJcbmltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJy4vRXZlbnREaXNwYXRjaGVyLmpzJztcclxuaW1wb3J0ICB7RXVsZXJ9ICBmcm9tICcuLi9tYXRoL0V1bGVyLmpzJztcclxuaW1wb3J0IHsgTGF5ZXJzIH0gZnJvbSAnLi9MYXllcnMuanMnO1xyXG5pbXBvcnQgeyBNYXRyaXgzIH0gZnJvbSAnLi4vbWF0aC9NYXRyaXgzLmpzJztcclxuaW1wb3J0ICB7X01hdGh9ICBmcm9tICcuLi9tYXRoL01hdGguanMnO1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKiBAYXV0aG9yIGVsZXBoYW50YXR3b3JrIC8gd3d3LmVsZXBoYW50YXR3b3JrLmNoXHJcbiAqL1xyXG5cclxudmFyIG9iamVjdDNESWQgPSAwO1xyXG5cclxuZnVuY3Rpb24gT2JqZWN0M0QoKSB7XHJcblxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogb2JqZWN0M0RJZCArKyB9ICk7XHJcblxyXG5cdHRoaXMudXVpZCA9IF9NYXRoLmdlbmVyYXRlVVVJRCgpO1xyXG5cclxuXHR0aGlzLm5hbWUgPSAnJztcclxuXHR0aGlzLnR5cGUgPSAnT2JqZWN0M0QnO1xyXG5cclxuXHR0aGlzLnBhcmVudCA9IG51bGw7XHJcblx0dGhpcy5jaGlsZHJlbiA9IFtdO1xyXG5cclxuXHR0aGlzLnVwID0gT2JqZWN0M0QuRGVmYXVsdFVwLmNsb25lKCk7XHJcblxyXG5cdHZhciBwb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XHJcblx0dmFyIHJvdGF0aW9uID0gbmV3IEV1bGVyKCk7XHJcblx0dmFyIHF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xyXG5cdHZhciBzY2FsZSA9IG5ldyBWZWN0b3IzKCAxLCAxLCAxICk7XHJcblxyXG5cdGZ1bmN0aW9uIG9uUm90YXRpb25DaGFuZ2UoKSB7XHJcblxyXG5cdFx0cXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIHJvdGF0aW9uLCBmYWxzZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIG9uUXVhdGVybmlvbkNoYW5nZSgpIHtcclxuXHJcblx0XHRyb3RhdGlvbi5zZXRGcm9tUXVhdGVybmlvbiggcXVhdGVybmlvbiwgdW5kZWZpbmVkLCBmYWxzZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJvdGF0aW9uLm9uQ2hhbmdlKCBvblJvdGF0aW9uQ2hhbmdlICk7XHJcblx0cXVhdGVybmlvbi5vbkNoYW5nZSggb25RdWF0ZXJuaW9uQ2hhbmdlICk7XHJcblxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLCB7XHJcblx0XHRwb3NpdGlvbjoge1xyXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdHZhbHVlOiBwb3NpdGlvblxyXG5cdFx0fSxcclxuXHRcdHJvdGF0aW9uOiB7XHJcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0dmFsdWU6IHJvdGF0aW9uXHJcblx0XHR9LFxyXG5cdFx0cXVhdGVybmlvbjoge1xyXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdHZhbHVlOiBxdWF0ZXJuaW9uXHJcblx0XHR9LFxyXG5cdFx0c2NhbGU6IHtcclxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHR2YWx1ZTogc2NhbGVcclxuXHRcdH0sXHJcblx0XHRtb2RlbFZpZXdNYXRyaXg6IHtcclxuXHRcdFx0dmFsdWU6IG5ldyBNYXRyaXg0KClcclxuXHRcdH0sXHJcblx0XHRub3JtYWxNYXRyaXg6IHtcclxuXHRcdFx0dmFsdWU6IG5ldyBNYXRyaXgzKClcclxuXHRcdH1cclxuXHR9ICk7XHJcblxyXG5cdHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcclxuXHR0aGlzLm1hdHJpeFdvcmxkID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gT2JqZWN0M0QuRGVmYXVsdE1hdHJpeEF1dG9VcGRhdGU7XHJcblx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdHRoaXMubGF5ZXJzID0gbmV3IExheWVycygpO1xyXG5cdHRoaXMudmlzaWJsZSA9IHRydWU7XHJcblxyXG5cdHRoaXMuY2FzdFNoYWRvdyA9IGZhbHNlO1xyXG5cdHRoaXMucmVjZWl2ZVNoYWRvdyA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLmZydXN0dW1DdWxsZWQgPSB0cnVlO1xyXG5cdHRoaXMucmVuZGVyT3JkZXIgPSAwO1xyXG5cclxuXHR0aGlzLnVzZXJEYXRhID0ge307XHJcblxyXG59XHJcblxyXG5PYmplY3QzRC5EZWZhdWx0VXAgPSBuZXcgVmVjdG9yMyggMCwgMSwgMCApO1xyXG5PYmplY3QzRC5EZWZhdWx0TWF0cml4QXV0b1VwZGF0ZSA9IHRydWU7XHJcblxyXG5PYmplY3QzRC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlICksIHtcclxuXHJcblx0Y29uc3RydWN0b3I6IE9iamVjdDNELFxyXG5cclxuXHRpc09iamVjdDNEOiB0cnVlLFxyXG5cclxuXHRvbkJlZm9yZVJlbmRlcjogZnVuY3Rpb24gKCkge30sXHJcblx0b25BZnRlclJlbmRlcjogZnVuY3Rpb24gKCkge30sXHJcblxyXG5cdGFwcGx5TWF0cml4OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcclxuXHJcblx0XHR0aGlzLm1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXgsIHRoaXMubWF0cml4ICk7XHJcblxyXG5cdFx0dGhpcy5tYXRyaXguZGVjb21wb3NlKCB0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIHRoaXMuc2NhbGUgKTtcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlRdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XHJcblxyXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLnByZW11bHRpcGx5KCBxICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFJvdGF0aW9uRnJvbUF4aXNBbmdsZTogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcclxuXHJcblx0XHQvLyBhc3N1bWVzIGF4aXMgaXMgbm9ybWFsaXplZFxyXG5cclxuXHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRSb3RhdGlvbkZyb21FdWxlcjogZnVuY3Rpb24gKCBldWxlciApIHtcclxuXHJcblx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciwgdHJ1ZSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRSb3RhdGlvbkZyb21NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxyXG5cclxuXHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG0gKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xyXG5cclxuXHRcdC8vIGFzc3VtZXMgcSBpcyBub3JtYWxpemVkXHJcblxyXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLmNvcHkoIHEgKTtcclxuXHJcblx0fSxcclxuXHJcblx0cm90YXRlT25BeGlzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gcm90YXRlIG9iamVjdCBvbiBheGlzIGluIG9iamVjdCBzcGFjZVxyXG5cdFx0Ly8gYXhpcyBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcclxuXHJcblx0XHR2YXIgcTEgPSBuZXcgUXVhdGVybmlvbigpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVPbkF4aXMoIGF4aXMsIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0cTEuc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcclxuXHJcblx0XHRcdHRoaXMucXVhdGVybmlvbi5tdWx0aXBseSggcTEgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0cm90YXRlT25Xb3JsZEF4aXM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyByb3RhdGUgb2JqZWN0IG9uIGF4aXMgaW4gd29ybGQgc3BhY2VcclxuXHRcdC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXHJcblx0XHQvLyBtZXRob2QgYXNzdW1lcyBubyByb3RhdGVkIHBhcmVudFxyXG5cclxuXHRcdHZhciBxMSA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZU9uV29ybGRBeGlzKCBheGlzLCBhbmdsZSApIHtcclxuXHJcblx0XHRcdHExLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICk7XHJcblxyXG5cdFx0XHR0aGlzLnF1YXRlcm5pb24ucHJlbXVsdGlwbHkoIHExICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHJvdGF0ZVg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMyggMSwgMCwgMCApO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVYKCBhbmdsZSApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyggdjEsIGFuZ2xlICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRyb3RhdGVZOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoIDAsIDEsIDAgKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWSggYW5nbGUgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIHYxLCBhbmdsZSApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0cm90YXRlWjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCAwLCAwLCAxICk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVooIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHRyYW5zbGF0ZU9uQXhpczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHRyYW5zbGF0ZSBvYmplY3QgYnkgZGlzdGFuY2UgYWxvbmcgYXhpcyBpbiBvYmplY3Qgc3BhY2VcclxuXHRcdC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gdHJhbnNsYXRlT25BeGlzKCBheGlzLCBkaXN0YW5jZSApIHtcclxuXHJcblx0XHRcdHYxLmNvcHkoIGF4aXMgKS5hcHBseVF1YXRlcm5pb24oIHRoaXMucXVhdGVybmlvbiApO1xyXG5cclxuXHRcdFx0dGhpcy5wb3NpdGlvbi5hZGQoIHYxLm11bHRpcGx5U2NhbGFyKCBkaXN0YW5jZSApICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHRyYW5zbGF0ZVg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMyggMSwgMCwgMCApO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiB0cmFuc2xhdGVYKCBkaXN0YW5jZSApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggdjEsIGRpc3RhbmNlICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHR0cmFuc2xhdGVZOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoIDAsIDEsIDAgKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gdHJhbnNsYXRlWSggZGlzdGFuY2UgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIHYxLCBkaXN0YW5jZSApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0dHJhbnNsYXRlWjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCAwLCAwLCAxICk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZVooIGRpc3RhbmNlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGxvY2FsVG9Xb3JsZDogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0d29ybGRUb0xvY2FsOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gd29ybGRUb0xvY2FsKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggbTEuZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRsb29rQXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyBUaGlzIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IG9iamVjdHMgaGF2aW5nIG5vbi11bmlmb3JtbHktc2NhbGVkIHBhcmVudChzKVxyXG5cclxuXHRcdHZhciBxMSA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcblx0XHR2YXIgbTEgPSBuZXcgTWF0cml4NCgpO1xyXG5cdFx0dmFyIHRhcmdldCA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHR2YXIgcG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBsb29rQXQoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0XHRpZiAoIHguaXNWZWN0b3IzICkge1xyXG5cclxuXHRcdFx0XHR0YXJnZXQuY29weSggeCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGFyZ2V0LnNldCggeCwgeSwgeiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xyXG5cclxuXHRcdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcclxuXHJcblx0XHRcdHBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmlzQ2FtZXJhIHx8IHRoaXMuaXNMaWdodCApIHtcclxuXHJcblx0XHRcdFx0bTEubG9va0F0KCBwb3NpdGlvbiwgdGFyZ2V0LCB0aGlzLnVwICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRtMS5sb29rQXQoIHRhcmdldCwgcG9zaXRpb24sIHRoaXMudXAgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG0xICk7XHJcblxyXG5cdFx0XHRpZiAoIHBhcmVudCApIHtcclxuXHJcblx0XHRcdFx0bTEuZXh0cmFjdFJvdGF0aW9uKCBwYXJlbnQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRxMS5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG0xICk7XHJcblx0XHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnByZW11bHRpcGx5KCBxMS5pbnZlcnNlKCkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGFkZDogZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuYWRkKCBhcmd1bWVudHNbIGkgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb2JqZWN0ID09PSB0aGlzICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggXCJDT09MLk9iamVjdDNELmFkZDogb2JqZWN0IGNhbid0IGJlIGFkZGVkIGFzIGEgY2hpbGQgb2YgaXRzZWxmLlwiLCBvYmplY3QgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggKCBvYmplY3QgJiYgb2JqZWN0LmlzT2JqZWN0M0QgKSApIHtcclxuXHJcblx0XHRcdGlmICggb2JqZWN0LnBhcmVudCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0b2JqZWN0LnBhcmVudC5yZW1vdmUoIG9iamVjdCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0b2JqZWN0LnBhcmVudCA9IHRoaXM7XHJcblx0XHRcdG9iamVjdC5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdhZGRlZCcgfSApO1xyXG5cclxuXHRcdFx0dGhpcy5jaGlsZHJlbi5wdXNoKCBvYmplY3QgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggXCJDT09MLk9iamVjdDNELmFkZDogb2JqZWN0IG5vdCBhbiBpbnN0YW5jZSBvZiBDT09MLk9iamVjdDNELlwiLCBvYmplY3QgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJlbW92ZTogZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMucmVtb3ZlKCBhcmd1bWVudHNbIGkgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZiggb2JqZWN0ICk7XHJcblxyXG5cdFx0aWYgKCBpbmRleCAhPT0gLSAxICkge1xyXG5cclxuXHRcdFx0b2JqZWN0LnBhcmVudCA9IG51bGw7XHJcblxyXG5cdFx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAncmVtb3ZlZCcgfSApO1xyXG5cclxuXHRcdFx0dGhpcy5jaGlsZHJlbi5zcGxpY2UoIGluZGV4LCAxICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRPYmplY3RCeUlkOiBmdW5jdGlvbiAoIGlkICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmdldE9iamVjdEJ5UHJvcGVydHkoICdpZCcsIGlkICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldE9iamVjdEJ5TmFtZTogZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmdldE9iamVjdEJ5UHJvcGVydHkoICduYW1lJywgbmFtZSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRPYmplY3RCeVByb3BlcnR5OiBmdW5jdGlvbiAoIG5hbWUsIHZhbHVlICkge1xyXG5cclxuXHRcdGlmICggdGhpc1sgbmFtZSBdID09PSB2YWx1ZSApIHJldHVybiB0aGlzO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5bIGkgXTtcclxuXHRcdFx0dmFyIG9iamVjdCA9IGNoaWxkLmdldE9iamVjdEJ5UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gb2JqZWN0O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRXb3JsZFBvc2l0aW9uOiBmdW5jdGlvbiAoIHRhcmdldCApIHtcclxuXHJcblx0XHRpZiAoIHRhcmdldCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5PYmplY3QzRDogLmdldFdvcmxkUG9zaXRpb24oKSB0YXJnZXQgaXMgbm93IHJlcXVpcmVkJyApO1xyXG5cdFx0XHR0YXJnZXQgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldC5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0V29ybGRRdWF0ZXJuaW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHZhciBzY2FsZSA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGdldFdvcmxkUXVhdGVybmlvbiggdGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0aWYgKCB0YXJnZXQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5PYmplY3QzRDogLmdldFdvcmxkUXVhdGVybmlvbigpIHRhcmdldCBpcyBub3cgcmVxdWlyZWQnICk7XHJcblx0XHRcdFx0dGFyZ2V0ID0gbmV3IFF1YXRlcm5pb24oKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcclxuXHJcblx0XHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBwb3NpdGlvbiwgdGFyZ2V0LCBzY2FsZSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRhcmdldDtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGdldFdvcmxkU2NhbGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgcG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0dmFyIHF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRXb3JsZFNjYWxlKCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRhcmdldCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdDT09MLk9iamVjdDNEOiAuZ2V0V29ybGRTY2FsZSgpIHRhcmdldCBpcyBub3cgcmVxdWlyZWQnICk7XHJcblx0XHRcdFx0dGFyZ2V0ID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcclxuXHJcblx0XHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgdGFyZ2V0ICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGFyZ2V0O1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Z2V0V29ybGREaXJlY3Rpb246IGZ1bmN0aW9uICggdGFyZ2V0ICkge1xyXG5cclxuXHRcdGlmICggdGFyZ2V0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdDT09MLk9iamVjdDNEOiAuZ2V0V29ybGREaXJlY3Rpb24oKSB0YXJnZXQgaXMgbm93IHJlcXVpcmVkJyApO1xyXG5cdFx0XHR0YXJnZXQgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XHJcblxyXG5cdFx0dmFyIGUgPSB0aGlzLm1hdHJpeFdvcmxkLmVsZW1lbnRzO1xyXG5cclxuXHRcdHJldHVybiB0YXJnZXQuc2V0KCBlWyA4IF0sIGVbIDkgXSwgZVsgMTAgXSApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyYXljYXN0OiBmdW5jdGlvbiAoKSB7fSxcclxuXHJcblx0dHJhdmVyc2U6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XHJcblxyXG5cdFx0Y2FsbGJhY2soIHRoaXMgKTtcclxuXHJcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjaGlsZHJlblsgaSBdLnRyYXZlcnNlKCBjYWxsYmFjayApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0dHJhdmVyc2VWaXNpYmxlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xyXG5cclxuXHRcdGlmICggdGhpcy52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRjYWxsYmFjayggdGhpcyApO1xyXG5cclxuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGNoaWxkcmVuWyBpIF0udHJhdmVyc2VWaXNpYmxlKCBjYWxsYmFjayApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0dHJhdmVyc2VBbmNlc3RvcnM6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XHJcblxyXG5cdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xyXG5cclxuXHRcdGlmICggcGFyZW50ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0Y2FsbGJhY2soIHBhcmVudCApO1xyXG5cclxuXHRcdFx0cGFyZW50LnRyYXZlcnNlQW5jZXN0b3JzKCBjYWxsYmFjayApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0dXBkYXRlTWF0cml4OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5tYXRyaXguY29tcG9zZSggdGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCB0aGlzLnNjYWxlICk7XHJcblxyXG5cdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0dXBkYXRlTWF0cml4V29ybGQ6IGZ1bmN0aW9uICggZm9yY2UgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgKSB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xyXG5cclxuXHRcdGlmICggdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlIHx8IGZvcmNlICkge1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLnBhcmVudCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCB0aGlzLm1hdHJpeCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCwgdGhpcy5tYXRyaXggKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0Zm9yY2UgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyB1cGRhdGUgY2hpbGRyZW5cclxuXHJcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjaGlsZHJlblsgaSBdLnVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0dXBkYXRlV29ybGRNYXRyaXg6IGZ1bmN0aW9uICggdXBkYXRlUGFyZW50cywgdXBkYXRlQ2hpbGRyZW4gKSB7XHJcblxyXG5cdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xyXG5cclxuXHRcdGlmICggdXBkYXRlUGFyZW50cyA9PT0gdHJ1ZSAmJiBwYXJlbnQgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRwYXJlbnQudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5tYXRyaXhBdXRvVXBkYXRlICkgdGhpcy51cGRhdGVNYXRyaXgoKTtcclxuXHJcblx0XHRpZiAoIHRoaXMucGFyZW50ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCB0aGlzLm1hdHJpeCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXMoIHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLCB0aGlzLm1hdHJpeCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyB1cGRhdGUgY2hpbGRyZW5cclxuXHJcblx0XHRpZiAoIHVwZGF0ZUNoaWxkcmVuID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGNoaWxkcmVuWyBpIF0udXBkYXRlV29ybGRNYXRyaXgoIGZhbHNlLCB0cnVlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHR0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcclxuXHJcblx0XHQvLyBtZXRhIGlzIGEgc3RyaW5nIHdoZW4gY2FsbGVkIGZyb20gSlNPTi5zdHJpbmdpZnlcclxuXHRcdHZhciBpc1Jvb3RPYmplY3QgPSAoIG1ldGEgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgbWV0YSA9PT0gJ3N0cmluZycgKTtcclxuXHJcblx0XHR2YXIgb3V0cHV0ID0ge307XHJcblxyXG5cdFx0Ly8gbWV0YSBpcyBhIGhhc2ggdXNlZCB0byBjb2xsZWN0IGdlb21ldHJpZXMsIG1hdGVyaWFscy5cclxuXHRcdC8vIG5vdCBwcm92aWRpbmcgaXQgaW1wbGllcyB0aGF0IHRoaXMgaXMgdGhlIHJvb3Qgb2JqZWN0XHJcblx0XHQvLyBiZWluZyBzZXJpYWxpemVkLlxyXG5cdFx0aWYgKCBpc1Jvb3RPYmplY3QgKSB7XHJcblxyXG5cdFx0XHQvLyBpbml0aWFsaXplIG1ldGEgb2JqXHJcblx0XHRcdG1ldGEgPSB7XHJcblx0XHRcdFx0Z2VvbWV0cmllczoge30sXHJcblx0XHRcdFx0bWF0ZXJpYWxzOiB7fSxcclxuXHRcdFx0XHR0ZXh0dXJlczoge30sXHJcblx0XHRcdFx0aW1hZ2VzOiB7fSxcclxuXHRcdFx0XHRzaGFwZXM6IHt9XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRvdXRwdXQubWV0YWRhdGEgPSB7XHJcblx0XHRcdFx0dmVyc2lvbjogNC41LFxyXG5cdFx0XHRcdHR5cGU6ICdPYmplY3QnLFxyXG5cdFx0XHRcdGdlbmVyYXRvcjogJ09iamVjdDNELnRvSlNPTidcclxuXHRcdFx0fTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc3RhbmRhcmQgT2JqZWN0M0Qgc2VyaWFsaXphdGlvblxyXG5cclxuXHRcdHZhciBvYmplY3QgPSB7fTtcclxuXHJcblx0XHRvYmplY3QudXVpZCA9IHRoaXMudXVpZDtcclxuXHRcdG9iamVjdC50eXBlID0gdGhpcy50eXBlO1xyXG5cclxuXHRcdGlmICggdGhpcy5uYW1lICE9PSAnJyApIG9iamVjdC5uYW1lID0gdGhpcy5uYW1lO1xyXG5cdFx0aWYgKCB0aGlzLmNhc3RTaGFkb3cgPT09IHRydWUgKSBvYmplY3QuY2FzdFNoYWRvdyA9IHRydWU7XHJcblx0XHRpZiAoIHRoaXMucmVjZWl2ZVNoYWRvdyA9PT0gdHJ1ZSApIG9iamVjdC5yZWNlaXZlU2hhZG93ID0gdHJ1ZTtcclxuXHRcdGlmICggdGhpcy52aXNpYmxlID09PSBmYWxzZSApIG9iamVjdC52aXNpYmxlID0gZmFsc2U7XHJcblx0XHRpZiAoIHRoaXMuZnJ1c3R1bUN1bGxlZCA9PT0gZmFsc2UgKSBvYmplY3QuZnJ1c3R1bUN1bGxlZCA9IGZhbHNlO1xyXG5cdFx0aWYgKCB0aGlzLnJlbmRlck9yZGVyICE9PSAwICkgb2JqZWN0LnJlbmRlck9yZGVyID0gdGhpcy5yZW5kZXJPcmRlcjtcclxuXHRcdGlmICggSlNPTi5zdHJpbmdpZnkoIHRoaXMudXNlckRhdGEgKSAhPT0gJ3t9JyApIG9iamVjdC51c2VyRGF0YSA9IHRoaXMudXNlckRhdGE7XHJcblxyXG5cdFx0b2JqZWN0LmxheWVycyA9IHRoaXMubGF5ZXJzLm1hc2s7XHJcblx0XHRvYmplY3QubWF0cml4ID0gdGhpcy5tYXRyaXgudG9BcnJheSgpO1xyXG5cclxuXHRcdGlmICggdGhpcy5tYXRyaXhBdXRvVXBkYXRlID09PSBmYWxzZSApIG9iamVjdC5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRmdW5jdGlvbiBzZXJpYWxpemUoIGxpYnJhcnksIGVsZW1lbnQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGxpYnJhcnlbIGVsZW1lbnQudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGxpYnJhcnlbIGVsZW1lbnQudXVpZCBdID0gZWxlbWVudC50b0pTT04oIG1ldGEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBlbGVtZW50LnV1aWQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5pc01lc2ggfHwgdGhpcy5pc0xpbmUgfHwgdGhpcy5pc1BvaW50cyApIHtcclxuXHJcblx0XHRcdG9iamVjdC5nZW9tZXRyeSA9IHNlcmlhbGl6ZSggbWV0YS5nZW9tZXRyaWVzLCB0aGlzLmdlb21ldHJ5ICk7XHJcblxyXG5cdFx0XHR2YXIgcGFyYW1ldGVycyA9IHRoaXMuZ2VvbWV0cnkucGFyYW1ldGVycztcclxuXHJcblx0XHRcdGlmICggcGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICYmIHBhcmFtZXRlcnMuc2hhcGVzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBzaGFwZXMgPSBwYXJhbWV0ZXJzLnNoYXBlcztcclxuXHJcblx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSApIHtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzaGFwZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBzaGFwZSA9IHNoYXBlc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0c2VyaWFsaXplKCBtZXRhLnNoYXBlcywgc2hhcGUgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0c2VyaWFsaXplKCBtZXRhLnNoYXBlcywgc2hhcGVzICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLm1hdGVyaWFsICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHRoaXMubWF0ZXJpYWwgKSApIHtcclxuXHJcblx0XHRcdFx0dmFyIHV1aWRzID0gW107XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMubWF0ZXJpYWwubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHR1dWlkcy5wdXNoKCBzZXJpYWxpemUoIG1ldGEubWF0ZXJpYWxzLCB0aGlzLm1hdGVyaWFsWyBpIF0gKSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdG9iamVjdC5tYXRlcmlhbCA9IHV1aWRzO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0b2JqZWN0Lm1hdGVyaWFsID0gc2VyaWFsaXplKCBtZXRhLm1hdGVyaWFscywgdGhpcy5tYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGlmICggdGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0b2JqZWN0LmNoaWxkcmVuID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0b2JqZWN0LmNoaWxkcmVuLnB1c2goIHRoaXMuY2hpbGRyZW5bIGkgXS50b0pTT04oIG1ldGEgKS5vYmplY3QgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBpc1Jvb3RPYmplY3QgKSB7XHJcblxyXG5cdFx0XHR2YXIgZ2VvbWV0cmllcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuZ2VvbWV0cmllcyApO1xyXG5cdFx0XHR2YXIgbWF0ZXJpYWxzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5tYXRlcmlhbHMgKTtcclxuXHRcdFx0dmFyIHRleHR1cmVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS50ZXh0dXJlcyApO1xyXG5cdFx0XHR2YXIgaW1hZ2VzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5pbWFnZXMgKTtcclxuXHRcdFx0dmFyIHNoYXBlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuc2hhcGVzICk7XHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJpZXMubGVuZ3RoID4gMCApIG91dHB1dC5nZW9tZXRyaWVzID0gZ2VvbWV0cmllcztcclxuXHRcdFx0aWYgKCBtYXRlcmlhbHMubGVuZ3RoID4gMCApIG91dHB1dC5tYXRlcmlhbHMgPSBtYXRlcmlhbHM7XHJcblx0XHRcdGlmICggdGV4dHVyZXMubGVuZ3RoID4gMCApIG91dHB1dC50ZXh0dXJlcyA9IHRleHR1cmVzO1xyXG5cdFx0XHRpZiAoIGltYWdlcy5sZW5ndGggPiAwICkgb3V0cHV0LmltYWdlcyA9IGltYWdlcztcclxuXHRcdFx0aWYgKCBzaGFwZXMubGVuZ3RoID4gMCApIG91dHB1dC5zaGFwZXMgPSBzaGFwZXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdG91dHB1dC5vYmplY3QgPSBvYmplY3Q7XHJcblxyXG5cdFx0cmV0dXJuIG91dHB1dDtcclxuXHJcblx0XHQvLyBleHRyYWN0IGRhdGEgZnJvbSB0aGUgY2FjaGUgaGFzaFxyXG5cdFx0Ly8gcmVtb3ZlIG1ldGFkYXRhIG9uIGVhY2ggaXRlbVxyXG5cdFx0Ly8gYW5kIHJldHVybiBhcyBhcnJheVxyXG5cdFx0ZnVuY3Rpb24gZXh0cmFjdEZyb21DYWNoZSggY2FjaGUgKSB7XHJcblxyXG5cdFx0XHR2YXIgdmFsdWVzID0gW107XHJcblx0XHRcdGZvciAoIHZhciBrZXkgaW4gY2FjaGUgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBkYXRhID0gY2FjaGVbIGtleSBdO1xyXG5cdFx0XHRcdGRlbGV0ZSBkYXRhLm1ldGFkYXRhO1xyXG5cdFx0XHRcdHZhbHVlcy5wdXNoKCBkYXRhICk7XHJcblxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB2YWx1ZXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCByZWN1cnNpdmUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcywgcmVjdXJzaXZlICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggc291cmNlLCByZWN1cnNpdmUgKSB7XHJcblxyXG5cdFx0aWYgKCByZWN1cnNpdmUgPT09IHVuZGVmaW5lZCApIHJlY3Vyc2l2ZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5uYW1lID0gc291cmNlLm5hbWU7XHJcblxyXG5cdFx0dGhpcy51cC5jb3B5KCBzb3VyY2UudXAgKTtcclxuXHJcblx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoIHNvdXJjZS5wb3NpdGlvbiApO1xyXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLmNvcHkoIHNvdXJjZS5xdWF0ZXJuaW9uICk7XHJcblx0XHR0aGlzLnNjYWxlLmNvcHkoIHNvdXJjZS5zY2FsZSApO1xyXG5cclxuXHRcdHRoaXMubWF0cml4LmNvcHkoIHNvdXJjZS5tYXRyaXggKTtcclxuXHRcdHRoaXMubWF0cml4V29ybGQuY29weSggc291cmNlLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeEF1dG9VcGRhdGU7XHJcblx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBzb3VyY2UubWF0cml4V29ybGROZWVkc1VwZGF0ZTtcclxuXHJcblx0XHR0aGlzLmxheWVycy5tYXNrID0gc291cmNlLmxheWVycy5tYXNrO1xyXG5cdFx0dGhpcy52aXNpYmxlID0gc291cmNlLnZpc2libGU7XHJcblxyXG5cdFx0dGhpcy5jYXN0U2hhZG93ID0gc291cmNlLmNhc3RTaGFkb3c7XHJcblx0XHR0aGlzLnJlY2VpdmVTaGFkb3cgPSBzb3VyY2UucmVjZWl2ZVNoYWRvdztcclxuXHJcblx0XHR0aGlzLmZydXN0dW1DdWxsZWQgPSBzb3VyY2UuZnJ1c3R1bUN1bGxlZDtcclxuXHRcdHRoaXMucmVuZGVyT3JkZXIgPSBzb3VyY2UucmVuZGVyT3JkZXI7XHJcblxyXG5cdFx0dGhpcy51c2VyRGF0YSA9IEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCBzb3VyY2UudXNlckRhdGEgKSApO1xyXG5cclxuXHRcdGlmICggcmVjdXJzaXZlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgc291cmNlLmNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGNoaWxkID0gc291cmNlLmNoaWxkcmVuWyBpIF07XHJcblx0XHRcdFx0dGhpcy5hZGQoIGNoaWxkLmNsb25lKCkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuXHJcblxyXG5leHBvcnQgeyBPYmplY3QzRCB9O1xyXG4iLCJpbXBvcnQgeyBFdmVudERpc3BhdGNoZXIgfSBmcm9tICcuL0V2ZW50RGlzcGF0Y2hlci5qcyc7XHJcbmltcG9ydCB7IEZhY2UzIH0gZnJvbSAnLi9GYWNlMy5qcyc7XHJcbmltcG9ydCB7IE1hdHJpeDMgfSBmcm9tICcuLi9tYXRoL01hdHJpeDMuanMnO1xyXG5pbXBvcnQgeyBTcGhlcmUgfSBmcm9tICcuLi9tYXRoL1NwaGVyZS5qcyc7XHJcbmltcG9ydCB7IEJveDMgfSBmcm9tICcuLi9tYXRoL0JveDMuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcclxuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uL21hdGgvTWF0cml4NC5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uL21hdGgvQ29sb3IuanMnO1xyXG5pbXBvcnQgeyBPYmplY3QzRCB9IGZyb20gJy4vT2JqZWN0M0QuanMnO1xyXG5pbXBvcnQgeyBfTWF0aCB9IGZyb20gJy4uL21hdGgvTWF0aC5qcyc7XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBraWxlIC8gaHR0cDovL2tpbGUuc3RyYXZhZ2FuemEub3JnL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICovXHJcblxyXG52YXIgZ2VvbWV0cnlJZCA9IDA7IC8vIEdlb21ldHJ5IHVzZXMgZXZlbiBudW1iZXJzIGFzIElkXHJcblxyXG5mdW5jdGlvbiBHZW9tZXRyeSgpIHtcclxuXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBnZW9tZXRyeUlkICs9IDIgfSApO1xyXG5cclxuXHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcblx0dGhpcy5uYW1lID0gJyc7XHJcblx0dGhpcy50eXBlID0gJ0dlb21ldHJ5JztcclxuXHJcblx0dGhpcy52ZXJ0aWNlcyA9IFtdO1xyXG5cdHRoaXMuY29sb3JzID0gW107XHJcblx0dGhpcy5mYWNlcyA9IFtdO1xyXG5cdHRoaXMuZmFjZVZlcnRleFV2cyA9IFtbXV07XHJcblxyXG5cdHRoaXMubW9ycGhUYXJnZXRzID0gW107XHJcblx0dGhpcy5tb3JwaE5vcm1hbHMgPSBbXTtcclxuXHJcblx0dGhpcy5za2luV2VpZ2h0cyA9IFtdO1xyXG5cdHRoaXMuc2tpbkluZGljZXMgPSBbXTtcclxuXHJcblx0dGhpcy5saW5lRGlzdGFuY2VzID0gW107XHJcblxyXG5cdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xyXG5cdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xyXG5cclxuXHQvLyB1cGRhdGUgZmxhZ3NcclxuXHJcblx0dGhpcy5lbGVtZW50c05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHR0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHR0aGlzLmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHR0aGlzLmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0dGhpcy5ncm91cHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG59XHJcblxyXG5HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlICksIHtcclxuXHJcblx0Y29uc3RydWN0b3I6IEdlb21ldHJ5LFxyXG5cclxuXHRpc0dlb21ldHJ5OiB0cnVlLFxyXG5cclxuXHRhcHBseU1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG5cdFx0dmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBNYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXggPSB0aGlzLnZlcnRpY2VzWyBpIF07XHJcblx0XHRcdHZlcnRleC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBmYWNlID0gdGhpcy5mYWNlc1sgaSBdO1xyXG5cdFx0XHRmYWNlLm5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzWyBqIF0uYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cdFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdGF0ZVg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHgtYXhpc1xyXG5cclxuXHRcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVgoIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0bTEubWFrZVJvdGF0aW9uWCggYW5nbGUgKTtcclxuXHJcblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHktYXhpc1xyXG5cclxuXHRcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVkoIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0bTEubWFrZVJvdGF0aW9uWSggYW5nbGUgKTtcclxuXHJcblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHJvdGF0ZVo6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHotYXhpc1xyXG5cclxuXHRcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVooIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0bTEubWFrZVJvdGF0aW9uWiggYW5nbGUgKTtcclxuXHJcblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHRyYW5zbGF0ZSBnZW9tZXRyeVxyXG5cclxuXHRcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZSggeCwgeSwgeiApIHtcclxuXHJcblx0XHRcdG0xLm1ha2VUcmFuc2xhdGlvbiggeCwgeSwgeiApO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0c2NhbGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyBzY2FsZSBnZW9tZXRyeVxyXG5cclxuXHRcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHNjYWxlKCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdFx0bTEubWFrZVNjYWxlKCB4LCB5LCB6ICk7XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRsb29rQXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgb2JqID0gbmV3IE9iamVjdDNEKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGxvb2tBdCggdmVjdG9yICkge1xyXG5cclxuXHRcdFx0b2JqLmxvb2tBdCggdmVjdG9yICk7XHJcblxyXG5cdFx0XHRvYmoudXBkYXRlTWF0cml4KCk7XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBvYmoubWF0cml4ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRmcm9tQnVmZmVyR2VvbWV0cnk6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcclxuXHJcblx0XHR2YXIgaW5kaWNlcyA9IGdlb21ldHJ5LmluZGV4ICE9PSBudWxsID8gZ2VvbWV0cnkuaW5kZXguYXJyYXkgOiB1bmRlZmluZWQ7XHJcblx0XHR2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0dmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblx0XHR2YXIgbm9ybWFscyA9IGF0dHJpYnV0ZXMubm9ybWFsICE9PSB1bmRlZmluZWQgPyBhdHRyaWJ1dGVzLm5vcm1hbC5hcnJheSA6IHVuZGVmaW5lZDtcclxuXHRcdHZhciBjb2xvcnMgPSBhdHRyaWJ1dGVzLmNvbG9yICE9PSB1bmRlZmluZWQgPyBhdHRyaWJ1dGVzLmNvbG9yLmFycmF5IDogdW5kZWZpbmVkO1xyXG5cdFx0dmFyIHV2cyA9IGF0dHJpYnV0ZXMudXYgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMudXYuYXJyYXkgOiB1bmRlZmluZWQ7XHJcblx0XHR2YXIgdXZzMiA9IGF0dHJpYnV0ZXMudXYyICE9PSB1bmRlZmluZWQgPyBhdHRyaWJ1dGVzLnV2Mi5hcnJheSA6IHVuZGVmaW5lZDtcclxuXHJcblx0XHRpZiAoIHV2czIgIT09IHVuZGVmaW5lZCApIHRoaXMuZmFjZVZlcnRleFV2c1sgMSBdID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBqID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkgKz0gMywgaiArPSAyICkge1xyXG5cclxuXHRcdFx0c2NvcGUudmVydGljZXMucHVzaCggbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSApICk7XHJcblxyXG5cdFx0XHRpZiAoIGNvbG9ycyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRzY29wZS5jb2xvcnMucHVzaCggbmV3IENvbG9yKCkuZnJvbUFycmF5KCBjb2xvcnMsIGkgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBhZGRGYWNlKCBhLCBiLCBjLCBtYXRlcmlhbEluZGV4ICkge1xyXG5cclxuXHRcdFx0dmFyIHZlcnRleENvbG9ycyA9ICggY29sb3JzID09PSB1bmRlZmluZWQgKSA/IFtdIDogW1xyXG5cdFx0XHRcdHNjb3BlLmNvbG9yc1sgYSBdLmNsb25lKCksXHJcblx0XHRcdFx0c2NvcGUuY29sb3JzWyBiIF0uY2xvbmUoKSxcclxuXHRcdFx0XHRzY29wZS5jb2xvcnNbIGMgXS5jbG9uZSgpIF07XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4Tm9ybWFscyA9ICggbm9ybWFscyA9PT0gdW5kZWZpbmVkICkgPyBbXSA6IFtcclxuXHRcdFx0XHRuZXcgVmVjdG9yMygpLmZyb21BcnJheSggbm9ybWFscywgYSAqIDMgKSxcclxuXHRcdFx0XHRuZXcgVmVjdG9yMygpLmZyb21BcnJheSggbm9ybWFscywgYiAqIDMgKSxcclxuXHRcdFx0XHRuZXcgVmVjdG9yMygpLmZyb21BcnJheSggbm9ybWFscywgYyAqIDMgKVxyXG5cdFx0XHRdO1xyXG5cclxuXHRcdFx0dmFyIGZhY2UgPSBuZXcgRmFjZTMoIGEsIGIsIGMsIHZlcnRleE5vcm1hbHMsIHZlcnRleENvbG9ycywgbWF0ZXJpYWxJbmRleCApO1xyXG5cclxuXHRcdFx0c2NvcGUuZmFjZXMucHVzaCggZmFjZSApO1xyXG5cclxuXHRcdFx0aWYgKCB1dnMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0c2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFtcclxuXHRcdFx0XHRcdG5ldyBWZWN0b3IyKCkuZnJvbUFycmF5KCB1dnMsIGEgKiAyICksXHJcblx0XHRcdFx0XHRuZXcgVmVjdG9yMigpLmZyb21BcnJheSggdXZzLCBiICogMiApLFxyXG5cdFx0XHRcdFx0bmV3IFZlY3RvcjIoKS5mcm9tQXJyYXkoIHV2cywgYyAqIDIgKVxyXG5cdFx0XHRcdF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggdXZzMiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRzY29wZS5mYWNlVmVydGV4VXZzWyAxIF0ucHVzaCggW1xyXG5cdFx0XHRcdFx0bmV3IFZlY3RvcjIoKS5mcm9tQXJyYXkoIHV2czIsIGEgKiAyICksXHJcblx0XHRcdFx0XHRuZXcgVmVjdG9yMigpLmZyb21BcnJheSggdXZzMiwgYiAqIDIgKSxcclxuXHRcdFx0XHRcdG5ldyBWZWN0b3IyKCkuZnJvbUFycmF5KCB1dnMyLCBjICogMiApXHJcblx0XHRcdFx0XSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xyXG5cclxuXHRcdGlmICggZ3JvdXBzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZ3JvdXAgPSBncm91cHNbIGkgXTtcclxuXHJcblx0XHRcdFx0dmFyIHN0YXJ0ID0gZ3JvdXAuc3RhcnQ7XHJcblx0XHRcdFx0dmFyIGNvdW50ID0gZ3JvdXAuY291bnQ7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBqID0gc3RhcnQsIGpsID0gc3RhcnQgKyBjb3VudDsgaiA8IGpsOyBqICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBpbmRpY2VzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRhZGRGYWNlKCBpbmRpY2VzWyBqIF0sIGluZGljZXNbIGogKyAxIF0sIGluZGljZXNbIGogKyAyIF0sIGdyb3VwLm1hdGVyaWFsSW5kZXggKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0YWRkRmFjZSggaiwgaiArIDEsIGogKyAyLCBncm91cC5tYXRlcmlhbEluZGV4ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGlmICggaW5kaWNlcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0XHRcdGFkZEZhY2UoIGluZGljZXNbIGkgXSwgaW5kaWNlc1sgaSArIDEgXSwgaW5kaWNlc1sgaSArIDIgXSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoIC8gMzsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0XHRcdGFkZEZhY2UoIGksIGkgKyAxLCBpICsgMiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBnZW9tZXRyeS5ib3VuZGluZ0JveC5jbG9uZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgb2Zmc2V0ID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gY2VudGVyKCkge1xyXG5cclxuXHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcclxuXHJcblx0XHRcdHRoaXMuYm91bmRpbmdCb3guZ2V0Q2VudGVyKCBvZmZzZXQgKS5uZWdhdGUoKTtcclxuXHJcblx0XHRcdHRoaXMudHJhbnNsYXRlKCBvZmZzZXQueCwgb2Zmc2V0LnksIG9mZnNldC56ICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG5cdFx0dmFyIGNlbnRlciA9IHRoaXMuYm91bmRpbmdTcGhlcmUuY2VudGVyO1xyXG5cdFx0dmFyIHJhZGl1cyA9IHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzO1xyXG5cclxuXHRcdHZhciBzID0gcmFkaXVzID09PSAwID8gMSA6IDEuMCAvIHJhZGl1cztcclxuXHJcblx0XHR2YXIgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcclxuXHRcdG1hdHJpeC5zZXQoXHJcblx0XHRcdHMsIDAsIDAsIC0gcyAqIGNlbnRlci54LFxyXG5cdFx0XHQwLCBzLCAwLCAtIHMgKiBjZW50ZXIueSxcclxuXHRcdFx0MCwgMCwgcywgLSBzICogY2VudGVyLnosXHJcblx0XHRcdDAsIDAsIDAsIDFcclxuXHRcdCk7XHJcblxyXG5cdFx0dGhpcy5hcHBseU1hdHJpeCggbWF0cml4ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbXB1dGVGYWNlTm9ybWFsczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBjYiA9IG5ldyBWZWN0b3IzKCksIGFiID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdHZhciBmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cclxuXHRcdFx0dmFyIHZBID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5hIF07XHJcblx0XHRcdHZhciB2QiA9IHRoaXMudmVydGljZXNbIGZhY2UuYiBdO1xyXG5cdFx0XHR2YXIgdkMgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmMgXTtcclxuXHJcblx0XHRcdGNiLnN1YlZlY3RvcnMoIHZDLCB2QiApO1xyXG5cdFx0XHRhYi5zdWJWZWN0b3JzKCB2QSwgdkIgKTtcclxuXHRcdFx0Y2IuY3Jvc3MoIGFiICk7XHJcblxyXG5cdFx0XHRjYi5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdGZhY2Uubm9ybWFsLmNvcHkoIGNiICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wdXRlVmVydGV4Tm9ybWFsczogZnVuY3Rpb24gKCBhcmVhV2VpZ2h0ZWQgKSB7XHJcblxyXG5cdFx0aWYgKCBhcmVhV2VpZ2h0ZWQgPT09IHVuZGVmaW5lZCApIGFyZWFXZWlnaHRlZCA9IHRydWU7XHJcblxyXG5cdFx0dmFyIHYsIHZsLCBmLCBmbCwgZmFjZSwgdmVydGljZXM7XHJcblxyXG5cdFx0dmVydGljZXMgPSBuZXcgQXJyYXkoIHRoaXMudmVydGljZXMubGVuZ3RoICk7XHJcblxyXG5cdFx0Zm9yICggdiA9IDAsIHZsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArKyApIHtcclxuXHJcblx0XHRcdHZlcnRpY2VzWyB2IF0gPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGFyZWFXZWlnaHRlZCApIHtcclxuXHJcblx0XHRcdC8vIHZlcnRleCBub3JtYWxzIHdlaWdodGVkIGJ5IHRyaWFuZ2xlIGFyZWFzXHJcblx0XHRcdC8vIGh0dHA6Ly93d3cuaXF1aWxlemxlcy5vcmcvd3d3L2FydGljbGVzL25vcm1hbHMvbm9ybWFscy5odG1cclxuXHJcblx0XHRcdHZhciB2QSwgdkIsIHZDO1xyXG5cdFx0XHR2YXIgY2IgPSBuZXcgVmVjdG9yMygpLCBhYiA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cclxuXHRcdFx0XHR2QSA9IHRoaXMudmVydGljZXNbIGZhY2UuYSBdO1xyXG5cdFx0XHRcdHZCID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5iIF07XHJcblx0XHRcdFx0dkMgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmMgXTtcclxuXHJcblx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggdkMsIHZCICk7XHJcblx0XHRcdFx0YWIuc3ViVmVjdG9ycyggdkEsIHZCICk7XHJcblx0XHRcdFx0Y2IuY3Jvc3MoIGFiICk7XHJcblxyXG5cdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmEgXS5hZGQoIGNiICk7XHJcblx0XHRcdFx0dmVydGljZXNbIGZhY2UuYiBdLmFkZCggY2IgKTtcclxuXHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5jIF0uYWRkKCBjYiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cclxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcblx0XHRcdFx0dmVydGljZXNbIGZhY2UuYSBdLmFkZCggZmFjZS5ub3JtYWwgKTtcclxuXHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5iIF0uYWRkKCBmYWNlLm5vcm1hbCApO1xyXG5cdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmMgXS5hZGQoIGZhY2Uubm9ybWFsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIHYgPSAwLCB2bCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKysgKSB7XHJcblxyXG5cdFx0XHR2ZXJ0aWNlc1sgdiBdLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXhOb3JtYWxzID0gZmFjZS52ZXJ0ZXhOb3JtYWxzO1xyXG5cclxuXHRcdFx0aWYgKCB2ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA9PT0gMyApIHtcclxuXHJcblx0XHRcdFx0dmVydGV4Tm9ybWFsc1sgMCBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmEgXSApO1xyXG5cdFx0XHRcdHZlcnRleE5vcm1hbHNbIDEgXS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5iIF0gKTtcclxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAyIF0uY29weSggdmVydGljZXNbIGZhY2UuYyBdICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAwIF0gPSB2ZXJ0aWNlc1sgZmFjZS5hIF0uY2xvbmUoKTtcclxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAxIF0gPSB2ZXJ0aWNlc1sgZmFjZS5iIF0uY2xvbmUoKTtcclxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAyIF0gPSB2ZXJ0aWNlc1sgZmFjZS5jIF0uY2xvbmUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLmZhY2VzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbXB1dGVGbGF0VmVydGV4Tm9ybWFsczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBmLCBmbCwgZmFjZTtcclxuXHJcblx0XHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cclxuXHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cclxuXHRcdFx0dmFyIHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XHJcblxyXG5cdFx0XHRpZiAoIHZlcnRleE5vcm1hbHMubGVuZ3RoID09PSAzICkge1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAwIF0uY29weSggZmFjZS5ub3JtYWwgKTtcclxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAxIF0uY29weSggZmFjZS5ub3JtYWwgKTtcclxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAyIF0uY29weSggZmFjZS5ub3JtYWwgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHZlcnRleE5vcm1hbHNbIDAgXSA9IGZhY2Uubm9ybWFsLmNsb25lKCk7XHJcblx0XHRcdFx0dmVydGV4Tm9ybWFsc1sgMSBdID0gZmFjZS5ub3JtYWwuY2xvbmUoKTtcclxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAyIF0gPSBmYWNlLm5vcm1hbC5jbG9uZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuZmFjZXMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Y29tcHV0ZU1vcnBoTm9ybWFsczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBpLCBpbCwgZiwgZmwsIGZhY2U7XHJcblxyXG5cdFx0Ly8gc2F2ZSBvcmlnaW5hbCBub3JtYWxzXHJcblx0XHQvLyAtIGNyZWF0ZSB0ZW1wIHZhcmlhYmxlcyBvbiBmaXJzdCBhY2Nlc3NcclxuXHRcdC8vICAgb3RoZXJ3aXNlIGp1c3QgY29weSAoZm9yIGZhc3RlciByZXBlYXRlZCBjYWxscylcclxuXHJcblx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcblx0XHRcdGlmICggISBmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsICkge1xyXG5cclxuXHRcdFx0XHRmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsID0gZmFjZS5ub3JtYWwuY2xvbmUoKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGZhY2UuX19vcmlnaW5hbEZhY2VOb3JtYWwuY29weSggZmFjZS5ub3JtYWwgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggISBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzICkgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFscyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRpZiAoICEgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFsc1sgaSBdICkge1xyXG5cclxuXHRcdFx0XHRcdGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXSA9IGZhY2UudmVydGV4Tm9ybWFsc1sgaSBdLmNsb25lKCk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0ZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFsc1sgaSBdLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgaSBdICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdXNlIHRlbXAgZ2VvbWV0cnkgdG8gY29tcHV0ZSBmYWNlIGFuZCB2ZXJ0ZXggbm9ybWFscyBmb3IgZWFjaCBtb3JwaFxyXG5cclxuXHRcdHZhciB0bXBHZW8gPSBuZXcgR2VvbWV0cnkoKTtcclxuXHRcdHRtcEdlby5mYWNlcyA9IHRoaXMuZmFjZXM7XHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gdGhpcy5tb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHQvLyBjcmVhdGUgb24gZmlyc3QgYWNjZXNzXHJcblxyXG5cdFx0XHRpZiAoICEgdGhpcy5tb3JwaE5vcm1hbHNbIGkgXSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5tb3JwaE5vcm1hbHNbIGkgXSA9IHt9O1xyXG5cdFx0XHRcdHRoaXMubW9ycGhOb3JtYWxzWyBpIF0uZmFjZU5vcm1hbHMgPSBbXTtcclxuXHRcdFx0XHR0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLnZlcnRleE5vcm1hbHMgPSBbXTtcclxuXHJcblx0XHRcdFx0dmFyIGRzdE5vcm1hbHNGYWNlID0gdGhpcy5tb3JwaE5vcm1hbHNbIGkgXS5mYWNlTm9ybWFscztcclxuXHRcdFx0XHR2YXIgZHN0Tm9ybWFsc1ZlcnRleCA9IHRoaXMubW9ycGhOb3JtYWxzWyBpIF0udmVydGV4Tm9ybWFscztcclxuXHJcblx0XHRcdFx0dmFyIGZhY2VOb3JtYWwsIHZlcnRleE5vcm1hbHM7XHJcblxyXG5cdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZmFjZU5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzID0geyBhOiBuZXcgVmVjdG9yMygpLCBiOiBuZXcgVmVjdG9yMygpLCBjOiBuZXcgVmVjdG9yMygpIH07XHJcblxyXG5cdFx0XHRcdFx0ZHN0Tm9ybWFsc0ZhY2UucHVzaCggZmFjZU5vcm1hbCApO1xyXG5cdFx0XHRcdFx0ZHN0Tm9ybWFsc1ZlcnRleC5wdXNoKCB2ZXJ0ZXhOb3JtYWxzICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBtb3JwaE5vcm1hbHMgPSB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdO1xyXG5cclxuXHRcdFx0Ly8gc2V0IHZlcnRpY2VzIHRvIG1vcnBoIHRhcmdldFxyXG5cclxuXHRcdFx0dG1wR2VvLnZlcnRpY2VzID0gdGhpcy5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcztcclxuXHJcblx0XHRcdC8vIGNvbXB1dGUgbW9ycGggbm9ybWFsc1xyXG5cclxuXHRcdFx0dG1wR2VvLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cdFx0XHR0bXBHZW8uY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcclxuXHJcblx0XHRcdC8vIHN0b3JlIG1vcnBoIG5vcm1hbHNcclxuXHJcblx0XHRcdHZhciBmYWNlTm9ybWFsLCB2ZXJ0ZXhOb3JtYWxzO1xyXG5cclxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcblx0XHRcdFx0ZmFjZU5vcm1hbCA9IG1vcnBoTm9ybWFscy5mYWNlTm9ybWFsc1sgZiBdO1xyXG5cdFx0XHRcdHZlcnRleE5vcm1hbHMgPSBtb3JwaE5vcm1hbHMudmVydGV4Tm9ybWFsc1sgZiBdO1xyXG5cclxuXHRcdFx0XHRmYWNlTm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XHJcblxyXG5cdFx0XHRcdHZlcnRleE5vcm1hbHMuYS5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDAgXSApO1xyXG5cdFx0XHRcdHZlcnRleE5vcm1hbHMuYi5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDEgXSApO1xyXG5cdFx0XHRcdHZlcnRleE5vcm1hbHMuYy5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDIgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyByZXN0b3JlIG9yaWdpbmFsIG5vcm1hbHNcclxuXHJcblx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcblx0XHRcdGZhY2Uubm9ybWFsID0gZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbDtcclxuXHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzID0gZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFscztcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbXB1dGVCb3VuZGluZ0JveDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICggdGhpcy5ib3VuZGluZ0JveCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgQm94MygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmJvdW5kaW5nQm94LnNldEZyb21Qb2ludHMoIHRoaXMudmVydGljZXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29tcHV0ZUJvdW5kaW5nU3BoZXJlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBTcGhlcmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5ib3VuZGluZ1NwaGVyZS5zZXRGcm9tUG9pbnRzKCB0aGlzLnZlcnRpY2VzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1lcmdlOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRyaXgsIG1hdGVyaWFsSW5kZXhPZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCAhICggZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNHZW9tZXRyeSApICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ0NPT0wuR2VvbWV0cnkubWVyZ2UoKTogZ2VvbWV0cnkgbm90IGFuIGluc3RhbmNlIG9mIENPT0wuR2VvbWV0cnkuJywgZ2VvbWV0cnkgKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbm9ybWFsTWF0cml4LFxyXG5cdFx0XHR2ZXJ0ZXhPZmZzZXQgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCxcclxuXHRcdFx0dmVydGljZXMxID0gdGhpcy52ZXJ0aWNlcyxcclxuXHRcdFx0dmVydGljZXMyID0gZ2VvbWV0cnkudmVydGljZXMsXHJcblx0XHRcdGZhY2VzMSA9IHRoaXMuZmFjZXMsXHJcblx0XHRcdGZhY2VzMiA9IGdlb21ldHJ5LmZhY2VzLFxyXG5cdFx0XHR1dnMxID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0sXHJcblx0XHRcdHV2czIgPSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyAwIF0sXHJcblx0XHRcdGNvbG9yczEgPSB0aGlzLmNvbG9ycyxcclxuXHRcdFx0Y29sb3JzMiA9IGdlb21ldHJ5LmNvbG9ycztcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsSW5kZXhPZmZzZXQgPT09IHVuZGVmaW5lZCApIG1hdGVyaWFsSW5kZXhPZmZzZXQgPSAwO1xyXG5cclxuXHRcdGlmICggbWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRub3JtYWxNYXRyaXggPSBuZXcgTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHZlcnRpY2VzXHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzMi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlczJbIGkgXTtcclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXhDb3B5ID0gdmVydGV4LmNsb25lKCk7XHJcblxyXG5cdFx0XHRpZiAoIG1hdHJpeCAhPT0gdW5kZWZpbmVkICkgdmVydGV4Q29weS5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xyXG5cclxuXHRcdFx0dmVydGljZXMxLnB1c2goIHZlcnRleENvcHkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY29sb3JzXHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGNvbG9yczIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjb2xvcnMxLnB1c2goIGNvbG9yczJbIGkgXS5jbG9uZSgpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGZhY2VzXHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gZmFjZXMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGZhY2UgPSBmYWNlczJbIGkgXSwgZmFjZUNvcHksIG5vcm1hbCwgY29sb3IsXHJcblx0XHRcdFx0ZmFjZVZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHMsXHJcblx0XHRcdFx0ZmFjZVZlcnRleENvbG9ycyA9IGZhY2UudmVydGV4Q29sb3JzO1xyXG5cclxuXHRcdFx0ZmFjZUNvcHkgPSBuZXcgRmFjZTMoIGZhY2UuYSArIHZlcnRleE9mZnNldCwgZmFjZS5iICsgdmVydGV4T2Zmc2V0LCBmYWNlLmMgKyB2ZXJ0ZXhPZmZzZXQgKTtcclxuXHRcdFx0ZmFjZUNvcHkubm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XHJcblxyXG5cdFx0XHRpZiAoIG5vcm1hbE1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRmYWNlQ29weS5ub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlVmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0bm9ybWFsID0gZmFjZVZlcnRleE5vcm1hbHNbIGogXS5jbG9uZSgpO1xyXG5cclxuXHRcdFx0XHRpZiAoIG5vcm1hbE1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGZhY2VDb3B5LnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmYWNlQ29weS5jb2xvci5jb3B5KCBmYWNlLmNvbG9yICk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZVZlcnRleENvbG9ycy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0Y29sb3IgPSBmYWNlVmVydGV4Q29sb3JzWyBqIF07XHJcblx0XHRcdFx0ZmFjZUNvcHkudmVydGV4Q29sb3JzLnB1c2goIGNvbG9yLmNsb25lKCkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZhY2VDb3B5Lm1hdGVyaWFsSW5kZXggPSBmYWNlLm1hdGVyaWFsSW5kZXggKyBtYXRlcmlhbEluZGV4T2Zmc2V0O1xyXG5cclxuXHRcdFx0ZmFjZXMxLnB1c2goIGZhY2VDb3B5ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHV2c1xyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHV2czIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdXYgPSB1dnMyWyBpIF0sIHV2Q29weSA9IFtdO1xyXG5cclxuXHRcdFx0aWYgKCB1diA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSB1di5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0dXZDb3B5LnB1c2goIHV2WyBqIF0uY2xvbmUoKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dXZzMS5wdXNoKCB1dkNvcHkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdG1lcmdlTWVzaDogZnVuY3Rpb24gKCBtZXNoICkge1xyXG5cclxuXHRcdGlmICggISAoIG1lc2ggJiYgbWVzaC5pc01lc2ggKSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdDT09MLkdlb21ldHJ5Lm1lcmdlTWVzaCgpOiBtZXNoIG5vdCBhbiBpbnN0YW5jZSBvZiBDT09MLk1lc2guJywgbWVzaCApO1xyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWVzaC5tYXRyaXhBdXRvVXBkYXRlICkgbWVzaC51cGRhdGVNYXRyaXgoKTtcclxuXHJcblx0XHR0aGlzLm1lcmdlKCBtZXNoLmdlb21ldHJ5LCBtZXNoLm1hdHJpeCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvKlxyXG5cdCAqIENoZWNrcyBmb3IgZHVwbGljYXRlIHZlcnRpY2VzIHdpdGggaGFzaG1hcC5cclxuXHQgKiBEdXBsaWNhdGVkIHZlcnRpY2VzIGFyZSByZW1vdmVkXHJcblx0ICogYW5kIGZhY2VzJyB2ZXJ0aWNlcyBhcmUgdXBkYXRlZC5cclxuXHQgKi9cclxuXHJcblx0bWVyZ2VWZXJ0aWNlczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2ZXJ0aWNlc01hcCA9IHt9OyAvLyBIYXNobWFwIGZvciBsb29raW5nIHVwIHZlcnRpY2VzIGJ5IHBvc2l0aW9uIGNvb3JkaW5hdGVzIChhbmQgbWFraW5nIHN1cmUgdGhleSBhcmUgdW5pcXVlKVxyXG5cdFx0dmFyIHVuaXF1ZSA9IFtdLCBjaGFuZ2VzID0gW107XHJcblxyXG5cdFx0dmFyIHYsIGtleTtcclxuXHRcdHZhciBwcmVjaXNpb25Qb2ludHMgPSA0OyAvLyBudW1iZXIgb2YgZGVjaW1hbCBwb2ludHMsIGUuZy4gNCBmb3IgZXBzaWxvbiBvZiAwLjAwMDFcclxuXHRcdHZhciBwcmVjaXNpb24gPSBNYXRoLnBvdyggMTAsIHByZWNpc2lvblBvaW50cyApO1xyXG5cdFx0dmFyIGksIGlsLCBmYWNlO1xyXG5cdFx0dmFyIGluZGljZXMsIGosIGpsO1xyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xyXG5cdFx0XHRrZXkgPSBNYXRoLnJvdW5kKCB2LnggKiBwcmVjaXNpb24gKSArICdfJyArIE1hdGgucm91bmQoIHYueSAqIHByZWNpc2lvbiApICsgJ18nICsgTWF0aC5yb3VuZCggdi56ICogcHJlY2lzaW9uICk7XHJcblxyXG5cdFx0XHRpZiAoIHZlcnRpY2VzTWFwWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHR2ZXJ0aWNlc01hcFsga2V5IF0gPSBpO1xyXG5cdFx0XHRcdHVuaXF1ZS5wdXNoKCB0aGlzLnZlcnRpY2VzWyBpIF0gKTtcclxuXHRcdFx0XHRjaGFuZ2VzWyBpIF0gPSB1bmlxdWUubGVuZ3RoIC0gMTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ0R1cGxpY2F0ZSB2ZXJ0ZXggZm91bmQuICcsIGksICcgY291bGQgYmUgdXNpbmcgJywgdmVydGljZXNNYXBba2V5XSk7XHJcblx0XHRcdFx0Y2hhbmdlc1sgaSBdID0gY2hhbmdlc1sgdmVydGljZXNNYXBbIGtleSBdIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHJcblx0XHQvLyBpZiBmYWNlcyBhcmUgY29tcGxldGVseSBkZWdlbmVyYXRlIGFmdGVyIG1lcmdpbmcgdmVydGljZXMsIHdlXHJcblx0XHQvLyBoYXZlIHRvIHJlbW92ZSB0aGVtIGZyb20gdGhlIGdlb21ldHJ5LlxyXG5cdFx0dmFyIGZhY2VJbmRpY2VzVG9SZW1vdmUgPSBbXTtcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGkgXTtcclxuXHJcblx0XHRcdGZhY2UuYSA9IGNoYW5nZXNbIGZhY2UuYSBdO1xyXG5cdFx0XHRmYWNlLmIgPSBjaGFuZ2VzWyBmYWNlLmIgXTtcclxuXHRcdFx0ZmFjZS5jID0gY2hhbmdlc1sgZmFjZS5jIF07XHJcblxyXG5cdFx0XHRpbmRpY2VzID0gWyBmYWNlLmEsIGZhY2UuYiwgZmFjZS5jIF07XHJcblxyXG5cdFx0XHQvLyBpZiBhbnkgZHVwbGljYXRlIHZlcnRpY2VzIGFyZSBmb3VuZCBpbiBhIEZhY2UzXHJcblx0XHRcdC8vIHdlIGhhdmUgdG8gcmVtb3ZlIHRoZSBmYWNlIGFzIG5vdGhpbmcgY2FuIGJlIHNhdmVkXHJcblx0XHRcdGZvciAoIHZhciBuID0gMDsgbiA8IDM7IG4gKysgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggaW5kaWNlc1sgbiBdID09PSBpbmRpY2VzWyAoIG4gKyAxICkgJSAzIF0gKSB7XHJcblxyXG5cdFx0XHRcdFx0ZmFjZUluZGljZXNUb1JlbW92ZS5wdXNoKCBpICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCBpID0gZmFjZUluZGljZXNUb1JlbW92ZS5sZW5ndGggLSAxOyBpID49IDA7IGkgLS0gKSB7XHJcblxyXG5cdFx0XHR2YXIgaWR4ID0gZmFjZUluZGljZXNUb1JlbW92ZVsgaSBdO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlcy5zcGxpY2UoIGlkeCwgMSApO1xyXG5cclxuXHRcdFx0Zm9yICggaiA9IDAsIGpsID0gdGhpcy5mYWNlVmVydGV4VXZzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIGogXS5zcGxpY2UoIGlkeCwgMSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBVc2UgdW5pcXVlIHNldCBvZiB2ZXJ0aWNlc1xyXG5cclxuXHRcdHZhciBkaWZmID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSB1bmlxdWUubGVuZ3RoO1xyXG5cdFx0dGhpcy52ZXJ0aWNlcyA9IHVuaXF1ZTtcclxuXHRcdHJldHVybiBkaWZmO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoIHBvaW50cyApIHtcclxuXHJcblx0XHR0aGlzLnZlcnRpY2VzID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgcG9pbnQgPSBwb2ludHNbIGkgXTtcclxuXHRcdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCBuZXcgVmVjdG9yMyggcG9pbnQueCwgcG9pbnQueSwgcG9pbnQueiB8fCAwICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNvcnRGYWNlc0J5TWF0ZXJpYWxJbmRleDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBmYWNlcyA9IHRoaXMuZmFjZXM7XHJcblx0XHR2YXIgbGVuZ3RoID0gZmFjZXMubGVuZ3RoO1xyXG5cclxuXHRcdC8vIHRhZyBmYWNlc1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdGZhY2VzWyBpIF0uX2lkID0gaTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc29ydCBmYWNlc1xyXG5cclxuXHRcdGZ1bmN0aW9uIG1hdGVyaWFsSW5kZXhTb3J0KCBhLCBiICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGEubWF0ZXJpYWxJbmRleCAtIGIubWF0ZXJpYWxJbmRleDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZmFjZXMuc29ydCggbWF0ZXJpYWxJbmRleFNvcnQgKTtcclxuXHJcblx0XHQvLyBzb3J0IHV2c1xyXG5cclxuXHRcdHZhciB1dnMxID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF07XHJcblx0XHR2YXIgdXZzMiA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMSBdO1xyXG5cclxuXHRcdHZhciBuZXdVdnMxLCBuZXdVdnMyO1xyXG5cclxuXHRcdGlmICggdXZzMSAmJiB1dnMxLmxlbmd0aCA9PT0gbGVuZ3RoICkgbmV3VXZzMSA9IFtdO1xyXG5cdFx0aWYgKCB1dnMyICYmIHV2czIubGVuZ3RoID09PSBsZW5ndGggKSBuZXdVdnMyID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGlkID0gZmFjZXNbIGkgXS5faWQ7XHJcblxyXG5cdFx0XHRpZiAoIG5ld1V2czEgKSBuZXdVdnMxLnB1c2goIHV2czFbIGlkIF0gKTtcclxuXHRcdFx0aWYgKCBuZXdVdnMyICkgbmV3VXZzMi5wdXNoKCB1dnMyWyBpZCBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbmV3VXZzMSApIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdID0gbmV3VXZzMTtcclxuXHRcdGlmICggbmV3VXZzMiApIHRoaXMuZmFjZVZlcnRleFV2c1sgMSBdID0gbmV3VXZzMjtcclxuXHJcblx0fSxcclxuXHJcblx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdG1ldGFkYXRhOiB7XHJcblx0XHRcdFx0dmVyc2lvbjogNC41LFxyXG5cdFx0XHRcdHR5cGU6ICdHZW9tZXRyeScsXHJcblx0XHRcdFx0Z2VuZXJhdG9yOiAnR2VvbWV0cnkudG9KU09OJ1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIHN0YW5kYXJkIEdlb21ldHJ5IHNlcmlhbGl6YXRpb25cclxuXHJcblx0XHRkYXRhLnV1aWQgPSB0aGlzLnV1aWQ7XHJcblx0XHRkYXRhLnR5cGUgPSB0aGlzLnR5cGU7XHJcblx0XHRpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBkYXRhLm5hbWUgPSB0aGlzLm5hbWU7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHBhcmFtZXRlcnNbIGtleSBdICE9PSB1bmRlZmluZWQgKSBkYXRhWyBrZXkgXSA9IHBhcmFtZXRlcnNbIGtleSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGRhdGE7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB2ZXJ0aWNlcyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHZlcnRleCA9IHRoaXMudmVydGljZXNbIGkgXTtcclxuXHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZmFjZXMgPSBbXTtcclxuXHRcdHZhciBub3JtYWxzID0gW107XHJcblx0XHR2YXIgbm9ybWFsc0hhc2ggPSB7fTtcclxuXHRcdHZhciBjb2xvcnMgPSBbXTtcclxuXHRcdHZhciBjb2xvcnNIYXNoID0ge307XHJcblx0XHR2YXIgdXZzID0gW107XHJcblx0XHR2YXIgdXZzSGFzaCA9IHt9O1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuZmFjZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGZhY2UgPSB0aGlzLmZhY2VzWyBpIF07XHJcblxyXG5cdFx0XHR2YXIgaGFzTWF0ZXJpYWwgPSB0cnVlO1xyXG5cdFx0XHR2YXIgaGFzRmFjZVV2ID0gZmFsc2U7IC8vIGRlcHJlY2F0ZWRcclxuXHRcdFx0dmFyIGhhc0ZhY2VWZXJ0ZXhVdiA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdWyBpIF0gIT09IHVuZGVmaW5lZDtcclxuXHRcdFx0dmFyIGhhc0ZhY2VOb3JtYWwgPSBmYWNlLm5vcm1hbC5sZW5ndGgoKSA+IDA7XHJcblx0XHRcdHZhciBoYXNGYWNlVmVydGV4Tm9ybWFsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA+IDA7XHJcblx0XHRcdHZhciBoYXNGYWNlQ29sb3IgPSBmYWNlLmNvbG9yLnIgIT09IDEgfHwgZmFjZS5jb2xvci5nICE9PSAxIHx8IGZhY2UuY29sb3IuYiAhPT0gMTtcclxuXHRcdFx0dmFyIGhhc0ZhY2VWZXJ0ZXhDb2xvciA9IGZhY2UudmVydGV4Q29sb3JzLmxlbmd0aCA+IDA7XHJcblxyXG5cdFx0XHR2YXIgZmFjZVR5cGUgPSAwO1xyXG5cclxuXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAwLCAwICk7IC8vIGlzUXVhZFxyXG5cdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDEsIGhhc01hdGVyaWFsICk7XHJcblx0XHRcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgMiwgaGFzRmFjZVV2ICk7XHJcblx0XHRcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgMywgaGFzRmFjZVZlcnRleFV2ICk7XHJcblx0XHRcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNCwgaGFzRmFjZU5vcm1hbCApO1xyXG5cdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDUsIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgKTtcclxuXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA2LCBoYXNGYWNlQ29sb3IgKTtcclxuXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA3LCBoYXNGYWNlVmVydGV4Q29sb3IgKTtcclxuXHJcblx0XHRcdGZhY2VzLnB1c2goIGZhY2VUeXBlICk7XHJcblx0XHRcdGZhY2VzLnB1c2goIGZhY2UuYSwgZmFjZS5iLCBmYWNlLmMgKTtcclxuXHRcdFx0ZmFjZXMucHVzaCggZmFjZS5tYXRlcmlhbEluZGV4ICk7XHJcblxyXG5cdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiApIHtcclxuXHJcblx0XHRcdFx0dmFyIGZhY2VWZXJ0ZXhVdnMgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXVsgaSBdO1xyXG5cclxuXHRcdFx0XHRmYWNlcy5wdXNoKFxyXG5cdFx0XHRcdFx0Z2V0VXZJbmRleCggZmFjZVZlcnRleFV2c1sgMCBdICksXHJcblx0XHRcdFx0XHRnZXRVdkluZGV4KCBmYWNlVmVydGV4VXZzWyAxIF0gKSxcclxuXHRcdFx0XHRcdGdldFV2SW5kZXgoIGZhY2VWZXJ0ZXhVdnNbIDIgXSApXHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggaGFzRmFjZU5vcm1hbCApIHtcclxuXHJcblx0XHRcdFx0ZmFjZXMucHVzaCggZ2V0Tm9ybWFsSW5kZXgoIGZhY2Uubm9ybWFsICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggaGFzRmFjZVZlcnRleE5vcm1hbCApIHtcclxuXHJcblx0XHRcdFx0dmFyIHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XHJcblxyXG5cdFx0XHRcdGZhY2VzLnB1c2goXHJcblx0XHRcdFx0XHRnZXROb3JtYWxJbmRleCggdmVydGV4Tm9ybWFsc1sgMCBdICksXHJcblx0XHRcdFx0XHRnZXROb3JtYWxJbmRleCggdmVydGV4Tm9ybWFsc1sgMSBdICksXHJcblx0XHRcdFx0XHRnZXROb3JtYWxJbmRleCggdmVydGV4Tm9ybWFsc1sgMiBdIClcclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBoYXNGYWNlQ29sb3IgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2VzLnB1c2goIGdldENvbG9ySW5kZXgoIGZhY2UuY29sb3IgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4Q29sb3IgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB2ZXJ0ZXhDb2xvcnMgPSBmYWNlLnZlcnRleENvbG9ycztcclxuXHJcblx0XHRcdFx0ZmFjZXMucHVzaChcclxuXHRcdFx0XHRcdGdldENvbG9ySW5kZXgoIHZlcnRleENvbG9yc1sgMCBdICksXHJcblx0XHRcdFx0XHRnZXRDb2xvckluZGV4KCB2ZXJ0ZXhDb2xvcnNbIDEgXSApLFxyXG5cdFx0XHRcdFx0Z2V0Q29sb3JJbmRleCggdmVydGV4Q29sb3JzWyAyIF0gKVxyXG5cdFx0XHRcdCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHNldEJpdCggdmFsdWUsIHBvc2l0aW9uLCBlbmFibGVkICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGVuYWJsZWQgPyB2YWx1ZSB8ICggMSA8PCBwb3NpdGlvbiApIDogdmFsdWUgJiAoIH4gKCAxIDw8IHBvc2l0aW9uICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2V0Tm9ybWFsSW5kZXgoIG5vcm1hbCApIHtcclxuXHJcblx0XHRcdHZhciBoYXNoID0gbm9ybWFsLngudG9TdHJpbmcoKSArIG5vcm1hbC55LnRvU3RyaW5nKCkgKyBub3JtYWwuei50b1N0cmluZygpO1xyXG5cclxuXHRcdFx0aWYgKCBub3JtYWxzSGFzaFsgaGFzaCBdICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBub3JtYWxzSGFzaFsgaGFzaCBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bm9ybWFsc0hhc2hbIGhhc2ggXSA9IG5vcm1hbHMubGVuZ3RoIC8gMztcclxuXHRcdFx0bm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gbm9ybWFsc0hhc2hbIGhhc2ggXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2V0Q29sb3JJbmRleCggY29sb3IgKSB7XHJcblxyXG5cdFx0XHR2YXIgaGFzaCA9IGNvbG9yLnIudG9TdHJpbmcoKSArIGNvbG9yLmcudG9TdHJpbmcoKSArIGNvbG9yLmIudG9TdHJpbmcoKTtcclxuXHJcblx0XHRcdGlmICggY29sb3JzSGFzaFsgaGFzaCBdICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBjb2xvcnNIYXNoWyBoYXNoIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb2xvcnNIYXNoWyBoYXNoIF0gPSBjb2xvcnMubGVuZ3RoO1xyXG5cdFx0XHRjb2xvcnMucHVzaCggY29sb3IuZ2V0SGV4KCkgKTtcclxuXHJcblx0XHRcdHJldHVybiBjb2xvcnNIYXNoWyBoYXNoIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGdldFV2SW5kZXgoIHV2ICkge1xyXG5cclxuXHRcdFx0dmFyIGhhc2ggPSB1di54LnRvU3RyaW5nKCkgKyB1di55LnRvU3RyaW5nKCk7XHJcblxyXG5cdFx0XHRpZiAoIHV2c0hhc2hbIGhhc2ggXSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdXZzSGFzaFsgaGFzaCBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dXZzSGFzaFsgaGFzaCBdID0gdXZzLmxlbmd0aCAvIDI7XHJcblx0XHRcdHV2cy5wdXNoKCB1di54LCB1di55ICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdXZzSGFzaFsgaGFzaCBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRkYXRhLmRhdGEgPSB7fTtcclxuXHJcblx0XHRkYXRhLmRhdGEudmVydGljZXMgPSB2ZXJ0aWNlcztcclxuXHRcdGRhdGEuZGF0YS5ub3JtYWxzID0gbm9ybWFscztcclxuXHRcdGlmICggY29sb3JzLmxlbmd0aCA+IDAgKSBkYXRhLmRhdGEuY29sb3JzID0gY29sb3JzO1xyXG5cdFx0aWYgKCB1dnMubGVuZ3RoID4gMCApIGRhdGEuZGF0YS51dnMgPSBbIHV2cyBdOyAvLyB0ZW1wb3JhbCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XHJcblx0XHRkYXRhLmRhdGEuZmFjZXMgPSBmYWNlcztcclxuXHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvKlxyXG5cdFx0IC8vIEhhbmRsZSBwcmltaXRpdmVzXHJcblxyXG5cdFx0IHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xyXG5cclxuXHRcdCBpZiAoIHBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHQgdmFyIHZhbHVlcyA9IFtdO1xyXG5cclxuXHRcdCBmb3IgKCB2YXIga2V5IGluIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFx0IHZhbHVlcy5wdXNoKCBwYXJhbWV0ZXJzWyBrZXkgXSApO1xyXG5cclxuXHRcdCB9XHJcblxyXG5cdFx0IHZhciBnZW9tZXRyeSA9IE9iamVjdC5jcmVhdGUoIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlICk7XHJcblx0XHQgdGhpcy5jb25zdHJ1Y3Rvci5hcHBseSggZ2VvbWV0cnksIHZhbHVlcyApO1xyXG5cdFx0IHJldHVybiBnZW9tZXRyeTtcclxuXHJcblx0XHQgfVxyXG5cclxuXHRcdCByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblx0XHQgKi9cclxuXHJcblx0XHRyZXR1cm4gbmV3IEdlb21ldHJ5KCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0XHR2YXIgaSwgaWwsIGosIGpsLCBrLCBrbDtcclxuXHJcblx0XHQvLyByZXNldFxyXG5cclxuXHRcdHRoaXMudmVydGljZXMgPSBbXTtcclxuXHRcdHRoaXMuY29sb3JzID0gW107XHJcblx0XHR0aGlzLmZhY2VzID0gW107XHJcblx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnMgPSBbW11dO1xyXG5cdFx0dGhpcy5tb3JwaFRhcmdldHMgPSBbXTtcclxuXHRcdHRoaXMubW9ycGhOb3JtYWxzID0gW107XHJcblx0XHR0aGlzLnNraW5XZWlnaHRzID0gW107XHJcblx0XHR0aGlzLnNraW5JbmRpY2VzID0gW107XHJcblx0XHR0aGlzLmxpbmVEaXN0YW5jZXMgPSBbXTtcclxuXHRcdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xyXG5cdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XHJcblxyXG5cdFx0Ly8gbmFtZVxyXG5cclxuXHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xyXG5cclxuXHRcdC8vIHZlcnRpY2VzXHJcblxyXG5cdFx0dmFyIHZlcnRpY2VzID0gc291cmNlLnZlcnRpY2VzO1xyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1sgaSBdLmNsb25lKCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY29sb3JzXHJcblxyXG5cdFx0dmFyIGNvbG9ycyA9IHNvdXJjZS5jb2xvcnM7XHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gY29sb3JzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dGhpcy5jb2xvcnMucHVzaCggY29sb3JzWyBpIF0uY2xvbmUoKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBmYWNlc1xyXG5cclxuXHRcdHZhciBmYWNlcyA9IHNvdXJjZS5mYWNlcztcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSBmYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMuZmFjZXMucHVzaCggZmFjZXNbIGkgXS5jbG9uZSgpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGZhY2UgdmVydGV4IHV2c1xyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHNvdXJjZS5mYWNlVmVydGV4VXZzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGZhY2VWZXJ0ZXhVdnMgPSBzb3VyY2UuZmFjZVZlcnRleFV2c1sgaSBdO1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmZhY2VWZXJ0ZXhVdnNbIGkgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIGkgXSA9IFtdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yICggaiA9IDAsIGpsID0gZmFjZVZlcnRleFV2cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIHV2cyA9IGZhY2VWZXJ0ZXhVdnNbIGogXSwgdXZzQ29weSA9IFtdO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBrID0gMCwga2wgPSB1dnMubGVuZ3RoOyBrIDwga2w7IGsgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHV2ID0gdXZzWyBrIF07XHJcblxyXG5cdFx0XHRcdFx0dXZzQ29weS5wdXNoKCB1di5jbG9uZSgpICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyBpIF0ucHVzaCggdXZzQ29weSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBtb3JwaCB0YXJnZXRzXHJcblxyXG5cdFx0dmFyIG1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gbW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIG1vcnBoVGFyZ2V0ID0ge307XHJcblx0XHRcdG1vcnBoVGFyZ2V0Lm5hbWUgPSBtb3JwaFRhcmdldHNbIGkgXS5uYW1lO1xyXG5cclxuXHRcdFx0Ly8gdmVydGljZXNcclxuXHJcblx0XHRcdGlmICggbW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0bW9ycGhUYXJnZXQudmVydGljZXMgPSBbXTtcclxuXHJcblx0XHRcdFx0Zm9yICggaiA9IDAsIGpsID0gbW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0bW9ycGhUYXJnZXQudmVydGljZXMucHVzaCggbW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXNbIGogXS5jbG9uZSgpICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIG5vcm1hbHNcclxuXHJcblx0XHRcdGlmICggbW9ycGhUYXJnZXRzWyBpIF0ubm9ybWFscyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRtb3JwaFRhcmdldC5ub3JtYWxzID0gW107XHJcblxyXG5cdFx0XHRcdGZvciAoIGogPSAwLCBqbCA9IG1vcnBoVGFyZ2V0c1sgaSBdLm5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0bW9ycGhUYXJnZXQubm9ybWFscy5wdXNoKCBtb3JwaFRhcmdldHNbIGkgXS5ub3JtYWxzWyBqIF0uY2xvbmUoKSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLm1vcnBoVGFyZ2V0cy5wdXNoKCBtb3JwaFRhcmdldCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBtb3JwaCBub3JtYWxzXHJcblxyXG5cdFx0dmFyIG1vcnBoTm9ybWFscyA9IHNvdXJjZS5tb3JwaE5vcm1hbHM7XHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gbW9ycGhOb3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIG1vcnBoTm9ybWFsID0ge307XHJcblxyXG5cdFx0XHQvLyB2ZXJ0ZXggbm9ybWFsc1xyXG5cclxuXHRcdFx0aWYgKCBtb3JwaE5vcm1hbHNbIGkgXS52ZXJ0ZXhOb3JtYWxzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdG1vcnBoTm9ybWFsLnZlcnRleE5vcm1hbHMgPSBbXTtcclxuXHJcblx0XHRcdFx0Zm9yICggaiA9IDAsIGpsID0gbW9ycGhOb3JtYWxzWyBpIF0udmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgc3JjVmVydGV4Tm9ybWFsID0gbW9ycGhOb3JtYWxzWyBpIF0udmVydGV4Tm9ybWFsc1sgaiBdO1xyXG5cdFx0XHRcdFx0dmFyIGRlc3RWZXJ0ZXhOb3JtYWwgPSB7fTtcclxuXHJcblx0XHRcdFx0XHRkZXN0VmVydGV4Tm9ybWFsLmEgPSBzcmNWZXJ0ZXhOb3JtYWwuYS5jbG9uZSgpO1xyXG5cdFx0XHRcdFx0ZGVzdFZlcnRleE5vcm1hbC5iID0gc3JjVmVydGV4Tm9ybWFsLmIuY2xvbmUoKTtcclxuXHRcdFx0XHRcdGRlc3RWZXJ0ZXhOb3JtYWwuYyA9IHNyY1ZlcnRleE5vcm1hbC5jLmNsb25lKCk7XHJcblxyXG5cdFx0XHRcdFx0bW9ycGhOb3JtYWwudmVydGV4Tm9ybWFscy5wdXNoKCBkZXN0VmVydGV4Tm9ybWFsICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGZhY2Ugbm9ybWFsc1xyXG5cclxuXHRcdFx0aWYgKCBtb3JwaE5vcm1hbHNbIGkgXS5mYWNlTm9ybWFscyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRtb3JwaE5vcm1hbC5mYWNlTm9ybWFscyA9IFtdO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBqID0gMCwgamwgPSBtb3JwaE5vcm1hbHNbIGkgXS5mYWNlTm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRtb3JwaE5vcm1hbC5mYWNlTm9ybWFscy5wdXNoKCBtb3JwaE5vcm1hbHNbIGkgXS5mYWNlTm9ybWFsc1sgaiBdLmNsb25lKCkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5tb3JwaE5vcm1hbHMucHVzaCggbW9ycGhOb3JtYWwgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2tpbiB3ZWlnaHRzXHJcblxyXG5cdFx0dmFyIHNraW5XZWlnaHRzID0gc291cmNlLnNraW5XZWlnaHRzO1xyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHNraW5XZWlnaHRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dGhpcy5za2luV2VpZ2h0cy5wdXNoKCBza2luV2VpZ2h0c1sgaSBdLmNsb25lKCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2tpbiBpbmRpY2VzXHJcblxyXG5cdFx0dmFyIHNraW5JbmRpY2VzID0gc291cmNlLnNraW5JbmRpY2VzO1xyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHNraW5JbmRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dGhpcy5za2luSW5kaWNlcy5wdXNoKCBza2luSW5kaWNlc1sgaSBdLmNsb25lKCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gbGluZSBkaXN0YW5jZXNcclxuXHJcblx0XHR2YXIgbGluZURpc3RhbmNlcyA9IHNvdXJjZS5saW5lRGlzdGFuY2VzO1xyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGxpbmVEaXN0YW5jZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmxpbmVEaXN0YW5jZXMucHVzaCggbGluZURpc3RhbmNlc1sgaSBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGJvdW5kaW5nIGJveFxyXG5cclxuXHRcdHZhciBib3VuZGluZ0JveCA9IHNvdXJjZS5ib3VuZGluZ0JveDtcclxuXHJcblx0XHRpZiAoIGJvdW5kaW5nQm94ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IGJvdW5kaW5nQm94LmNsb25lKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGJvdW5kaW5nIHNwaGVyZVxyXG5cclxuXHRcdHZhciBib3VuZGluZ1NwaGVyZSA9IHNvdXJjZS5ib3VuZGluZ1NwaGVyZTtcclxuXHJcblx0XHRpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IGJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHVwZGF0ZSBmbGFnc1xyXG5cclxuXHRcdHRoaXMuZWxlbWVudHNOZWVkVXBkYXRlID0gc291cmNlLmVsZW1lbnRzTmVlZFVwZGF0ZTtcclxuXHRcdHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gc291cmNlLnZlcnRpY2VzTmVlZFVwZGF0ZTtcclxuXHRcdHRoaXMudXZzTmVlZFVwZGF0ZSA9IHNvdXJjZS51dnNOZWVkVXBkYXRlO1xyXG5cdFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IHNvdXJjZS5ub3JtYWxzTmVlZFVwZGF0ZTtcclxuXHRcdHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IHNvdXJjZS5jb2xvcnNOZWVkVXBkYXRlO1xyXG5cdFx0dGhpcy5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZSA9IHNvdXJjZS5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZTtcclxuXHRcdHRoaXMuZ3JvdXBzTmVlZFVwZGF0ZSA9IHNvdXJjZS5ncm91cHNOZWVkVXBkYXRlO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuXHJcblxyXG5leHBvcnQgeyBHZW9tZXRyeSB9O1xyXG4iLCIvKipcclxuICogQGF1dGhvciBzdXBlcmVnZ2JlcnQgLyBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9cclxuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gVmVjdG9yNCggeCwgeSwgeiwgdyApIHtcclxuXHJcblx0dGhpcy54ID0geCB8fCAwO1xyXG5cdHRoaXMueSA9IHkgfHwgMDtcclxuXHR0aGlzLnogPSB6IHx8IDA7XHJcblx0dGhpcy53ID0gKCB3ICE9PSB1bmRlZmluZWQgKSA/IHcgOiAxO1xyXG5cclxufVxyXG5cclxuT2JqZWN0LmFzc2lnbiggVmVjdG9yNC5wcm90b3R5cGUsIHtcclxuXHJcblx0aXNWZWN0b3I0OiB0cnVlLFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcclxuXHJcblx0XHR0aGlzLnggPSB4O1xyXG5cdFx0dGhpcy55ID0geTtcclxuXHRcdHRoaXMueiA9IHo7XHJcblx0XHR0aGlzLncgPSB3O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHNjYWxhcjtcclxuXHRcdHRoaXMueSA9IHNjYWxhcjtcclxuXHRcdHRoaXMueiA9IHNjYWxhcjtcclxuXHRcdHRoaXMudyA9IHNjYWxhcjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WDogZnVuY3Rpb24gKCB4ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHg7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFk6IGZ1bmN0aW9uICggeSApIHtcclxuXHJcblx0XHR0aGlzLnkgPSB5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRaOiBmdW5jdGlvbiAoIHogKSB7XHJcblxyXG5cdFx0dGhpcy56ID0gejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0VzogZnVuY3Rpb24gKCB3ICkge1xyXG5cclxuXHRcdHRoaXMudyA9IHc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCwgdmFsdWUgKSB7XHJcblxyXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgMjogdGhpcy56ID0gdmFsdWU7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIDM6IHRoaXMudyA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcclxuXHJcblx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcclxuXHRcdFx0Y2FzZSAxOiByZXR1cm4gdGhpcy55O1xyXG5cdFx0XHRjYXNlIDI6IHJldHVybiB0aGlzLno7XHJcblx0XHRcdGNhc2UgMzogcmV0dXJuIHRoaXMudztcclxuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLncgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHYueDtcclxuXHRcdHRoaXMueSA9IHYueTtcclxuXHRcdHRoaXMueiA9IHYuejtcclxuXHRcdHRoaXMudyA9ICggdi53ICE9PSB1bmRlZmluZWQgKSA/IHYudyA6IDE7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZDogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5WZWN0b3I0OiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCB2LCB3ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMueCArPSB2Lng7XHJcblx0XHR0aGlzLnkgKz0gdi55O1xyXG5cdFx0dGhpcy56ICs9IHYuejtcclxuXHRcdHRoaXMudyArPSB2Lnc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMueCArPSBzO1xyXG5cdFx0dGhpcy55ICs9IHM7XHJcblx0XHR0aGlzLnogKz0gcztcclxuXHRcdHRoaXMudyArPSBzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGRWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gYS54ICsgYi54O1xyXG5cdFx0dGhpcy55ID0gYS55ICsgYi55O1xyXG5cdFx0dGhpcy56ID0gYS56ICsgYi56O1xyXG5cdFx0dGhpcy53ID0gYS53ICsgYi53O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGRTY2FsZWRWZWN0b3I6IGZ1bmN0aW9uICggdiwgcyApIHtcclxuXHJcblx0XHR0aGlzLnggKz0gdi54ICogcztcclxuXHRcdHRoaXMueSArPSB2LnkgKiBzO1xyXG5cdFx0dGhpcy56ICs9IHYueiAqIHM7XHJcblx0XHR0aGlzLncgKz0gdi53ICogcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c3ViOiBmdW5jdGlvbiAoIHYsIHcgKSB7XHJcblxyXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdDT09MLlZlY3RvcjQ6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYsIHcgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy54IC09IHYueDtcclxuXHRcdHRoaXMueSAtPSB2Lnk7XHJcblx0XHR0aGlzLnogLT0gdi56O1xyXG5cdFx0dGhpcy53IC09IHYudztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c3ViU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0dGhpcy54IC09IHM7XHJcblx0XHR0aGlzLnkgLT0gcztcclxuXHRcdHRoaXMueiAtPSBzO1xyXG5cdFx0dGhpcy53IC09IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHN1YlZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBhLnggLSBiLng7XHJcblx0XHR0aGlzLnkgPSBhLnkgLSBiLnk7XHJcblx0XHR0aGlzLnogPSBhLnogLSBiLno7XHJcblx0XHR0aGlzLncgPSBhLncgLSBiLnc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcclxuXHJcblx0XHR0aGlzLnggKj0gc2NhbGFyO1xyXG5cdFx0dGhpcy55ICo9IHNjYWxhcjtcclxuXHRcdHRoaXMueiAqPSBzY2FsYXI7XHJcblx0XHR0aGlzLncgKj0gc2NhbGFyO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMueiwgdyA9IHRoaXMudztcclxuXHRcdHZhciBlID0gbS5lbGVtZW50cztcclxuXHJcblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAqIHogKyBlWyAxMiBdICogdztcclxuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICogeiArIGVbIDEzIF0gKiB3O1xyXG5cdFx0dGhpcy56ID0gZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF0gKiB3O1xyXG5cdFx0dGhpcy53ID0gZVsgMyBdICogeCArIGVbIDcgXSAqIHkgKyBlWyAxMSBdICogeiArIGVbIDE1IF0gKiB3O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gc2NhbGFyICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEF4aXNBbmdsZUZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XHJcblxyXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL3F1YXRlcm5pb25Ub0FuZ2xlL2luZGV4Lmh0bVxyXG5cclxuXHRcdC8vIHEgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXHJcblxyXG5cdFx0dGhpcy53ID0gMiAqIE1hdGguYWNvcyggcS53ICk7XHJcblxyXG5cdFx0dmFyIHMgPSBNYXRoLnNxcnQoIDEgLSBxLncgKiBxLncgKTtcclxuXHJcblx0XHRpZiAoIHMgPCAwLjAwMDEgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSAxO1xyXG5cdFx0XHR0aGlzLnkgPSAwO1xyXG5cdFx0XHR0aGlzLnogPSAwO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSBxLnggLyBzO1xyXG5cdFx0XHR0aGlzLnkgPSBxLnkgLyBzO1xyXG5cdFx0XHR0aGlzLnogPSBxLnogLyBzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0QXhpc0FuZ2xlRnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvQW5nbGUvaW5kZXguaHRtXHJcblxyXG5cdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcclxuXHJcblx0XHR2YXIgYW5nbGUsIHgsIHksIHosXHRcdC8vIHZhcmlhYmxlcyBmb3IgcmVzdWx0XHJcblx0XHRcdGVwc2lsb24gPSAwLjAxLFx0XHQvLyBtYXJnaW4gdG8gYWxsb3cgZm9yIHJvdW5kaW5nIGVycm9yc1xyXG5cdFx0XHRlcHNpbG9uMiA9IDAuMSxcdFx0Ly8gbWFyZ2luIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gMCBhbmQgMTgwIGRlZ3JlZXNcclxuXHJcblx0XHRcdHRlID0gbS5lbGVtZW50cyxcclxuXHJcblx0XHRcdG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF0sXHJcblx0XHRcdG0yMSA9IHRlWyAxIF0sIG0yMiA9IHRlWyA1IF0sIG0yMyA9IHRlWyA5IF0sXHJcblx0XHRcdG0zMSA9IHRlWyAyIF0sIG0zMiA9IHRlWyA2IF0sIG0zMyA9IHRlWyAxMCBdO1xyXG5cclxuXHRcdGlmICggKCBNYXRoLmFicyggbTEyIC0gbTIxICkgPCBlcHNpbG9uICkgJiZcclxuXHRcdCAgICAgKCBNYXRoLmFicyggbTEzIC0gbTMxICkgPCBlcHNpbG9uICkgJiZcclxuXHRcdCAgICAgKCBNYXRoLmFicyggbTIzIC0gbTMyICkgPCBlcHNpbG9uICkgKSB7XHJcblxyXG5cdFx0XHQvLyBzaW5ndWxhcml0eSBmb3VuZFxyXG5cdFx0XHQvLyBmaXJzdCBjaGVjayBmb3IgaWRlbnRpdHkgbWF0cml4IHdoaWNoIG11c3QgaGF2ZSArMSBmb3IgYWxsIHRlcm1zXHJcblx0XHRcdC8vIGluIGxlYWRpbmcgZGlhZ29uYWwgYW5kIHplcm8gaW4gb3RoZXIgdGVybXNcclxuXHJcblx0XHRcdGlmICggKCBNYXRoLmFicyggbTEyICsgbTIxICkgPCBlcHNpbG9uMiApICYmXHJcblx0XHRcdCAgICAgKCBNYXRoLmFicyggbTEzICsgbTMxICkgPCBlcHNpbG9uMiApICYmXHJcblx0XHRcdCAgICAgKCBNYXRoLmFicyggbTIzICsgbTMyICkgPCBlcHNpbG9uMiApICYmXHJcblx0XHRcdCAgICAgKCBNYXRoLmFicyggbTExICsgbTIyICsgbTMzIC0gMyApIDwgZXBzaWxvbjIgKSApIHtcclxuXHJcblx0XHRcdFx0Ly8gdGhpcyBzaW5ndWxhcml0eSBpcyBpZGVudGl0eSBtYXRyaXggc28gYW5nbGUgPSAwXHJcblxyXG5cdFx0XHRcdHRoaXMuc2V0KCAxLCAwLCAwLCAwICk7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzOyAvLyB6ZXJvIGFuZ2xlLCBhcmJpdHJhcnkgYXhpc1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gb3RoZXJ3aXNlIHRoaXMgc2luZ3VsYXJpdHkgaXMgYW5nbGUgPSAxODBcclxuXHJcblx0XHRcdGFuZ2xlID0gTWF0aC5QSTtcclxuXHJcblx0XHRcdHZhciB4eCA9ICggbTExICsgMSApIC8gMjtcclxuXHRcdFx0dmFyIHl5ID0gKCBtMjIgKyAxICkgLyAyO1xyXG5cdFx0XHR2YXIgenogPSAoIG0zMyArIDEgKSAvIDI7XHJcblx0XHRcdHZhciB4eSA9ICggbTEyICsgbTIxICkgLyA0O1xyXG5cdFx0XHR2YXIgeHogPSAoIG0xMyArIG0zMSApIC8gNDtcclxuXHRcdFx0dmFyIHl6ID0gKCBtMjMgKyBtMzIgKSAvIDQ7XHJcblxyXG5cdFx0XHRpZiAoICggeHggPiB5eSApICYmICggeHggPiB6eiApICkge1xyXG5cclxuXHRcdFx0XHQvLyBtMTEgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybVxyXG5cclxuXHRcdFx0XHRpZiAoIHh4IDwgZXBzaWxvbiApIHtcclxuXHJcblx0XHRcdFx0XHR4ID0gMDtcclxuXHRcdFx0XHRcdHkgPSAwLjcwNzEwNjc4MTtcclxuXHRcdFx0XHRcdHogPSAwLjcwNzEwNjc4MTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR4ID0gTWF0aC5zcXJ0KCB4eCApO1xyXG5cdFx0XHRcdFx0eSA9IHh5IC8geDtcclxuXHRcdFx0XHRcdHogPSB4eiAvIHg7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHl5ID4genogKSB7XHJcblxyXG5cdFx0XHRcdC8vIG0yMiBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtXHJcblxyXG5cdFx0XHRcdGlmICggeXkgPCBlcHNpbG9uICkge1xyXG5cclxuXHRcdFx0XHRcdHggPSAwLjcwNzEwNjc4MTtcclxuXHRcdFx0XHRcdHkgPSAwO1xyXG5cdFx0XHRcdFx0eiA9IDAuNzA3MTA2NzgxO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHkgPSBNYXRoLnNxcnQoIHl5ICk7XHJcblx0XHRcdFx0XHR4ID0geHkgLyB5O1xyXG5cdFx0XHRcdFx0eiA9IHl6IC8geTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gbTMzIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm0gc28gYmFzZSByZXN1bHQgb24gdGhpc1xyXG5cclxuXHRcdFx0XHRpZiAoIHp6IDwgZXBzaWxvbiApIHtcclxuXHJcblx0XHRcdFx0XHR4ID0gMC43MDcxMDY3ODE7XHJcblx0XHRcdFx0XHR5ID0gMC43MDcxMDY3ODE7XHJcblx0XHRcdFx0XHR6ID0gMDtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR6ID0gTWF0aC5zcXJ0KCB6eiApO1xyXG5cdFx0XHRcdFx0eCA9IHh6IC8gejtcclxuXHRcdFx0XHRcdHkgPSB5eiAvIHo7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuc2V0KCB4LCB5LCB6LCBhbmdsZSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7IC8vIHJldHVybiAxODAgZGVnIHJvdGF0aW9uXHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGFzIHdlIGhhdmUgcmVhY2hlZCBoZXJlIHRoZXJlIGFyZSBubyBzaW5ndWxhcml0aWVzIHNvIHdlIGNhbiBoYW5kbGUgbm9ybWFsbHlcclxuXHJcblx0XHR2YXIgcyA9IE1hdGguc3FydCggKCBtMzIgLSBtMjMgKSAqICggbTMyIC0gbTIzICkgK1xyXG5cdFx0ICAgICAgICAgICAgICAgICAgICggbTEzIC0gbTMxICkgKiAoIG0xMyAtIG0zMSApICtcclxuXHRcdCAgICAgICAgICAgICAgICAgICAoIG0yMSAtIG0xMiApICogKCBtMjEgLSBtMTIgKSApOyAvLyB1c2VkIHRvIG5vcm1hbGl6ZVxyXG5cclxuXHRcdGlmICggTWF0aC5hYnMoIHMgKSA8IDAuMDAxICkgcyA9IDE7XHJcblxyXG5cdFx0Ly8gcHJldmVudCBkaXZpZGUgYnkgemVybywgc2hvdWxkIG5vdCBoYXBwZW4gaWYgbWF0cml4IGlzIG9ydGhvZ29uYWwgYW5kIHNob3VsZCBiZVxyXG5cdFx0Ly8gY2F1Z2h0IGJ5IHNpbmd1bGFyaXR5IHRlc3QgYWJvdmUsIGJ1dCBJJ3ZlIGxlZnQgaXQgaW4ganVzdCBpbiBjYXNlXHJcblxyXG5cdFx0dGhpcy54ID0gKCBtMzIgLSBtMjMgKSAvIHM7XHJcblx0XHR0aGlzLnkgPSAoIG0xMyAtIG0zMSApIC8gcztcclxuXHRcdHRoaXMueiA9ICggbTIxIC0gbTEyICkgLyBzO1xyXG5cdFx0dGhpcy53ID0gTWF0aC5hY29zKCAoIG0xMSArIG0yMiArIG0zMyAtIDEgKSAvIDIgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWluOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5taW4oIHRoaXMueCwgdi54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLm1pbiggdGhpcy55LCB2LnkgKTtcclxuXHRcdHRoaXMueiA9IE1hdGgubWluKCB0aGlzLnosIHYueiApO1xyXG5cdFx0dGhpcy53ID0gTWF0aC5taW4oIHRoaXMudywgdi53ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1heDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCB0aGlzLngsIHYueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIHRoaXMueSwgdi55ICk7XHJcblx0XHR0aGlzLnogPSBNYXRoLm1heCggdGhpcy56LCB2LnogKTtcclxuXHRcdHRoaXMudyA9IE1hdGgubWF4KCB0aGlzLncsIHYudyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbGFtcDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcclxuXHJcblx0XHQvLyBhc3N1bWVzIG1pbiA8IG1heCwgY29tcG9uZW50d2lzZVxyXG5cclxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCBtaW4ueCwgTWF0aC5taW4oIG1heC54LCB0aGlzLnggKSApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIG1pbi55LCBNYXRoLm1pbiggbWF4LnksIHRoaXMueSApICk7XHJcblx0XHR0aGlzLnogPSBNYXRoLm1heCggbWluLnosIE1hdGgubWluKCBtYXgueiwgdGhpcy56ICkgKTtcclxuXHRcdHRoaXMudyA9IE1hdGgubWF4KCBtaW4udywgTWF0aC5taW4oIG1heC53LCB0aGlzLncgKSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbGFtcFNjYWxhcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBtaW4sIG1heDtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gY2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xyXG5cclxuXHRcdFx0aWYgKCBtaW4gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0bWluID0gbmV3IFZlY3RvcjQoKTtcclxuXHRcdFx0XHRtYXggPSBuZXcgVmVjdG9yNCgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bWluLnNldCggbWluVmFsLCBtaW5WYWwsIG1pblZhbCwgbWluVmFsICk7XHJcblx0XHRcdG1heC5zZXQoIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwsIG1heFZhbCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuY2xhbXAoIG1pbiwgbWF4ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRjbGFtcExlbmd0aDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcclxuXHJcblx0XHR2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIGxlbmd0aCB8fCAxICkubXVsdGlwbHlTY2FsYXIoIE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIGxlbmd0aCApICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5mbG9vciggdGhpcy56ICk7XHJcblx0XHR0aGlzLncgPSBNYXRoLmZsb29yKCB0aGlzLncgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2VpbDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcclxuXHRcdHRoaXMudyA9IE1hdGguY2VpbCggdGhpcy53ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdW5kOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcclxuXHRcdHRoaXMueiA9IE1hdGgucm91bmQoIHRoaXMueiApO1xyXG5cdFx0dGhpcy53ID0gTWF0aC5yb3VuZCggdGhpcy53ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcclxuXHRcdHRoaXMueiA9ICggdGhpcy56IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnogKSA6IE1hdGguZmxvb3IoIHRoaXMueiApO1xyXG5cdFx0dGhpcy53ID0gKCB0aGlzLncgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMudyApIDogTWF0aC5mbG9vciggdGhpcy53ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IC0gdGhpcy54O1xyXG5cdFx0dGhpcy55ID0gLSB0aGlzLnk7XHJcblx0XHR0aGlzLnogPSAtIHRoaXMuejtcclxuXHRcdHRoaXMudyA9IC0gdGhpcy53O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56ICsgdGhpcy53ICogdi53O1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLnc7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlbmd0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYW5oYXR0YW5MZW5ndGg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApICsgTWF0aC5hYnMoIHRoaXMueiApICsgTWF0aC5hYnMoIHRoaXMudyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgfHwgMSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRMZW5ndGg6IGZ1bmN0aW9uICggbGVuZ3RoICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCBsZW5ndGggKTtcclxuXHJcblx0fSxcclxuXHJcblx0bGVycDogZnVuY3Rpb24gKCB2LCBhbHBoYSApIHtcclxuXHJcblx0XHR0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xyXG5cdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcclxuXHRcdHRoaXMueiArPSAoIHYueiAtIHRoaXMueiApICogYWxwaGE7XHJcblx0XHR0aGlzLncgKz0gKCB2LncgLSB0aGlzLncgKSAqIGFscGhhO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZXJwVmVjdG9yczogZnVuY3Rpb24gKCB2MSwgdjIsIGFscGhhICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYyLCB2MSApLm11bHRpcGx5U2NhbGFyKCBhbHBoYSApLmFkZCggdjEgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSAmJiAoIHYueiA9PT0gdGhpcy56ICkgJiYgKCB2LncgPT09IHRoaXMudyApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcclxuXHRcdHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XHJcblx0XHR0aGlzLnogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xyXG5cdFx0dGhpcy53ID0gYXJyYXlbIG9mZnNldCArIDMgXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XHJcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLng7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy55O1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuejtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLnc7XHJcblxyXG5cdFx0cmV0dXJuIGFycmF5O1xyXG5cclxuXHR9LFxyXG5cclxuXHRmcm9tQnVmZmVyQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIG9mZnNldCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5WZWN0b3I0OiBvZmZzZXQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIC5mcm9tQnVmZmVyQXR0cmlidXRlKCkuJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnggPSBhdHRyaWJ1dGUuZ2V0WCggaW5kZXggKTtcclxuXHRcdHRoaXMueSA9IGF0dHJpYnV0ZS5nZXRZKCBpbmRleCApO1xyXG5cdFx0dGhpcy56ID0gYXR0cmlidXRlLmdldFooIGluZGV4ICk7XHJcblx0XHR0aGlzLncgPSBhdHRyaWJ1dGUuZ2V0VyggaW5kZXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxufSApO1xyXG5cclxuXHJcbmV4cG9ydCB7IFZlY3RvcjQgfTtcclxuIiwiaW1wb3J0IHsgVmVjdG9yNCB9IGZyb20gJy4uL21hdGgvVmVjdG9yNC5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IyLmpzJztcclxuaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi9tYXRoL0NvbG9yLmpzJztcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xyXG5cclxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIGFycmF5ICkgKSB7XHJcblxyXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ0NPT0wuQnVmZmVyQXR0cmlidXRlOiBhcnJheSBzaG91bGQgYmUgYSBUeXBlZCBBcnJheS4nICk7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5uYW1lID0gJyc7XHJcblxyXG5cdHRoaXMuYXJyYXkgPSBhcnJheTtcclxuXHR0aGlzLml0ZW1TaXplID0gaXRlbVNpemU7XHJcblx0dGhpcy5jb3VudCA9IGFycmF5ICE9PSB1bmRlZmluZWQgPyBhcnJheS5sZW5ndGggLyBpdGVtU2l6ZSA6IDA7XHJcblx0dGhpcy5ub3JtYWxpemVkID0gbm9ybWFsaXplZCA9PT0gdHJ1ZTtcclxuXHJcblx0dGhpcy5keW5hbWljID0gZmFsc2U7XHJcblx0dGhpcy51cGRhdGVSYW5nZSA9IHsgb2Zmc2V0OiAwLCBjb3VudDogLSAxIH07XHJcblxyXG5cdHRoaXMudmVyc2lvbiA9IDA7XHJcblxyXG59XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUsICduZWVkc1VwZGF0ZScsIHtcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24gKys7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuXHJcbk9iamVjdC5hc3NpZ24oIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUsIHtcclxuXHJcblx0aXNCdWZmZXJBdHRyaWJ1dGU6IHRydWUsXHJcblxyXG5cdG9uVXBsb2FkQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHt9LFxyXG5cclxuXHRzZXRBcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcclxuXHJcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGFycmF5ICkgKSB7XHJcblxyXG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnQ09PTC5CdWZmZXJBdHRyaWJ1dGU6IGFycmF5IHNob3VsZCBiZSBhIFR5cGVkIEFycmF5LicgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jb3VudCA9IGFycmF5ICE9PSB1bmRlZmluZWQgPyBhcnJheS5sZW5ndGggLyB0aGlzLml0ZW1TaXplIDogMDtcclxuXHRcdHRoaXMuYXJyYXkgPSBhcnJheTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RHluYW1pYzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLmR5bmFtaWMgPSB2YWx1ZTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0dGhpcy5uYW1lID0gc291cmNlLm5hbWU7XHJcblx0XHR0aGlzLmFycmF5ID0gbmV3IHNvdXJjZS5hcnJheS5jb25zdHJ1Y3Rvciggc291cmNlLmFycmF5ICk7XHJcblx0XHR0aGlzLml0ZW1TaXplID0gc291cmNlLml0ZW1TaXplO1xyXG5cdFx0dGhpcy5jb3VudCA9IHNvdXJjZS5jb3VudDtcclxuXHRcdHRoaXMubm9ybWFsaXplZCA9IHNvdXJjZS5ub3JtYWxpemVkO1xyXG5cclxuXHRcdHRoaXMuZHluYW1pYyA9IHNvdXJjZS5keW5hbWljO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5QXQ6IGZ1bmN0aW9uICggaW5kZXgxLCBhdHRyaWJ1dGUsIGluZGV4MiApIHtcclxuXHJcblx0XHRpbmRleDEgKj0gdGhpcy5pdGVtU2l6ZTtcclxuXHRcdGluZGV4MiAqPSBhdHRyaWJ1dGUuaXRlbVNpemU7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5pdGVtU2l6ZTsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmFycmF5WyBpbmRleDEgKyBpIF0gPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4MiArIGkgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHlBcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcclxuXHJcblx0XHR0aGlzLmFycmF5LnNldCggYXJyYXkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weUNvbG9yc0FycmF5OiBmdW5jdGlvbiAoIGNvbG9ycyApIHtcclxuXHJcblx0XHR2YXIgYXJyYXkgPSB0aGlzLmFycmF5LCBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNvbG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGNvbG9yID0gY29sb3JzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ0NPT0wuQnVmZmVyQXR0cmlidXRlLmNvcHlDb2xvcnNBcnJheSgpOiBjb2xvciBpcyB1bmRlZmluZWQnLCBpICk7XHJcblx0XHRcdFx0Y29sb3IgPSBuZXcgQ29sb3IoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IGNvbG9yLnI7XHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IGNvbG9yLmc7XHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IGNvbG9yLmI7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5VmVjdG9yMnNBcnJheTogZnVuY3Rpb24gKCB2ZWN0b3JzICkge1xyXG5cclxuXHRcdHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdmVjdG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHZlY3RvciA9IHZlY3RvcnNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggdmVjdG9yID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ0NPT0wuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3Iyc0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWQnLCBpICk7XHJcblx0XHRcdFx0dmVjdG9yID0gbmV3IFZlY3RvcjIoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci54O1xyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHlWZWN0b3Izc0FycmF5OiBmdW5jdGlvbiAoIHZlY3RvcnMgKSB7XHJcblxyXG5cdFx0dmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdmVjdG9yID0gdmVjdG9yc1sgaSBdO1xyXG5cclxuXHRcdFx0aWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5CdWZmZXJBdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoKTogdmVjdG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcclxuXHRcdFx0XHR2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLng7XHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci55O1xyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IuejtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHlWZWN0b3I0c0FycmF5OiBmdW5jdGlvbiAoIHZlY3RvcnMgKSB7XHJcblxyXG5cdFx0dmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdmVjdG9yID0gdmVjdG9yc1sgaSBdO1xyXG5cclxuXHRcdFx0aWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5CdWZmZXJBdHRyaWJ1dGUuY29weVZlY3RvcjRzQXJyYXkoKTogdmVjdG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcclxuXHRcdFx0XHR2ZWN0b3IgPSBuZXcgVmVjdG9yNCgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLng7XHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci55O1xyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IuejtcclxuXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLnc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUsIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHR0aGlzLmFycmF5LnNldCggdmFsdWUsIG9mZnNldCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRYOiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgXTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WDogZnVuY3Rpb24gKCBpbmRleCwgeCApIHtcclxuXHJcblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgXSA9IHg7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldFk6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDEgXTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WTogZnVuY3Rpb24gKCBpbmRleCwgeSApIHtcclxuXHJcblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAxIF0gPSB5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRaOiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAyIF07XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFo6IGZ1bmN0aW9uICggaW5kZXgsIHogKSB7XHJcblxyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMiBdID0gejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0VzogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMyBdO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRXOiBmdW5jdGlvbiAoIGluZGV4LCB3ICkge1xyXG5cclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDMgXSA9IHc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFhZOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5ICkge1xyXG5cclxuXHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XHJcblxyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRYWVo6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHksIHogKSB7XHJcblxyXG5cdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcclxuXHJcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XHJcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XHJcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFhZWlc6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHksIHosIHcgKSB7XHJcblxyXG5cdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcclxuXHJcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XHJcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XHJcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XHJcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDMgXSA9IHc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG9uVXBsb2FkOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xyXG5cclxuXHRcdHRoaXMub25VcGxvYWRDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5hcnJheSwgdGhpcy5pdGVtU2l6ZSApLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxufSApO1xyXG5cclxuLy9cclxuXHJcbmZ1bmN0aW9uIEludDhCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcclxuXHJcblx0QnVmZmVyQXR0cmlidXRlLmNhbGwoIHRoaXMsIG5ldyBJbnQ4QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XHJcblxyXG59XHJcblxyXG5JbnQ4QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKTtcclxuSW50OEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbnQ4QnVmZmVyQXR0cmlidXRlO1xyXG5cclxuXHJcbmZ1bmN0aW9uIFVpbnQ4QnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XHJcblxyXG5cdEJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBuZXcgVWludDhBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcclxuXHJcbn1cclxuXHJcblVpbnQ4QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKTtcclxuVWludDhCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVWludDhCdWZmZXJBdHRyaWJ1dGU7XHJcblxyXG5cclxuZnVuY3Rpb24gVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XHJcblxyXG5cdEJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBuZXcgVWludDhDbGFtcGVkQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XHJcblxyXG59XHJcblxyXG5VaW50OENsYW1wZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSApO1xyXG5VaW50OENsYW1wZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlO1xyXG5cclxuXHJcbmZ1bmN0aW9uIEludDE2QnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XHJcblxyXG5cdEJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBuZXcgSW50MTZBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcclxuXHJcbn1cclxuXHJcbkludDE2QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKTtcclxuSW50MTZCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW50MTZCdWZmZXJBdHRyaWJ1dGU7XHJcblxyXG5cclxuZnVuY3Rpb24gVWludDE2QnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XHJcblxyXG5cdEJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBuZXcgVWludDE2QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XHJcblxyXG59XHJcblxyXG5VaW50MTZCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSApO1xyXG5VaW50MTZCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVWludDE2QnVmZmVyQXR0cmlidXRlO1xyXG5cclxuXHJcbmZ1bmN0aW9uIEludDMyQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XHJcblxyXG5cdEJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBuZXcgSW50MzJBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcclxuXHJcbn1cclxuXHJcbkludDMyQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKTtcclxuSW50MzJCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW50MzJCdWZmZXJBdHRyaWJ1dGU7XHJcblxyXG5cclxuZnVuY3Rpb24gVWludDMyQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XHJcblxyXG5cdEJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBuZXcgVWludDMyQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XHJcblxyXG59XHJcblxyXG5VaW50MzJCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSApO1xyXG5VaW50MzJCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVWludDMyQnVmZmVyQXR0cmlidXRlO1xyXG5cclxuXHJcbmZ1bmN0aW9uIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcclxuXHJcblx0QnVmZmVyQXR0cmlidXRlLmNhbGwoIHRoaXMsIG5ldyBGbG9hdDMyQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XHJcblxyXG59XHJcblxyXG5GbG9hdDMyQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKTtcclxuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGbG9hdDMyQnVmZmVyQXR0cmlidXRlO1xyXG5cclxuXHJcbmZ1bmN0aW9uIEZsb2F0NjRCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcclxuXHJcblx0QnVmZmVyQXR0cmlidXRlLmNhbGwoIHRoaXMsIG5ldyBGbG9hdDY0QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XHJcblxyXG59XHJcblxyXG5GbG9hdDY0QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKTtcclxuRmxvYXQ2NEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGbG9hdDY0QnVmZmVyQXR0cmlidXRlO1xyXG5cclxuLy9cclxuXHJcbmV4cG9ydCB7XHJcblx0RmxvYXQ2NEJ1ZmZlckF0dHJpYnV0ZSxcclxuXHRGbG9hdDMyQnVmZmVyQXR0cmlidXRlLFxyXG5cdFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSxcclxuXHRJbnQzMkJ1ZmZlckF0dHJpYnV0ZSxcclxuXHRVaW50MTZCdWZmZXJBdHRyaWJ1dGUsXHJcblx0SW50MTZCdWZmZXJBdHRyaWJ1dGUsXHJcblx0VWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlLFxyXG5cdFVpbnQ4QnVmZmVyQXR0cmlidXRlLFxyXG5cdEludDhCdWZmZXJBdHRyaWJ1dGUsXHJcblx0QnVmZmVyQXR0cmlidXRlXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjIuanMnO1xyXG5cclxuZnVuY3Rpb24gRGlyZWN0R2VvbWV0cnkoKSB7XHJcblxyXG5cdHRoaXMudmVydGljZXMgPSBbXTtcclxuXHR0aGlzLm5vcm1hbHMgPSBbXTtcclxuXHR0aGlzLmNvbG9ycyA9IFtdO1xyXG5cdHRoaXMudXZzID0gW107XHJcblx0dGhpcy51dnMyID0gW107XHJcblxyXG5cdHRoaXMuZ3JvdXBzID0gW107XHJcblxyXG5cdHRoaXMubW9ycGhUYXJnZXRzID0ge307XHJcblxyXG5cdHRoaXMuc2tpbldlaWdodHMgPSBbXTtcclxuXHR0aGlzLnNraW5JbmRpY2VzID0gW107XHJcblxyXG5cdC8vIHRoaXMubGluZURpc3RhbmNlcyA9IFtdO1xyXG5cclxuXHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcclxuXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcclxuXHJcblx0Ly8gdXBkYXRlIGZsYWdzXHJcblxyXG5cdHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMuZ3JvdXBzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxufVxyXG5cclxuT2JqZWN0LmFzc2lnbiggRGlyZWN0R2VvbWV0cnkucHJvdG90eXBlLCB7XHJcblxyXG5cdGNvbXB1dGVHcm91cHM6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0dmFyIGdyb3VwO1xyXG5cdFx0dmFyIGdyb3VwcyA9IFtdO1xyXG5cdFx0dmFyIG1hdGVyaWFsSW5kZXggPSB1bmRlZmluZWQ7XHJcblxyXG5cdFx0dmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZmFjZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cclxuXHRcdFx0Ly8gbWF0ZXJpYWxzXHJcblxyXG5cdFx0XHRpZiAoIGZhY2UubWF0ZXJpYWxJbmRleCAhPT0gbWF0ZXJpYWxJbmRleCApIHtcclxuXHJcblx0XHRcdFx0bWF0ZXJpYWxJbmRleCA9IGZhY2UubWF0ZXJpYWxJbmRleDtcclxuXHJcblx0XHRcdFx0aWYgKCBncm91cCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdGdyb3VwLmNvdW50ID0gKCBpICogMyApIC0gZ3JvdXAuc3RhcnQ7XHJcblx0XHRcdFx0XHRncm91cHMucHVzaCggZ3JvdXAgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRncm91cCA9IHtcclxuXHRcdFx0XHRcdHN0YXJ0OiBpICogMyxcclxuXHRcdFx0XHRcdG1hdGVyaWFsSW5kZXg6IG1hdGVyaWFsSW5kZXhcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdyb3VwICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRncm91cC5jb3VudCA9ICggaSAqIDMgKSAtIGdyb3VwLnN0YXJ0O1xyXG5cdFx0XHRncm91cHMucHVzaCggZ3JvdXAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5ncm91cHMgPSBncm91cHM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21HZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHR2YXIgZmFjZXMgPSBnZW9tZXRyeS5mYWNlcztcclxuXHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cdFx0dmFyIGZhY2VWZXJ0ZXhVdnMgPSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzO1xyXG5cclxuXHRcdHZhciBoYXNGYWNlVmVydGV4VXYgPSBmYWNlVmVydGV4VXZzWyAwIF0gJiYgZmFjZVZlcnRleFV2c1sgMCBdLmxlbmd0aCA+IDA7XHJcblx0XHR2YXIgaGFzRmFjZVZlcnRleFV2MiA9IGZhY2VWZXJ0ZXhVdnNbIDEgXSAmJiBmYWNlVmVydGV4VXZzWyAxIF0ubGVuZ3RoID4gMDtcclxuXHJcblx0XHQvLyBtb3JwaHNcclxuXHJcblx0XHR2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzO1xyXG5cdFx0dmFyIG1vcnBoVGFyZ2V0c0xlbmd0aCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7XHJcblxyXG5cdFx0dmFyIG1vcnBoVGFyZ2V0c1Bvc2l0aW9uO1xyXG5cclxuXHRcdGlmICggbW9ycGhUYXJnZXRzTGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdG1vcnBoVGFyZ2V0c1Bvc2l0aW9uID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBtb3JwaFRhcmdldHNMZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdG1vcnBoVGFyZ2V0c1Bvc2l0aW9uWyBpIF0gPSB7XHJcblx0XHRcdFx0XHRuYW1lOiBtb3JwaFRhcmdldHNbIGkgXS5uYW1lLFxyXG5cdFx0XHRcdCBcdGRhdGE6IFtdXHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMubW9ycGhUYXJnZXRzLnBvc2l0aW9uID0gbW9ycGhUYXJnZXRzUG9zaXRpb247XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBtb3JwaE5vcm1hbHMgPSBnZW9tZXRyeS5tb3JwaE5vcm1hbHM7XHJcblx0XHR2YXIgbW9ycGhOb3JtYWxzTGVuZ3RoID0gbW9ycGhOb3JtYWxzLmxlbmd0aDtcclxuXHJcblx0XHR2YXIgbW9ycGhUYXJnZXRzTm9ybWFsO1xyXG5cclxuXHRcdGlmICggbW9ycGhOb3JtYWxzTGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdG1vcnBoVGFyZ2V0c05vcm1hbCA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbW9ycGhOb3JtYWxzTGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRtb3JwaFRhcmdldHNOb3JtYWxbIGkgXSA9IHtcclxuXHRcdFx0XHRcdG5hbWU6IG1vcnBoTm9ybWFsc1sgaSBdLm5hbWUsXHJcblx0XHRcdFx0IFx0ZGF0YTogW11cclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldHMubm9ybWFsID0gbW9ycGhUYXJnZXRzTm9ybWFsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBza2luc1xyXG5cclxuXHRcdHZhciBza2luSW5kaWNlcyA9IGdlb21ldHJ5LnNraW5JbmRpY2VzO1xyXG5cdFx0dmFyIHNraW5XZWlnaHRzID0gZ2VvbWV0cnkuc2tpbldlaWdodHM7XHJcblxyXG5cdFx0dmFyIGhhc1NraW5JbmRpY2VzID0gc2tpbkluZGljZXMubGVuZ3RoID09PSB2ZXJ0aWNlcy5sZW5ndGg7XHJcblx0XHR2YXIgaGFzU2tpbldlaWdodHMgPSBza2luV2VpZ2h0cy5sZW5ndGggPT09IHZlcnRpY2VzLmxlbmd0aDtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGlmICggdmVydGljZXMubGVuZ3RoID4gMCAmJiBmYWNlcy5sZW5ndGggPT09IDAgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnQ09PTC5EaXJlY3RHZW9tZXRyeTogRmFjZWxlc3MgZ2VvbWV0cmllcyBhcmUgbm90IHN1cHBvcnRlZC4nICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGZhY2VzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcclxuXHJcblx0XHRcdHRoaXMudmVydGljZXMucHVzaCggdmVydGljZXNbIGZhY2UuYSBdLCB2ZXJ0aWNlc1sgZmFjZS5iIF0sIHZlcnRpY2VzWyBmYWNlLmMgXSApO1xyXG5cclxuXHRcdFx0dmFyIHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XHJcblxyXG5cdFx0XHRpZiAoIHZlcnRleE5vcm1hbHMubGVuZ3RoID09PSAzICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLm5vcm1hbHMucHVzaCggdmVydGV4Tm9ybWFsc1sgMCBdLCB2ZXJ0ZXhOb3JtYWxzWyAxIF0sIHZlcnRleE5vcm1hbHNbIDIgXSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dmFyIG5vcm1hbCA9IGZhY2Uubm9ybWFsO1xyXG5cclxuXHRcdFx0XHR0aGlzLm5vcm1hbHMucHVzaCggbm9ybWFsLCBub3JtYWwsIG5vcm1hbCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHZlcnRleENvbG9ycyA9IGZhY2UudmVydGV4Q29sb3JzO1xyXG5cclxuXHRcdFx0aWYgKCB2ZXJ0ZXhDb2xvcnMubGVuZ3RoID09PSAzICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmNvbG9ycy5wdXNoKCB2ZXJ0ZXhDb2xvcnNbIDAgXSwgdmVydGV4Q29sb3JzWyAxIF0sIHZlcnRleENvbG9yc1sgMiBdICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR2YXIgY29sb3IgPSBmYWNlLmNvbG9yO1xyXG5cclxuXHRcdFx0XHR0aGlzLmNvbG9ycy5wdXNoKCBjb2xvciwgY29sb3IsIGNvbG9yICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0dmFyIHZlcnRleFV2cyA9IGZhY2VWZXJ0ZXhVdnNbIDAgXVsgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIHZlcnRleFV2cyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMudXZzLnB1c2goIHZlcnRleFV2c1sgMCBdLCB2ZXJ0ZXhVdnNbIDEgXSwgdmVydGV4VXZzWyAyIF0gKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdDT09MLkRpcmVjdEdlb21ldHJ5LmZyb21HZW9tZXRyeSgpOiBVbmRlZmluZWQgdmVydGV4VXYgJywgaSApO1xyXG5cclxuXHRcdFx0XHRcdHRoaXMudXZzLnB1c2goIG5ldyBWZWN0b3IyKCksIG5ldyBWZWN0b3IyKCksIG5ldyBWZWN0b3IyKCkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4VXYyID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdmVydGV4VXZzID0gZmFjZVZlcnRleFV2c1sgMSBdWyBpIF07XHJcblxyXG5cdFx0XHRcdGlmICggdmVydGV4VXZzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy51dnMyLnB1c2goIHZlcnRleFV2c1sgMCBdLCB2ZXJ0ZXhVdnNbIDEgXSwgdmVydGV4VXZzWyAyIF0gKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdDT09MLkRpcmVjdEdlb21ldHJ5LmZyb21HZW9tZXRyeSgpOiBVbmRlZmluZWQgdmVydGV4VXYyICcsIGkgKTtcclxuXHJcblx0XHRcdFx0XHR0aGlzLnV2czIucHVzaCggbmV3IFZlY3RvcjIoKSwgbmV3IFZlY3RvcjIoKSwgbmV3IFZlY3RvcjIoKSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBtb3JwaHNcclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IG1vcnBoVGFyZ2V0c0xlbmd0aDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIG1vcnBoVGFyZ2V0ID0gbW9ycGhUYXJnZXRzWyBqIF0udmVydGljZXM7XHJcblxyXG5cdFx0XHRcdG1vcnBoVGFyZ2V0c1Bvc2l0aW9uWyBqIF0uZGF0YS5wdXNoKCBtb3JwaFRhcmdldFsgZmFjZS5hIF0sIG1vcnBoVGFyZ2V0WyBmYWNlLmIgXSwgbW9ycGhUYXJnZXRbIGZhY2UuYyBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBtb3JwaE5vcm1hbHNMZW5ndGg7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBtb3JwaE5vcm1hbCA9IG1vcnBoTm9ybWFsc1sgaiBdLnZlcnRleE5vcm1hbHNbIGkgXTtcclxuXHJcblx0XHRcdFx0bW9ycGhUYXJnZXRzTm9ybWFsWyBqIF0uZGF0YS5wdXNoKCBtb3JwaE5vcm1hbC5hLCBtb3JwaE5vcm1hbC5iLCBtb3JwaE5vcm1hbC5jICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBza2luc1xyXG5cclxuXHRcdFx0aWYgKCBoYXNTa2luSW5kaWNlcyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5za2luSW5kaWNlcy5wdXNoKCBza2luSW5kaWNlc1sgZmFjZS5hIF0sIHNraW5JbmRpY2VzWyBmYWNlLmIgXSwgc2tpbkluZGljZXNbIGZhY2UuYyBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGhhc1NraW5XZWlnaHRzICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnNraW5XZWlnaHRzLnB1c2goIHNraW5XZWlnaHRzWyBmYWNlLmEgXSwgc2tpbldlaWdodHNbIGZhY2UuYiBdLCBza2luV2VpZ2h0c1sgZmFjZS5jIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jb21wdXRlR3JvdXBzKCBnZW9tZXRyeSApO1xyXG5cclxuXHRcdHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlO1xyXG5cdFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlO1xyXG5cdFx0dGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZTtcclxuXHRcdHRoaXMudXZzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnV2c05lZWRVcGRhdGU7XHJcblx0XHR0aGlzLmdyb3Vwc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcblxyXG5cclxuZXhwb3J0IHsgRGlyZWN0R2VvbWV0cnkgfTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gYXJyYXlNaW4oIGFycmF5ICkge1xyXG5cclxuXHRpZiAoIGFycmF5Lmxlbmd0aCA9PT0gMCApIHJldHVybiBJbmZpbml0eTtcclxuXHJcblx0dmFyIG1pbiA9IGFycmF5WyAwIF07XHJcblxyXG5cdGZvciAoIHZhciBpID0gMSwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7ICsrIGkgKSB7XHJcblxyXG5cdFx0aWYgKCBhcnJheVsgaSBdIDwgbWluICkgbWluID0gYXJyYXlbIGkgXTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbWluO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gYXJyYXlNYXgoIGFycmF5ICkge1xyXG5cclxuXHRpZiAoIGFycmF5Lmxlbmd0aCA9PT0gMCApIHJldHVybiAtIEluZmluaXR5O1xyXG5cclxuXHR2YXIgbWF4ID0gYXJyYXlbIDAgXTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAxLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgKysgaSApIHtcclxuXHJcblx0XHRpZiAoIGFycmF5WyBpIF0gPiBtYXggKSBtYXggPSBhcnJheVsgaSBdO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBtYXg7XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBhcnJheU1pbiwgYXJyYXlNYXggfTtcclxuIiwiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XHJcbmltcG9ydCB7IEJveDMgfSBmcm9tICcuLi9tYXRoL0JveDMuanMnO1xyXG5pbXBvcnQgeyBFdmVudERpc3BhdGNoZXIgfSBmcm9tICcuL0V2ZW50RGlzcGF0Y2hlci5qcyc7XHJcbmltcG9ydCB7IEJ1ZmZlckF0dHJpYnV0ZSwgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSwgVWludDE2QnVmZmVyQXR0cmlidXRlLCBVaW50MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XHJcbmltcG9ydCB7IFNwaGVyZSB9IGZyb20gJy4uL21hdGgvU3BoZXJlLmpzJztcclxuaW1wb3J0IHsgRGlyZWN0R2VvbWV0cnkgfSBmcm9tICcuL0RpcmVjdEdlb21ldHJ5LmpzJztcclxuaW1wb3J0IHsgT2JqZWN0M0QgfSBmcm9tICcuL09iamVjdDNELmpzJztcclxuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uL21hdGgvTWF0cml4NC5qcyc7XHJcbmltcG9ydCB7IE1hdHJpeDMgfSBmcm9tICcuLi9tYXRoL01hdHJpeDMuanMnO1xyXG5pbXBvcnQge19NYXRofSBmcm9tICcuLi9tYXRoL01hdGguanMnO1xyXG5pbXBvcnQgeyBhcnJheU1heCB9IGZyb20gJy4vdXRpbHMuanMnO1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxudmFyIGJ1ZmZlckdlb21ldHJ5SWQgPSAxOyAvLyBCdWZmZXJHZW9tZXRyeSB1c2VzIG9kZCBudW1iZXJzIGFzIElkXHJcblxyXG5mdW5jdGlvbiBCdWZmZXJHZW9tZXRyeSgpIHtcclxuXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBidWZmZXJHZW9tZXRyeUlkICs9IDIgfSApO1xyXG5cclxuXHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcblx0dGhpcy5uYW1lID0gJyc7XHJcblx0dGhpcy50eXBlID0gJ0J1ZmZlckdlb21ldHJ5JztcclxuXHJcblx0dGhpcy5pbmRleCA9IG51bGw7XHJcblx0dGhpcy5hdHRyaWJ1dGVzID0ge307XHJcblxyXG5cdHRoaXMubW9ycGhBdHRyaWJ1dGVzID0ge307XHJcblxyXG5cdHRoaXMuZ3JvdXBzID0gW107XHJcblxyXG5cdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xyXG5cdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xyXG5cclxuXHR0aGlzLmRyYXdSYW5nZSA9IHsgc3RhcnQ6IDAsIGNvdW50OiBJbmZpbml0eSB9O1xyXG5cclxuXHR0aGlzLnVzZXJEYXRhID0ge307XHJcblxyXG59XHJcblxyXG5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlICksIHtcclxuXHJcblx0Y29uc3RydWN0b3I6IEJ1ZmZlckdlb21ldHJ5LFxyXG5cclxuXHRpc0J1ZmZlckdlb21ldHJ5OiB0cnVlLFxyXG5cclxuXHRnZXRJbmRleDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmluZGV4O1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRJbmRleDogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGluZGV4ICkgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmluZGV4ID0gbmV3ICggYXJyYXlNYXgoIGluZGV4ICkgPiA2NTUzNSA/IFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSA6IFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSApKCBpbmRleCwgMSApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLmluZGV4ID0gaW5kZXg7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRhZGRBdHRyaWJ1dGU6IGZ1bmN0aW9uICggbmFtZSwgYXR0cmlidXRlICkge1xyXG5cclxuXHRcdGlmICggISAoIGF0dHJpYnV0ZSAmJiBhdHRyaWJ1dGUuaXNCdWZmZXJBdHRyaWJ1dGUgKSAmJiAhICggYXR0cmlidXRlICYmIGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdDT09MLkJ1ZmZlckdlb21ldHJ5OiAuYWRkQXR0cmlidXRlKCkgbm93IGV4cGVjdHMgKCBuYW1lLCBhdHRyaWJ1dGUgKS4nICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRBdHRyaWJ1dGUoIG5hbWUsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGFyZ3VtZW50c1sgMSBdLCBhcmd1bWVudHNbIDIgXSApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbmFtZSA9PT0gJ2luZGV4JyApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ0NPT0wuQnVmZmVyR2VvbWV0cnkuYWRkQXR0cmlidXRlOiBVc2UgLnNldEluZGV4KCkgZm9yIGluZGV4IGF0dHJpYnV0ZS4nICk7XHJcblx0XHRcdHRoaXMuc2V0SW5kZXgoIGF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdID0gYXR0cmlidXRlO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF07XHJcblxyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUF0dHJpYnV0ZTogZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuXHRcdGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkR3JvdXA6IGZ1bmN0aW9uICggc3RhcnQsIGNvdW50LCBtYXRlcmlhbEluZGV4ICkge1xyXG5cclxuXHRcdHRoaXMuZ3JvdXBzLnB1c2goIHtcclxuXHJcblx0XHRcdHN0YXJ0OiBzdGFydCxcclxuXHRcdFx0Y291bnQ6IGNvdW50LFxyXG5cdFx0XHRtYXRlcmlhbEluZGV4OiBtYXRlcmlhbEluZGV4ICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbEluZGV4IDogMFxyXG5cclxuXHRcdH0gKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y2xlYXJHcm91cHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmdyb3VwcyA9IFtdO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXREcmF3UmFuZ2U6IGZ1bmN0aW9uICggc3RhcnQsIGNvdW50ICkge1xyXG5cclxuXHRcdHRoaXMuZHJhd1JhbmdlLnN0YXJ0ID0gc3RhcnQ7XHJcblx0XHR0aGlzLmRyYXdSYW5nZS5jb3VudCA9IGNvdW50O1xyXG5cclxuXHR9LFxyXG5cclxuXHRhcHBseU1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG5cdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cclxuXHRcdGlmICggcG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdG1hdHJpeC5hcHBseVRvQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiApO1xyXG5cdFx0XHRwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBub3JtYWwgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsO1xyXG5cclxuXHRcdGlmICggbm9ybWFsICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR2YXIgbm9ybWFsTWF0cml4ID0gbmV3IE1hdHJpeDMoKS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xyXG5cclxuXHRcdFx0bm9ybWFsTWF0cml4LmFwcGx5VG9CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbCApO1xyXG5cdFx0XHRub3JtYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0cm90YXRlWDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeC1heGlzXHJcblxyXG5cdFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWCggYW5nbGUgKSB7XHJcblxyXG5cdFx0XHRtMS5tYWtlUm90YXRpb25YKCBhbmdsZSApO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0cm90YXRlWTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeS1heGlzXHJcblxyXG5cdFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWSggYW5nbGUgKSB7XHJcblxyXG5cdFx0XHRtMS5tYWtlUm90YXRpb25ZKCBhbmdsZSApO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0cm90YXRlWjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgei1heGlzXHJcblxyXG5cdFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWiggYW5nbGUgKSB7XHJcblxyXG5cdFx0XHRtMS5tYWtlUm90YXRpb25aKCBhbmdsZSApO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gdHJhbnNsYXRlIGdlb21ldHJ5XHJcblxyXG5cdFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gdHJhbnNsYXRlKCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdFx0bTEubWFrZVRyYW5zbGF0aW9uKCB4LCB5LCB6ICk7XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRzY2FsZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHNjYWxlIGdlb21ldHJ5XHJcblxyXG5cdFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gc2NhbGUoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0XHRtMS5tYWtlU2NhbGUoIHgsIHksIHogKTtcclxuXHJcblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGxvb2tBdDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBvYmogPSBuZXcgT2JqZWN0M0QoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gbG9va0F0KCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0XHRvYmoubG9va0F0KCB2ZWN0b3IgKTtcclxuXHJcblx0XHRcdG9iai51cGRhdGVNYXRyaXgoKTtcclxuXHJcblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG9iai5tYXRyaXggKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGNlbnRlcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBvZmZzZXQgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBjZW50ZXIoKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xyXG5cclxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveC5nZXRDZW50ZXIoIG9mZnNldCApLm5lZ2F0ZSgpO1xyXG5cclxuXHRcdFx0dGhpcy50cmFuc2xhdGUoIG9mZnNldC54LCBvZmZzZXQueSwgb2Zmc2V0LnogKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0c2V0RnJvbU9iamVjdDogZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0Ly8gY29uc29sZS5sb2coICdDT09MLkJ1ZmZlckdlb21ldHJ5LnNldEZyb21PYmplY3QoKS4gQ29udmVydGluZycsIG9iamVjdCwgdGhpcyApO1xyXG5cclxuXHRcdHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcclxuXHJcblx0XHRpZiAoIG9iamVjdC5pc1BvaW50cyB8fCBvYmplY3QuaXNMaW5lICkge1xyXG5cclxuXHRcdFx0dmFyIHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggKiAzLCAzICk7XHJcblx0XHRcdHZhciBjb2xvcnMgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggZ2VvbWV0cnkuY29sb3JzLmxlbmd0aCAqIDMsIDMgKTtcclxuXHJcblx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbnMuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5LnZlcnRpY2VzICkgKTtcclxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIGNvbG9ycy5jb3B5Q29sb3JzQXJyYXkoIGdlb21ldHJ5LmNvbG9ycyApICk7XHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMgJiYgZ2VvbWV0cnkubGluZURpc3RhbmNlcy5sZW5ndGggPT09IGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGxpbmVEaXN0YW5jZXMgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggZ2VvbWV0cnkubGluZURpc3RhbmNlcy5sZW5ndGgsIDEgKTtcclxuXHJcblx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdsaW5lRGlzdGFuY2UnLCBsaW5lRGlzdGFuY2VzLmNvcHlBcnJheSggZ2VvbWV0cnkubGluZURpc3RhbmNlcyApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBnZW9tZXRyeS5ib3VuZGluZ0JveC5jbG9uZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc01lc2ggKSB7XHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJ5ICYmIGdlb21ldHJ5LmlzR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuZnJvbUdlb21ldHJ5KCBnZW9tZXRyeSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbVBvaW50czogZnVuY3Rpb24gKCBwb2ludHMgKSB7XHJcblxyXG5cdFx0dmFyIHBvc2l0aW9uID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgcG9pbnQgPSBwb2ludHNbIGkgXTtcclxuXHRcdFx0cG9zaXRpb24ucHVzaCggcG9pbnQueCwgcG9pbnQueSwgcG9pbnQueiB8fCAwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIDMgKSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR1cGRhdGVGcm9tT2JqZWN0OiBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XHJcblxyXG5cdFx0aWYgKCBvYmplY3QuaXNNZXNoICkge1xyXG5cclxuXHRcdFx0dmFyIGRpcmVjdCA9IGdlb21ldHJ5Ll9fZGlyZWN0R2VvbWV0cnk7XHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmVsZW1lbnRzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0ZGlyZWN0ID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRcdGdlb21ldHJ5LmVsZW1lbnRzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBkaXJlY3QgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJvbUdlb21ldHJ5KCBnZW9tZXRyeSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZGlyZWN0LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZTtcclxuXHRcdFx0ZGlyZWN0Lm5vcm1hbHNOZWVkVXBkYXRlID0gZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGU7XHJcblx0XHRcdGRpcmVjdC5jb2xvcnNOZWVkVXBkYXRlID0gZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZTtcclxuXHRcdFx0ZGlyZWN0LnV2c05lZWRVcGRhdGUgPSBnZW9tZXRyeS51dnNOZWVkVXBkYXRlO1xyXG5cdFx0XHRkaXJlY3QuZ3JvdXBzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5Lmdyb3Vwc05lZWRVcGRhdGU7XHJcblxyXG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHRcdFx0Z2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHRcdFx0Z2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHRnZW9tZXRyeS51dnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0XHRcdGdlb21ldHJ5Lmdyb3Vwc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdGdlb21ldHJ5ID0gZGlyZWN0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYXR0cmlidXRlO1xyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0YXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0YXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcyApO1xyXG5cdFx0XHRcdGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWw7XHJcblxyXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRhdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5Lm5vcm1hbHMgKTtcclxuXHRcdFx0XHRhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Z2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0YXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLmNvbG9yO1xyXG5cclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0YXR0cmlidXRlLmNvcHlDb2xvcnNBcnJheSggZ2VvbWV0cnkuY29sb3JzICk7XHJcblx0XHRcdFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS51dnNOZWVkVXBkYXRlICkge1xyXG5cclxuXHRcdFx0YXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLnV2O1xyXG5cclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0YXR0cmlidXRlLmNvcHlWZWN0b3Iyc0FycmF5KCBnZW9tZXRyeS51dnMgKTtcclxuXHRcdFx0XHRhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Z2VvbWV0cnkudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlICkge1xyXG5cclxuXHRcdFx0YXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLmxpbmVEaXN0YW5jZTtcclxuXHJcblx0XHRcdGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGF0dHJpYnV0ZS5jb3B5QXJyYXkoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMgKTtcclxuXHRcdFx0XHRhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Z2VvbWV0cnkubGluZURpc3RhbmNlc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlICkge1xyXG5cclxuXHRcdFx0Z2VvbWV0cnkuY29tcHV0ZUdyb3Vwcyggb2JqZWN0Lmdlb21ldHJ5ICk7XHJcblx0XHRcdHRoaXMuZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xyXG5cclxuXHRcdFx0Z2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZnJvbUdlb21ldHJ5OiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xyXG5cclxuXHRcdGdlb21ldHJ5Ll9fZGlyZWN0R2VvbWV0cnkgPSBuZXcgRGlyZWN0R2VvbWV0cnkoKS5mcm9tR2VvbWV0cnkoIGdlb21ldHJ5ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZnJvbURpcmVjdEdlb21ldHJ5KCBnZW9tZXRyeS5fX2RpcmVjdEdlb21ldHJ5ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21EaXJlY3RHZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHR2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICogMyApO1xyXG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcyApICk7XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5ub3JtYWxzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHR2YXIgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5Lm5vcm1hbHMubGVuZ3RoICogMyApO1xyXG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKS5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkubm9ybWFscyApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkuY29sb3JzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHR2YXIgY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkuY29sb3JzLmxlbmd0aCAqIDMgKTtcclxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApLmNvcHlDb2xvcnNBcnJheSggZ2VvbWV0cnkuY29sb3JzICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS51dnMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdHZhciB1dnMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS51dnMubGVuZ3RoICogMiApO1xyXG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkuY29weVZlY3RvcjJzQXJyYXkoIGdlb21ldHJ5LnV2cyApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkudXZzMi5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0dmFyIHV2czIgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS51dnMyLmxlbmd0aCAqIDIgKTtcclxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1djInLCBuZXcgQnVmZmVyQXR0cmlidXRlKCB1dnMyLCAyICkuY29weVZlY3RvcjJzQXJyYXkoIGdlb21ldHJ5LnV2czIgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBncm91cHNcclxuXHJcblx0XHR0aGlzLmdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcclxuXHJcblx0XHQvLyBtb3JwaHNcclxuXHJcblx0XHRmb3IgKCB2YXIgbmFtZSBpbiBnZW9tZXRyeS5tb3JwaFRhcmdldHMgKSB7XHJcblxyXG5cdFx0XHR2YXIgYXJyYXkgPSBbXTtcclxuXHRcdFx0dmFyIG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgbmFtZSBdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBtb3JwaFRhcmdldCA9IG1vcnBoVGFyZ2V0c1sgaSBdO1xyXG5cclxuXHRcdFx0XHR2YXIgYXR0cmlidXRlID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG1vcnBoVGFyZ2V0LmRhdGEubGVuZ3RoICogMywgMyApO1xyXG5cdFx0XHRcdGF0dHJpYnV0ZS5uYW1lID0gbW9ycGhUYXJnZXQubmFtZTtcclxuXHJcblx0XHRcdFx0YXJyYXkucHVzaCggYXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCBtb3JwaFRhcmdldC5kYXRhICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMubW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF0gPSBhcnJheTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2tpbm5pbmdcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHR2YXIgc2tpbkluZGljZXMgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoICogNCwgNCApO1xyXG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3NraW5JbmRleCcsIHNraW5JbmRpY2VzLmNvcHlWZWN0b3I0c0FycmF5KCBnZW9tZXRyeS5za2luSW5kaWNlcyApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdHZhciBza2luV2VpZ2h0cyA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBnZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggKiA0LCA0ICk7XHJcblx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnc2tpbldlaWdodCcsIHNraW5XZWlnaHRzLmNvcHlWZWN0b3I0c0FycmF5KCBnZW9tZXRyeS5za2luV2VpZ2h0cyApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94LmNsb25lKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wdXRlQm91bmRpbmdCb3g6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gbmV3IEJveDMoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cclxuXHRcdGlmICggcG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHRoaXMuYm91bmRpbmdCb3guc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24gKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveC5tYWtlRW1wdHkoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueCApIHx8IGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi55ICkgfHwgaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnogKSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdDT09MLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveDogQ29tcHV0ZWQgbWluL21heCBoYXZlIE5hTiB2YWx1ZXMuIFRoZSBcInBvc2l0aW9uXCIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJywgdGhpcyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Y29tcHV0ZUJvdW5kaW5nU3BoZXJlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGJveCA9IG5ldyBCb3gzKCk7XHJcblx0XHR2YXIgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCkge1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cclxuXHRcdFx0aWYgKCBwb3NpdGlvbiApIHtcclxuXHJcblx0XHRcdFx0dmFyIGNlbnRlciA9IHRoaXMuYm91bmRpbmdTcGhlcmUuY2VudGVyO1xyXG5cclxuXHRcdFx0XHRib3guc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24gKTtcclxuXHRcdFx0XHRib3guZ2V0Q2VudGVyKCBjZW50ZXIgKTtcclxuXHJcblx0XHRcdFx0Ly8gaG9waW5nIHRvIGZpbmQgYSBib3VuZGluZ1NwaGVyZSB3aXRoIGEgcmFkaXVzIHNtYWxsZXIgdGhhbiB0aGVcclxuXHRcdFx0XHQvLyBib3VuZGluZ1NwaGVyZSBvZiB0aGUgYm91bmRpbmdCb3g6IHNxcnQoMykgc21hbGxlciBpbiB0aGUgYmVzdCBjYXNlXHJcblxyXG5cdFx0XHRcdHZhciBtYXhSYWRpdXNTcSA9IDA7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb3NpdGlvbi5jb3VudDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZlY3Rvci54ID0gcG9zaXRpb24uZ2V0WCggaSApO1xyXG5cdFx0XHRcdFx0dmVjdG9yLnkgPSBwb3NpdGlvbi5nZXRZKCBpICk7XHJcblx0XHRcdFx0XHR2ZWN0b3IueiA9IHBvc2l0aW9uLmdldFooIGkgKTtcclxuXHRcdFx0XHRcdG1heFJhZGl1c1NxID0gTWF0aC5tYXgoIG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHZlY3RvciApICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgPSBNYXRoLnNxcnQoIG1heFJhZGl1c1NxICk7XHJcblxyXG5cdFx0XHRcdGlmICggaXNOYU4oIHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ0NPT0wuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk6IENvbXB1dGVkIHJhZGl1cyBpcyBOYU4uIFRoZSBcInBvc2l0aW9uXCIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJywgdGhpcyApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRjb21wdXRlRmFjZU5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wdXRlVmVydGV4Tm9ybWFsczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XHJcblx0XHR2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcclxuXHJcblx0XHRpZiAoIGF0dHJpYnV0ZXMucG9zaXRpb24gKSB7XHJcblxyXG5cdFx0XHR2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcclxuXHJcblx0XHRcdGlmICggYXR0cmlidXRlcy5ub3JtYWwgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBwb3NpdGlvbnMubGVuZ3RoICksIDMgKSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gcmVzZXQgZXhpc3Rpbmcgbm9ybWFscyB0byB6ZXJvXHJcblxyXG5cdFx0XHRcdHZhciBhcnJheSA9IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gYXJyYXkubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0YXJyYXlbIGkgXSA9IDA7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBub3JtYWxzID0gYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XHJcblxyXG5cdFx0XHR2YXIgdkEsIHZCLCB2QztcclxuXHRcdFx0dmFyIHBBID0gbmV3IFZlY3RvcjMoKSwgcEIgPSBuZXcgVmVjdG9yMygpLCBwQyA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHZhciBjYiA9IG5ldyBWZWN0b3IzKCksIGFiID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdC8vIGluZGV4ZWQgZWxlbWVudHNcclxuXHJcblx0XHRcdGlmICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRcdHZhciBpbmRpY2VzID0gaW5kZXguYXJyYXk7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBpbmRleC5jb3VudDsgaSA8IGlsOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0dkEgPSBpbmRpY2VzWyBpICsgMCBdICogMztcclxuXHRcdFx0XHRcdHZCID0gaW5kaWNlc1sgaSArIDEgXSAqIDM7XHJcblx0XHRcdFx0XHR2QyA9IGluZGljZXNbIGkgKyAyIF0gKiAzO1xyXG5cclxuXHRcdFx0XHRcdHBBLmZyb21BcnJheSggcG9zaXRpb25zLCB2QSApO1xyXG5cdFx0XHRcdFx0cEIuZnJvbUFycmF5KCBwb3NpdGlvbnMsIHZCICk7XHJcblx0XHRcdFx0XHRwQy5mcm9tQXJyYXkoIHBvc2l0aW9ucywgdkMgKTtcclxuXHJcblx0XHRcdFx0XHRjYi5zdWJWZWN0b3JzKCBwQywgcEIgKTtcclxuXHRcdFx0XHRcdGFiLnN1YlZlY3RvcnMoIHBBLCBwQiApO1xyXG5cdFx0XHRcdFx0Y2IuY3Jvc3MoIGFiICk7XHJcblxyXG5cdFx0XHRcdFx0bm9ybWFsc1sgdkEgXSArPSBjYi54O1xyXG5cdFx0XHRcdFx0bm9ybWFsc1sgdkEgKyAxIF0gKz0gY2IueTtcclxuXHRcdFx0XHRcdG5vcm1hbHNbIHZBICsgMiBdICs9IGNiLno7XHJcblxyXG5cdFx0XHRcdFx0bm9ybWFsc1sgdkIgXSArPSBjYi54O1xyXG5cdFx0XHRcdFx0bm9ybWFsc1sgdkIgKyAxIF0gKz0gY2IueTtcclxuXHRcdFx0XHRcdG5vcm1hbHNbIHZCICsgMiBdICs9IGNiLno7XHJcblxyXG5cdFx0XHRcdFx0bm9ybWFsc1sgdkMgXSArPSBjYi54O1xyXG5cdFx0XHRcdFx0bm9ybWFsc1sgdkMgKyAxIF0gKz0gY2IueTtcclxuXHRcdFx0XHRcdG5vcm1hbHNbIHZDICsgMiBdICs9IGNiLno7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIG5vbi1pbmRleGVkIGVsZW1lbnRzICh1bmNvbm5lY3RlZCB0cmlhbmdsZSBzb3VwKVxyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDkgKSB7XHJcblxyXG5cdFx0XHRcdFx0cEEuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKTtcclxuXHRcdFx0XHRcdHBCLmZyb21BcnJheSggcG9zaXRpb25zLCBpICsgMyApO1xyXG5cdFx0XHRcdFx0cEMuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKyA2ICk7XHJcblxyXG5cdFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggcEMsIHBCICk7XHJcblx0XHRcdFx0XHRhYi5zdWJWZWN0b3JzKCBwQSwgcEIgKTtcclxuXHRcdFx0XHRcdGNiLmNyb3NzKCBhYiApO1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgXSA9IGNiLng7XHJcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgMSBdID0gY2IueTtcclxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyAyIF0gPSBjYi56O1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyAzIF0gPSBjYi54O1xyXG5cdFx0XHRcdFx0bm9ybWFsc1sgaSArIDQgXSA9IGNiLnk7XHJcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgNSBdID0gY2IuejtcclxuXHJcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgNiBdID0gY2IueDtcclxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyA3IF0gPSBjYi55O1xyXG5cdFx0XHRcdFx0bm9ybWFsc1sgaSArIDggXSA9IGNiLno7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMubm9ybWFsaXplTm9ybWFscygpO1xyXG5cclxuXHRcdFx0YXR0cmlidXRlcy5ub3JtYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0bWVyZ2U6IGZ1bmN0aW9uICggZ2VvbWV0cnksIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoICEgKCBnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICkgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnQ09PTC5CdWZmZXJHZW9tZXRyeS5tZXJnZSgpOiBnZW9tZXRyeSBub3QgYW4gaW5zdGFuY2Ugb2YgQ09PTC5CdWZmZXJHZW9tZXRyeS4nLCBnZW9tZXRyeSApO1xyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRvZmZzZXQgPSAwO1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKFxyXG5cdFx0XHRcdCdDT09MLkJ1ZmZlckdlb21ldHJ5Lm1lcmdlKCk6IE92ZXJ3cml0aW5nIG9yaWdpbmFsIGdlb21ldHJ5LCBzdGFydGluZyBhdCBvZmZzZXQ9MC4gJ1xyXG5cdFx0XHRcdCsgJ1VzZSBCdWZmZXJHZW9tZXRyeVV0aWxzLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZvciBsb3NzbGVzcyBtZXJnZS4nXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xyXG5cclxuXHRcdGZvciAoIHZhciBrZXkgaW4gYXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnkuYXR0cmlidXRlc1sga2V5IF0gPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0dmFyIGF0dHJpYnV0ZTEgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcclxuXHRcdFx0dmFyIGF0dHJpYnV0ZUFycmF5MSA9IGF0dHJpYnV0ZTEuYXJyYXk7XHJcblxyXG5cdFx0XHR2YXIgYXR0cmlidXRlMiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbIGtleSBdO1xyXG5cdFx0XHR2YXIgYXR0cmlidXRlQXJyYXkyID0gYXR0cmlidXRlMi5hcnJheTtcclxuXHJcblx0XHRcdHZhciBhdHRyaWJ1dGVTaXplID0gYXR0cmlidXRlMi5pdGVtU2l6ZTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaiA9IGF0dHJpYnV0ZVNpemUgKiBvZmZzZXQ7IGkgPCBhdHRyaWJ1dGVBcnJheTIubGVuZ3RoOyBpICsrLCBqICsrICkge1xyXG5cclxuXHRcdFx0XHRhdHRyaWJ1dGVBcnJheTFbIGogXSA9IGF0dHJpYnV0ZUFycmF5MlsgaSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bm9ybWFsaXplTm9ybWFsczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBub3JtYWxpemVOb3JtYWxzKCkge1xyXG5cclxuXHRcdFx0dmFyIG5vcm1hbHMgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG5vcm1hbHMuY291bnQ7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmVjdG9yLnggPSBub3JtYWxzLmdldFgoIGkgKTtcclxuXHRcdFx0XHR2ZWN0b3IueSA9IG5vcm1hbHMuZ2V0WSggaSApO1xyXG5cdFx0XHRcdHZlY3Rvci56ID0gbm9ybWFscy5nZXRaKCBpICk7XHJcblxyXG5cdFx0XHRcdHZlY3Rvci5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdFx0bm9ybWFscy5zZXRYWVooIGksIHZlY3Rvci54LCB2ZWN0b3IueSwgdmVjdG9yLnogKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHRvTm9uSW5kZXhlZDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICggdGhpcy5pbmRleCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ0NPT0wuQnVmZmVyR2VvbWV0cnkudG9Ob25JbmRleGVkKCk6IEdlb21ldHJ5IGlzIGFscmVhZHkgbm9uLWluZGV4ZWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5MiA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xyXG5cclxuXHRcdHZhciBpbmRpY2VzID0gdGhpcy5pbmRleC5hcnJheTtcclxuXHRcdHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xyXG5cclxuXHRcdGZvciAoIHZhciBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHR2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1sgbmFtZSBdO1xyXG5cclxuXHRcdFx0dmFyIGFycmF5ID0gYXR0cmlidXRlLmFycmF5O1xyXG5cdFx0XHR2YXIgaXRlbVNpemUgPSBhdHRyaWJ1dGUuaXRlbVNpemU7XHJcblxyXG5cdFx0XHR2YXIgYXJyYXkyID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKCBpbmRpY2VzLmxlbmd0aCAqIGl0ZW1TaXplICk7XHJcblxyXG5cdFx0XHR2YXIgaW5kZXggPSAwLCBpbmRleDIgPSAwO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRpbmRleCA9IGluZGljZXNbIGkgXSAqIGl0ZW1TaXplO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBpdGVtU2l6ZTsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRhcnJheTJbIGluZGV4MiArKyBdID0gYXJyYXlbIGluZGV4ICsrIF07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGdlb21ldHJ5Mi5hZGRBdHRyaWJ1dGUoIG5hbWUsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGFycmF5MiwgaXRlbVNpemUgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZ3JvdXBzID0gdGhpcy5ncm91cHM7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgZ3JvdXAgPSBncm91cHNbIGkgXTtcclxuXHRcdFx0Z2VvbWV0cnkyLmFkZEdyb3VwKCBncm91cC5zdGFydCwgZ3JvdXAuY291bnQsIGdyb3VwLm1hdGVyaWFsSW5kZXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGdlb21ldHJ5MjtcclxuXHJcblx0fSxcclxuXHJcblx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdG1ldGFkYXRhOiB7XHJcblx0XHRcdFx0dmVyc2lvbjogNC41LFxyXG5cdFx0XHRcdHR5cGU6ICdCdWZmZXJHZW9tZXRyeScsXHJcblx0XHRcdFx0Z2VuZXJhdG9yOiAnQnVmZmVyR2VvbWV0cnkudG9KU09OJ1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIHN0YW5kYXJkIEJ1ZmZlckdlb21ldHJ5IHNlcmlhbGl6YXRpb25cclxuXHJcblx0XHRkYXRhLnV1aWQgPSB0aGlzLnV1aWQ7XHJcblx0XHRkYXRhLnR5cGUgPSB0aGlzLnR5cGU7XHJcblx0XHRpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBkYXRhLm5hbWUgPSB0aGlzLm5hbWU7XHJcblx0XHRpZiAoIE9iamVjdC5rZXlzKCB0aGlzLnVzZXJEYXRhICkubGVuZ3RoID4gMCApIGRhdGEudXNlckRhdGEgPSB0aGlzLnVzZXJEYXRhO1xyXG5cclxuXHRcdGlmICggdGhpcy5wYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcclxuXHJcblx0XHRcdGZvciAoIHZhciBrZXkgaW4gcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBwYXJhbWV0ZXJzWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkgZGF0YVsga2V5IF0gPSBwYXJhbWV0ZXJzWyBrZXkgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRkYXRhLmRhdGEgPSB7IGF0dHJpYnV0ZXM6IHt9IH07XHJcblxyXG5cdFx0dmFyIGluZGV4ID0gdGhpcy5pbmRleDtcclxuXHJcblx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGluZGV4LmFycmF5ICk7XHJcblxyXG5cdFx0XHRkYXRhLmRhdGEuaW5kZXggPSB7XHJcblx0XHRcdFx0dHlwZTogaW5kZXguYXJyYXkuY29uc3RydWN0b3IubmFtZSxcclxuXHRcdFx0XHRhcnJheTogYXJyYXlcclxuXHRcdFx0fTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0Zm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0dmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xyXG5cclxuXHRcdFx0dmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGF0dHJpYnV0ZS5hcnJheSApO1xyXG5cclxuXHRcdFx0ZGF0YS5kYXRhLmF0dHJpYnV0ZXNbIGtleSBdID0ge1xyXG5cdFx0XHRcdGl0ZW1TaXplOiBhdHRyaWJ1dGUuaXRlbVNpemUsXHJcblx0XHRcdFx0dHlwZTogYXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXHJcblx0XHRcdFx0YXJyYXk6IGFycmF5LFxyXG5cdFx0XHRcdG5vcm1hbGl6ZWQ6IGF0dHJpYnV0ZS5ub3JtYWxpemVkXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBncm91cHMgPSB0aGlzLmdyb3VwcztcclxuXHJcblx0XHRpZiAoIGdyb3Vwcy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0ZGF0YS5kYXRhLmdyb3VwcyA9IEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCBncm91cHMgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYm91bmRpbmdTcGhlcmUgPSB0aGlzLmJvdW5kaW5nU3BoZXJlO1xyXG5cclxuXHRcdGlmICggYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRkYXRhLmRhdGEuYm91bmRpbmdTcGhlcmUgPSB7XHJcblx0XHRcdFx0Y2VudGVyOiBib3VuZGluZ1NwaGVyZS5jZW50ZXIudG9BcnJheSgpLFxyXG5cdFx0XHRcdHJhZGl1czogYm91bmRpbmdTcGhlcmUucmFkaXVzXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8qXHJcblx0XHQgLy8gSGFuZGxlIHByaW1pdGl2ZXNcclxuXHJcblx0XHQgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XHJcblxyXG5cdFx0IGlmICggcGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdCB2YXIgdmFsdWVzID0gW107XHJcblxyXG5cdFx0IGZvciAoIHZhciBrZXkgaW4gcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHQgdmFsdWVzLnB1c2goIHBhcmFtZXRlcnNbIGtleSBdICk7XHJcblxyXG5cdFx0IH1cclxuXHJcblx0XHQgdmFyIGdlb21ldHJ5ID0gT2JqZWN0LmNyZWF0ZSggdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgKTtcclxuXHRcdCB0aGlzLmNvbnN0cnVjdG9yLmFwcGx5KCBnZW9tZXRyeSwgdmFsdWVzICk7XHJcblx0XHQgcmV0dXJuIGdlb21ldHJ5O1xyXG5cclxuXHRcdCB9XHJcblxyXG5cdFx0IHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHRcdCAqL1xyXG5cclxuXHRcdHJldHVybiBuZXcgQnVmZmVyR2VvbWV0cnkoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdHZhciBuYW1lLCBpLCBsO1xyXG5cclxuXHRcdC8vIHJlc2V0XHJcblxyXG5cdFx0dGhpcy5pbmRleCA9IG51bGw7XHJcblx0XHR0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcclxuXHRcdHRoaXMubW9ycGhBdHRyaWJ1dGVzID0ge307XHJcblx0XHR0aGlzLmdyb3VwcyA9IFtdO1xyXG5cdFx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XHJcblx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcclxuXHJcblx0XHQvLyBuYW1lXHJcblxyXG5cdFx0dGhpcy5uYW1lID0gc291cmNlLm5hbWU7XHJcblxyXG5cdFx0Ly8gaW5kZXhcclxuXHJcblx0XHR2YXIgaW5kZXggPSBzb3VyY2UuaW5kZXg7XHJcblxyXG5cdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuc2V0SW5kZXgoIGluZGV4LmNsb25lKCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYXR0cmlidXRlc1xyXG5cclxuXHRcdHZhciBhdHRyaWJ1dGVzID0gc291cmNlLmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0Zm9yICggbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0dmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIG5hbWUgXTtcclxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoIG5hbWUsIGF0dHJpYnV0ZS5jbG9uZSgpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG1vcnBoIGF0dHJpYnV0ZXNcclxuXHJcblx0XHR2YXIgbW9ycGhBdHRyaWJ1dGVzID0gc291cmNlLm1vcnBoQXR0cmlidXRlcztcclxuXHJcblx0XHRmb3IgKCBuYW1lIGluIG1vcnBoQXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdHZhciBhcnJheSA9IFtdO1xyXG5cdFx0XHR2YXIgbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXTsgLy8gbW9ycGhBdHRyaWJ1dGU6IGFycmF5IG9mIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGVzXHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IG1vcnBoQXR0cmlidXRlLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGFycmF5LnB1c2goIG1vcnBoQXR0cmlidXRlWyBpIF0uY2xvbmUoKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5tb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXSA9IGFycmF5O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBncm91cHNcclxuXHJcblx0XHR2YXIgZ3JvdXBzID0gc291cmNlLmdyb3VwcztcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGdyb3VwID0gZ3JvdXBzWyBpIF07XHJcblx0XHRcdHRoaXMuYWRkR3JvdXAoIGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCwgZ3JvdXAubWF0ZXJpYWxJbmRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBib3VuZGluZyBib3hcclxuXHJcblx0XHR2YXIgYm91bmRpbmdCb3ggPSBzb3VyY2UuYm91bmRpbmdCb3g7XHJcblxyXG5cdFx0aWYgKCBib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBib3VuZGluZ0JveC5jbG9uZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBib3VuZGluZyBzcGhlcmVcclxuXHJcblx0XHR2YXIgYm91bmRpbmdTcGhlcmUgPSBzb3VyY2UuYm91bmRpbmdTcGhlcmU7XHJcblxyXG5cdFx0aWYgKCBib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBkcmF3IHJhbmdlXHJcblxyXG5cdFx0dGhpcy5kcmF3UmFuZ2Uuc3RhcnQgPSBzb3VyY2UuZHJhd1JhbmdlLnN0YXJ0O1xyXG5cdFx0dGhpcy5kcmF3UmFuZ2UuY291bnQgPSBzb3VyY2UuZHJhd1JhbmdlLmNvdW50O1xyXG5cclxuXHRcdC8vIHVzZXIgZGF0YVxyXG5cclxuXHRcdHRoaXMudXNlckRhdGEgPSBzb3VyY2UudXNlckRhdGE7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcclxuXHJcblx0fVxyXG5cclxufSApO1xyXG5cclxuXHJcbmV4cG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH07XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xyXG4gKiBQb3J0IGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9lYXJjdXQgKHYyLjEuMilcclxuICovXHJcblxyXG52YXIgRWFyY3V0ID0ge1xyXG5cclxuXHR0cmlhbmd1bGF0ZTogZnVuY3Rpb24gKCBkYXRhLCBob2xlSW5kaWNlcywgZGltICkge1xyXG5cclxuXHRcdGRpbSA9IGRpbSB8fCAyO1xyXG5cclxuXHRcdHZhciBoYXNIb2xlcyA9IGhvbGVJbmRpY2VzICYmIGhvbGVJbmRpY2VzLmxlbmd0aCxcclxuXHRcdFx0b3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWyAwIF0gKiBkaW0gOiBkYXRhLmxlbmd0aCxcclxuXHRcdFx0b3V0ZXJOb2RlID0gbGlua2VkTGlzdCggZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSwgdHJ1ZSApLFxyXG5cdFx0XHR0cmlhbmdsZXMgPSBbXTtcclxuXHJcblx0XHRpZiAoICEgb3V0ZXJOb2RlICkgcmV0dXJuIHRyaWFuZ2xlcztcclxuXHJcblx0XHR2YXIgbWluWCwgbWluWSwgbWF4WCwgbWF4WSwgeCwgeSwgaW52U2l6ZTtcclxuXHJcblx0XHRpZiAoIGhhc0hvbGVzICkgb3V0ZXJOb2RlID0gZWxpbWluYXRlSG9sZXMoIGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSApO1xyXG5cclxuXHRcdC8vIGlmIHRoZSBzaGFwZSBpcyBub3QgdG9vIHNpbXBsZSwgd2UnbGwgdXNlIHotb3JkZXIgY3VydmUgaGFzaCBsYXRlcjsgY2FsY3VsYXRlIHBvbHlnb24gYmJveFxyXG5cclxuXHRcdGlmICggZGF0YS5sZW5ndGggPiA4MCAqIGRpbSApIHtcclxuXHJcblx0XHRcdG1pblggPSBtYXhYID0gZGF0YVsgMCBdO1xyXG5cdFx0XHRtaW5ZID0gbWF4WSA9IGRhdGFbIDEgXTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gZGltOyBpIDwgb3V0ZXJMZW47IGkgKz0gZGltICkge1xyXG5cclxuXHRcdFx0XHR4ID0gZGF0YVsgaSBdO1xyXG5cdFx0XHRcdHkgPSBkYXRhWyBpICsgMSBdO1xyXG5cdFx0XHRcdGlmICggeCA8IG1pblggKSBtaW5YID0geDtcclxuXHRcdFx0XHRpZiAoIHkgPCBtaW5ZICkgbWluWSA9IHk7XHJcblx0XHRcdFx0aWYgKCB4ID4gbWF4WCApIG1heFggPSB4O1xyXG5cdFx0XHRcdGlmICggeSA+IG1heFkgKSBtYXhZID0geTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIG1pblgsIG1pblkgYW5kIGludlNpemUgYXJlIGxhdGVyIHVzZWQgdG8gdHJhbnNmb3JtIGNvb3JkcyBpbnRvIGludGVnZXJzIGZvciB6LW9yZGVyIGNhbGN1bGF0aW9uXHJcblxyXG5cdFx0XHRpbnZTaXplID0gTWF0aC5tYXgoIG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSApO1xyXG5cdFx0XHRpbnZTaXplID0gaW52U2l6ZSAhPT0gMCA/IDEgLyBpbnZTaXplIDogMDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZWFyY3V0TGlua2VkKCBvdXRlck5vZGUsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplICk7XHJcblxyXG5cdFx0cmV0dXJuIHRyaWFuZ2xlcztcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIGNyZWF0ZSBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdCBmcm9tIHBvbHlnb24gcG9pbnRzIGluIHRoZSBzcGVjaWZpZWQgd2luZGluZyBvcmRlclxyXG5cclxuZnVuY3Rpb24gbGlua2VkTGlzdCggZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBjbG9ja3dpc2UgKSB7XHJcblxyXG5cdHZhciBpLCBsYXN0O1xyXG5cclxuXHRpZiAoIGNsb2Nrd2lzZSA9PT0gKCBzaWduZWRBcmVhKCBkYXRhLCBzdGFydCwgZW5kLCBkaW0gKSA+IDAgKSApIHtcclxuXHJcblx0XHRmb3IgKCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gZGltICkgbGFzdCA9IGluc2VydE5vZGUoIGksIGRhdGFbIGkgXSwgZGF0YVsgaSArIDEgXSwgbGFzdCApO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdGZvciAoIGkgPSBlbmQgLSBkaW07IGkgPj0gc3RhcnQ7IGkgLT0gZGltICkgbGFzdCA9IGluc2VydE5vZGUoIGksIGRhdGFbIGkgXSwgZGF0YVsgaSArIDEgXSwgbGFzdCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGlmICggbGFzdCAmJiBlcXVhbHMoIGxhc3QsIGxhc3QubmV4dCApICkge1xyXG5cclxuXHRcdHJlbW92ZU5vZGUoIGxhc3QgKTtcclxuXHRcdGxhc3QgPSBsYXN0Lm5leHQ7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGxhc3Q7XHJcblxyXG59XHJcblxyXG4vLyBlbGltaW5hdGUgY29saW5lYXIgb3IgZHVwbGljYXRlIHBvaW50c1xyXG5cclxuZnVuY3Rpb24gZmlsdGVyUG9pbnRzKCBzdGFydCwgZW5kICkge1xyXG5cclxuXHRpZiAoICEgc3RhcnQgKSByZXR1cm4gc3RhcnQ7XHJcblx0aWYgKCAhIGVuZCApIGVuZCA9IHN0YXJ0O1xyXG5cclxuXHR2YXIgcCA9IHN0YXJ0LCBhZ2FpbjtcclxuXHJcblx0ZG8ge1xyXG5cclxuXHRcdGFnYWluID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKCAhIHAuc3RlaW5lciAmJiAoIGVxdWFscyggcCwgcC5uZXh0ICkgfHwgYXJlYSggcC5wcmV2LCBwLCBwLm5leHQgKSA9PT0gMCApICkge1xyXG5cclxuXHRcdFx0cmVtb3ZlTm9kZSggcCApO1xyXG5cdFx0XHRwID0gZW5kID0gcC5wcmV2O1xyXG5cdFx0XHRpZiAoIHAgPT09IHAubmV4dCApIGJyZWFrO1xyXG5cdFx0XHRhZ2FpbiA9IHRydWU7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHAgPSBwLm5leHQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9IHdoaWxlICggYWdhaW4gfHwgcCAhPT0gZW5kICk7XHJcblxyXG5cdHJldHVybiBlbmQ7XHJcblxyXG59XHJcblxyXG4vLyBtYWluIGVhciBzbGljaW5nIGxvb3Agd2hpY2ggdHJpYW5ndWxhdGVzIGEgcG9seWdvbiAoZ2l2ZW4gYXMgYSBsaW5rZWQgbGlzdClcclxuXHJcbmZ1bmN0aW9uIGVhcmN1dExpbmtlZCggZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgcGFzcyApIHtcclxuXHJcblx0aWYgKCAhIGVhciApIHJldHVybjtcclxuXHJcblx0Ly8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxyXG5cclxuXHRpZiAoICEgcGFzcyAmJiBpbnZTaXplICkgaW5kZXhDdXJ2ZSggZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplICk7XHJcblxyXG5cdHZhciBzdG9wID0gZWFyLCBwcmV2LCBuZXh0O1xyXG5cclxuXHQvLyBpdGVyYXRlIHRocm91Z2ggZWFycywgc2xpY2luZyB0aGVtIG9uZSBieSBvbmVcclxuXHJcblx0d2hpbGUgKCBlYXIucHJldiAhPT0gZWFyLm5leHQgKSB7XHJcblxyXG5cdFx0cHJldiA9IGVhci5wcmV2O1xyXG5cdFx0bmV4dCA9IGVhci5uZXh0O1xyXG5cclxuXHRcdGlmICggaW52U2l6ZSA/IGlzRWFySGFzaGVkKCBlYXIsIG1pblgsIG1pblksIGludlNpemUgKSA6IGlzRWFyKCBlYXIgKSApIHtcclxuXHJcblx0XHRcdC8vIGN1dCBvZmYgdGhlIHRyaWFuZ2xlXHJcblx0XHRcdHRyaWFuZ2xlcy5wdXNoKCBwcmV2LmkgLyBkaW0gKTtcclxuXHRcdFx0dHJpYW5nbGVzLnB1c2goIGVhci5pIC8gZGltICk7XHJcblx0XHRcdHRyaWFuZ2xlcy5wdXNoKCBuZXh0LmkgLyBkaW0gKTtcclxuXHJcblx0XHRcdHJlbW92ZU5vZGUoIGVhciApO1xyXG5cclxuXHRcdFx0Ly8gc2tpcHBpbmcgdGhlIG5leHQgdmVydGljZSBsZWFkcyB0byBsZXNzIHNsaXZlciB0cmlhbmdsZXNcclxuXHRcdFx0ZWFyID0gbmV4dC5uZXh0O1xyXG5cdFx0XHRzdG9wID0gbmV4dC5uZXh0O1xyXG5cclxuXHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGVhciA9IG5leHQ7XHJcblxyXG5cdFx0Ly8gaWYgd2UgbG9vcGVkIHRocm91Z2ggdGhlIHdob2xlIHJlbWFpbmluZyBwb2x5Z29uIGFuZCBjYW4ndCBmaW5kIGFueSBtb3JlIGVhcnNcclxuXHJcblx0XHRpZiAoIGVhciA9PT0gc3RvcCApIHtcclxuXHJcblx0XHRcdC8vIHRyeSBmaWx0ZXJpbmcgcG9pbnRzIGFuZCBzbGljaW5nIGFnYWluXHJcblxyXG5cdFx0XHRpZiAoICEgcGFzcyApIHtcclxuXHJcblx0XHRcdFx0ZWFyY3V0TGlua2VkKCBmaWx0ZXJQb2ludHMoIGVhciApLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMSApO1xyXG5cclxuXHRcdFx0XHQvLyBpZiB0aGlzIGRpZG4ndCB3b3JrLCB0cnkgY3VyaW5nIGFsbCBzbWFsbCBzZWxmLWludGVyc2VjdGlvbnMgbG9jYWxseVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggcGFzcyA9PT0gMSApIHtcclxuXHJcblx0XHRcdFx0ZWFyID0gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyggZWFyLCB0cmlhbmdsZXMsIGRpbSApO1xyXG5cdFx0XHRcdGVhcmN1dExpbmtlZCggZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMiApO1xyXG5cclxuXHRcdFx0XHQvLyBhcyBhIGxhc3QgcmVzb3J0LCB0cnkgc3BsaXR0aW5nIHRoZSByZW1haW5pbmcgcG9seWdvbiBpbnRvIHR3b1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggcGFzcyA9PT0gMiApIHtcclxuXHJcblx0XHRcdFx0c3BsaXRFYXJjdXQoIGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuLy8gY2hlY2sgd2hldGhlciBhIHBvbHlnb24gbm9kZSBmb3JtcyBhIHZhbGlkIGVhciB3aXRoIGFkamFjZW50IG5vZGVzXHJcblxyXG5mdW5jdGlvbiBpc0VhciggZWFyICkge1xyXG5cclxuXHR2YXIgYSA9IGVhci5wcmV2LFxyXG5cdFx0YiA9IGVhcixcclxuXHRcdGMgPSBlYXIubmV4dDtcclxuXHJcblx0aWYgKCBhcmVhKCBhLCBiLCBjICkgPj0gMCApIHJldHVybiBmYWxzZTsgLy8gcmVmbGV4LCBjYW4ndCBiZSBhbiBlYXJcclxuXHJcblx0Ly8gbm93IG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlIG90aGVyIHBvaW50cyBpbnNpZGUgdGhlIHBvdGVudGlhbCBlYXJcclxuXHR2YXIgcCA9IGVhci5uZXh0Lm5leHQ7XHJcblxyXG5cdHdoaWxlICggcCAhPT0gZWFyLnByZXYgKSB7XHJcblxyXG5cdFx0aWYgKCBwb2ludEluVHJpYW5nbGUoIGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55ICkgJiYgYXJlYSggcC5wcmV2LCBwLCBwLm5leHQgKSA+PSAwICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRwID0gcC5uZXh0O1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiB0cnVlO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gaXNFYXJIYXNoZWQoIGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSApIHtcclxuXHJcblx0dmFyIGEgPSBlYXIucHJldixcclxuXHRcdGIgPSBlYXIsXHJcblx0XHRjID0gZWFyLm5leHQ7XHJcblxyXG5cdGlmICggYXJlYSggYSwgYiwgYyApID49IDAgKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXHJcblxyXG5cdC8vIHRyaWFuZ2xlIGJib3g7IG1pbiAmIG1heCBhcmUgY2FsY3VsYXRlZCBsaWtlIHRoaXMgZm9yIHNwZWVkXHJcblxyXG5cdHZhciBtaW5UWCA9IGEueCA8IGIueCA/ICggYS54IDwgYy54ID8gYS54IDogYy54ICkgOiAoIGIueCA8IGMueCA/IGIueCA6IGMueCApLFxyXG5cdFx0bWluVFkgPSBhLnkgPCBiLnkgPyAoIGEueSA8IGMueSA/IGEueSA6IGMueSApIDogKCBiLnkgPCBjLnkgPyBiLnkgOiBjLnkgKSxcclxuXHRcdG1heFRYID0gYS54ID4gYi54ID8gKCBhLnggPiBjLnggPyBhLnggOiBjLnggKSA6ICggYi54ID4gYy54ID8gYi54IDogYy54ICksXHJcblx0XHRtYXhUWSA9IGEueSA+IGIueSA/ICggYS55ID4gYy55ID8gYS55IDogYy55ICkgOiAoIGIueSA+IGMueSA/IGIueSA6IGMueSApO1xyXG5cclxuXHQvLyB6LW9yZGVyIHJhbmdlIGZvciB0aGUgY3VycmVudCB0cmlhbmdsZSBiYm94O1xyXG5cclxuXHR2YXIgbWluWiA9IHpPcmRlciggbWluVFgsIG1pblRZLCBtaW5YLCBtaW5ZLCBpbnZTaXplICksXHJcblx0XHRtYXhaID0gek9yZGVyKCBtYXhUWCwgbWF4VFksIG1pblgsIG1pblksIGludlNpemUgKTtcclxuXHJcblx0Ly8gZmlyc3QgbG9vayBmb3IgcG9pbnRzIGluc2lkZSB0aGUgdHJpYW5nbGUgaW4gaW5jcmVhc2luZyB6LW9yZGVyXHJcblxyXG5cdHZhciBwID0gZWFyLm5leHRaO1xyXG5cclxuXHR3aGlsZSAoIHAgJiYgcC56IDw9IG1heFogKSB7XHJcblxyXG5cdFx0aWYgKCBwICE9PSBlYXIucHJldiAmJiBwICE9PSBlYXIubmV4dCAmJlxyXG5cdFx0XHRcdHBvaW50SW5UcmlhbmdsZSggYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkgKSAmJlxyXG5cdFx0XHRcdGFyZWEoIHAucHJldiwgcCwgcC5uZXh0ICkgPj0gMCApIHJldHVybiBmYWxzZTtcclxuXHRcdHAgPSBwLm5leHRaO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIHRoZW4gbG9vayBmb3IgcG9pbnRzIGluIGRlY3JlYXNpbmcgei1vcmRlclxyXG5cclxuXHRwID0gZWFyLnByZXZaO1xyXG5cclxuXHR3aGlsZSAoIHAgJiYgcC56ID49IG1pblogKSB7XHJcblxyXG5cdFx0aWYgKCBwICE9PSBlYXIucHJldiAmJiBwICE9PSBlYXIubmV4dCAmJlxyXG5cdFx0XHRcdHBvaW50SW5UcmlhbmdsZSggYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkgKSAmJlxyXG5cdFx0XHRcdGFyZWEoIHAucHJldiwgcCwgcC5uZXh0ICkgPj0gMCApIHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRwID0gcC5wcmV2WjtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdHJ1ZTtcclxuXHJcbn1cclxuXHJcbi8vIGdvIHRocm91Z2ggYWxsIHBvbHlnb24gbm9kZXMgYW5kIGN1cmUgc21hbGwgbG9jYWwgc2VsZi1pbnRlcnNlY3Rpb25zXHJcblxyXG5mdW5jdGlvbiBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKCBzdGFydCwgdHJpYW5nbGVzLCBkaW0gKSB7XHJcblxyXG5cdHZhciBwID0gc3RhcnQ7XHJcblxyXG5cdGRvIHtcclxuXHJcblx0XHR2YXIgYSA9IHAucHJldiwgYiA9IHAubmV4dC5uZXh0O1xyXG5cclxuXHRcdGlmICggISBlcXVhbHMoIGEsIGIgKSAmJiBpbnRlcnNlY3RzKCBhLCBwLCBwLm5leHQsIGIgKSAmJiBsb2NhbGx5SW5zaWRlKCBhLCBiICkgJiYgbG9jYWxseUluc2lkZSggYiwgYSApICkge1xyXG5cclxuXHRcdFx0dHJpYW5nbGVzLnB1c2goIGEuaSAvIGRpbSApO1xyXG5cdFx0XHR0cmlhbmdsZXMucHVzaCggcC5pIC8gZGltICk7XHJcblx0XHRcdHRyaWFuZ2xlcy5wdXNoKCBiLmkgLyBkaW0gKTtcclxuXHJcblx0XHRcdC8vIHJlbW92ZSB0d28gbm9kZXMgaW52b2x2ZWRcclxuXHJcblx0XHRcdHJlbW92ZU5vZGUoIHAgKTtcclxuXHRcdFx0cmVtb3ZlTm9kZSggcC5uZXh0ICk7XHJcblxyXG5cdFx0XHRwID0gc3RhcnQgPSBiO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRwID0gcC5uZXh0O1xyXG5cclxuXHR9IHdoaWxlICggcCAhPT0gc3RhcnQgKTtcclxuXHJcblx0cmV0dXJuIHA7XHJcblxyXG59XHJcblxyXG4vLyB0cnkgc3BsaXR0aW5nIHBvbHlnb24gaW50byB0d28gYW5kIHRyaWFuZ3VsYXRlIHRoZW0gaW5kZXBlbmRlbnRseVxyXG5cclxuZnVuY3Rpb24gc3BsaXRFYXJjdXQoIHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSApIHtcclxuXHJcblx0Ly8gbG9vayBmb3IgYSB2YWxpZCBkaWFnb25hbCB0aGF0IGRpdmlkZXMgdGhlIHBvbHlnb24gaW50byB0d29cclxuXHJcblx0dmFyIGEgPSBzdGFydDtcclxuXHJcblx0ZG8ge1xyXG5cclxuXHRcdHZhciBiID0gYS5uZXh0Lm5leHQ7XHJcblxyXG5cdFx0d2hpbGUgKCBiICE9PSBhLnByZXYgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGEuaSAhPT0gYi5pICYmIGlzVmFsaWREaWFnb25hbCggYSwgYiApICkge1xyXG5cclxuXHRcdFx0XHQvLyBzcGxpdCB0aGUgcG9seWdvbiBpbiB0d28gYnkgdGhlIGRpYWdvbmFsXHJcblxyXG5cdFx0XHRcdHZhciBjID0gc3BsaXRQb2x5Z29uKCBhLCBiICk7XHJcblxyXG5cdFx0XHRcdC8vIGZpbHRlciBjb2xpbmVhciBwb2ludHMgYXJvdW5kIHRoZSBjdXRzXHJcblxyXG5cdFx0XHRcdGEgPSBmaWx0ZXJQb2ludHMoIGEsIGEubmV4dCApO1xyXG5cdFx0XHRcdGMgPSBmaWx0ZXJQb2ludHMoIGMsIGMubmV4dCApO1xyXG5cclxuXHRcdFx0XHQvLyBydW4gZWFyY3V0IG9uIGVhY2ggaGFsZlxyXG5cclxuXHRcdFx0XHRlYXJjdXRMaW5rZWQoIGEsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplICk7XHJcblx0XHRcdFx0ZWFyY3V0TGlua2VkKCBjLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSApO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGIgPSBiLm5leHQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGEgPSBhLm5leHQ7XHJcblxyXG5cdH0gd2hpbGUgKCBhICE9PSBzdGFydCApO1xyXG5cclxufVxyXG5cclxuLy8gbGluayBldmVyeSBob2xlIGludG8gdGhlIG91dGVyIGxvb3AsIHByb2R1Y2luZyBhIHNpbmdsZS1yaW5nIHBvbHlnb24gd2l0aG91dCBob2xlc1xyXG5cclxuZnVuY3Rpb24gZWxpbWluYXRlSG9sZXMoIGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSApIHtcclxuXHJcblx0dmFyIHF1ZXVlID0gW10sIGksIGxlbiwgc3RhcnQsIGVuZCwgbGlzdDtcclxuXHJcblx0Zm9yICggaSA9IDAsIGxlbiA9IGhvbGVJbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSArKyApIHtcclxuXHJcblx0XHRzdGFydCA9IGhvbGVJbmRpY2VzWyBpIF0gKiBkaW07XHJcblx0XHRlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzWyBpICsgMSBdICogZGltIDogZGF0YS5sZW5ndGg7XHJcblx0XHRsaXN0ID0gbGlua2VkTGlzdCggZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBmYWxzZSApO1xyXG5cdFx0aWYgKCBsaXN0ID09PSBsaXN0Lm5leHQgKSBsaXN0LnN0ZWluZXIgPSB0cnVlO1xyXG5cdFx0cXVldWUucHVzaCggZ2V0TGVmdG1vc3QoIGxpc3QgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHF1ZXVlLnNvcnQoIGNvbXBhcmVYICk7XHJcblxyXG5cdC8vIHByb2Nlc3MgaG9sZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0XHJcblxyXG5cdGZvciAoIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdGVsaW1pbmF0ZUhvbGUoIHF1ZXVlWyBpIF0sIG91dGVyTm9kZSApO1xyXG5cdFx0b3V0ZXJOb2RlID0gZmlsdGVyUG9pbnRzKCBvdXRlck5vZGUsIG91dGVyTm9kZS5uZXh0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG91dGVyTm9kZTtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXBhcmVYKCBhLCBiICkge1xyXG5cclxuXHRyZXR1cm4gYS54IC0gYi54O1xyXG5cclxufVxyXG5cclxuLy8gZmluZCBhIGJyaWRnZSBiZXR3ZWVuIHZlcnRpY2VzIHRoYXQgY29ubmVjdHMgaG9sZSB3aXRoIGFuIG91dGVyIHJpbmcgYW5kIGFuZCBsaW5rIGl0XHJcblxyXG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlKCBob2xlLCBvdXRlck5vZGUgKSB7XHJcblxyXG5cdG91dGVyTm9kZSA9IGZpbmRIb2xlQnJpZGdlKCBob2xlLCBvdXRlck5vZGUgKTtcclxuXHJcblx0aWYgKCBvdXRlck5vZGUgKSB7XHJcblxyXG5cdFx0dmFyIGIgPSBzcGxpdFBvbHlnb24oIG91dGVyTm9kZSwgaG9sZSApO1xyXG5cclxuXHRcdGZpbHRlclBvaW50cyggYiwgYi5uZXh0ICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbi8vIERhdmlkIEViZXJseSdzIGFsZ29yaXRobSBmb3IgZmluZGluZyBhIGJyaWRnZSBiZXR3ZWVuIGhvbGUgYW5kIG91dGVyIHBvbHlnb25cclxuXHJcbmZ1bmN0aW9uIGZpbmRIb2xlQnJpZGdlKCBob2xlLCBvdXRlck5vZGUgKSB7XHJcblxyXG5cdHZhciBwID0gb3V0ZXJOb2RlLFxyXG5cdFx0aHggPSBob2xlLngsXHJcblx0XHRoeSA9IGhvbGUueSxcclxuXHRcdHF4ID0gLSBJbmZpbml0eSxcclxuXHRcdG07XHJcblxyXG5cdC8vIGZpbmQgYSBzZWdtZW50IGludGVyc2VjdGVkIGJ5IGEgcmF5IGZyb20gdGhlIGhvbGUncyBsZWZ0bW9zdCBwb2ludCB0byB0aGUgbGVmdDtcclxuXHQvLyBzZWdtZW50J3MgZW5kcG9pbnQgd2l0aCBsZXNzZXIgeCB3aWxsIGJlIHBvdGVudGlhbCBjb25uZWN0aW9uIHBvaW50XHJcblxyXG5cdGRvIHtcclxuXHJcblx0XHRpZiAoIGh5IDw9IHAueSAmJiBoeSA+PSBwLm5leHQueSAmJiBwLm5leHQueSAhPT0gcC55ICkge1xyXG5cclxuXHRcdFx0dmFyIHggPSBwLnggKyAoIGh5IC0gcC55ICkgKiAoIHAubmV4dC54IC0gcC54ICkgLyAoIHAubmV4dC55IC0gcC55ICk7XHJcblxyXG5cdFx0XHRpZiAoIHggPD0gaHggJiYgeCA+IHF4ICkge1xyXG5cclxuXHRcdFx0XHRxeCA9IHg7XHJcblxyXG5cdFx0XHRcdGlmICggeCA9PT0gaHggKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBoeSA9PT0gcC55ICkgcmV0dXJuIHA7XHJcblx0XHRcdFx0XHRpZiAoIGh5ID09PSBwLm5leHQueSApIHJldHVybiBwLm5leHQ7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bSA9IHAueCA8IHAubmV4dC54ID8gcCA6IHAubmV4dDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cCA9IHAubmV4dDtcclxuXHJcblx0fSB3aGlsZSAoIHAgIT09IG91dGVyTm9kZSApO1xyXG5cclxuXHRpZiAoICEgbSApIHJldHVybiBudWxsO1xyXG5cclxuXHRpZiAoIGh4ID09PSBxeCApIHJldHVybiBtLnByZXY7IC8vIGhvbGUgdG91Y2hlcyBvdXRlciBzZWdtZW50OyBwaWNrIGxvd2VyIGVuZHBvaW50XHJcblxyXG5cdC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIG9mIGhvbGUgcG9pbnQsIHNlZ21lbnQgaW50ZXJzZWN0aW9uIGFuZCBlbmRwb2ludDtcclxuXHQvLyBpZiB0aGVyZSBhcmUgbm8gcG9pbnRzIGZvdW5kLCB3ZSBoYXZlIGEgdmFsaWQgY29ubmVjdGlvbjtcclxuXHQvLyBvdGhlcndpc2UgY2hvb3NlIHRoZSBwb2ludCBvZiB0aGUgbWluaW11bSBhbmdsZSB3aXRoIHRoZSByYXkgYXMgY29ubmVjdGlvbiBwb2ludFxyXG5cclxuXHR2YXIgc3RvcCA9IG0sXHJcblx0XHRteCA9IG0ueCxcclxuXHRcdG15ID0gbS55LFxyXG5cdFx0dGFuTWluID0gSW5maW5pdHksXHJcblx0XHR0YW47XHJcblxyXG5cdHAgPSBtLm5leHQ7XHJcblxyXG5cdHdoaWxlICggcCAhPT0gc3RvcCApIHtcclxuXHJcblx0XHRpZiAoIGh4ID49IHAueCAmJiBwLnggPj0gbXggJiYgaHggIT09IHAueCAmJlxyXG5cdFx0XHRcdFx0XHRwb2ludEluVHJpYW5nbGUoIGh5IDwgbXkgPyBoeCA6IHF4LCBoeSwgbXgsIG15LCBoeSA8IG15ID8gcXggOiBoeCwgaHksIHAueCwgcC55ICkgKSB7XHJcblxyXG5cdFx0XHR0YW4gPSBNYXRoLmFicyggaHkgLSBwLnkgKSAvICggaHggLSBwLnggKTsgLy8gdGFuZ2VudGlhbFxyXG5cclxuXHRcdFx0aWYgKCAoIHRhbiA8IHRhbk1pbiB8fCAoIHRhbiA9PT0gdGFuTWluICYmIHAueCA+IG0ueCApICkgJiYgbG9jYWxseUluc2lkZSggcCwgaG9sZSApICkge1xyXG5cclxuXHRcdFx0XHRtID0gcDtcclxuXHRcdFx0XHR0YW5NaW4gPSB0YW47XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHAgPSBwLm5leHQ7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG07XHJcblxyXG59XHJcblxyXG4vLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXHJcblxyXG5mdW5jdGlvbiBpbmRleEN1cnZlKCBzdGFydCwgbWluWCwgbWluWSwgaW52U2l6ZSApIHtcclxuXHJcblx0dmFyIHAgPSBzdGFydDtcclxuXHJcblx0ZG8ge1xyXG5cclxuXHRcdGlmICggcC56ID09PSBudWxsICkgcC56ID0gek9yZGVyKCBwLngsIHAueSwgbWluWCwgbWluWSwgaW52U2l6ZSApO1xyXG5cdFx0cC5wcmV2WiA9IHAucHJldjtcclxuXHRcdHAubmV4dFogPSBwLm5leHQ7XHJcblx0XHRwID0gcC5uZXh0O1xyXG5cclxuXHR9IHdoaWxlICggcCAhPT0gc3RhcnQgKTtcclxuXHJcblx0cC5wcmV2Wi5uZXh0WiA9IG51bGw7XHJcblx0cC5wcmV2WiA9IG51bGw7XHJcblxyXG5cdHNvcnRMaW5rZWQoIHAgKTtcclxuXHJcbn1cclxuXHJcbi8vIFNpbW9uIFRhdGhhbSdzIGxpbmtlZCBsaXN0IG1lcmdlIHNvcnQgYWxnb3JpdGhtXHJcbi8vIGh0dHA6Ly93d3cuY2hpYXJrLmdyZWVuZW5kLm9yZy51ay9+c2d0YXRoYW0vYWxnb3JpdGhtcy9saXN0c29ydC5odG1sXHJcblxyXG5mdW5jdGlvbiBzb3J0TGlua2VkKCBsaXN0ICkge1xyXG5cclxuXHR2YXIgaSwgcCwgcSwgZSwgdGFpbCwgbnVtTWVyZ2VzLCBwU2l6ZSwgcVNpemUsIGluU2l6ZSA9IDE7XHJcblxyXG5cdGRvIHtcclxuXHJcblx0XHRwID0gbGlzdDtcclxuXHRcdGxpc3QgPSBudWxsO1xyXG5cdFx0dGFpbCA9IG51bGw7XHJcblx0XHRudW1NZXJnZXMgPSAwO1xyXG5cclxuXHRcdHdoaWxlICggcCApIHtcclxuXHJcblx0XHRcdG51bU1lcmdlcyArKztcclxuXHRcdFx0cSA9IHA7XHJcblx0XHRcdHBTaXplID0gMDtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaW5TaXplOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRwU2l6ZSArKztcclxuXHRcdFx0XHRxID0gcS5uZXh0WjtcclxuXHRcdFx0XHRpZiAoICEgcSApIGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cVNpemUgPSBpblNpemU7XHJcblxyXG5cdFx0XHR3aGlsZSAoIHBTaXplID4gMCB8fCAoIHFTaXplID4gMCAmJiBxICkgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggcFNpemUgIT09IDAgJiYgKCBxU2l6ZSA9PT0gMCB8fCAhIHEgfHwgcC56IDw9IHEueiApICkge1xyXG5cclxuXHRcdFx0XHRcdGUgPSBwO1xyXG5cdFx0XHRcdFx0cCA9IHAubmV4dFo7XHJcblx0XHRcdFx0XHRwU2l6ZSAtLTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRlID0gcTtcclxuXHRcdFx0XHRcdHEgPSBxLm5leHRaO1xyXG5cdFx0XHRcdFx0cVNpemUgLS07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCB0YWlsICkgdGFpbC5uZXh0WiA9IGU7XHJcblx0XHRcdFx0ZWxzZSBsaXN0ID0gZTtcclxuXHJcblx0XHRcdFx0ZS5wcmV2WiA9IHRhaWw7XHJcblx0XHRcdFx0dGFpbCA9IGU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRwID0gcTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGFpbC5uZXh0WiA9IG51bGw7XHJcblx0XHRpblNpemUgKj0gMjtcclxuXHJcblx0fSB3aGlsZSAoIG51bU1lcmdlcyA+IDEgKTtcclxuXHJcblx0cmV0dXJuIGxpc3Q7XHJcblxyXG59XHJcblxyXG4vLyB6LW9yZGVyIG9mIGEgcG9pbnQgZ2l2ZW4gY29vcmRzIGFuZCBpbnZlcnNlIG9mIHRoZSBsb25nZXIgc2lkZSBvZiBkYXRhIGJib3hcclxuXHJcbmZ1bmN0aW9uIHpPcmRlciggeCwgeSwgbWluWCwgbWluWSwgaW52U2l6ZSApIHtcclxuXHJcblx0Ly8gY29vcmRzIGFyZSB0cmFuc2Zvcm1lZCBpbnRvIG5vbi1uZWdhdGl2ZSAxNS1iaXQgaW50ZWdlciByYW5nZVxyXG5cclxuXHR4ID0gMzI3NjcgKiAoIHggLSBtaW5YICkgKiBpbnZTaXplO1xyXG5cdHkgPSAzMjc2NyAqICggeSAtIG1pblkgKSAqIGludlNpemU7XHJcblxyXG5cdHggPSAoIHggfCAoIHggPDwgOCApICkgJiAweDAwRkYwMEZGO1xyXG5cdHggPSAoIHggfCAoIHggPDwgNCApICkgJiAweDBGMEYwRjBGO1xyXG5cdHggPSAoIHggfCAoIHggPDwgMiApICkgJiAweDMzMzMzMzMzO1xyXG5cdHggPSAoIHggfCAoIHggPDwgMSApICkgJiAweDU1NTU1NTU1O1xyXG5cclxuXHR5ID0gKCB5IHwgKCB5IDw8IDggKSApICYgMHgwMEZGMDBGRjtcclxuXHR5ID0gKCB5IHwgKCB5IDw8IDQgKSApICYgMHgwRjBGMEYwRjtcclxuXHR5ID0gKCB5IHwgKCB5IDw8IDIgKSApICYgMHgzMzMzMzMzMztcclxuXHR5ID0gKCB5IHwgKCB5IDw8IDEgKSApICYgMHg1NTU1NTU1NTtcclxuXHJcblx0cmV0dXJuIHggfCAoIHkgPDwgMSApO1xyXG5cclxufVxyXG5cclxuLy8gZmluZCB0aGUgbGVmdG1vc3Qgbm9kZSBvZiBhIHBvbHlnb24gcmluZ1xyXG5cclxuZnVuY3Rpb24gZ2V0TGVmdG1vc3QoIHN0YXJ0ICkge1xyXG5cclxuXHR2YXIgcCA9IHN0YXJ0LCBsZWZ0bW9zdCA9IHN0YXJ0O1xyXG5cclxuXHRkbyB7XHJcblxyXG5cdFx0aWYgKCBwLnggPCBsZWZ0bW9zdC54ICkgbGVmdG1vc3QgPSBwO1xyXG5cdFx0cCA9IHAubmV4dDtcclxuXHJcblx0fSB3aGlsZSAoIHAgIT09IHN0YXJ0ICk7XHJcblxyXG5cdHJldHVybiBsZWZ0bW9zdDtcclxuXHJcbn1cclxuXHJcbi8vIGNoZWNrIGlmIGEgcG9pbnQgbGllcyB3aXRoaW4gYSBjb252ZXggdHJpYW5nbGVcclxuXHJcbmZ1bmN0aW9uIHBvaW50SW5UcmlhbmdsZSggYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcHgsIHB5ICkge1xyXG5cclxuXHRyZXR1cm4gKCBjeCAtIHB4ICkgKiAoIGF5IC0gcHkgKSAtICggYXggLSBweCApICogKCBjeSAtIHB5ICkgPj0gMCAmJlxyXG5cdCAoIGF4IC0gcHggKSAqICggYnkgLSBweSApIC0gKCBieCAtIHB4ICkgKiAoIGF5IC0gcHkgKSA+PSAwICYmXHJcblx0ICggYnggLSBweCApICogKCBjeSAtIHB5ICkgLSAoIGN4IC0gcHggKSAqICggYnkgLSBweSApID49IDA7XHJcblxyXG59XHJcblxyXG4vLyBjaGVjayBpZiBhIGRpYWdvbmFsIGJldHdlZW4gdHdvIHBvbHlnb24gbm9kZXMgaXMgdmFsaWQgKGxpZXMgaW4gcG9seWdvbiBpbnRlcmlvcilcclxuXHJcbmZ1bmN0aW9uIGlzVmFsaWREaWFnb25hbCggYSwgYiApIHtcclxuXHJcblx0cmV0dXJuIGEubmV4dC5pICE9PSBiLmkgJiYgYS5wcmV2LmkgIT09IGIuaSAmJiAhIGludGVyc2VjdHNQb2x5Z29uKCBhLCBiICkgJiZcclxuXHRcdGxvY2FsbHlJbnNpZGUoIGEsIGIgKSAmJiBsb2NhbGx5SW5zaWRlKCBiLCBhICkgJiYgbWlkZGxlSW5zaWRlKCBhLCBiICk7XHJcblxyXG59XHJcblxyXG4vLyBzaWduZWQgYXJlYSBvZiBhIHRyaWFuZ2xlXHJcblxyXG5mdW5jdGlvbiBhcmVhKCBwLCBxLCByICkge1xyXG5cclxuXHRyZXR1cm4gKCBxLnkgLSBwLnkgKSAqICggci54IC0gcS54ICkgLSAoIHEueCAtIHAueCApICogKCByLnkgLSBxLnkgKTtcclxuXHJcbn1cclxuXHJcbi8vIGNoZWNrIGlmIHR3byBwb2ludHMgYXJlIGVxdWFsXHJcblxyXG5mdW5jdGlvbiBlcXVhbHMoIHAxLCBwMiApIHtcclxuXHJcblx0cmV0dXJuIHAxLnggPT09IHAyLnggJiYgcDEueSA9PT0gcDIueTtcclxuXHJcbn1cclxuXHJcbi8vIGNoZWNrIGlmIHR3byBzZWdtZW50cyBpbnRlcnNlY3RcclxuXHJcbmZ1bmN0aW9uIGludGVyc2VjdHMoIHAxLCBxMSwgcDIsIHEyICkge1xyXG5cclxuXHRpZiAoICggZXF1YWxzKCBwMSwgcTEgKSAmJiBlcXVhbHMoIHAyLCBxMiApICkgfHxcclxuXHRcdFx0KCBlcXVhbHMoIHAxLCBxMiApICYmIGVxdWFscyggcDIsIHExICkgKSApIHJldHVybiB0cnVlO1xyXG5cclxuXHRyZXR1cm4gYXJlYSggcDEsIHExLCBwMiApID4gMCAhPT0gYXJlYSggcDEsIHExLCBxMiApID4gMCAmJlxyXG5cdFx0XHRcdCBhcmVhKCBwMiwgcTIsIHAxICkgPiAwICE9PSBhcmVhKCBwMiwgcTIsIHExICkgPiAwO1xyXG5cclxufVxyXG5cclxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGludGVyc2VjdHMgYW55IHBvbHlnb24gc2VnbWVudHNcclxuXHJcbmZ1bmN0aW9uIGludGVyc2VjdHNQb2x5Z29uKCBhLCBiICkge1xyXG5cclxuXHR2YXIgcCA9IGE7XHJcblxyXG5cdGRvIHtcclxuXHJcblx0XHRpZiAoIHAuaSAhPT0gYS5pICYmIHAubmV4dC5pICE9PSBhLmkgJiYgcC5pICE9PSBiLmkgJiYgcC5uZXh0LmkgIT09IGIuaSAmJlxyXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3RzKCBwLCBwLm5leHQsIGEsIGIgKSApIHtcclxuXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRwID0gcC5uZXh0O1xyXG5cclxuXHR9IHdoaWxlICggcCAhPT0gYSApO1xyXG5cclxuXHRyZXR1cm4gZmFsc2U7XHJcblxyXG59XHJcblxyXG4vLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgbG9jYWxseSBpbnNpZGUgdGhlIHBvbHlnb25cclxuXHJcbmZ1bmN0aW9uIGxvY2FsbHlJbnNpZGUoIGEsIGIgKSB7XHJcblxyXG5cdHJldHVybiBhcmVhKCBhLnByZXYsIGEsIGEubmV4dCApIDwgMCA/XHJcblx0XHRhcmVhKCBhLCBiLCBhLm5leHQgKSA+PSAwICYmIGFyZWEoIGEsIGEucHJldiwgYiApID49IDAgOlxyXG5cdFx0YXJlYSggYSwgYiwgYS5wcmV2ICkgPCAwIHx8IGFyZWEoIGEsIGEubmV4dCwgYiApIDwgMDtcclxuXHJcbn1cclxuXHJcbi8vIGNoZWNrIGlmIHRoZSBtaWRkbGUgcG9pbnQgb2YgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGluc2lkZSB0aGUgcG9seWdvblxyXG5cclxuZnVuY3Rpb24gbWlkZGxlSW5zaWRlKCBhLCBiICkge1xyXG5cclxuXHR2YXIgcCA9IGEsXHJcblx0XHRpbnNpZGUgPSBmYWxzZSxcclxuXHRcdHB4ID0gKCBhLnggKyBiLnggKSAvIDIsXHJcblx0XHRweSA9ICggYS55ICsgYi55ICkgLyAyO1xyXG5cclxuXHRkbyB7XHJcblxyXG5cdFx0aWYgKCAoICggcC55ID4gcHkgKSAhPT0gKCBwLm5leHQueSA+IHB5ICkgKSAmJiBwLm5leHQueSAhPT0gcC55ICYmXHJcblx0XHRcdFx0XHRcdCggcHggPCAoIHAubmV4dC54IC0gcC54ICkgKiAoIHB5IC0gcC55ICkgLyAoIHAubmV4dC55IC0gcC55ICkgKyBwLnggKSApIHtcclxuXHJcblx0XHRcdGluc2lkZSA9ICEgaW5zaWRlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRwID0gcC5uZXh0O1xyXG5cclxuXHR9IHdoaWxlICggcCAhPT0gYSApO1xyXG5cclxuXHRyZXR1cm4gaW5zaWRlO1xyXG5cclxufVxyXG5cclxuLy8gbGluayB0d28gcG9seWdvbiB2ZXJ0aWNlcyB3aXRoIGEgYnJpZGdlOyBpZiB0aGUgdmVydGljZXMgYmVsb25nIHRvIHRoZSBzYW1lIHJpbmcsIGl0IHNwbGl0cyBwb2x5Z29uIGludG8gdHdvO1xyXG4vLyBpZiBvbmUgYmVsb25ncyB0byB0aGUgb3V0ZXIgcmluZyBhbmQgYW5vdGhlciB0byBhIGhvbGUsIGl0IG1lcmdlcyBpdCBpbnRvIGEgc2luZ2xlIHJpbmdcclxuXHJcbmZ1bmN0aW9uIHNwbGl0UG9seWdvbiggYSwgYiApIHtcclxuXHJcblx0dmFyIGEyID0gbmV3IE5vZGUoIGEuaSwgYS54LCBhLnkgKSxcclxuXHRcdGIyID0gbmV3IE5vZGUoIGIuaSwgYi54LCBiLnkgKSxcclxuXHRcdGFuID0gYS5uZXh0LFxyXG5cdFx0YnAgPSBiLnByZXY7XHJcblxyXG5cdGEubmV4dCA9IGI7XHJcblx0Yi5wcmV2ID0gYTtcclxuXHJcblx0YTIubmV4dCA9IGFuO1xyXG5cdGFuLnByZXYgPSBhMjtcclxuXHJcblx0YjIubmV4dCA9IGEyO1xyXG5cdGEyLnByZXYgPSBiMjtcclxuXHJcblx0YnAubmV4dCA9IGIyO1xyXG5cdGIyLnByZXYgPSBicDtcclxuXHJcblx0cmV0dXJuIGIyO1xyXG5cclxufVxyXG5cclxuLy8gY3JlYXRlIGEgbm9kZSBhbmQgb3B0aW9uYWxseSBsaW5rIGl0IHdpdGggcHJldmlvdXMgb25lIChpbiBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdClcclxuXHJcbmZ1bmN0aW9uIGluc2VydE5vZGUoIGksIHgsIHksIGxhc3QgKSB7XHJcblxyXG5cdHZhciBwID0gbmV3IE5vZGUoIGksIHgsIHkgKTtcclxuXHJcblx0aWYgKCAhIGxhc3QgKSB7XHJcblxyXG5cdFx0cC5wcmV2ID0gcDtcclxuXHRcdHAubmV4dCA9IHA7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0cC5uZXh0ID0gbGFzdC5uZXh0O1xyXG5cdFx0cC5wcmV2ID0gbGFzdDtcclxuXHRcdGxhc3QubmV4dC5wcmV2ID0gcDtcclxuXHRcdGxhc3QubmV4dCA9IHA7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHA7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVOb2RlKCBwICkge1xyXG5cclxuXHRwLm5leHQucHJldiA9IHAucHJldjtcclxuXHRwLnByZXYubmV4dCA9IHAubmV4dDtcclxuXHJcblx0aWYgKCBwLnByZXZaICkgcC5wcmV2Wi5uZXh0WiA9IHAubmV4dFo7XHJcblx0aWYgKCBwLm5leHRaICkgcC5uZXh0Wi5wcmV2WiA9IHAucHJldlo7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBOb2RlKCBpLCB4LCB5ICkge1xyXG5cclxuXHQvLyB2ZXJ0aWNlIGluZGV4IGluIGNvb3JkaW5hdGVzIGFycmF5XHJcblx0dGhpcy5pID0gaTtcclxuXHJcblx0Ly8gdmVydGV4IGNvb3JkaW5hdGVzXHJcblx0dGhpcy54ID0geDtcclxuXHR0aGlzLnkgPSB5O1xyXG5cclxuXHQvLyBwcmV2aW91cyBhbmQgbmV4dCB2ZXJ0aWNlIG5vZGVzIGluIGEgcG9seWdvbiByaW5nXHJcblx0dGhpcy5wcmV2ID0gbnVsbDtcclxuXHR0aGlzLm5leHQgPSBudWxsO1xyXG5cclxuXHQvLyB6LW9yZGVyIGN1cnZlIHZhbHVlXHJcblx0dGhpcy56ID0gbnVsbDtcclxuXHJcblx0Ly8gcHJldmlvdXMgYW5kIG5leHQgbm9kZXMgaW4gei1vcmRlclxyXG5cdHRoaXMucHJldlogPSBudWxsO1xyXG5cdHRoaXMubmV4dFogPSBudWxsO1xyXG5cclxuXHQvLyBpbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIGEgc3RlaW5lciBwb2ludFxyXG5cdHRoaXMuc3RlaW5lciA9IGZhbHNlO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gc2lnbmVkQXJlYSggZGF0YSwgc3RhcnQsIGVuZCwgZGltICkge1xyXG5cclxuXHR2YXIgc3VtID0gMDtcclxuXHJcblx0Zm9yICggdmFyIGkgPSBzdGFydCwgaiA9IGVuZCAtIGRpbTsgaSA8IGVuZDsgaSArPSBkaW0gKSB7XHJcblxyXG5cdFx0c3VtICs9ICggZGF0YVsgaiBdIC0gZGF0YVsgaSBdICkgKiAoIGRhdGFbIGkgKyAxIF0gKyBkYXRhWyBqICsgMSBdICk7XHJcblx0XHRqID0gaTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gc3VtO1xyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgRWFyY3V0IH07XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgRWFyY3V0IH0gZnJvbSAnLi9FYXJjdXQuanMnO1xyXG5cclxudmFyIFNoYXBlVXRpbHMgPSB7XHJcblxyXG5cdC8vIGNhbGN1bGF0ZSBhcmVhIG9mIHRoZSBjb250b3VyIHBvbHlnb25cclxuXHJcblx0YXJlYTogZnVuY3Rpb24gKCBjb250b3VyICkge1xyXG5cclxuXHRcdHZhciBuID0gY29udG91ci5sZW5ndGg7XHJcblx0XHR2YXIgYSA9IDAuMDtcclxuXHJcblx0XHRmb3IgKCB2YXIgcCA9IG4gLSAxLCBxID0gMDsgcSA8IG47IHAgPSBxICsrICkge1xyXG5cclxuXHRcdFx0YSArPSBjb250b3VyWyBwIF0ueCAqIGNvbnRvdXJbIHEgXS55IC0gY29udG91clsgcSBdLnggKiBjb250b3VyWyBwIF0ueTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGEgKiAwLjU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGlzQ2xvY2tXaXNlOiBmdW5jdGlvbiAoIHB0cyApIHtcclxuXHJcblx0XHRyZXR1cm4gU2hhcGVVdGlscy5hcmVhKCBwdHMgKSA8IDA7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRyaWFuZ3VsYXRlU2hhcGU6IGZ1bmN0aW9uICggY29udG91ciwgaG9sZXMgKSB7XHJcblxyXG5cdFx0dmFyIHZlcnRpY2VzID0gW107IC8vIGZsYXQgYXJyYXkgb2YgdmVydGljZXMgbGlrZSBbIHgwLHkwLCB4MSx5MSwgeDIseTIsIC4uLiBdXHJcblx0XHR2YXIgaG9sZUluZGljZXMgPSBbXTsgLy8gYXJyYXkgb2YgaG9sZSBpbmRpY2VzXHJcblx0XHR2YXIgZmFjZXMgPSBbXTsgLy8gZmluYWwgYXJyYXkgb2YgdmVydGV4IGluZGljZXMgbGlrZSBbIFsgYSxiLGQgXSwgWyBiLGMsZCBdIF1cclxuXHJcblx0XHRyZW1vdmVEdXBFbmRQdHMoIGNvbnRvdXIgKTtcclxuXHRcdGFkZENvbnRvdXIoIHZlcnRpY2VzLCBjb250b3VyICk7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHR2YXIgaG9sZUluZGV4ID0gY29udG91ci5sZW5ndGg7XHJcblxyXG5cdFx0aG9sZXMuZm9yRWFjaCggcmVtb3ZlRHVwRW5kUHRzICk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgaG9sZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0aG9sZUluZGljZXMucHVzaCggaG9sZUluZGV4ICk7XHJcblx0XHRcdGhvbGVJbmRleCArPSBob2xlc1sgaSBdLmxlbmd0aDtcclxuXHRcdFx0YWRkQ29udG91ciggdmVydGljZXMsIGhvbGVzWyBpIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHR2YXIgdHJpYW5nbGVzID0gRWFyY3V0LnRyaWFuZ3VsYXRlKCB2ZXJ0aWNlcywgaG9sZUluZGljZXMgKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdGZhY2VzLnB1c2goIHRyaWFuZ2xlcy5zbGljZSggaSwgaSArIDMgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZmFjZXM7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5mdW5jdGlvbiByZW1vdmVEdXBFbmRQdHMoIHBvaW50cyApIHtcclxuXHJcblx0dmFyIGwgPSBwb2ludHMubGVuZ3RoO1xyXG5cclxuXHRpZiAoIGwgPiAyICYmIHBvaW50c1sgbCAtIDEgXS5lcXVhbHMoIHBvaW50c1sgMCBdICkgKSB7XHJcblxyXG5cdFx0cG9pbnRzLnBvcCgpO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRDb250b3VyKCB2ZXJ0aWNlcywgY29udG91ciApIHtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgY29udG91ci5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0dmVydGljZXMucHVzaCggY29udG91clsgaSBdLnggKTtcclxuXHRcdHZlcnRpY2VzLnB1c2goIGNvbnRvdXJbIGkgXS55ICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IFNoYXBlVXRpbHMgfTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICpcclxuICogQ3JlYXRlcyBleHRydWRlZCBnZW9tZXRyeSBmcm9tIGEgcGF0aCBzaGFwZS5cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICpcclxuICogIGN1cnZlU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXNcclxuICogIHN0ZXBzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBmb3Igei1zaWRlIGV4dHJ1c2lvbnMgLyB1c2VkIGZvciBzdWJkaXZpZGluZyBzZWdtZW50cyBvZiBleHRydWRlIHNwbGluZSB0b29cclxuICogIGRlcHRoOiA8ZmxvYXQ+LCAvLyBEZXB0aCB0byBleHRydWRlIHRoZSBzaGFwZVxyXG4gKlxyXG4gKiAgYmV2ZWxFbmFibGVkOiA8Ym9vbD4sIC8vIHR1cm4gb24gYmV2ZWxcclxuICogIGJldmVsVGhpY2tuZXNzOiA8ZmxvYXQ+LCAvLyBob3cgZGVlcCBpbnRvIHRoZSBvcmlnaW5hbCBzaGFwZSBiZXZlbCBnb2VzXHJcbiAqICBiZXZlbFNpemU6IDxmbG9hdD4sIC8vIGhvdyBmYXIgZnJvbSBzaGFwZSBvdXRsaW5lIGlzIGJldmVsXHJcbiAqICBiZXZlbFNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIGJldmVsIGxheWVyc1xyXG4gKlxyXG4gKiAgZXh0cnVkZVBhdGg6IDxDT09MLkN1cnZlPiAvLyBjdXJ2ZSB0byBleHRydWRlIHNoYXBlIGFsb25nXHJcbiAqXHJcbiAqICBVVkdlbmVyYXRvcjogPE9iamVjdD4gLy8gb2JqZWN0IHRoYXQgcHJvdmlkZXMgVVYgZ2VuZXJhdG9yIGZ1bmN0aW9uc1xyXG4gKlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgR2VvbWV0cnkgfSBmcm9tICcuL0dlb21ldHJ5LmpzJztcclxuaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuL0J1ZmZlckdlb21ldHJ5LmpzJztcclxuaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4vQnVmZmVyQXR0cmlidXRlLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uL21hdGgvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWxzIH0gZnJvbSAnLi4vZXh0cmFzL1NoYXBlVXRpbHMuanMnO1xyXG5cclxuLy8gRXh0cnVkZUdlb21ldHJ5XHJcblxyXG5mdW5jdGlvbiBFeHRydWRlR2VvbWV0cnkoIHNoYXBlcywgb3B0aW9ucyApIHtcclxuXHJcblx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnRXh0cnVkZUdlb21ldHJ5JztcclxuXHJcblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0c2hhcGVzOiBzaGFwZXMsXHJcblx0XHRvcHRpb25zOiBvcHRpb25zXHJcblx0fTtcclxuXHJcblx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBFeHRydWRlQnVmZmVyR2VvbWV0cnkoIHNoYXBlcywgb3B0aW9ucyApICk7XHJcblx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XHJcblxyXG59XHJcblxyXG5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XHJcbkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFeHRydWRlR2VvbWV0cnk7XHJcblxyXG5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIGRhdGEgPSBHZW9tZXRyeS5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dmFyIHNoYXBlcyA9IHRoaXMucGFyYW1ldGVycy5zaGFwZXM7XHJcblx0dmFyIG9wdGlvbnMgPSB0aGlzLnBhcmFtZXRlcnMub3B0aW9ucztcclxuXHJcblx0cmV0dXJuIHRvSlNPTiggc2hhcGVzLCBvcHRpb25zLCBkYXRhICk7XHJcblxyXG59O1xyXG5cclxuLy8gRXh0cnVkZUJ1ZmZlckdlb21ldHJ5XHJcblxyXG5mdW5jdGlvbiBFeHRydWRlQnVmZmVyR2VvbWV0cnkoIHNoYXBlcywgb3B0aW9ucyApIHtcclxuXHJcblx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnRXh0cnVkZUJ1ZmZlckdlb21ldHJ5JztcclxuXHJcblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0c2hhcGVzOiBzaGFwZXMsXHJcblx0XHRvcHRpb25zOiBvcHRpb25zXHJcblx0fTtcclxuXHJcblx0c2hhcGVzID0gQXJyYXkuaXNBcnJheSggc2hhcGVzICkgPyBzaGFwZXMgOiBbIHNoYXBlcyBdO1xyXG5cclxuXHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHR2YXIgdmVydGljZXNBcnJheSA9IFtdO1xyXG5cdHZhciB1dkFycmF5ID0gW107XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdHZhciBzaGFwZSA9IHNoYXBlc1sgaSBdO1xyXG5cdFx0YWRkU2hhcGUoIHNoYXBlICk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gYnVpbGQgZ2VvbWV0cnlcclxuXHJcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlc0FycmF5LCAzICkgKTtcclxuXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2QXJyYXksIDIgKSApO1xyXG5cclxuXHR0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XHJcblxyXG5cdC8vIGZ1bmN0aW9uc1xyXG5cclxuXHRmdW5jdGlvbiBhZGRTaGFwZSggc2hhcGUgKSB7XHJcblxyXG5cdFx0dmFyIHBsYWNlaG9sZGVyID0gW107XHJcblxyXG5cdFx0Ly8gb3B0aW9uc1xyXG5cclxuXHRcdHZhciBjdXJ2ZVNlZ21lbnRzID0gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmN1cnZlU2VnbWVudHMgOiAxMjtcclxuXHRcdHZhciBzdGVwcyA9IG9wdGlvbnMuc3RlcHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3RlcHMgOiAxO1xyXG5cdFx0dmFyIGRlcHRoID0gb3B0aW9ucy5kZXB0aCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZXB0aCA6IDEwMDtcclxuXHJcblx0XHR2YXIgYmV2ZWxFbmFibGVkID0gb3B0aW9ucy5iZXZlbEVuYWJsZWQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxFbmFibGVkIDogdHJ1ZTtcclxuXHRcdHZhciBiZXZlbFRoaWNrbmVzcyA9IG9wdGlvbnMuYmV2ZWxUaGlja25lc3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxUaGlja25lc3MgOiA2O1xyXG5cdFx0dmFyIGJldmVsU2l6ZSA9IG9wdGlvbnMuYmV2ZWxTaXplICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsU2l6ZSA6IGJldmVsVGhpY2tuZXNzIC0gMjtcclxuXHRcdHZhciBiZXZlbFNlZ21lbnRzID0gb3B0aW9ucy5iZXZlbFNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsU2VnbWVudHMgOiAzO1xyXG5cclxuXHRcdHZhciBleHRydWRlUGF0aCA9IG9wdGlvbnMuZXh0cnVkZVBhdGg7XHJcblxyXG5cdFx0dmFyIHV2Z2VuID0gb3B0aW9ucy5VVkdlbmVyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5VVkdlbmVyYXRvciA6IFdvcmxkVVZHZW5lcmF0b3I7XHJcblxyXG5cdFx0Ly8gZGVwcmVjYXRlZCBvcHRpb25zXHJcblxyXG5cdFx0aWYgKCBvcHRpb25zLmFtb3VudCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5FeHRydWRlQnVmZmVyR2VvbWV0cnk6IGFtb3VudCBoYXMgYmVlbiByZW5hbWVkIHRvIGRlcHRoLicgKTtcclxuXHRcdFx0ZGVwdGggPSBvcHRpb25zLmFtb3VudDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHR2YXIgZXh0cnVkZVB0cywgZXh0cnVkZUJ5UGF0aCA9IGZhbHNlO1xyXG5cdFx0dmFyIHNwbGluZVR1YmUsIGJpbm9ybWFsLCBub3JtYWwsIHBvc2l0aW9uMjtcclxuXHJcblx0XHRpZiAoIGV4dHJ1ZGVQYXRoICkge1xyXG5cclxuXHRcdFx0ZXh0cnVkZVB0cyA9IGV4dHJ1ZGVQYXRoLmdldFNwYWNlZFBvaW50cyggc3RlcHMgKTtcclxuXHJcblx0XHRcdGV4dHJ1ZGVCeVBhdGggPSB0cnVlO1xyXG5cdFx0XHRiZXZlbEVuYWJsZWQgPSBmYWxzZTsgLy8gYmV2ZWxzIG5vdCBzdXBwb3J0ZWQgZm9yIHBhdGggZXh0cnVzaW9uXHJcblxyXG5cdFx0XHQvLyBTRVRVUCBUTkIgdmFyaWFibGVzXHJcblxyXG5cdFx0XHQvLyBUT0RPMSAtIGhhdmUgYSAuaXNDbG9zZWQgaW4gc3BsaW5lP1xyXG5cclxuXHRcdFx0c3BsaW5lVHViZSA9IGV4dHJ1ZGVQYXRoLmNvbXB1dGVGcmVuZXRGcmFtZXMoIHN0ZXBzLCBmYWxzZSApO1xyXG5cclxuXHRcdFx0Ly8gY29uc29sZS5sb2coc3BsaW5lVHViZSwgJ3NwbGluZVR1YmUnLCBzcGxpbmVUdWJlLm5vcm1hbHMubGVuZ3RoLCAnc3RlcHMnLCBzdGVwcywgJ2V4dHJ1ZGVQdHMnLCBleHRydWRlUHRzLmxlbmd0aCk7XHJcblxyXG5cdFx0XHRiaW5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHBvc2l0aW9uMiA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNhZmVndWFyZHMgaWYgYmV2ZWxzIGFyZSBub3QgZW5hYmxlZFxyXG5cclxuXHRcdGlmICggISBiZXZlbEVuYWJsZWQgKSB7XHJcblxyXG5cdFx0XHRiZXZlbFNlZ21lbnRzID0gMDtcclxuXHRcdFx0YmV2ZWxUaGlja25lc3MgPSAwO1xyXG5cdFx0XHRiZXZlbFNpemUgPSAwO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBWYXJpYWJsZXMgaW5pdGlhbGl6YXRpb25cclxuXHJcblx0XHR2YXIgYWhvbGUsIGgsIGhsOyAvLyBsb29waW5nIG9mIGhvbGVzXHJcblxyXG5cdFx0dmFyIHNoYXBlUG9pbnRzID0gc2hhcGUuZXh0cmFjdFBvaW50cyggY3VydmVTZWdtZW50cyApO1xyXG5cclxuXHRcdHZhciB2ZXJ0aWNlcyA9IHNoYXBlUG9pbnRzLnNoYXBlO1xyXG5cdFx0dmFyIGhvbGVzID0gc2hhcGVQb2ludHMuaG9sZXM7XHJcblxyXG5cdFx0dmFyIHJldmVyc2UgPSAhIFNoYXBlVXRpbHMuaXNDbG9ja1dpc2UoIHZlcnRpY2VzICk7XHJcblxyXG5cdFx0aWYgKCByZXZlcnNlICkge1xyXG5cclxuXHRcdFx0dmVydGljZXMgPSB2ZXJ0aWNlcy5yZXZlcnNlKCk7XHJcblxyXG5cdFx0XHQvLyBNYXliZSB3ZSBzaG91bGQgYWxzbyBjaGVjayBpZiBob2xlcyBhcmUgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiwganVzdCB0byBiZSBzYWZlIC4uLlxyXG5cclxuXHRcdFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XHJcblxyXG5cdFx0XHRcdGFob2xlID0gaG9sZXNbIGggXTtcclxuXHJcblx0XHRcdFx0aWYgKCBTaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKCBhaG9sZSApICkge1xyXG5cclxuXHRcdFx0XHRcdGhvbGVzWyBoIF0gPSBhaG9sZS5yZXZlcnNlKCk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHRcdHZhciBmYWNlcyA9IFNoYXBlVXRpbHMudHJpYW5ndWxhdGVTaGFwZSggdmVydGljZXMsIGhvbGVzICk7XHJcblxyXG5cdFx0LyogVmVydGljZXMgKi9cclxuXHJcblx0XHR2YXIgY29udG91ciA9IHZlcnRpY2VzOyAvLyB2ZXJ0aWNlcyBoYXMgYWxsIHBvaW50cyBidXQgY29udG91ciBoYXMgb25seSBwb2ludHMgb2YgY2lyY3VtZmVyZW5jZVxyXG5cclxuXHRcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xyXG5cclxuXHRcdFx0YWhvbGUgPSBob2xlc1sgaCBdO1xyXG5cclxuXHRcdFx0dmVydGljZXMgPSB2ZXJ0aWNlcy5jb25jYXQoIGFob2xlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHJcblx0XHRmdW5jdGlvbiBzY2FsZVB0MiggcHQsIHZlYywgc2l6ZSApIHtcclxuXHJcblx0XHRcdGlmICggISB2ZWMgKSBjb25zb2xlLmVycm9yKCBcIkNPT0wuRXh0cnVkZUdlb21ldHJ5OiB2ZWMgZG9lcyBub3QgZXhpc3RcIiApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHZlYy5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKCBzaXplICkuYWRkKCBwdCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYiwgYnMsIHQsIHosXHJcblx0XHRcdHZlcnQsIHZsZW4gPSB2ZXJ0aWNlcy5sZW5ndGgsXHJcblx0XHRcdGZhY2UsIGZsZW4gPSBmYWNlcy5sZW5ndGg7XHJcblxyXG5cclxuXHRcdC8vIEZpbmQgZGlyZWN0aW9ucyBmb3IgcG9pbnQgbW92ZW1lbnRcclxuXHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2V0QmV2ZWxWZWMoIGluUHQsIGluUHJldiwgaW5OZXh0ICkge1xyXG5cclxuXHRcdFx0Ly8gY29tcHV0ZXMgZm9yIGluUHQgdGhlIGNvcnJlc3BvbmRpbmcgcG9pbnQgaW5QdCcgb24gYSBuZXcgY29udG91clxyXG5cdFx0XHQvLyAgIHNoaWZ0ZWQgYnkgMSB1bml0IChsZW5ndGggb2Ygbm9ybWFsaXplZCB2ZWN0b3IpIHRvIHRoZSBsZWZ0XHJcblx0XHRcdC8vIGlmIHdlIHdhbGsgYWxvbmcgY29udG91ciBjbG9ja3dpc2UsIHRoaXMgbmV3IGNvbnRvdXIgaXMgb3V0c2lkZSB0aGUgb2xkIG9uZVxyXG5cdFx0XHQvL1xyXG5cdFx0XHQvLyBpblB0JyBpcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSB0d28gbGluZXMgcGFyYWxsZWwgdG8gdGhlIHR3b1xyXG5cdFx0XHQvLyAgYWRqYWNlbnQgZWRnZXMgb2YgaW5QdCBhdCBhIGRpc3RhbmNlIG9mIDEgdW5pdCBvbiB0aGUgbGVmdCBzaWRlLlxyXG5cclxuXHRcdFx0dmFyIHZfdHJhbnNfeCwgdl90cmFuc195LCBzaHJpbmtfYnk7IC8vIHJlc3VsdGluZyB0cmFuc2xhdGlvbiB2ZWN0b3IgZm9yIGluUHRcclxuXHJcblx0XHRcdC8vIGdvb2QgcmVhZGluZyBmb3IgZ2VvbWV0cnkgYWxnb3JpdGhtcyAoaGVyZTogbGluZS1saW5lIGludGVyc2VjdGlvbilcclxuXHRcdFx0Ly8gaHR0cDovL2dlb21hbGdvcml0aG1zLmNvbS9hMDUtX2ludGVyc2VjdC0xLmh0bWxcclxuXHJcblx0XHRcdHZhciB2X3ByZXZfeCA9IGluUHQueCAtIGluUHJldi54LFxyXG5cdFx0XHRcdHZfcHJldl95ID0gaW5QdC55IC0gaW5QcmV2Lnk7XHJcblx0XHRcdHZhciB2X25leHRfeCA9IGluTmV4dC54IC0gaW5QdC54LFxyXG5cdFx0XHRcdHZfbmV4dF95ID0gaW5OZXh0LnkgLSBpblB0Lnk7XHJcblxyXG5cdFx0XHR2YXIgdl9wcmV2X2xlbnNxID0gKCB2X3ByZXZfeCAqIHZfcHJldl94ICsgdl9wcmV2X3kgKiB2X3ByZXZfeSApO1xyXG5cclxuXHRcdFx0Ly8gY2hlY2sgZm9yIGNvbGxpbmVhciBlZGdlc1xyXG5cdFx0XHR2YXIgY29sbGluZWFyMCA9ICggdl9wcmV2X3ggKiB2X25leHRfeSAtIHZfcHJldl95ICogdl9uZXh0X3ggKTtcclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIGNvbGxpbmVhcjAgKSA+IE51bWJlci5FUFNJTE9OICkge1xyXG5cclxuXHRcdFx0XHQvLyBub3QgY29sbGluZWFyXHJcblxyXG5cdFx0XHRcdC8vIGxlbmd0aCBvZiB2ZWN0b3JzIGZvciBub3JtYWxpemluZ1xyXG5cclxuXHRcdFx0XHR2YXIgdl9wcmV2X2xlbiA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxICk7XHJcblx0XHRcdFx0dmFyIHZfbmV4dF9sZW4gPSBNYXRoLnNxcnQoIHZfbmV4dF94ICogdl9uZXh0X3ggKyB2X25leHRfeSAqIHZfbmV4dF95ICk7XHJcblxyXG5cdFx0XHRcdC8vIHNoaWZ0IGFkamFjZW50IHBvaW50cyBieSB1bml0IHZlY3RvcnMgdG8gdGhlIGxlZnRcclxuXHJcblx0XHRcdFx0dmFyIHB0UHJldlNoaWZ0X3ggPSAoIGluUHJldi54IC0gdl9wcmV2X3kgLyB2X3ByZXZfbGVuICk7XHJcblx0XHRcdFx0dmFyIHB0UHJldlNoaWZ0X3kgPSAoIGluUHJldi55ICsgdl9wcmV2X3ggLyB2X3ByZXZfbGVuICk7XHJcblxyXG5cdFx0XHRcdHZhciBwdE5leHRTaGlmdF94ID0gKCBpbk5leHQueCAtIHZfbmV4dF95IC8gdl9uZXh0X2xlbiApO1xyXG5cdFx0XHRcdHZhciBwdE5leHRTaGlmdF95ID0gKCBpbk5leHQueSArIHZfbmV4dF94IC8gdl9uZXh0X2xlbiApO1xyXG5cclxuXHRcdFx0XHQvLyBzY2FsaW5nIGZhY3RvciBmb3Igdl9wcmV2IHRvIGludGVyc2VjdGlvbiBwb2ludFxyXG5cclxuXHRcdFx0XHR2YXIgc2YgPSAoICggcHROZXh0U2hpZnRfeCAtIHB0UHJldlNoaWZ0X3ggKSAqIHZfbmV4dF95IC1cclxuXHRcdFx0XHRcdFx0KCBwdE5leHRTaGlmdF95IC0gcHRQcmV2U2hpZnRfeSApICogdl9uZXh0X3ggKSAvXHJcblx0XHRcdFx0XHQoIHZfcHJldl94ICogdl9uZXh0X3kgLSB2X3ByZXZfeSAqIHZfbmV4dF94ICk7XHJcblxyXG5cdFx0XHRcdC8vIHZlY3RvciBmcm9tIGluUHQgdG8gaW50ZXJzZWN0aW9uIHBvaW50XHJcblxyXG5cdFx0XHRcdHZfdHJhbnNfeCA9ICggcHRQcmV2U2hpZnRfeCArIHZfcHJldl94ICogc2YgLSBpblB0LnggKTtcclxuXHRcdFx0XHR2X3RyYW5zX3kgPSAoIHB0UHJldlNoaWZ0X3kgKyB2X3ByZXZfeSAqIHNmIC0gaW5QdC55ICk7XHJcblxyXG5cdFx0XHRcdC8vIERvbid0IG5vcm1hbGl6ZSEsIG90aGVyd2lzZSBzaGFycCBjb3JuZXJzIGJlY29tZSB1Z2x5XHJcblx0XHRcdFx0Ly8gIGJ1dCBwcmV2ZW50IGNyYXp5IHNwaWtlc1xyXG5cdFx0XHRcdHZhciB2X3RyYW5zX2xlbnNxID0gKCB2X3RyYW5zX3ggKiB2X3RyYW5zX3ggKyB2X3RyYW5zX3kgKiB2X3RyYW5zX3kgKTtcclxuXHRcdFx0XHRpZiAoIHZfdHJhbnNfbGVuc3EgPD0gMiApIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFZlY3RvcjIoIHZfdHJhbnNfeCwgdl90cmFuc195ICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0c2hyaW5rX2J5ID0gTWF0aC5zcXJ0KCB2X3RyYW5zX2xlbnNxIC8gMiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyBoYW5kbGUgc3BlY2lhbCBjYXNlIG9mIGNvbGxpbmVhciBlZGdlc1xyXG5cclxuXHRcdFx0XHR2YXIgZGlyZWN0aW9uX2VxID0gZmFsc2U7IC8vIGFzc3VtZXM6IG9wcG9zaXRlXHJcblx0XHRcdFx0aWYgKCB2X3ByZXZfeCA+IE51bWJlci5FUFNJTE9OICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggdl9uZXh0X3ggPiBOdW1iZXIuRVBTSUxPTiApIHtcclxuXHJcblx0XHRcdFx0XHRcdGRpcmVjdGlvbl9lcSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGlmICggdl9wcmV2X3ggPCAtIE51bWJlci5FUFNJTE9OICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCB2X25leHRfeCA8IC0gTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGRpcmVjdGlvbl9lcSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggTWF0aC5zaWduKCB2X3ByZXZfeSApID09PSBNYXRoLnNpZ24oIHZfbmV4dF95ICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGRpcmVjdGlvbl9lcSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggZGlyZWN0aW9uX2VxICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiV2FybmluZzogbGluZXMgYXJlIGEgc3RyYWlnaHQgc2VxdWVuY2VcIik7XHJcblx0XHRcdFx0XHR2X3RyYW5zX3ggPSAtIHZfcHJldl95O1xyXG5cdFx0XHRcdFx0dl90cmFuc195ID0gdl9wcmV2X3g7XHJcblx0XHRcdFx0XHRzaHJpbmtfYnkgPSBNYXRoLnNxcnQoIHZfcHJldl9sZW5zcSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiV2FybmluZzogbGluZXMgYXJlIGEgc3RyYWlnaHQgc3Bpa2VcIik7XHJcblx0XHRcdFx0XHR2X3RyYW5zX3ggPSB2X3ByZXZfeDtcclxuXHRcdFx0XHRcdHZfdHJhbnNfeSA9IHZfcHJldl95O1xyXG5cdFx0XHRcdFx0c2hyaW5rX2J5ID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgLyAyICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBuZXcgVmVjdG9yMiggdl90cmFuc194IC8gc2hyaW5rX2J5LCB2X3RyYW5zX3kgLyBzaHJpbmtfYnkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHRcdHZhciBjb250b3VyTW92ZW1lbnRzID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoLCBqID0gaWwgLSAxLCBrID0gaSArIDE7IGkgPCBpbDsgaSArKywgaiArKywgayArKyApIHtcclxuXHJcblx0XHRcdGlmICggaiA9PT0gaWwgKSBqID0gMDtcclxuXHRcdFx0aWYgKCBrID09PSBpbCApIGsgPSAwO1xyXG5cclxuXHRcdFx0Ly8gIChqKS0tLShpKS0tLShrKVxyXG5cdFx0XHQvLyBjb25zb2xlLmxvZygnaSxqLGsnLCBpLCBqICwgaylcclxuXHJcblx0XHRcdGNvbnRvdXJNb3ZlbWVudHNbIGkgXSA9IGdldEJldmVsVmVjKCBjb250b3VyWyBpIF0sIGNvbnRvdXJbIGogXSwgY29udG91clsgayBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBob2xlc01vdmVtZW50cyA9IFtdLFxyXG5cdFx0XHRvbmVIb2xlTW92ZW1lbnRzLCB2ZXJ0aWNlc01vdmVtZW50cyA9IGNvbnRvdXJNb3ZlbWVudHMuY29uY2F0KCk7XHJcblxyXG5cdFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XHJcblxyXG5cdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XHJcblxyXG5cdFx0XHRvbmVIb2xlTW92ZW1lbnRzID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGgsIGogPSBpbCAtIDEsIGsgPSBpICsgMTsgaSA8IGlsOyBpICsrLCBqICsrLCBrICsrICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGogPT09IGlsICkgaiA9IDA7XHJcblx0XHRcdFx0aWYgKCBrID09PSBpbCApIGsgPSAwO1xyXG5cclxuXHRcdFx0XHQvLyAgKGopLS0tKGkpLS0tKGspXHJcblx0XHRcdFx0b25lSG9sZU1vdmVtZW50c1sgaSBdID0gZ2V0QmV2ZWxWZWMoIGFob2xlWyBpIF0sIGFob2xlWyBqIF0sIGFob2xlWyBrIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGhvbGVzTW92ZW1lbnRzLnB1c2goIG9uZUhvbGVNb3ZlbWVudHMgKTtcclxuXHRcdFx0dmVydGljZXNNb3ZlbWVudHMgPSB2ZXJ0aWNlc01vdmVtZW50cy5jb25jYXQoIG9uZUhvbGVNb3ZlbWVudHMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHRcdC8vIExvb3AgYmV2ZWxTZWdtZW50cywgMSBmb3IgdGhlIGZyb250LCAxIGZvciB0aGUgYmFja1xyXG5cclxuXHRcdGZvciAoIGIgPSAwOyBiIDwgYmV2ZWxTZWdtZW50czsgYiArKyApIHtcclxuXHJcblx0XHRcdC8vZm9yICggYiA9IGJldmVsU2VnbWVudHM7IGIgPiAwOyBiIC0tICkge1xyXG5cclxuXHRcdFx0dCA9IGIgLyBiZXZlbFNlZ21lbnRzO1xyXG5cdFx0XHR6ID0gYmV2ZWxUaGlja25lc3MgKiBNYXRoLmNvcyggdCAqIE1hdGguUEkgLyAyICk7XHJcblx0XHRcdGJzID0gYmV2ZWxTaXplICogTWF0aC5zaW4oIHQgKiBNYXRoLlBJIC8gMiApO1xyXG5cclxuXHRcdFx0Ly8gY29udHJhY3Qgc2hhcGVcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZlcnQgPSBzY2FsZVB0MiggY29udG91clsgaSBdLCBjb250b3VyTW92ZW1lbnRzWyBpIF0sIGJzICk7XHJcblxyXG5cdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAtIHogKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGV4cGFuZCBob2xlc1xyXG5cclxuXHRcdFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XHJcblxyXG5cdFx0XHRcdGFob2xlID0gaG9sZXNbIGggXTtcclxuXHRcdFx0XHRvbmVIb2xlTW92ZW1lbnRzID0gaG9sZXNNb3ZlbWVudHNbIGggXTtcclxuXHJcblx0XHRcdFx0Zm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmVydCA9IHNjYWxlUHQyKCBhaG9sZVsgaSBdLCBvbmVIb2xlTW92ZW1lbnRzWyBpIF0sIGJzICk7XHJcblxyXG5cdFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksIC0geiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGJzID0gYmV2ZWxTaXplO1xyXG5cclxuXHRcdC8vIEJhY2sgZmFjaW5nIHZlcnRpY2VzXHJcblxyXG5cdFx0Zm9yICggaSA9IDA7IGkgPCB2bGVuOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmVydCA9IGJldmVsRW5hYmxlZCA/IHNjYWxlUHQyKCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc01vdmVtZW50c1sgaSBdLCBicyApIDogdmVydGljZXNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggISBleHRydWRlQnlQYXRoICkge1xyXG5cclxuXHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgMCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gdiggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyAwIF0ueSwgZXh0cnVkZVB0c1sgMCBdLnggKTtcclxuXHJcblx0XHRcdFx0bm9ybWFsLmNvcHkoIHNwbGluZVR1YmUubm9ybWFsc1sgMCBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueCApO1xyXG5cdFx0XHRcdGJpbm9ybWFsLmNvcHkoIHNwbGluZVR1YmUuYmlub3JtYWxzWyAwIF0gKS5tdWx0aXBseVNjYWxhciggdmVydC55ICk7XHJcblxyXG5cdFx0XHRcdHBvc2l0aW9uMi5jb3B5KCBleHRydWRlUHRzWyAwIF0gKS5hZGQoIG5vcm1hbCApLmFkZCggYmlub3JtYWwgKTtcclxuXHJcblx0XHRcdFx0diggcG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBBZGQgc3RlcHBlZCB2ZXJ0aWNlcy4uLlxyXG5cdFx0Ly8gSW5jbHVkaW5nIGZyb250IGZhY2luZyB2ZXJ0aWNlc1xyXG5cclxuXHRcdHZhciBzO1xyXG5cclxuXHRcdGZvciAoIHMgPSAxOyBzIDw9IHN0ZXBzOyBzICsrICkge1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCB2bGVuOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2ZXJ0ID0gYmV2ZWxFbmFibGVkID8gc2NhbGVQdDIoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzTW92ZW1lbnRzWyBpIF0sIGJzICkgOiB2ZXJ0aWNlc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcclxuXHJcblx0XHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgZGVwdGggLyBzdGVwcyAqIHMgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHQvLyB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIHMgLSAxIF0ueSwgZXh0cnVkZVB0c1sgcyAtIDEgXS54ICk7XHJcblxyXG5cdFx0XHRcdFx0bm9ybWFsLmNvcHkoIHNwbGluZVR1YmUubm9ybWFsc1sgcyBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueCApO1xyXG5cdFx0XHRcdFx0Ymlub3JtYWwuY29weSggc3BsaW5lVHViZS5iaW5vcm1hbHNbIHMgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnkgKTtcclxuXHJcblx0XHRcdFx0XHRwb3NpdGlvbjIuY29weSggZXh0cnVkZVB0c1sgcyBdICkuYWRkKCBub3JtYWwgKS5hZGQoIGJpbm9ybWFsICk7XHJcblxyXG5cdFx0XHRcdFx0diggcG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHJcblx0XHQvLyBBZGQgYmV2ZWwgc2VnbWVudHMgcGxhbmVzXHJcblxyXG5cdFx0Ly9mb3IgKCBiID0gMTsgYiA8PSBiZXZlbFNlZ21lbnRzOyBiICsrICkge1xyXG5cdFx0Zm9yICggYiA9IGJldmVsU2VnbWVudHMgLSAxOyBiID49IDA7IGIgLS0gKSB7XHJcblxyXG5cdFx0XHR0ID0gYiAvIGJldmVsU2VnbWVudHM7XHJcblx0XHRcdHogPSBiZXZlbFRoaWNrbmVzcyAqIE1hdGguY29zKCB0ICogTWF0aC5QSSAvIDIgKTtcclxuXHRcdFx0YnMgPSBiZXZlbFNpemUgKiBNYXRoLnNpbiggdCAqIE1hdGguUEkgLyAyICk7XHJcblxyXG5cdFx0XHQvLyBjb250cmFjdCBzaGFwZVxyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmVydCA9IHNjYWxlUHQyKCBjb250b3VyWyBpIF0sIGNvbnRvdXJNb3ZlbWVudHNbIGkgXSwgYnMgKTtcclxuXHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgZGVwdGggKyB6ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBleHBhbmQgaG9sZXNcclxuXHJcblx0XHRcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xyXG5cclxuXHRcdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XHJcblx0XHRcdFx0b25lSG9sZU1vdmVtZW50cyA9IGhvbGVzTW92ZW1lbnRzWyBoIF07XHJcblxyXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZlcnQgPSBzY2FsZVB0MiggYWhvbGVbIGkgXSwgb25lSG9sZU1vdmVtZW50c1sgaSBdLCBicyApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggISBleHRydWRlQnlQYXRoICkge1xyXG5cclxuXHRcdFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksIGRlcHRoICsgeiApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIHN0ZXBzIC0gMSBdLnksIGV4dHJ1ZGVQdHNbIHN0ZXBzIC0gMSBdLnggKyB6ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8qIEZhY2VzICovXHJcblxyXG5cdFx0Ly8gVG9wIGFuZCBib3R0b20gZmFjZXNcclxuXHJcblx0XHRidWlsZExpZEZhY2VzKCk7XHJcblxyXG5cdFx0Ly8gU2lkZXMgZmFjZXNcclxuXHJcblx0XHRidWlsZFNpZGVGYWNlcygpO1xyXG5cclxuXHJcblx0XHQvLy8vLyAgSW50ZXJuYWwgZnVuY3Rpb25zXHJcblxyXG5cdFx0ZnVuY3Rpb24gYnVpbGRMaWRGYWNlcygpIHtcclxuXHJcblx0XHRcdHZhciBzdGFydCA9IHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMztcclxuXHJcblx0XHRcdGlmICggYmV2ZWxFbmFibGVkICkge1xyXG5cclxuXHRcdFx0XHR2YXIgbGF5ZXIgPSAwOyAvLyBzdGVwcyArIDFcclxuXHRcdFx0XHR2YXIgb2Zmc2V0ID0gdmxlbiAqIGxheWVyO1xyXG5cclxuXHRcdFx0XHQvLyBCb3R0b20gZmFjZXNcclxuXHJcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cdFx0XHRcdFx0ZjMoIGZhY2VbIDIgXSArIG9mZnNldCwgZmFjZVsgMSBdICsgb2Zmc2V0LCBmYWNlWyAwIF0gKyBvZmZzZXQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRsYXllciA9IHN0ZXBzICsgYmV2ZWxTZWdtZW50cyAqIDI7XHJcblx0XHRcdFx0b2Zmc2V0ID0gdmxlbiAqIGxheWVyO1xyXG5cclxuXHRcdFx0XHQvLyBUb3AgZmFjZXNcclxuXHJcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cdFx0XHRcdFx0ZjMoIGZhY2VbIDAgXSArIG9mZnNldCwgZmFjZVsgMSBdICsgb2Zmc2V0LCBmYWNlWyAyIF0gKyBvZmZzZXQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gQm90dG9tIGZhY2VzXHJcblxyXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRmYWNlID0gZmFjZXNbIGkgXTtcclxuXHRcdFx0XHRcdGYzKCBmYWNlWyAyIF0sIGZhY2VbIDEgXSwgZmFjZVsgMCBdICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gVG9wIGZhY2VzXHJcblxyXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRmYWNlID0gZmFjZXNbIGkgXTtcclxuXHRcdFx0XHRcdGYzKCBmYWNlWyAwIF0gKyB2bGVuICogc3RlcHMsIGZhY2VbIDEgXSArIHZsZW4gKiBzdGVwcywgZmFjZVsgMiBdICsgdmxlbiAqIHN0ZXBzICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHNjb3BlLmFkZEdyb3VwKCBzdGFydCwgdmVydGljZXNBcnJheS5sZW5ndGggLyAzIC0gc3RhcnQsIDAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ3JlYXRlIGZhY2VzIGZvciB0aGUgei1zaWRlcyBvZiB0aGUgc2hhcGVcclxuXHJcblx0XHRmdW5jdGlvbiBidWlsZFNpZGVGYWNlcygpIHtcclxuXHJcblx0XHRcdHZhciBzdGFydCA9IHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMztcclxuXHRcdFx0dmFyIGxheWVyb2Zmc2V0ID0gMDtcclxuXHRcdFx0c2lkZXdhbGxzKCBjb250b3VyLCBsYXllcm9mZnNldCApO1xyXG5cdFx0XHRsYXllcm9mZnNldCArPSBjb250b3VyLmxlbmd0aDtcclxuXHJcblx0XHRcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xyXG5cclxuXHRcdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XHJcblx0XHRcdFx0c2lkZXdhbGxzKCBhaG9sZSwgbGF5ZXJvZmZzZXQgKTtcclxuXHJcblx0XHRcdFx0Ly8sIHRydWVcclxuXHRcdFx0XHRsYXllcm9mZnNldCArPSBhaG9sZS5sZW5ndGg7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0c2NvcGUuYWRkR3JvdXAoIHN0YXJ0LCB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDMgLSBzdGFydCwgMSApO1xyXG5cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gc2lkZXdhbGxzKCBjb250b3VyLCBsYXllcm9mZnNldCApIHtcclxuXHJcblx0XHRcdHZhciBqLCBrO1xyXG5cdFx0XHRpID0gY29udG91ci5sZW5ndGg7XHJcblxyXG5cdFx0XHR3aGlsZSAoIC0tIGkgPj0gMCApIHtcclxuXHJcblx0XHRcdFx0aiA9IGk7XHJcblx0XHRcdFx0ayA9IGkgLSAxO1xyXG5cdFx0XHRcdGlmICggayA8IDAgKSBrID0gY29udG91ci5sZW5ndGggLSAxO1xyXG5cclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdiJywgaSxqLCBpLTEsIGssdmVydGljZXMubGVuZ3RoKTtcclxuXHJcblx0XHRcdFx0dmFyIHMgPSAwLFxyXG5cdFx0XHRcdFx0c2wgPSBzdGVwcyArIGJldmVsU2VnbWVudHMgKiAyO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBzID0gMDsgcyA8IHNsOyBzICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBzbGVuMSA9IHZsZW4gKiBzO1xyXG5cdFx0XHRcdFx0dmFyIHNsZW4yID0gdmxlbiAqICggcyArIDEgKTtcclxuXHJcblx0XHRcdFx0XHR2YXIgYSA9IGxheWVyb2Zmc2V0ICsgaiArIHNsZW4xLFxyXG5cdFx0XHRcdFx0XHRiID0gbGF5ZXJvZmZzZXQgKyBrICsgc2xlbjEsXHJcblx0XHRcdFx0XHRcdGMgPSBsYXllcm9mZnNldCArIGsgKyBzbGVuMixcclxuXHRcdFx0XHRcdFx0ZCA9IGxheWVyb2Zmc2V0ICsgaiArIHNsZW4yO1xyXG5cclxuXHRcdFx0XHRcdGY0KCBhLCBiLCBjLCBkICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gdiggeCwgeSwgeiApIHtcclxuXHJcblx0XHRcdHBsYWNlaG9sZGVyLnB1c2goIHggKTtcclxuXHRcdFx0cGxhY2Vob2xkZXIucHVzaCggeSApO1xyXG5cdFx0XHRwbGFjZWhvbGRlci5wdXNoKCB6ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHJcblx0XHRmdW5jdGlvbiBmMyggYSwgYiwgYyApIHtcclxuXHJcblx0XHRcdGFkZFZlcnRleCggYSApO1xyXG5cdFx0XHRhZGRWZXJ0ZXgoIGIgKTtcclxuXHRcdFx0YWRkVmVydGV4KCBjICk7XHJcblxyXG5cdFx0XHR2YXIgbmV4dEluZGV4ID0gdmVydGljZXNBcnJheS5sZW5ndGggLyAzO1xyXG5cdFx0XHR2YXIgdXZzID0gdXZnZW4uZ2VuZXJhdGVUb3BVViggc2NvcGUsIHZlcnRpY2VzQXJyYXksIG5leHRJbmRleCAtIDMsIG5leHRJbmRleCAtIDIsIG5leHRJbmRleCAtIDEgKTtcclxuXHJcblx0XHRcdGFkZFVWKCB1dnNbIDAgXSApO1xyXG5cdFx0XHRhZGRVViggdXZzWyAxIF0gKTtcclxuXHRcdFx0YWRkVVYoIHV2c1sgMiBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGY0KCBhLCBiLCBjLCBkICkge1xyXG5cclxuXHRcdFx0YWRkVmVydGV4KCBhICk7XHJcblx0XHRcdGFkZFZlcnRleCggYiApO1xyXG5cdFx0XHRhZGRWZXJ0ZXgoIGQgKTtcclxuXHJcblx0XHRcdGFkZFZlcnRleCggYiApO1xyXG5cdFx0XHRhZGRWZXJ0ZXgoIGMgKTtcclxuXHRcdFx0YWRkVmVydGV4KCBkICk7XHJcblxyXG5cclxuXHRcdFx0dmFyIG5leHRJbmRleCA9IHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMztcclxuXHRcdFx0dmFyIHV2cyA9IHV2Z2VuLmdlbmVyYXRlU2lkZVdhbGxVViggc2NvcGUsIHZlcnRpY2VzQXJyYXksIG5leHRJbmRleCAtIDYsIG5leHRJbmRleCAtIDMsIG5leHRJbmRleCAtIDIsIG5leHRJbmRleCAtIDEgKTtcclxuXHJcblx0XHRcdGFkZFVWKCB1dnNbIDAgXSApO1xyXG5cdFx0XHRhZGRVViggdXZzWyAxIF0gKTtcclxuXHRcdFx0YWRkVVYoIHV2c1sgMyBdICk7XHJcblxyXG5cdFx0XHRhZGRVViggdXZzWyAxIF0gKTtcclxuXHRcdFx0YWRkVVYoIHV2c1sgMiBdICk7XHJcblx0XHRcdGFkZFVWKCB1dnNbIDMgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBhZGRWZXJ0ZXgoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0dmVydGljZXNBcnJheS5wdXNoKCBwbGFjZWhvbGRlclsgaW5kZXggKiAzICsgMCBdICk7XHJcblx0XHRcdHZlcnRpY2VzQXJyYXkucHVzaCggcGxhY2Vob2xkZXJbIGluZGV4ICogMyArIDEgXSApO1xyXG5cdFx0XHR2ZXJ0aWNlc0FycmF5LnB1c2goIHBsYWNlaG9sZGVyWyBpbmRleCAqIDMgKyAyIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHRcdGZ1bmN0aW9uIGFkZFVWKCB2ZWN0b3IyICkge1xyXG5cclxuXHRcdFx0dXZBcnJheS5wdXNoKCB2ZWN0b3IyLnggKTtcclxuXHRcdFx0dXZBcnJheS5wdXNoKCB2ZWN0b3IyLnkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbkV4dHJ1ZGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuRXh0cnVkZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeTtcclxuXHJcbkV4dHJ1ZGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgZGF0YSA9IEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xyXG5cclxuXHR2YXIgc2hhcGVzID0gdGhpcy5wYXJhbWV0ZXJzLnNoYXBlcztcclxuXHR2YXIgb3B0aW9ucyA9IHRoaXMucGFyYW1ldGVycy5vcHRpb25zO1xyXG5cclxuXHRyZXR1cm4gdG9KU09OKCBzaGFwZXMsIG9wdGlvbnMsIGRhdGEgKTtcclxuXHJcbn07XHJcblxyXG4vL1xyXG5cclxudmFyIFdvcmxkVVZHZW5lcmF0b3IgPSB7XHJcblxyXG5cdGdlbmVyYXRlVG9wVVY6IGZ1bmN0aW9uICggZ2VvbWV0cnksIHZlcnRpY2VzLCBpbmRleEEsIGluZGV4QiwgaW5kZXhDICkge1xyXG5cclxuXHRcdHZhciBhX3ggPSB2ZXJ0aWNlc1sgaW5kZXhBICogMyBdO1xyXG5cdFx0dmFyIGFfeSA9IHZlcnRpY2VzWyBpbmRleEEgKiAzICsgMSBdO1xyXG5cdFx0dmFyIGJfeCA9IHZlcnRpY2VzWyBpbmRleEIgKiAzIF07XHJcblx0XHR2YXIgYl95ID0gdmVydGljZXNbIGluZGV4QiAqIDMgKyAxIF07XHJcblx0XHR2YXIgY194ID0gdmVydGljZXNbIGluZGV4QyAqIDMgXTtcclxuXHRcdHZhciBjX3kgPSB2ZXJ0aWNlc1sgaW5kZXhDICogMyArIDEgXTtcclxuXHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHRuZXcgVmVjdG9yMiggYV94LCBhX3kgKSxcclxuXHRcdFx0bmV3IFZlY3RvcjIoIGJfeCwgYl95ICksXHJcblx0XHRcdG5ldyBWZWN0b3IyKCBjX3gsIGNfeSApXHJcblx0XHRdO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZVNpZGVXYWxsVVY6IGZ1bmN0aW9uICggZ2VvbWV0cnksIHZlcnRpY2VzLCBpbmRleEEsIGluZGV4QiwgaW5kZXhDLCBpbmRleEQgKSB7XHJcblxyXG5cdFx0dmFyIGFfeCA9IHZlcnRpY2VzWyBpbmRleEEgKiAzIF07XHJcblx0XHR2YXIgYV95ID0gdmVydGljZXNbIGluZGV4QSAqIDMgKyAxIF07XHJcblx0XHR2YXIgYV96ID0gdmVydGljZXNbIGluZGV4QSAqIDMgKyAyIF07XHJcblx0XHR2YXIgYl94ID0gdmVydGljZXNbIGluZGV4QiAqIDMgXTtcclxuXHRcdHZhciBiX3kgPSB2ZXJ0aWNlc1sgaW5kZXhCICogMyArIDEgXTtcclxuXHRcdHZhciBiX3ogPSB2ZXJ0aWNlc1sgaW5kZXhCICogMyArIDIgXTtcclxuXHRcdHZhciBjX3ggPSB2ZXJ0aWNlc1sgaW5kZXhDICogMyBdO1xyXG5cdFx0dmFyIGNfeSA9IHZlcnRpY2VzWyBpbmRleEMgKiAzICsgMSBdO1xyXG5cdFx0dmFyIGNfeiA9IHZlcnRpY2VzWyBpbmRleEMgKiAzICsgMiBdO1xyXG5cdFx0dmFyIGRfeCA9IHZlcnRpY2VzWyBpbmRleEQgKiAzIF07XHJcblx0XHR2YXIgZF95ID0gdmVydGljZXNbIGluZGV4RCAqIDMgKyAxIF07XHJcblx0XHR2YXIgZF96ID0gdmVydGljZXNbIGluZGV4RCAqIDMgKyAyIF07XHJcblxyXG5cdFx0aWYgKCBNYXRoLmFicyggYV95IC0gYl95ICkgPCAwLjAxICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIFtcclxuXHRcdFx0XHRuZXcgVmVjdG9yMiggYV94LCAxIC0gYV96ICksXHJcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGJfeCwgMSAtIGJfeiApLFxyXG5cdFx0XHRcdG5ldyBWZWN0b3IyKCBjX3gsIDEgLSBjX3ogKSxcclxuXHRcdFx0XHRuZXcgVmVjdG9yMiggZF94LCAxIC0gZF96IClcclxuXHRcdFx0XTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cmV0dXJuIFtcclxuXHRcdFx0XHRuZXcgVmVjdG9yMiggYV95LCAxIC0gYV96ICksXHJcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGJfeSwgMSAtIGJfeiApLFxyXG5cdFx0XHRcdG5ldyBWZWN0b3IyKCBjX3ksIDEgLSBjX3ogKSxcclxuXHRcdFx0XHRuZXcgVmVjdG9yMiggZF95LCAxIC0gZF96IClcclxuXHRcdFx0XTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIHRvSlNPTiggc2hhcGVzLCBvcHRpb25zLCBkYXRhICkge1xyXG5cclxuXHQvL1xyXG5cclxuXHRkYXRhLnNoYXBlcyA9IFtdO1xyXG5cclxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIHNoYXBlcyApICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHNoYXBlID0gc2hhcGVzWyBpIF07XHJcblxyXG5cdFx0XHRkYXRhLnNoYXBlcy5wdXNoKCBzaGFwZS51dWlkICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdGRhdGEuc2hhcGVzLnB1c2goIHNoYXBlcy51dWlkICk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly9cclxuXHJcblx0aWYgKCBvcHRpb25zLmV4dHJ1ZGVQYXRoICE9PSB1bmRlZmluZWQgKSBkYXRhLm9wdGlvbnMuZXh0cnVkZVBhdGggPSBvcHRpb25zLmV4dHJ1ZGVQYXRoLnRvSlNPTigpO1xyXG5cclxuXHRyZXR1cm4gZGF0YTtcclxuXHJcbn1cclxuXHJcblxyXG5leHBvcnQgeyBFeHRydWRlR2VvbWV0cnksIEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeSB9O1xyXG4iLCJpbXBvcnQgeyBfTWF0aCB9IGZyb20gJy4uLy4uL21hdGgvTWF0aC5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5pbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi4vLi4vbWF0aC9NYXRyaXg0LmpzJztcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqIEV4dGVuc2libGUgY3VydmUgb2JqZWN0XHJcbiAqXHJcbiAqIFNvbWUgY29tbW9uIG9mIGN1cnZlIG1ldGhvZHM6XHJcbiAqIC5nZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgKSwgLmdldFRhbmdlbnQoIHQgKVxyXG4gKiAuZ2V0UG9pbnRBdCggdSwgb3B0aW9uYWxUYXJnZXQgKSwgLmdldFRhbmdlbnRBdCggdSApXHJcbiAqIC5nZXRQb2ludHMoKSwgLmdldFNwYWNlZFBvaW50cygpXHJcbiAqIC5nZXRMZW5ndGgoKVxyXG4gKiAudXBkYXRlQXJjTGVuZ3RocygpXHJcbiAqXHJcbiAqIFRoaXMgZm9sbG93aW5nIGN1cnZlcyBpbmhlcml0IGZyb20gQ09PTC5DdXJ2ZTpcclxuICpcclxuICogLS0gMkQgY3VydmVzIC0tXHJcbiAqIENPT0wuQXJjQ3VydmVcclxuICogQ09PTC5DdWJpY0JlemllckN1cnZlXHJcbiAqIENPT0wuRWxsaXBzZUN1cnZlXHJcbiAqIENPT0wuTGluZUN1cnZlXHJcbiAqIENPT0wuUXVhZHJhdGljQmV6aWVyQ3VydmVcclxuICogQ09PTC5TcGxpbmVDdXJ2ZVxyXG4gKlxyXG4gKiAtLSAzRCBjdXJ2ZXMgLS1cclxuICogQ09PTC5DYXRtdWxsUm9tQ3VydmUzXHJcbiAqIENPT0wuQ3ViaWNCZXppZXJDdXJ2ZTNcclxuICogQ09PTC5MaW5lQ3VydmUzXHJcbiAqIENPT0wuUXVhZHJhdGljQmV6aWVyQ3VydmUzXHJcbiAqXHJcbiAqIEEgc2VyaWVzIG9mIGN1cnZlcyBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgYSBDT09MLkN1cnZlUGF0aC5cclxuICpcclxuICoqL1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRBYnN0cmFjdCBDdXJ2ZSBiYXNlIGNsYXNzXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcbmZ1bmN0aW9uIEN1cnZlKCkge1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnQ3VydmUnO1xyXG5cclxuXHR0aGlzLmFyY0xlbmd0aERpdmlzaW9ucyA9IDIwMDtcclxuXHJcbn1cclxuXHJcbk9iamVjdC5hc3NpZ24oIEN1cnZlLnByb3RvdHlwZSwge1xyXG5cclxuXHQvLyBWaXJ0dWFsIGJhc2UgY2xhc3MgbWV0aG9kIHRvIG92ZXJ3cml0ZSBhbmQgaW1wbGVtZW50IGluIHN1YmNsYXNzZXNcclxuXHQvL1x0LSB0IFswIC4uIDFdXHJcblxyXG5cdGdldFBvaW50OiBmdW5jdGlvbiAoIC8qIHQsIG9wdGlvbmFsVGFyZ2V0ICovICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ0NPT0wuQ3VydmU6IC5nZXRQb2ludCgpIG5vdCBpbXBsZW1lbnRlZC4nICk7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gR2V0IHBvaW50IGF0IHJlbGF0aXZlIHBvc2l0aW9uIGluIGN1cnZlIGFjY29yZGluZyB0byBhcmMgbGVuZ3RoXHJcblx0Ly8gLSB1IFswIC4uIDFdXHJcblxyXG5cdGdldFBvaW50QXQ6IGZ1bmN0aW9uICggdSwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHQgPSB0aGlzLmdldFV0b1RtYXBwaW5nKCB1ICk7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gR2V0IHNlcXVlbmNlIG9mIHBvaW50cyB1c2luZyBnZXRQb2ludCggdCApXHJcblxyXG5cdGdldFBvaW50czogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XHJcblxyXG5cdFx0aWYgKCBkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCApIGRpdmlzaW9ucyA9IDU7XHJcblxyXG5cdFx0dmFyIHBvaW50cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBkID0gMDsgZCA8PSBkaXZpc2lvbnM7IGQgKysgKSB7XHJcblxyXG5cdFx0XHRwb2ludHMucHVzaCggdGhpcy5nZXRQb2ludCggZCAvIGRpdmlzaW9ucyApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwb2ludHM7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIEdldCBzZXF1ZW5jZSBvZiBwb2ludHMgdXNpbmcgZ2V0UG9pbnRBdCggdSApXHJcblxyXG5cdGdldFNwYWNlZFBvaW50czogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XHJcblxyXG5cdFx0aWYgKCBkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCApIGRpdmlzaW9ucyA9IDU7XHJcblxyXG5cdFx0dmFyIHBvaW50cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBkID0gMDsgZCA8PSBkaXZpc2lvbnM7IGQgKysgKSB7XHJcblxyXG5cdFx0XHRwb2ludHMucHVzaCggdGhpcy5nZXRQb2ludEF0KCBkIC8gZGl2aXNpb25zICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHBvaW50cztcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gR2V0IHRvdGFsIGN1cnZlIGFyYyBsZW5ndGhcclxuXHJcblx0Z2V0TGVuZ3RoOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGxlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcclxuXHRcdHJldHVybiBsZW5ndGhzWyBsZW5ndGhzLmxlbmd0aCAtIDEgXTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gR2V0IGxpc3Qgb2YgY3VtdWxhdGl2ZSBzZWdtZW50IGxlbmd0aHNcclxuXHJcblx0Z2V0TGVuZ3RoczogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XHJcblxyXG5cdFx0aWYgKCBkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCApIGRpdmlzaW9ucyA9IHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zO1xyXG5cclxuXHRcdGlmICggdGhpcy5jYWNoZUFyY0xlbmd0aHMgJiZcclxuXHRcdFx0KCB0aGlzLmNhY2hlQXJjTGVuZ3Rocy5sZW5ndGggPT09IGRpdmlzaW9ucyArIDEgKSAmJlxyXG5cdFx0XHQhIHRoaXMubmVlZHNVcGRhdGUgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5jYWNoZUFyY0xlbmd0aHM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHR2YXIgY2FjaGUgPSBbXTtcclxuXHRcdHZhciBjdXJyZW50LCBsYXN0ID0gdGhpcy5nZXRQb2ludCggMCApO1xyXG5cdFx0dmFyIHAsIHN1bSA9IDA7XHJcblxyXG5cdFx0Y2FjaGUucHVzaCggMCApO1xyXG5cclxuXHRcdGZvciAoIHAgPSAxOyBwIDw9IGRpdmlzaW9uczsgcCArKyApIHtcclxuXHJcblx0XHRcdGN1cnJlbnQgPSB0aGlzLmdldFBvaW50KCBwIC8gZGl2aXNpb25zICk7XHJcblx0XHRcdHN1bSArPSBjdXJyZW50LmRpc3RhbmNlVG8oIGxhc3QgKTtcclxuXHRcdFx0Y2FjaGUucHVzaCggc3VtICk7XHJcblx0XHRcdGxhc3QgPSBjdXJyZW50O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmNhY2hlQXJjTGVuZ3RocyA9IGNhY2hlO1xyXG5cclxuXHRcdHJldHVybiBjYWNoZTsgLy8geyBzdW1zOiBjYWNoZSwgc3VtOiBzdW0gfTsgU3VtIGlzIGluIHRoZSBsYXN0IGVsZW1lbnQuXHJcblxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUFyY0xlbmd0aHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHRcdHRoaXMuZ2V0TGVuZ3RocygpO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBHaXZlbiB1ICggMCAuLiAxICksIGdldCBhIHQgdG8gZmluZCBwLiBUaGlzIGdpdmVzIHlvdSBwb2ludHMgd2hpY2ggYXJlIGVxdWlkaXN0YW50XHJcblxyXG5cdGdldFV0b1RtYXBwaW5nOiBmdW5jdGlvbiAoIHUsIGRpc3RhbmNlICkge1xyXG5cclxuXHRcdHZhciBhcmNMZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzKCk7XHJcblxyXG5cdFx0dmFyIGkgPSAwLCBpbCA9IGFyY0xlbmd0aHMubGVuZ3RoO1xyXG5cclxuXHRcdHZhciB0YXJnZXRBcmNMZW5ndGg7IC8vIFRoZSB0YXJnZXRlZCB1IGRpc3RhbmNlIHZhbHVlIHRvIGdldFxyXG5cclxuXHRcdGlmICggZGlzdGFuY2UgKSB7XHJcblxyXG5cdFx0XHR0YXJnZXRBcmNMZW5ndGggPSBkaXN0YW5jZTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGFyZ2V0QXJjTGVuZ3RoID0gdSAqIGFyY0xlbmd0aHNbIGlsIC0gMSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBiaW5hcnkgc2VhcmNoIGZvciB0aGUgaW5kZXggd2l0aCBsYXJnZXN0IHZhbHVlIHNtYWxsZXIgdGhhbiB0YXJnZXQgdSBkaXN0YW5jZVxyXG5cclxuXHRcdHZhciBsb3cgPSAwLCBoaWdoID0gaWwgLSAxLCBjb21wYXJpc29uO1xyXG5cclxuXHRcdHdoaWxlICggbG93IDw9IGhpZ2ggKSB7XHJcblxyXG5cdFx0XHRpID0gTWF0aC5mbG9vciggbG93ICsgKCBoaWdoIC0gbG93ICkgLyAyICk7IC8vIGxlc3MgbGlrZWx5IHRvIG92ZXJmbG93LCB0aG91Z2ggcHJvYmFibHkgbm90IGlzc3VlIGhlcmUsIEpTIGRvZXNuJ3QgcmVhbGx5IGhhdmUgaW50ZWdlcnMsIGFsbCBudW1iZXJzIGFyZSBmbG9hdHNcclxuXHJcblx0XHRcdGNvbXBhcmlzb24gPSBhcmNMZW5ndGhzWyBpIF0gLSB0YXJnZXRBcmNMZW5ndGg7XHJcblxyXG5cdFx0XHRpZiAoIGNvbXBhcmlzb24gPCAwICkge1xyXG5cclxuXHRcdFx0XHRsb3cgPSBpICsgMTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBhcmlzb24gPiAwICkge1xyXG5cclxuXHRcdFx0XHRoaWdoID0gaSAtIDE7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRoaWdoID0gaTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Ly8gRE9ORVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpID0gaGlnaDtcclxuXHJcblx0XHRpZiAoIGFyY0xlbmd0aHNbIGkgXSA9PT0gdGFyZ2V0QXJjTGVuZ3RoICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGkgLyAoIGlsIC0gMSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyB3ZSBjb3VsZCBnZXQgZmluZXIgZ3JhaW4gYXQgbGVuZ3Rocywgb3IgdXNlIHNpbXBsZSBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHBvaW50c1xyXG5cclxuXHRcdHZhciBsZW5ndGhCZWZvcmUgPSBhcmNMZW5ndGhzWyBpIF07XHJcblx0XHR2YXIgbGVuZ3RoQWZ0ZXIgPSBhcmNMZW5ndGhzWyBpICsgMSBdO1xyXG5cclxuXHRcdHZhciBzZWdtZW50TGVuZ3RoID0gbGVuZ3RoQWZ0ZXIgLSBsZW5ndGhCZWZvcmU7XHJcblxyXG5cdFx0Ly8gZGV0ZXJtaW5lIHdoZXJlIHdlIGFyZSBiZXR3ZWVuIHRoZSAnYmVmb3JlJyBhbmQgJ2FmdGVyJyBwb2ludHNcclxuXHJcblx0XHR2YXIgc2VnbWVudEZyYWN0aW9uID0gKCB0YXJnZXRBcmNMZW5ndGggLSBsZW5ndGhCZWZvcmUgKSAvIHNlZ21lbnRMZW5ndGg7XHJcblxyXG5cdFx0Ly8gYWRkIHRoYXQgZnJhY3Rpb25hbCBhbW91bnQgdG8gdFxyXG5cclxuXHRcdHZhciB0ID0gKCBpICsgc2VnbWVudEZyYWN0aW9uICkgLyAoIGlsIC0gMSApO1xyXG5cclxuXHRcdHJldHVybiB0O1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBSZXR1cm5zIGEgdW5pdCB2ZWN0b3IgdGFuZ2VudCBhdCB0XHJcblx0Ly8gSW4gY2FzZSBhbnkgc3ViIGN1cnZlIGRvZXMgbm90IGltcGxlbWVudCBpdHMgdGFuZ2VudCBkZXJpdmF0aW9uLFxyXG5cdC8vIDIgcG9pbnRzIGEgc21hbGwgZGVsdGEgYXBhcnQgd2lsbCBiZSB1c2VkIHRvIGZpbmQgaXRzIGdyYWRpZW50XHJcblx0Ly8gd2hpY2ggc2VlbXMgdG8gZ2l2ZSBhIHJlYXNvbmFibGUgYXBwcm94aW1hdGlvblxyXG5cclxuXHRnZXRUYW5nZW50OiBmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG5cdFx0dmFyIGRlbHRhID0gMC4wMDAxO1xyXG5cdFx0dmFyIHQxID0gdCAtIGRlbHRhO1xyXG5cdFx0dmFyIHQyID0gdCArIGRlbHRhO1xyXG5cclxuXHRcdC8vIENhcHBpbmcgaW4gY2FzZSBvZiBkYW5nZXJcclxuXHJcblx0XHRpZiAoIHQxIDwgMCApIHQxID0gMDtcclxuXHRcdGlmICggdDIgPiAxICkgdDIgPSAxO1xyXG5cclxuXHRcdHZhciBwdDEgPSB0aGlzLmdldFBvaW50KCB0MSApO1xyXG5cdFx0dmFyIHB0MiA9IHRoaXMuZ2V0UG9pbnQoIHQyICk7XHJcblxyXG5cdFx0dmFyIHZlYyA9IHB0Mi5jbG9uZSgpLnN1YiggcHQxICk7XHJcblx0XHRyZXR1cm4gdmVjLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRUYW5nZW50QXQ6IGZ1bmN0aW9uICggdSApIHtcclxuXHJcblx0XHR2YXIgdCA9IHRoaXMuZ2V0VXRvVG1hcHBpbmcoIHUgKTtcclxuXHRcdHJldHVybiB0aGlzLmdldFRhbmdlbnQoIHQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29tcHV0ZUZyZW5ldEZyYW1lczogZnVuY3Rpb24gKCBzZWdtZW50cywgY2xvc2VkICkge1xyXG5cclxuXHRcdC8vIHNlZSBodHRwOi8vd3d3LmNzLmluZGlhbmEuZWR1L3B1Yi90ZWNocmVwb3J0cy9UUjQyNS5wZGZcclxuXHJcblx0XHR2YXIgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHR2YXIgdGFuZ2VudHMgPSBbXTtcclxuXHRcdHZhciBub3JtYWxzID0gW107XHJcblx0XHR2YXIgYmlub3JtYWxzID0gW107XHJcblxyXG5cdFx0dmFyIHZlYyA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHR2YXIgbWF0ID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHR2YXIgaSwgdSwgdGhldGE7XHJcblxyXG5cdFx0Ly8gY29tcHV0ZSB0aGUgdGFuZ2VudCB2ZWN0b3JzIGZvciBlYWNoIHNlZ21lbnQgb24gdGhlIGN1cnZlXHJcblxyXG5cdFx0Zm9yICggaSA9IDA7IGkgPD0gc2VnbWVudHM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR1ID0gaSAvIHNlZ21lbnRzO1xyXG5cclxuXHRcdFx0dGFuZ2VudHNbIGkgXSA9IHRoaXMuZ2V0VGFuZ2VudEF0KCB1ICk7XHJcblx0XHRcdHRhbmdlbnRzWyBpIF0ubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHNlbGVjdCBhbiBpbml0aWFsIG5vcm1hbCB2ZWN0b3IgcGVycGVuZGljdWxhciB0byB0aGUgZmlyc3QgdGFuZ2VudCB2ZWN0b3IsXHJcblx0XHQvLyBhbmQgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgbWluaW11bSB0YW5nZW50IHh5eiBjb21wb25lbnRcclxuXHJcblx0XHRub3JtYWxzWyAwIF0gPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0Ymlub3JtYWxzWyAwIF0gPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0dmFyIG1pbiA9IE51bWJlci5NQVhfVkFMVUU7XHJcblx0XHR2YXIgdHggPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS54ICk7XHJcblx0XHR2YXIgdHkgPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS55ICk7XHJcblx0XHR2YXIgdHogPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS56ICk7XHJcblxyXG5cdFx0aWYgKCB0eCA8PSBtaW4gKSB7XHJcblxyXG5cdFx0XHRtaW4gPSB0eDtcclxuXHRcdFx0bm9ybWFsLnNldCggMSwgMCwgMCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHR5IDw9IG1pbiApIHtcclxuXHJcblx0XHRcdG1pbiA9IHR5O1xyXG5cdFx0XHRub3JtYWwuc2V0KCAwLCAxLCAwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdHogPD0gbWluICkge1xyXG5cclxuXHRcdFx0bm9ybWFsLnNldCggMCwgMCwgMSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2ZWMuY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWwgKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCB2ZWMgKTtcclxuXHRcdGJpbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICk7XHJcblxyXG5cclxuXHRcdC8vIGNvbXB1dGUgdGhlIHNsb3dseS12YXJ5aW5nIG5vcm1hbCBhbmQgYmlub3JtYWwgdmVjdG9ycyBmb3IgZWFjaCBzZWdtZW50IG9uIHRoZSBjdXJ2ZVxyXG5cclxuXHRcdGZvciAoIGkgPSAxOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xyXG5cclxuXHRcdFx0bm9ybWFsc1sgaSBdID0gbm9ybWFsc1sgaSAtIDEgXS5jbG9uZSgpO1xyXG5cclxuXHRcdFx0Ymlub3JtYWxzWyBpIF0gPSBiaW5vcm1hbHNbIGkgLSAxIF0uY2xvbmUoKTtcclxuXHJcblx0XHRcdHZlYy5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIC0gMSBdLCB0YW5nZW50c1sgaSBdICk7XHJcblxyXG5cdFx0XHRpZiAoIHZlYy5sZW5ndGgoKSA+IE51bWJlci5FUFNJTE9OICkge1xyXG5cclxuXHRcdFx0XHR2ZWMubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHRcdHRoZXRhID0gTWF0aC5hY29zKCBfTWF0aC5jbGFtcCggdGFuZ2VudHNbIGkgLSAxIF0uZG90KCB0YW5nZW50c1sgaSBdICksIC0gMSwgMSApICk7IC8vIGNsYW1wIGZvciBmbG9hdGluZyBwdCBlcnJvcnNcclxuXHJcblx0XHRcdFx0bm9ybWFsc1sgaSBdLmFwcGx5TWF0cml4NCggbWF0Lm1ha2VSb3RhdGlvbkF4aXMoIHZlYywgdGhldGEgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ymlub3JtYWxzWyBpIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgaSBdLCBub3JtYWxzWyBpIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaWYgdGhlIGN1cnZlIGlzIGNsb3NlZCwgcG9zdHByb2Nlc3MgdGhlIHZlY3RvcnMgc28gdGhlIGZpcnN0IGFuZCBsYXN0IG5vcm1hbCB2ZWN0b3JzIGFyZSB0aGUgc2FtZVxyXG5cclxuXHRcdGlmICggY2xvc2VkID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0dGhldGEgPSBNYXRoLmFjb3MoIF9NYXRoLmNsYW1wKCBub3JtYWxzWyAwIF0uZG90KCBub3JtYWxzWyBzZWdtZW50cyBdICksIC0gMSwgMSApICk7XHJcblx0XHRcdHRoZXRhIC89IHNlZ21lbnRzO1xyXG5cclxuXHRcdFx0aWYgKCB0YW5nZW50c1sgMCBdLmRvdCggdmVjLmNyb3NzVmVjdG9ycyggbm9ybWFsc1sgMCBdLCBub3JtYWxzWyBzZWdtZW50cyBdICkgKSA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdHRoZXRhID0gLSB0aGV0YTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIGkgPSAxOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHQvLyB0d2lzdCBhIGxpdHRsZS4uLlxyXG5cdFx0XHRcdG5vcm1hbHNbIGkgXS5hcHBseU1hdHJpeDQoIG1hdC5tYWtlUm90YXRpb25BeGlzKCB0YW5nZW50c1sgaSBdLCB0aGV0YSAqIGkgKSApO1xyXG5cdFx0XHRcdGJpbm9ybWFsc1sgaSBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgXSwgbm9ybWFsc1sgaSBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHRhbmdlbnRzOiB0YW5nZW50cyxcclxuXHRcdFx0bm9ybWFsczogbm9ybWFscyxcclxuXHRcdFx0Ymlub3JtYWxzOiBiaW5vcm1hbHNcclxuXHRcdH07XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0XHR0aGlzLmFyY0xlbmd0aERpdmlzaW9ucyA9IHNvdXJjZS5hcmNMZW5ndGhEaXZpc2lvbnM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvSlNPTjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRtZXRhZGF0YToge1xyXG5cdFx0XHRcdHZlcnNpb246IDQuNSxcclxuXHRcdFx0XHR0eXBlOiAnQ3VydmUnLFxyXG5cdFx0XHRcdGdlbmVyYXRvcjogJ0N1cnZlLnRvSlNPTidcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHRkYXRhLmFyY0xlbmd0aERpdmlzaW9ucyA9IHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zO1xyXG5cdFx0ZGF0YS50eXBlID0gdGhpcy50eXBlO1xyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmcm9tSlNPTjogZnVuY3Rpb24gKCBqc29uICkge1xyXG5cclxuXHRcdHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zID0ganNvbi5hcmNMZW5ndGhEaXZpc2lvbnM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuXHJcblxyXG5leHBvcnQgeyBDdXJ2ZSB9O1xyXG4iLCJpbXBvcnQgeyBDdXJ2ZSB9IGZyb20gJy4uL2NvcmUvQ3VydmUuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IyLmpzJztcclxuXHJcblxyXG5mdW5jdGlvbiBFbGxpcHNlQ3VydmUoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICkge1xyXG5cclxuXHRDdXJ2ZS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdFbGxpcHNlQ3VydmUnO1xyXG5cclxuXHR0aGlzLmFYID0gYVggfHwgMDtcclxuXHR0aGlzLmFZID0gYVkgfHwgMDtcclxuXHJcblx0dGhpcy54UmFkaXVzID0geFJhZGl1cyB8fCAxO1xyXG5cdHRoaXMueVJhZGl1cyA9IHlSYWRpdXMgfHwgMTtcclxuXHJcblx0dGhpcy5hU3RhcnRBbmdsZSA9IGFTdGFydEFuZ2xlIHx8IDA7XHJcblx0dGhpcy5hRW5kQW5nbGUgPSBhRW5kQW5nbGUgfHwgMiAqIE1hdGguUEk7XHJcblxyXG5cdHRoaXMuYUNsb2Nrd2lzZSA9IGFDbG9ja3dpc2UgfHwgZmFsc2U7XHJcblxyXG5cdHRoaXMuYVJvdGF0aW9uID0gYVJvdGF0aW9uIHx8IDA7XHJcblxyXG59XHJcblxyXG5FbGxpcHNlQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XHJcbkVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFbGxpcHNlQ3VydmU7XHJcblxyXG5FbGxpcHNlQ3VydmUucHJvdG90eXBlLmlzRWxsaXBzZUN1cnZlID0gdHJ1ZTtcclxuXHJcbkVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHR2YXIgcG9pbnQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMigpO1xyXG5cclxuXHR2YXIgdHdvUGkgPSBNYXRoLlBJICogMjtcclxuXHR2YXIgZGVsdGFBbmdsZSA9IHRoaXMuYUVuZEFuZ2xlIC0gdGhpcy5hU3RhcnRBbmdsZTtcclxuXHR2YXIgc2FtZVBvaW50cyA9IE1hdGguYWJzKCBkZWx0YUFuZ2xlICkgPCBOdW1iZXIuRVBTSUxPTjtcclxuXHJcblx0Ly8gZW5zdXJlcyB0aGF0IGRlbHRhQW5nbGUgaXMgMCAuLiAyIFBJXHJcblx0d2hpbGUgKCBkZWx0YUFuZ2xlIDwgMCApIGRlbHRhQW5nbGUgKz0gdHdvUGk7XHJcblx0d2hpbGUgKCBkZWx0YUFuZ2xlID4gdHdvUGkgKSBkZWx0YUFuZ2xlIC09IHR3b1BpO1xyXG5cclxuXHRpZiAoIGRlbHRhQW5nbGUgPCBOdW1iZXIuRVBTSUxPTiApIHtcclxuXHJcblx0XHRpZiAoIHNhbWVQb2ludHMgKSB7XHJcblxyXG5cdFx0XHRkZWx0YUFuZ2xlID0gMDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0ZGVsdGFBbmdsZSA9IHR3b1BpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRpZiAoIHRoaXMuYUNsb2Nrd2lzZSA9PT0gdHJ1ZSAmJiAhIHNhbWVQb2ludHMgKSB7XHJcblxyXG5cdFx0aWYgKCBkZWx0YUFuZ2xlID09PSB0d29QaSApIHtcclxuXHJcblx0XHRcdGRlbHRhQW5nbGUgPSAtIHR3b1BpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRkZWx0YUFuZ2xlID0gZGVsdGFBbmdsZSAtIHR3b1BpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR2YXIgYW5nbGUgPSB0aGlzLmFTdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XHJcblx0dmFyIHggPSB0aGlzLmFYICsgdGhpcy54UmFkaXVzICogTWF0aC5jb3MoIGFuZ2xlICk7XHJcblx0dmFyIHkgPSB0aGlzLmFZICsgdGhpcy55UmFkaXVzICogTWF0aC5zaW4oIGFuZ2xlICk7XHJcblxyXG5cdGlmICggdGhpcy5hUm90YXRpb24gIT09IDAgKSB7XHJcblxyXG5cdFx0dmFyIGNvcyA9IE1hdGguY29zKCB0aGlzLmFSb3RhdGlvbiApO1xyXG5cdFx0dmFyIHNpbiA9IE1hdGguc2luKCB0aGlzLmFSb3RhdGlvbiApO1xyXG5cclxuXHRcdHZhciB0eCA9IHggLSB0aGlzLmFYO1xyXG5cdFx0dmFyIHR5ID0geSAtIHRoaXMuYVk7XHJcblxyXG5cdFx0Ly8gUm90YXRlIHRoZSBwb2ludCBhYm91dCB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlLlxyXG5cdFx0eCA9IHR4ICogY29zIC0gdHkgKiBzaW4gKyB0aGlzLmFYO1xyXG5cdFx0eSA9IHR4ICogc2luICsgdHkgKiBjb3MgKyB0aGlzLmFZO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBwb2ludC5zZXQoIHgsIHkgKTtcclxuXHJcbn07XHJcblxyXG5FbGxpcHNlQ3VydmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0Q3VydmUucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdHRoaXMuYVggPSBzb3VyY2UuYVg7XHJcblx0dGhpcy5hWSA9IHNvdXJjZS5hWTtcclxuXHJcblx0dGhpcy54UmFkaXVzID0gc291cmNlLnhSYWRpdXM7XHJcblx0dGhpcy55UmFkaXVzID0gc291cmNlLnlSYWRpdXM7XHJcblxyXG5cdHRoaXMuYVN0YXJ0QW5nbGUgPSBzb3VyY2UuYVN0YXJ0QW5nbGU7XHJcblx0dGhpcy5hRW5kQW5nbGUgPSBzb3VyY2UuYUVuZEFuZ2xlO1xyXG5cclxuXHR0aGlzLmFDbG9ja3dpc2UgPSBzb3VyY2UuYUNsb2Nrd2lzZTtcclxuXHJcblx0dGhpcy5hUm90YXRpb24gPSBzb3VyY2UuYVJvdGF0aW9uO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG5cclxuRWxsaXBzZUN1cnZlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBkYXRhID0gQ3VydmUucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XHJcblxyXG5cdGRhdGEuYVggPSB0aGlzLmFYO1xyXG5cdGRhdGEuYVkgPSB0aGlzLmFZO1xyXG5cclxuXHRkYXRhLnhSYWRpdXMgPSB0aGlzLnhSYWRpdXM7XHJcblx0ZGF0YS55UmFkaXVzID0gdGhpcy55UmFkaXVzO1xyXG5cclxuXHRkYXRhLmFTdGFydEFuZ2xlID0gdGhpcy5hU3RhcnRBbmdsZTtcclxuXHRkYXRhLmFFbmRBbmdsZSA9IHRoaXMuYUVuZEFuZ2xlO1xyXG5cclxuXHRkYXRhLmFDbG9ja3dpc2UgPSB0aGlzLmFDbG9ja3dpc2U7XHJcblxyXG5cdGRhdGEuYVJvdGF0aW9uID0gdGhpcy5hUm90YXRpb247XHJcblxyXG5cdHJldHVybiBkYXRhO1xyXG5cclxufTtcclxuXHJcbkVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04gPSBmdW5jdGlvbiAoIGpzb24gKSB7XHJcblxyXG5cdEN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTi5jYWxsKCB0aGlzLCBqc29uICk7XHJcblxyXG5cdHRoaXMuYVggPSBqc29uLmFYO1xyXG5cdHRoaXMuYVkgPSBqc29uLmFZO1xyXG5cclxuXHR0aGlzLnhSYWRpdXMgPSBqc29uLnhSYWRpdXM7XHJcblx0dGhpcy55UmFkaXVzID0ganNvbi55UmFkaXVzO1xyXG5cclxuXHR0aGlzLmFTdGFydEFuZ2xlID0ganNvbi5hU3RhcnRBbmdsZTtcclxuXHR0aGlzLmFFbmRBbmdsZSA9IGpzb24uYUVuZEFuZ2xlO1xyXG5cclxuXHR0aGlzLmFDbG9ja3dpc2UgPSBqc29uLmFDbG9ja3dpc2U7XHJcblxyXG5cdHRoaXMuYVJvdGF0aW9uID0ganNvbi5hUm90YXRpb247XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcblxyXG5leHBvcnQgeyBFbGxpcHNlQ3VydmUgfTtcclxuIiwiaW1wb3J0IHsgRWxsaXBzZUN1cnZlIH0gZnJvbSAnLi9FbGxpcHNlQ3VydmUuanMnO1xyXG5cclxuXHJcbmZ1bmN0aW9uIEFyY0N1cnZlKCBhWCwgYVksIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XHJcblxyXG5cdEVsbGlwc2VDdXJ2ZS5jYWxsKCB0aGlzLCBhWCwgYVksIGFSYWRpdXMsIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ0FyY0N1cnZlJztcclxuXHJcbn1cclxuXHJcbkFyY0N1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUgKTtcclxuQXJjQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXJjQ3VydmU7XHJcblxyXG5BcmNDdXJ2ZS5wcm90b3R5cGUuaXNBcmNDdXJ2ZSA9IHRydWU7XHJcblxyXG5cclxuZXhwb3J0IHsgQXJjQ3VydmUgfTtcclxuIiwiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMy5qcyc7XHJcbmltcG9ydCB7IEN1cnZlIH0gZnJvbSAnLi4vY29yZS9DdXJ2ZS5qcyc7XHJcblxyXG4vKipcclxuICogQGF1dGhvciB6ejg1IGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1XHJcbiAqXHJcbiAqIENlbnRyaXBldGFsIENhdG11bGxSb20gQ3VydmUgLSB3aGljaCBpcyB1c2VmdWwgZm9yIGF2b2lkaW5nXHJcbiAqIGN1c3BzIGFuZCBzZWxmLWludGVyc2VjdGlvbnMgaW4gbm9uLXVuaWZvcm0gY2F0bXVsbCByb20gY3VydmVzLlxyXG4gKiBodHRwOi8vd3d3LmNlbXl1a3NlbC5jb20vcmVzZWFyY2gvY2F0bXVsbHJvbV9wYXJhbS9jYXRtdWxscm9tLnBkZlxyXG4gKlxyXG4gKiBjdXJ2ZS50eXBlIGFjY2VwdHMgY2VudHJpcGV0YWwoZGVmYXVsdCksIGNob3JkYWwgYW5kIGNhdG11bGxyb21cclxuICogY3VydmUudGVuc2lvbiBpcyB1c2VkIGZvciBjYXRtdWxscm9tIHdoaWNoIGRlZmF1bHRzIHRvIDAuNVxyXG4gKi9cclxuXHJcblxyXG4vKlxyXG5CYXNlZCBvbiBhbiBvcHRpbWl6ZWQgYysrIHNvbHV0aW9uIGluXHJcbiAtIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTQ4OTczNi9jYXRtdWxsLXJvbS1jdXJ2ZS13aXRoLW5vLWN1c3BzLWFuZC1uby1zZWxmLWludGVyc2VjdGlvbnMvXHJcbiAtIGh0dHA6Ly9pZGVvbmUuY29tL05vRWJWTVxyXG5cclxuVGhpcyBDdWJpY1BvbHkgY2xhc3MgY291bGQgYmUgdXNlZCBmb3IgcmV1c2luZyBzb21lIHZhcmlhYmxlcyBhbmQgY2FsY3VsYXRpb25zLFxyXG5idXQgZm9yIENPT0wuanMgY3VydmUgdXNlLCBpdCBjb3VsZCBiZSBwb3NzaWJsZSBpbmxpbmVkIGFuZCBmbGF0dGVuIGludG8gYSBzaW5nbGUgZnVuY3Rpb24gY2FsbFxyXG53aGljaCBjYW4gYmUgcGxhY2VkIGluIEN1cnZlVXRpbHMuXHJcbiovXHJcblxyXG5mdW5jdGlvbiBDdWJpY1BvbHkoKSB7XHJcblxyXG5cdHZhciBjMCA9IDAsIGMxID0gMCwgYzIgPSAwLCBjMyA9IDA7XHJcblxyXG5cdC8qXHJcblx0ICogQ29tcHV0ZSBjb2VmZmljaWVudHMgZm9yIGEgY3ViaWMgcG9seW5vbWlhbFxyXG5cdCAqICAgcChzKSA9IGMwICsgYzEqcyArIGMyKnNeMiArIGMzKnNeM1xyXG5cdCAqIHN1Y2ggdGhhdFxyXG5cdCAqICAgcCgwKSA9IHgwLCBwKDEpID0geDFcclxuXHQgKiAgYW5kXHJcblx0ICogICBwJygwKSA9IHQwLCBwJygxKSA9IHQxLlxyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIGluaXQoIHgwLCB4MSwgdDAsIHQxICkge1xyXG5cclxuXHRcdGMwID0geDA7XHJcblx0XHRjMSA9IHQwO1xyXG5cdFx0YzIgPSAtIDMgKiB4MCArIDMgKiB4MSAtIDIgKiB0MCAtIHQxO1xyXG5cdFx0YzMgPSAyICogeDAgLSAyICogeDEgKyB0MCArIHQxO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiB7XHJcblxyXG5cdFx0aW5pdENhdG11bGxSb206IGZ1bmN0aW9uICggeDAsIHgxLCB4MiwgeDMsIHRlbnNpb24gKSB7XHJcblxyXG5cdFx0XHRpbml0KCB4MSwgeDIsIHRlbnNpb24gKiAoIHgyIC0geDAgKSwgdGVuc2lvbiAqICggeDMgLSB4MSApICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRpbml0Tm9udW5pZm9ybUNhdG11bGxSb206IGZ1bmN0aW9uICggeDAsIHgxLCB4MiwgeDMsIGR0MCwgZHQxLCBkdDIgKSB7XHJcblxyXG5cdFx0XHQvLyBjb21wdXRlIHRhbmdlbnRzIHdoZW4gcGFyYW1ldGVyaXplZCBpbiBbdDEsdDJdXHJcblx0XHRcdHZhciB0MSA9ICggeDEgLSB4MCApIC8gZHQwIC0gKCB4MiAtIHgwICkgLyAoIGR0MCArIGR0MSApICsgKCB4MiAtIHgxICkgLyBkdDE7XHJcblx0XHRcdHZhciB0MiA9ICggeDIgLSB4MSApIC8gZHQxIC0gKCB4MyAtIHgxICkgLyAoIGR0MSArIGR0MiApICsgKCB4MyAtIHgyICkgLyBkdDI7XHJcblxyXG5cdFx0XHQvLyByZXNjYWxlIHRhbmdlbnRzIGZvciBwYXJhbWV0cml6YXRpb24gaW4gWzAsMV1cclxuXHRcdFx0dDEgKj0gZHQxO1xyXG5cdFx0XHR0MiAqPSBkdDE7XHJcblxyXG5cdFx0XHRpbml0KCB4MSwgeDIsIHQxLCB0MiApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y2FsYzogZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHRcdFx0dmFyIHQyID0gdCAqIHQ7XHJcblx0XHRcdHZhciB0MyA9IHQyICogdDtcclxuXHRcdFx0cmV0dXJuIGMwICsgYzEgKiB0ICsgYzIgKiB0MiArIGMzICogdDM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxufVxyXG5cclxuLy9cclxuXHJcbnZhciB0bXAgPSBuZXcgVmVjdG9yMygpO1xyXG52YXIgcHggPSBuZXcgQ3ViaWNQb2x5KCksIHB5ID0gbmV3IEN1YmljUG9seSgpLCBweiA9IG5ldyBDdWJpY1BvbHkoKTtcclxuXHJcbmZ1bmN0aW9uIENhdG11bGxSb21DdXJ2ZTMoIHBvaW50cywgY2xvc2VkLCBjdXJ2ZVR5cGUsIHRlbnNpb24gKSB7XHJcblxyXG5cdEN1cnZlLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ0NhdG11bGxSb21DdXJ2ZTMnO1xyXG5cclxuXHR0aGlzLnBvaW50cyA9IHBvaW50cyB8fCBbXTtcclxuXHR0aGlzLmNsb3NlZCA9IGNsb3NlZCB8fCBmYWxzZTtcclxuXHR0aGlzLmN1cnZlVHlwZSA9IGN1cnZlVHlwZSB8fCAnY2VudHJpcGV0YWwnO1xyXG5cdHRoaXMudGVuc2lvbiA9IHRlbnNpb24gfHwgMC41O1xyXG5cclxufVxyXG5cclxuQ2F0bXVsbFJvbUN1cnZlMy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKTtcclxuQ2F0bXVsbFJvbUN1cnZlMy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYXRtdWxsUm9tQ3VydmUzO1xyXG5cclxuQ2F0bXVsbFJvbUN1cnZlMy5wcm90b3R5cGUuaXNDYXRtdWxsUm9tQ3VydmUzID0gdHJ1ZTtcclxuXHJcbkNhdG11bGxSb21DdXJ2ZTMucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0dmFyIHBvaW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xyXG5cdHZhciBsID0gcG9pbnRzLmxlbmd0aDtcclxuXHJcblx0dmFyIHAgPSAoIGwgLSAoIHRoaXMuY2xvc2VkID8gMCA6IDEgKSApICogdDtcclxuXHR2YXIgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwICk7XHJcblx0dmFyIHdlaWdodCA9IHAgLSBpbnRQb2ludDtcclxuXHJcblx0aWYgKCB0aGlzLmNsb3NlZCApIHtcclxuXHJcblx0XHRpbnRQb2ludCArPSBpbnRQb2ludCA+IDAgPyAwIDogKCBNYXRoLmZsb29yKCBNYXRoLmFicyggaW50UG9pbnQgKSAvIGwgKSArIDEgKSAqIGw7XHJcblxyXG5cdH0gZWxzZSBpZiAoIHdlaWdodCA9PT0gMCAmJiBpbnRQb2ludCA9PT0gbCAtIDEgKSB7XHJcblxyXG5cdFx0aW50UG9pbnQgPSBsIC0gMjtcclxuXHRcdHdlaWdodCA9IDE7XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIHAwLCBwMSwgcDIsIHAzOyAvLyA0IHBvaW50c1xyXG5cclxuXHRpZiAoIHRoaXMuY2xvc2VkIHx8IGludFBvaW50ID4gMCApIHtcclxuXHJcblx0XHRwMCA9IHBvaW50c1sgKCBpbnRQb2ludCAtIDEgKSAlIGwgXTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHQvLyBleHRyYXBvbGF0ZSBmaXJzdCBwb2ludFxyXG5cdFx0dG1wLnN1YlZlY3RvcnMoIHBvaW50c1sgMCBdLCBwb2ludHNbIDEgXSApLmFkZCggcG9pbnRzWyAwIF0gKTtcclxuXHRcdHAwID0gdG1wO1xyXG5cclxuXHR9XHJcblxyXG5cdHAxID0gcG9pbnRzWyBpbnRQb2ludCAlIGwgXTtcclxuXHRwMiA9IHBvaW50c1sgKCBpbnRQb2ludCArIDEgKSAlIGwgXTtcclxuXHJcblx0aWYgKCB0aGlzLmNsb3NlZCB8fCBpbnRQb2ludCArIDIgPCBsICkge1xyXG5cclxuXHRcdHAzID0gcG9pbnRzWyAoIGludFBvaW50ICsgMiApICUgbCBdO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdC8vIGV4dHJhcG9sYXRlIGxhc3QgcG9pbnRcclxuXHRcdHRtcC5zdWJWZWN0b3JzKCBwb2ludHNbIGwgLSAxIF0sIHBvaW50c1sgbCAtIDIgXSApLmFkZCggcG9pbnRzWyBsIC0gMSBdICk7XHJcblx0XHRwMyA9IHRtcDtcclxuXHJcblx0fVxyXG5cclxuXHRpZiAoIHRoaXMuY3VydmVUeXBlID09PSAnY2VudHJpcGV0YWwnIHx8IHRoaXMuY3VydmVUeXBlID09PSAnY2hvcmRhbCcgKSB7XHJcblxyXG5cdFx0Ly8gaW5pdCBDZW50cmlwZXRhbCAvIENob3JkYWwgQ2F0bXVsbC1Sb21cclxuXHRcdHZhciBwb3cgPSB0aGlzLmN1cnZlVHlwZSA9PT0gJ2Nob3JkYWwnID8gMC41IDogMC4yNTtcclxuXHRcdHZhciBkdDAgPSBNYXRoLnBvdyggcDAuZGlzdGFuY2VUb1NxdWFyZWQoIHAxICksIHBvdyApO1xyXG5cdFx0dmFyIGR0MSA9IE1hdGgucG93KCBwMS5kaXN0YW5jZVRvU3F1YXJlZCggcDIgKSwgcG93ICk7XHJcblx0XHR2YXIgZHQyID0gTWF0aC5wb3coIHAyLmRpc3RhbmNlVG9TcXVhcmVkKCBwMyApLCBwb3cgKTtcclxuXHJcblx0XHQvLyBzYWZldHkgY2hlY2sgZm9yIHJlcGVhdGVkIHBvaW50c1xyXG5cdFx0aWYgKCBkdDEgPCAxZS00ICkgZHQxID0gMS4wO1xyXG5cdFx0aWYgKCBkdDAgPCAxZS00ICkgZHQwID0gZHQxO1xyXG5cdFx0aWYgKCBkdDIgPCAxZS00ICkgZHQyID0gZHQxO1xyXG5cclxuXHRcdHB4LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSggcDAueCwgcDEueCwgcDIueCwgcDMueCwgZHQwLCBkdDEsIGR0MiApO1xyXG5cdFx0cHkuaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tKCBwMC55LCBwMS55LCBwMi55LCBwMy55LCBkdDAsIGR0MSwgZHQyICk7XHJcblx0XHRwei5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oIHAwLnosIHAxLnosIHAyLnosIHAzLnosIGR0MCwgZHQxLCBkdDIgKTtcclxuXHJcblx0fSBlbHNlIGlmICggdGhpcy5jdXJ2ZVR5cGUgPT09ICdjYXRtdWxscm9tJyApIHtcclxuXHJcblx0XHRweC5pbml0Q2F0bXVsbFJvbSggcDAueCwgcDEueCwgcDIueCwgcDMueCwgdGhpcy50ZW5zaW9uICk7XHJcblx0XHRweS5pbml0Q2F0bXVsbFJvbSggcDAueSwgcDEueSwgcDIueSwgcDMueSwgdGhpcy50ZW5zaW9uICk7XHJcblx0XHRwei5pbml0Q2F0bXVsbFJvbSggcDAueiwgcDEueiwgcDIueiwgcDMueiwgdGhpcy50ZW5zaW9uICk7XHJcblxyXG5cdH1cclxuXHJcblx0cG9pbnQuc2V0KFxyXG5cdFx0cHguY2FsYyggd2VpZ2h0ICksXHJcblx0XHRweS5jYWxjKCB3ZWlnaHQgKSxcclxuXHRcdHB6LmNhbGMoIHdlaWdodCApXHJcblx0KTtcclxuXHJcblx0cmV0dXJuIHBvaW50O1xyXG5cclxufTtcclxuXHJcbkNhdG11bGxSb21DdXJ2ZTMucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0Q3VydmUucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdHRoaXMucG9pbnRzID0gW107XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IHNvdXJjZS5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHR2YXIgcG9pbnQgPSBzb3VyY2UucG9pbnRzWyBpIF07XHJcblxyXG5cdFx0dGhpcy5wb2ludHMucHVzaCggcG9pbnQuY2xvbmUoKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuY2xvc2VkID0gc291cmNlLmNsb3NlZDtcclxuXHR0aGlzLmN1cnZlVHlwZSA9IHNvdXJjZS5jdXJ2ZVR5cGU7XHJcblx0dGhpcy50ZW5zaW9uID0gc291cmNlLnRlbnNpb247XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbkNhdG11bGxSb21DdXJ2ZTMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIGRhdGEgPSBDdXJ2ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0ZGF0YS5wb2ludHMgPSBbXTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHR2YXIgcG9pbnQgPSB0aGlzLnBvaW50c1sgaSBdO1xyXG5cdFx0ZGF0YS5wb2ludHMucHVzaCggcG9pbnQudG9BcnJheSgpICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZGF0YS5jbG9zZWQgPSB0aGlzLmNsb3NlZDtcclxuXHRkYXRhLmN1cnZlVHlwZSA9IHRoaXMuY3VydmVUeXBlO1xyXG5cdGRhdGEudGVuc2lvbiA9IHRoaXMudGVuc2lvbjtcclxuXHJcblx0cmV0dXJuIGRhdGE7XHJcblxyXG59O1xyXG5cclxuQ2F0bXVsbFJvbUN1cnZlMy5wcm90b3R5cGUuZnJvbUpTT04gPSBmdW5jdGlvbiAoIGpzb24gKSB7XHJcblxyXG5cdEN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTi5jYWxsKCB0aGlzLCBqc29uICk7XHJcblxyXG5cdHRoaXMucG9pbnRzID0gW107XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIHBvaW50ID0ganNvbi5wb2ludHNbIGkgXTtcclxuXHRcdHRoaXMucG9pbnRzLnB1c2goIG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KCBwb2ludCApICk7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5jbG9zZWQgPSBqc29uLmNsb3NlZDtcclxuXHR0aGlzLmN1cnZlVHlwZSA9IGpzb24uY3VydmVUeXBlO1xyXG5cdHRoaXMudGVuc2lvbiA9IGpzb24udGVuc2lvbjtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuXHJcbmV4cG9ydCB7IENhdG11bGxSb21DdXJ2ZTMgfTtcclxuIiwiLyoqXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICpcclxuICogQmV6aWVyIEN1cnZlcyBmb3JtdWxhcyBvYnRhaW5lZCBmcm9tXHJcbiAqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQsOpemllcl9jdXJ2ZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIENhdG11bGxSb20oIHQsIHAwLCBwMSwgcDIsIHAzICkge1xyXG5cclxuXHR2YXIgdjAgPSAoIHAyIC0gcDAgKSAqIDAuNTtcclxuXHR2YXIgdjEgPSAoIHAzIC0gcDEgKSAqIDAuNTtcclxuXHR2YXIgdDIgPSB0ICogdDtcclxuXHR2YXIgdDMgPSB0ICogdDI7XHJcblx0cmV0dXJuICggMiAqIHAxIC0gMiAqIHAyICsgdjAgKyB2MSApICogdDMgKyAoIC0gMyAqIHAxICsgMyAqIHAyIC0gMiAqIHYwIC0gdjEgKSAqIHQyICsgdjAgKiB0ICsgcDE7XHJcblxyXG59XHJcblxyXG4vL1xyXG5cclxuZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyUDAoIHQsIHAgKSB7XHJcblxyXG5cdHZhciBrID0gMSAtIHQ7XHJcblx0cmV0dXJuIGsgKiBrICogcDtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIFF1YWRyYXRpY0JlemllclAxKCB0LCBwICkge1xyXG5cclxuXHRyZXR1cm4gMiAqICggMSAtIHQgKSAqIHQgKiBwO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyUDIoIHQsIHAgKSB7XHJcblxyXG5cdHJldHVybiB0ICogdCAqIHA7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBRdWFkcmF0aWNCZXppZXIoIHQsIHAwLCBwMSwgcDIgKSB7XHJcblxyXG5cdHJldHVybiBRdWFkcmF0aWNCZXppZXJQMCggdCwgcDAgKSArIFF1YWRyYXRpY0JlemllclAxKCB0LCBwMSApICtcclxuXHRcdFF1YWRyYXRpY0JlemllclAyKCB0LCBwMiApO1xyXG5cclxufVxyXG5cclxuLy9cclxuXHJcbmZ1bmN0aW9uIEN1YmljQmV6aWVyUDAoIHQsIHAgKSB7XHJcblxyXG5cdHZhciBrID0gMSAtIHQ7XHJcblx0cmV0dXJuIGsgKiBrICogayAqIHA7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBDdWJpY0JlemllclAxKCB0LCBwICkge1xyXG5cclxuXHR2YXIgayA9IDEgLSB0O1xyXG5cdHJldHVybiAzICogayAqIGsgKiB0ICogcDtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIEN1YmljQmV6aWVyUDIoIHQsIHAgKSB7XHJcblxyXG5cdHJldHVybiAzICogKCAxIC0gdCApICogdCAqIHQgKiBwO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gQ3ViaWNCZXppZXJQMyggdCwgcCApIHtcclxuXHJcblx0cmV0dXJuIHQgKiB0ICogdCAqIHA7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBDdWJpY0JlemllciggdCwgcDAsIHAxLCBwMiwgcDMgKSB7XHJcblxyXG5cdHJldHVybiBDdWJpY0JlemllclAwKCB0LCBwMCApICsgQ3ViaWNCZXppZXJQMSggdCwgcDEgKSArIEN1YmljQmV6aWVyUDIoIHQsIHAyICkgK1xyXG5cdFx0Q3ViaWNCZXppZXJQMyggdCwgcDMgKTtcclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IENhdG11bGxSb20sIFF1YWRyYXRpY0JlemllciwgQ3ViaWNCZXppZXIgfTtcclxuIiwiaW1wb3J0IHsgQ3VydmUgfSBmcm9tICcuLi9jb3JlL0N1cnZlLmpzJztcclxuaW1wb3J0IHsgQ3ViaWNCZXppZXIgfSBmcm9tICcuLi9jb3JlL0ludGVycG9sYXRpb25zLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMi5qcyc7XHJcblxyXG5cclxuZnVuY3Rpb24gQ3ViaWNCZXppZXJDdXJ2ZSggdjAsIHYxLCB2MiwgdjMgKSB7XHJcblxyXG5cdEN1cnZlLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ0N1YmljQmV6aWVyQ3VydmUnO1xyXG5cclxuXHR0aGlzLnYwID0gdjAgfHwgbmV3IFZlY3RvcjIoKTtcclxuXHR0aGlzLnYxID0gdjEgfHwgbmV3IFZlY3RvcjIoKTtcclxuXHR0aGlzLnYyID0gdjIgfHwgbmV3IFZlY3RvcjIoKTtcclxuXHR0aGlzLnYzID0gdjMgfHwgbmV3IFZlY3RvcjIoKTtcclxuXHJcbn1cclxuXHJcbkN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XHJcbkN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ3ViaWNCZXppZXJDdXJ2ZTtcclxuXHJcbkN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLmlzQ3ViaWNCZXppZXJDdXJ2ZSA9IHRydWU7XHJcblxyXG5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdHZhciBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IyKCk7XHJcblxyXG5cdHZhciB2MCA9IHRoaXMudjAsIHYxID0gdGhpcy52MSwgdjIgPSB0aGlzLnYyLCB2MyA9IHRoaXMudjM7XHJcblxyXG5cdHBvaW50LnNldChcclxuXHRcdEN1YmljQmV6aWVyKCB0LCB2MC54LCB2MS54LCB2Mi54LCB2My54ICksXHJcblx0XHRDdWJpY0JlemllciggdCwgdjAueSwgdjEueSwgdjIueSwgdjMueSApXHJcblx0KTtcclxuXHJcblx0cmV0dXJuIHBvaW50O1xyXG5cclxufTtcclxuXHJcbkN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0Q3VydmUucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdHRoaXMudjAuY29weSggc291cmNlLnYwICk7XHJcblx0dGhpcy52MS5jb3B5KCBzb3VyY2UudjEgKTtcclxuXHR0aGlzLnYyLmNvcHkoIHNvdXJjZS52MiApO1xyXG5cdHRoaXMudjMuY29weSggc291cmNlLnYzICk7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbkN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIGRhdGEgPSBDdXJ2ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0ZGF0YS52MCA9IHRoaXMudjAudG9BcnJheSgpO1xyXG5cdGRhdGEudjEgPSB0aGlzLnYxLnRvQXJyYXkoKTtcclxuXHRkYXRhLnYyID0gdGhpcy52Mi50b0FycmF5KCk7XHJcblx0ZGF0YS52MyA9IHRoaXMudjMudG9BcnJheSgpO1xyXG5cclxuXHRyZXR1cm4gZGF0YTtcclxuXHJcbn07XHJcblxyXG5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uICgganNvbiApIHtcclxuXHJcblx0Q3VydmUucHJvdG90eXBlLmZyb21KU09OLmNhbGwoIHRoaXMsIGpzb24gKTtcclxuXHJcblx0dGhpcy52MC5mcm9tQXJyYXkoIGpzb24udjAgKTtcclxuXHR0aGlzLnYxLmZyb21BcnJheSgganNvbi52MSApO1xyXG5cdHRoaXMudjIuZnJvbUFycmF5KCBqc29uLnYyICk7XHJcblx0dGhpcy52My5mcm9tQXJyYXkoIGpzb24udjMgKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuXHJcbmV4cG9ydCB7IEN1YmljQmV6aWVyQ3VydmUgfTtcclxuIiwiaW1wb3J0IHsgQ3VydmUgfSBmcm9tICcuLi9jb3JlL0N1cnZlLmpzJztcclxuaW1wb3J0IHsgQ3ViaWNCZXppZXIgfSBmcm9tICcuLi9jb3JlL0ludGVycG9sYXRpb25zLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMy5qcyc7XHJcblxyXG5cclxuZnVuY3Rpb24gQ3ViaWNCZXppZXJDdXJ2ZTMoIHYwLCB2MSwgdjIsIHYzICkge1xyXG5cclxuXHRDdXJ2ZS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdDdWJpY0JlemllckN1cnZlMyc7XHJcblxyXG5cdHRoaXMudjAgPSB2MCB8fCBuZXcgVmVjdG9yMygpO1xyXG5cdHRoaXMudjEgPSB2MSB8fCBuZXcgVmVjdG9yMygpO1xyXG5cdHRoaXMudjIgPSB2MiB8fCBuZXcgVmVjdG9yMygpO1xyXG5cdHRoaXMudjMgPSB2MyB8fCBuZXcgVmVjdG9yMygpO1xyXG5cclxufVxyXG5cclxuQ3ViaWNCZXppZXJDdXJ2ZTMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XHJcbkN1YmljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEN1YmljQmV6aWVyQ3VydmUzO1xyXG5cclxuQ3ViaWNCZXppZXJDdXJ2ZTMucHJvdG90eXBlLmlzQ3ViaWNCZXppZXJDdXJ2ZTMgPSB0cnVlO1xyXG5cclxuQ3ViaWNCZXppZXJDdXJ2ZTMucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0dmFyIHBvaW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0dmFyIHYwID0gdGhpcy52MCwgdjEgPSB0aGlzLnYxLCB2MiA9IHRoaXMudjIsIHYzID0gdGhpcy52MztcclxuXHJcblx0cG9pbnQuc2V0KFxyXG5cdFx0Q3ViaWNCZXppZXIoIHQsIHYwLngsIHYxLngsIHYyLngsIHYzLnggKSxcclxuXHRcdEN1YmljQmV6aWVyKCB0LCB2MC55LCB2MS55LCB2Mi55LCB2My55ICksXHJcblx0XHRDdWJpY0JlemllciggdCwgdjAueiwgdjEueiwgdjIueiwgdjMueiApXHJcblx0KTtcclxuXHJcblx0cmV0dXJuIHBvaW50O1xyXG5cclxufTtcclxuXHJcbkN1YmljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdEN1cnZlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLnYwLmNvcHkoIHNvdXJjZS52MCApO1xyXG5cdHRoaXMudjEuY29weSggc291cmNlLnYxICk7XHJcblx0dGhpcy52Mi5jb3B5KCBzb3VyY2UudjIgKTtcclxuXHR0aGlzLnYzLmNvcHkoIHNvdXJjZS52MyApO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG5DdWJpY0JlemllckN1cnZlMy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgZGF0YSA9IEN1cnZlLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xyXG5cclxuXHRkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XHJcblx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xyXG5cdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcclxuXHRkYXRhLnYzID0gdGhpcy52My50b0FycmF5KCk7XHJcblxyXG5cdHJldHVybiBkYXRhO1xyXG5cclxufTtcclxuXHJcbkN1YmljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uICgganNvbiApIHtcclxuXHJcblx0Q3VydmUucHJvdG90eXBlLmZyb21KU09OLmNhbGwoIHRoaXMsIGpzb24gKTtcclxuXHJcblx0dGhpcy52MC5mcm9tQXJyYXkoIGpzb24udjAgKTtcclxuXHR0aGlzLnYxLmZyb21BcnJheSgganNvbi52MSApO1xyXG5cdHRoaXMudjIuZnJvbUFycmF5KCBqc29uLnYyICk7XHJcblx0dGhpcy52My5mcm9tQXJyYXkoIGpzb24udjMgKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuXHJcbmV4cG9ydCB7IEN1YmljQmV6aWVyQ3VydmUzIH07XHJcbiIsImltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgeyBDdXJ2ZSB9IGZyb20gJy4uL2NvcmUvQ3VydmUuanMnO1xyXG5cclxuXHJcbmZ1bmN0aW9uIExpbmVDdXJ2ZSggdjEsIHYyICkge1xyXG5cclxuXHRDdXJ2ZS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdMaW5lQ3VydmUnO1xyXG5cclxuXHR0aGlzLnYxID0gdjEgfHwgbmV3IFZlY3RvcjIoKTtcclxuXHR0aGlzLnYyID0gdjIgfHwgbmV3IFZlY3RvcjIoKTtcclxuXHJcbn1cclxuXHJcbkxpbmVDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKTtcclxuTGluZUN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpbmVDdXJ2ZTtcclxuXHJcbkxpbmVDdXJ2ZS5wcm90b3R5cGUuaXNMaW5lQ3VydmUgPSB0cnVlO1xyXG5cclxuTGluZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdHZhciBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IyKCk7XHJcblxyXG5cdGlmICggdCA9PT0gMSApIHtcclxuXHJcblx0XHRwb2ludC5jb3B5KCB0aGlzLnYyICk7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0cG9pbnQuY29weSggdGhpcy52MiApLnN1YiggdGhpcy52MSApO1xyXG5cdFx0cG9pbnQubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMudjEgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcG9pbnQ7XHJcblxyXG59O1xyXG5cclxuLy8gTGluZSBjdXJ2ZSBpcyBsaW5lYXIsIHNvIHdlIGNhbiBvdmVyd3JpdGUgZGVmYXVsdCBnZXRQb2ludEF0XHJcblxyXG5MaW5lQ3VydmUucHJvdG90eXBlLmdldFBvaW50QXQgPSBmdW5jdGlvbiAoIHUsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRyZXR1cm4gdGhpcy5nZXRQb2ludCggdSwgb3B0aW9uYWxUYXJnZXQgKTtcclxuXHJcbn07XHJcblxyXG5MaW5lQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiAoIC8qIHQgKi8gKSB7XHJcblxyXG5cdHZhciB0YW5nZW50ID0gdGhpcy52Mi5jbG9uZSgpLnN1YiggdGhpcy52MSApO1xyXG5cclxuXHRyZXR1cm4gdGFuZ2VudC5ub3JtYWxpemUoKTtcclxuXHJcbn07XHJcblxyXG5MaW5lQ3VydmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0Q3VydmUucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdHRoaXMudjEuY29weSggc291cmNlLnYxICk7XHJcblx0dGhpcy52Mi5jb3B5KCBzb3VyY2UudjIgKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuTGluZUN1cnZlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBkYXRhID0gQ3VydmUucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XHJcblxyXG5cdGRhdGEudjEgPSB0aGlzLnYxLnRvQXJyYXkoKTtcclxuXHRkYXRhLnYyID0gdGhpcy52Mi50b0FycmF5KCk7XHJcblxyXG5cdHJldHVybiBkYXRhO1xyXG5cclxufTtcclxuXHJcbkxpbmVDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04gPSBmdW5jdGlvbiAoIGpzb24gKSB7XHJcblxyXG5cdEN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTi5jYWxsKCB0aGlzLCBqc29uICk7XHJcblxyXG5cdHRoaXMudjEuZnJvbUFycmF5KCBqc29uLnYxICk7XHJcblx0dGhpcy52Mi5mcm9tQXJyYXkoIGpzb24udjIgKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuXHJcbmV4cG9ydCB7IExpbmVDdXJ2ZSB9O1xyXG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IzLmpzJztcclxuaW1wb3J0IHsgQ3VydmUgfSBmcm9tICcuLi9jb3JlL0N1cnZlLmpzJztcclxuXHJcblxyXG5mdW5jdGlvbiBMaW5lQ3VydmUzKCB2MSwgdjIgKSB7XHJcblxyXG5cdEN1cnZlLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ0xpbmVDdXJ2ZTMnO1xyXG5cclxuXHR0aGlzLnYxID0gdjEgfHwgbmV3IFZlY3RvcjMoKTtcclxuXHR0aGlzLnYyID0gdjIgfHwgbmV3IFZlY3RvcjMoKTtcclxuXHJcbn1cclxuXHJcbkxpbmVDdXJ2ZTMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XHJcbkxpbmVDdXJ2ZTMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGluZUN1cnZlMztcclxuXHJcbkxpbmVDdXJ2ZTMucHJvdG90eXBlLmlzTGluZUN1cnZlMyA9IHRydWU7XHJcblxyXG5MaW5lQ3VydmUzLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdHZhciBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdGlmICggdCA9PT0gMSApIHtcclxuXHJcblx0XHRwb2ludC5jb3B5KCB0aGlzLnYyICk7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0cG9pbnQuY29weSggdGhpcy52MiApLnN1YiggdGhpcy52MSApO1xyXG5cdFx0cG9pbnQubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMudjEgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcG9pbnQ7XHJcblxyXG59O1xyXG5cclxuLy8gTGluZSBjdXJ2ZSBpcyBsaW5lYXIsIHNvIHdlIGNhbiBvdmVyd3JpdGUgZGVmYXVsdCBnZXRQb2ludEF0XHJcblxyXG5MaW5lQ3VydmUzLnByb3RvdHlwZS5nZXRQb2ludEF0ID0gZnVuY3Rpb24gKCB1LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0cmV0dXJuIHRoaXMuZ2V0UG9pbnQoIHUsIG9wdGlvbmFsVGFyZ2V0ICk7XHJcblxyXG59O1xyXG5cclxuTGluZUN1cnZlMy5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRDdXJ2ZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0dGhpcy52MS5jb3B5KCBzb3VyY2UudjEgKTtcclxuXHR0aGlzLnYyLmNvcHkoIHNvdXJjZS52MiApO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG5MaW5lQ3VydmUzLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBkYXRhID0gQ3VydmUucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XHJcblxyXG5cdGRhdGEudjEgPSB0aGlzLnYxLnRvQXJyYXkoKTtcclxuXHRkYXRhLnYyID0gdGhpcy52Mi50b0FycmF5KCk7XHJcblxyXG5cdHJldHVybiBkYXRhO1xyXG5cclxufTtcclxuXHJcbkxpbmVDdXJ2ZTMucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24gKCBqc29uICkge1xyXG5cclxuXHRDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04uY2FsbCggdGhpcywganNvbiApO1xyXG5cclxuXHR0aGlzLnYxLmZyb21BcnJheSgganNvbi52MSApO1xyXG5cdHRoaXMudjIuZnJvbUFycmF5KCBqc29uLnYyICk7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcblxyXG5leHBvcnQgeyBMaW5lQ3VydmUzIH07XHJcbiIsImltcG9ydCB7IEN1cnZlIH0gZnJvbSAnLi4vY29yZS9DdXJ2ZS5qcyc7XHJcbmltcG9ydCB7IFF1YWRyYXRpY0JlemllciB9IGZyb20gJy4uL2NvcmUvSW50ZXJwb2xhdGlvbnMuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IyLmpzJztcclxuXHJcblxyXG5mdW5jdGlvbiBRdWFkcmF0aWNCZXppZXJDdXJ2ZSggdjAsIHYxLCB2MiApIHtcclxuXHJcblx0Q3VydmUuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnUXVhZHJhdGljQmV6aWVyQ3VydmUnO1xyXG5cclxuXHR0aGlzLnYwID0gdjAgfHwgbmV3IFZlY3RvcjIoKTtcclxuXHR0aGlzLnYxID0gdjEgfHwgbmV3IFZlY3RvcjIoKTtcclxuXHR0aGlzLnYyID0gdjIgfHwgbmV3IFZlY3RvcjIoKTtcclxuXHJcbn1cclxuXHJcblF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN1cnZlLnByb3RvdHlwZSApO1xyXG5RdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBRdWFkcmF0aWNCZXppZXJDdXJ2ZTtcclxuXHJcblF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5pc1F1YWRyYXRpY0JlemllckN1cnZlID0gdHJ1ZTtcclxuXHJcblF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdHZhciBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IyKCk7XHJcblxyXG5cdHZhciB2MCA9IHRoaXMudjAsIHYxID0gdGhpcy52MSwgdjIgPSB0aGlzLnYyO1xyXG5cclxuXHRwb2ludC5zZXQoXHJcblx0XHRRdWFkcmF0aWNCZXppZXIoIHQsIHYwLngsIHYxLngsIHYyLnggKSxcclxuXHRcdFF1YWRyYXRpY0JlemllciggdCwgdjAueSwgdjEueSwgdjIueSApXHJcblx0KTtcclxuXHJcblx0cmV0dXJuIHBvaW50O1xyXG5cclxufTtcclxuXHJcblF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdEN1cnZlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLnYwLmNvcHkoIHNvdXJjZS52MCApO1xyXG5cdHRoaXMudjEuY29weSggc291cmNlLnYxICk7XHJcblx0dGhpcy52Mi5jb3B5KCBzb3VyY2UudjIgKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuUXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIGRhdGEgPSBDdXJ2ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0ZGF0YS52MCA9IHRoaXMudjAudG9BcnJheSgpO1xyXG5cdGRhdGEudjEgPSB0aGlzLnYxLnRvQXJyYXkoKTtcclxuXHRkYXRhLnYyID0gdGhpcy52Mi50b0FycmF5KCk7XHJcblxyXG5cdHJldHVybiBkYXRhO1xyXG5cclxufTtcclxuXHJcblF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uICgganNvbiApIHtcclxuXHJcblx0Q3VydmUucHJvdG90eXBlLmZyb21KU09OLmNhbGwoIHRoaXMsIGpzb24gKTtcclxuXHJcblx0dGhpcy52MC5mcm9tQXJyYXkoIGpzb24udjAgKTtcclxuXHR0aGlzLnYxLmZyb21BcnJheSgganNvbi52MSApO1xyXG5cdHRoaXMudjIuZnJvbUFycmF5KCBqc29uLnYyICk7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcblxyXG5leHBvcnQgeyBRdWFkcmF0aWNCZXppZXJDdXJ2ZSB9O1xyXG4iLCJpbXBvcnQgeyBDdXJ2ZSB9IGZyb20gJy4uL2NvcmUvQ3VydmUuanMnO1xyXG5pbXBvcnQgeyBRdWFkcmF0aWNCZXppZXIgfSBmcm9tICcuLi9jb3JlL0ludGVycG9sYXRpb25zLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMy5qcyc7XHJcblxyXG5cclxuZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyQ3VydmUzKCB2MCwgdjEsIHYyICkge1xyXG5cclxuXHRDdXJ2ZS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdRdWFkcmF0aWNCZXppZXJDdXJ2ZTMnO1xyXG5cclxuXHR0aGlzLnYwID0gdjAgfHwgbmV3IFZlY3RvcjMoKTtcclxuXHR0aGlzLnYxID0gdjEgfHwgbmV3IFZlY3RvcjMoKTtcclxuXHR0aGlzLnYyID0gdjIgfHwgbmV3IFZlY3RvcjMoKTtcclxuXHJcbn1cclxuXHJcblF1YWRyYXRpY0JlemllckN1cnZlMy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKTtcclxuUXVhZHJhdGljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFF1YWRyYXRpY0JlemllckN1cnZlMztcclxuXHJcblF1YWRyYXRpY0JlemllckN1cnZlMy5wcm90b3R5cGUuaXNRdWFkcmF0aWNCZXppZXJDdXJ2ZTMgPSB0cnVlO1xyXG5cclxuUXVhZHJhdGljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdHZhciBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdHZhciB2MCA9IHRoaXMudjAsIHYxID0gdGhpcy52MSwgdjIgPSB0aGlzLnYyO1xyXG5cclxuXHRwb2ludC5zZXQoXHJcblx0XHRRdWFkcmF0aWNCZXppZXIoIHQsIHYwLngsIHYxLngsIHYyLnggKSxcclxuXHRcdFF1YWRyYXRpY0JlemllciggdCwgdjAueSwgdjEueSwgdjIueSApLFxyXG5cdFx0UXVhZHJhdGljQmV6aWVyKCB0LCB2MC56LCB2MS56LCB2Mi56IClcclxuXHQpO1xyXG5cclxuXHRyZXR1cm4gcG9pbnQ7XHJcblxyXG59O1xyXG5cclxuUXVhZHJhdGljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdEN1cnZlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLnYwLmNvcHkoIHNvdXJjZS52MCApO1xyXG5cdHRoaXMudjEuY29weSggc291cmNlLnYxICk7XHJcblx0dGhpcy52Mi5jb3B5KCBzb3VyY2UudjIgKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuUXVhZHJhdGljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBkYXRhID0gQ3VydmUucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XHJcblxyXG5cdGRhdGEudjAgPSB0aGlzLnYwLnRvQXJyYXkoKTtcclxuXHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XHJcblx0ZGF0YS52MiA9IHRoaXMudjIudG9BcnJheSgpO1xyXG5cclxuXHRyZXR1cm4gZGF0YTtcclxuXHJcbn07XHJcblxyXG5RdWFkcmF0aWNCZXppZXJDdXJ2ZTMucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24gKCBqc29uICkge1xyXG5cclxuXHRDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04uY2FsbCggdGhpcywganNvbiApO1xyXG5cclxuXHR0aGlzLnYwLmZyb21BcnJheSgganNvbi52MCApO1xyXG5cdHRoaXMudjEuZnJvbUFycmF5KCBqc29uLnYxICk7XHJcblx0dGhpcy52Mi5mcm9tQXJyYXkoIGpzb24udjIgKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuXHJcbmV4cG9ydCB7IFF1YWRyYXRpY0JlemllckN1cnZlMyB9O1xyXG4iLCJpbXBvcnQgeyBDdXJ2ZSB9IGZyb20gJy4uL2NvcmUvQ3VydmUuanMnO1xyXG5pbXBvcnQgeyBDYXRtdWxsUm9tIH0gZnJvbSAnLi4vY29yZS9JbnRlcnBvbGF0aW9ucy5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjIuanMnO1xyXG5cclxuXHJcbmZ1bmN0aW9uIFNwbGluZUN1cnZlKCBwb2ludHMgLyogYXJyYXkgb2YgVmVjdG9yMiAqLyApIHtcclxuXHJcblx0Q3VydmUuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnU3BsaW5lQ3VydmUnO1xyXG5cclxuXHR0aGlzLnBvaW50cyA9IHBvaW50cyB8fCBbXTtcclxuXHJcbn1cclxuXHJcblNwbGluZUN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN1cnZlLnByb3RvdHlwZSApO1xyXG5TcGxpbmVDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTcGxpbmVDdXJ2ZTtcclxuXHJcblNwbGluZUN1cnZlLnByb3RvdHlwZS5pc1NwbGluZUN1cnZlID0gdHJ1ZTtcclxuXHJcblNwbGluZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdHZhciBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IyKCk7XHJcblxyXG5cdHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcclxuXHR2YXIgcCA9ICggcG9pbnRzLmxlbmd0aCAtIDEgKSAqIHQ7XHJcblxyXG5cdHZhciBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHAgKTtcclxuXHR2YXIgd2VpZ2h0ID0gcCAtIGludFBvaW50O1xyXG5cclxuXHR2YXIgcDAgPSBwb2ludHNbIGludFBvaW50ID09PSAwID8gaW50UG9pbnQgOiBpbnRQb2ludCAtIDEgXTtcclxuXHR2YXIgcDEgPSBwb2ludHNbIGludFBvaW50IF07XHJcblx0dmFyIHAyID0gcG9pbnRzWyBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAyID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDEgXTtcclxuXHR2YXIgcDMgPSBwb2ludHNbIGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDMgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMiBdO1xyXG5cclxuXHRwb2ludC5zZXQoXHJcblx0XHRDYXRtdWxsUm9tKCB3ZWlnaHQsIHAwLngsIHAxLngsIHAyLngsIHAzLnggKSxcclxuXHRcdENhdG11bGxSb20oIHdlaWdodCwgcDAueSwgcDEueSwgcDIueSwgcDMueSApXHJcblx0KTtcclxuXHJcblx0cmV0dXJuIHBvaW50O1xyXG5cclxufTtcclxuXHJcblNwbGluZUN1cnZlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdEN1cnZlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLnBvaW50cyA9IFtdO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzb3VyY2UucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIHBvaW50ID0gc291cmNlLnBvaW50c1sgaSBdO1xyXG5cclxuXHRcdHRoaXMucG9pbnRzLnB1c2goIHBvaW50LmNsb25lKCkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG5TcGxpbmVDdXJ2ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgZGF0YSA9IEN1cnZlLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xyXG5cclxuXHRkYXRhLnBvaW50cyA9IFtdO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLnBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdHZhciBwb2ludCA9IHRoaXMucG9pbnRzWyBpIF07XHJcblx0XHRkYXRhLnBvaW50cy5wdXNoKCBwb2ludC50b0FycmF5KCkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZGF0YTtcclxuXHJcbn07XHJcblxyXG5TcGxpbmVDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04gPSBmdW5jdGlvbiAoIGpzb24gKSB7XHJcblxyXG5cdEN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTi5jYWxsKCB0aGlzLCBqc29uICk7XHJcblxyXG5cdHRoaXMucG9pbnRzID0gW107XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIHBvaW50ID0ganNvbi5wb2ludHNbIGkgXTtcclxuXHRcdHRoaXMucG9pbnRzLnB1c2goIG5ldyBWZWN0b3IyKCkuZnJvbUFycmF5KCBwb2ludCApICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuXHJcbmV4cG9ydCB7IFNwbGluZUN1cnZlIH07XHJcbiIsImV4cG9ydCB7IEFyY0N1cnZlIH0gZnJvbSAnLi9BcmNDdXJ2ZS5qcyc7XHJcbmV4cG9ydCB7IENhdG11bGxSb21DdXJ2ZTMgfSBmcm9tICcuL0NhdG11bGxSb21DdXJ2ZTMuanMnO1xyXG5leHBvcnQgeyBDdWJpY0JlemllckN1cnZlIH0gZnJvbSAnLi9DdWJpY0JlemllckN1cnZlLmpzJztcclxuZXhwb3J0IHsgQ3ViaWNCZXppZXJDdXJ2ZTMgfSBmcm9tICcuL0N1YmljQmV6aWVyQ3VydmUzLmpzJztcclxuZXhwb3J0IHsgRWxsaXBzZUN1cnZlIH0gZnJvbSAnLi9FbGxpcHNlQ3VydmUuanMnO1xyXG5leHBvcnQgeyBMaW5lQ3VydmUgfSBmcm9tICcuL0xpbmVDdXJ2ZS5qcyc7XHJcbmV4cG9ydCB7IExpbmVDdXJ2ZTMgfSBmcm9tICcuL0xpbmVDdXJ2ZTMuanMnO1xyXG5leHBvcnQgeyBRdWFkcmF0aWNCZXppZXJDdXJ2ZSB9IGZyb20gJy4vUXVhZHJhdGljQmV6aWVyQ3VydmUuanMnO1xyXG5leHBvcnQgeyBRdWFkcmF0aWNCZXppZXJDdXJ2ZTMgfSBmcm9tICcuL1F1YWRyYXRpY0JlemllckN1cnZlMy5qcyc7XHJcbmV4cG9ydCB7IFNwbGluZUN1cnZlIH0gZnJvbSAnLi9TcGxpbmVDdXJ2ZS5qcyc7XHJcbiIsImltcG9ydCB7IEN1cnZlIH0gZnJvbSAnLi9DdXJ2ZS5qcyc7XHJcbmltcG9ydCAqIGFzIEN1cnZlcyBmcm9tICcuLi9jdXJ2ZXMvQ3VydmVzLmpzJztcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqXHJcbiAqKi9cclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0Q3VydmVkIFBhdGggLSBhIGN1cnZlIHBhdGggaXMgc2ltcGx5IGEgYXJyYXkgb2YgY29ubmVjdGVkXHJcbiAqICBjdXJ2ZXMsIGJ1dCByZXRhaW5zIHRoZSBhcGkgb2YgYSBjdXJ2ZVxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5mdW5jdGlvbiBDdXJ2ZVBhdGgoKSB7XHJcblxyXG5cdEN1cnZlLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ0N1cnZlUGF0aCc7XHJcblxyXG5cdHRoaXMuY3VydmVzID0gW107XHJcblx0dGhpcy5hdXRvQ2xvc2UgPSBmYWxzZTsgLy8gQXV0b21hdGljYWxseSBjbG9zZXMgdGhlIHBhdGhcclxuXHJcbn1cclxuXHJcbkN1cnZlUGF0aC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKSwge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogQ3VydmVQYXRoLFxyXG5cclxuXHRhZGQ6IGZ1bmN0aW9uICggY3VydmUgKSB7XHJcblxyXG5cdFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvc2VQYXRoOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gQWRkIGEgbGluZSBjdXJ2ZSBpZiBzdGFydCBhbmQgZW5kIG9mIGxpbmVzIGFyZSBub3QgY29ubmVjdGVkXHJcblx0XHR2YXIgc3RhcnRQb2ludCA9IHRoaXMuY3VydmVzWyAwIF0uZ2V0UG9pbnQoIDAgKTtcclxuXHRcdHZhciBlbmRQb2ludCA9IHRoaXMuY3VydmVzWyB0aGlzLmN1cnZlcy5sZW5ndGggLSAxIF0uZ2V0UG9pbnQoIDEgKTtcclxuXHJcblx0XHRpZiAoICEgc3RhcnRQb2ludC5lcXVhbHMoIGVuZFBvaW50ICkgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmN1cnZlcy5wdXNoKCBuZXcgQ3VydmVzWyAnTGluZUN1cnZlJyBdKCBlbmRQb2ludCwgc3RhcnRQb2ludCApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBUbyBnZXQgYWNjdXJhdGUgcG9pbnQgd2l0aCByZWZlcmVuY2UgdG9cclxuXHQvLyBlbnRpcmUgcGF0aCBkaXN0YW5jZSBhdCB0aW1lIHQsXHJcblx0Ly8gZm9sbG93aW5nIGhhcyB0byBiZSBkb25lOlxyXG5cclxuXHQvLyAxLiBMZW5ndGggb2YgZWFjaCBzdWIgcGF0aCBoYXZlIHRvIGJlIGtub3duXHJcblx0Ly8gMi4gTG9jYXRlIGFuZCBpZGVudGlmeSB0eXBlIG9mIGN1cnZlXHJcblx0Ly8gMy4gR2V0IHQgZm9yIHRoZSBjdXJ2ZVxyXG5cdC8vIDQuIFJldHVybiBjdXJ2ZS5nZXRQb2ludEF0KHQnKVxyXG5cclxuXHRnZXRQb2ludDogZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHRcdHZhciBkID0gdCAqIHRoaXMuZ2V0TGVuZ3RoKCk7XHJcblx0XHR2YXIgY3VydmVMZW5ndGhzID0gdGhpcy5nZXRDdXJ2ZUxlbmd0aHMoKTtcclxuXHRcdHZhciBpID0gMDtcclxuXHJcblx0XHQvLyBUbyB0aGluayBhYm91dCBib3VuZGFyaWVzIHBvaW50cy5cclxuXHJcblx0XHR3aGlsZSAoIGkgPCBjdXJ2ZUxlbmd0aHMubGVuZ3RoICkge1xyXG5cclxuXHRcdFx0aWYgKCBjdXJ2ZUxlbmd0aHNbIGkgXSA+PSBkICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZGlmZiA9IGN1cnZlTGVuZ3Roc1sgaSBdIC0gZDtcclxuXHRcdFx0XHR2YXIgY3VydmUgPSB0aGlzLmN1cnZlc1sgaSBdO1xyXG5cclxuXHRcdFx0XHR2YXIgc2VnbWVudExlbmd0aCA9IGN1cnZlLmdldExlbmd0aCgpO1xyXG5cdFx0XHRcdHZhciB1ID0gc2VnbWVudExlbmd0aCA9PT0gMCA/IDAgOiAxIC0gZGlmZiAvIHNlZ21lbnRMZW5ndGg7XHJcblxyXG5cdFx0XHRcdHJldHVybiBjdXJ2ZS5nZXRQb2ludEF0KCB1ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpICsrO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHQvLyBsb29wIHdoZXJlIHN1bSAhPSAwLCBzdW0gPiBkICwgc3VtKzEgPGRcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gV2UgY2Fubm90IHVzZSB0aGUgZGVmYXVsdCBDT09MLkN1cnZlIGdldFBvaW50KCkgd2l0aCBnZXRMZW5ndGgoKSBiZWNhdXNlIGluXHJcblx0Ly8gQ09PTC5DdXJ2ZSwgZ2V0TGVuZ3RoKCkgZGVwZW5kcyBvbiBnZXRQb2ludCgpIGJ1dCBpbiBDT09MLkN1cnZlUGF0aFxyXG5cdC8vIGdldFBvaW50KCkgZGVwZW5kcyBvbiBnZXRMZW5ndGhcclxuXHJcblx0Z2V0TGVuZ3RoOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGxlbnMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xyXG5cdFx0cmV0dXJuIGxlbnNbIGxlbnMubGVuZ3RoIC0gMSBdO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBjYWNoZUxlbmd0aHMgbXVzdCBiZSByZWNhbGN1bGF0ZWQuXHJcblx0dXBkYXRlQXJjTGVuZ3RoczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cdFx0dGhpcy5jYWNoZUxlbmd0aHMgPSBudWxsO1xyXG5cdFx0dGhpcy5nZXRDdXJ2ZUxlbmd0aHMoKTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gQ29tcHV0ZSBsZW5ndGhzIGFuZCBjYWNoZSB0aGVtXHJcblx0Ly8gV2UgY2Fubm90IG92ZXJ3cml0ZSBnZXRMZW5ndGhzKCkgYmVjYXVzZSBVdG9UIG1hcHBpbmcgdXNlcyBpdC5cclxuXHJcblx0Z2V0Q3VydmVMZW5ndGhzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gV2UgdXNlIGNhY2hlIHZhbHVlcyBpZiBjdXJ2ZXMgYW5kIGNhY2hlIGFycmF5IGFyZSBzYW1lIGxlbmd0aFxyXG5cclxuXHRcdGlmICggdGhpcy5jYWNoZUxlbmd0aHMgJiYgdGhpcy5jYWNoZUxlbmd0aHMubGVuZ3RoID09PSB0aGlzLmN1cnZlcy5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5jYWNoZUxlbmd0aHM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEdldCBsZW5ndGggb2Ygc3ViLWN1cnZlXHJcblx0XHQvLyBQdXNoIHN1bXMgaW50byBjYWNoZWQgYXJyYXlcclxuXHJcblx0XHR2YXIgbGVuZ3RocyA9IFtdLCBzdW1zID0gMDtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0c3VtcyArPSB0aGlzLmN1cnZlc1sgaSBdLmdldExlbmd0aCgpO1xyXG5cdFx0XHRsZW5ndGhzLnB1c2goIHN1bXMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jYWNoZUxlbmd0aHMgPSBsZW5ndGhzO1xyXG5cclxuXHRcdHJldHVybiBsZW5ndGhzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRTcGFjZWRQb2ludHM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xyXG5cclxuXHRcdGlmICggZGl2aXNpb25zID09PSB1bmRlZmluZWQgKSBkaXZpc2lvbnMgPSA0MDtcclxuXHJcblx0XHR2YXIgcG9pbnRzID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDw9IGRpdmlzaW9uczsgaSArKyApIHtcclxuXHJcblx0XHRcdHBvaW50cy5wdXNoKCB0aGlzLmdldFBvaW50KCBpIC8gZGl2aXNpb25zICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLmF1dG9DbG9zZSApIHtcclxuXHJcblx0XHRcdHBvaW50cy5wdXNoKCBwb2ludHNbIDAgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcG9pbnRzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRQb2ludHM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xyXG5cclxuXHRcdGRpdmlzaW9ucyA9IGRpdmlzaW9ucyB8fCAxMjtcclxuXHJcblx0XHR2YXIgcG9pbnRzID0gW10sIGxhc3Q7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBjdXJ2ZXMgPSB0aGlzLmN1cnZlczsgaSA8IGN1cnZlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgY3VydmUgPSBjdXJ2ZXNbIGkgXTtcclxuXHRcdFx0dmFyIHJlc29sdXRpb24gPSAoIGN1cnZlICYmIGN1cnZlLmlzRWxsaXBzZUN1cnZlICkgPyBkaXZpc2lvbnMgKiAyXHJcblx0XHRcdFx0OiAoIGN1cnZlICYmICggY3VydmUuaXNMaW5lQ3VydmUgfHwgY3VydmUuaXNMaW5lQ3VydmUzICkgKSA/IDFcclxuXHRcdFx0XHRcdDogKCBjdXJ2ZSAmJiBjdXJ2ZS5pc1NwbGluZUN1cnZlICkgPyBkaXZpc2lvbnMgKiBjdXJ2ZS5wb2ludHMubGVuZ3RoXHJcblx0XHRcdFx0XHRcdDogZGl2aXNpb25zO1xyXG5cclxuXHRcdFx0dmFyIHB0cyA9IGN1cnZlLmdldFBvaW50cyggcmVzb2x1dGlvbiApO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgcHRzLmxlbmd0aDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIHBvaW50ID0gcHRzWyBqIF07XHJcblxyXG5cdFx0XHRcdGlmICggbGFzdCAmJiBsYXN0LmVxdWFscyggcG9pbnQgKSApIGNvbnRpbnVlOyAvLyBlbnN1cmVzIG5vIGNvbnNlY3V0aXZlIHBvaW50cyBhcmUgZHVwbGljYXRlc1xyXG5cclxuXHRcdFx0XHRwb2ludHMucHVzaCggcG9pbnQgKTtcclxuXHRcdFx0XHRsYXN0ID0gcG9pbnQ7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5hdXRvQ2xvc2UgJiYgcG9pbnRzLmxlbmd0aCA+IDEgJiYgISBwb2ludHNbIHBvaW50cy5sZW5ndGggLSAxIF0uZXF1YWxzKCBwb2ludHNbIDAgXSApICkge1xyXG5cclxuXHRcdFx0cG9pbnRzLnB1c2goIHBvaW50c1sgMCBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwb2ludHM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdEN1cnZlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHRcdHRoaXMuY3VydmVzID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gc291cmNlLmN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGN1cnZlID0gc291cmNlLmN1cnZlc1sgaSBdO1xyXG5cclxuXHRcdFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUuY2xvbmUoKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmF1dG9DbG9zZSA9IHNvdXJjZS5hdXRvQ2xvc2U7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvSlNPTjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBkYXRhID0gQ3VydmUucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0ZGF0YS5hdXRvQ2xvc2UgPSB0aGlzLmF1dG9DbG9zZTtcclxuXHRcdGRhdGEuY3VydmVzID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBjdXJ2ZSA9IHRoaXMuY3VydmVzWyBpIF07XHJcblx0XHRcdGRhdGEuY3VydmVzLnB1c2goIGN1cnZlLnRvSlNPTigpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmcm9tSlNPTjogZnVuY3Rpb24gKCBqc29uICkge1xyXG5cclxuXHRcdEN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTi5jYWxsKCB0aGlzLCBqc29uICk7XHJcblxyXG5cdFx0dGhpcy5hdXRvQ2xvc2UgPSBqc29uLmF1dG9DbG9zZTtcclxuXHRcdHRoaXMuY3VydmVzID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBjdXJ2ZSA9IGpzb24uY3VydmVzWyBpIF07XHJcblx0XHRcdHRoaXMuY3VydmVzLnB1c2goIG5ldyBDdXJ2ZXNbIGN1cnZlLnR5cGUgXSgpLmZyb21KU09OKCBjdXJ2ZSApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcblxyXG5cclxuZXhwb3J0IHsgQ3VydmVQYXRoIH07XHJcbiIsImltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgeyBDdXJ2ZVBhdGggfSBmcm9tICcuL0N1cnZlUGF0aC5qcyc7XHJcbmltcG9ydCB7IEVsbGlwc2VDdXJ2ZSB9IGZyb20gJy4uL2N1cnZlcy9FbGxpcHNlQ3VydmUuanMnO1xyXG5pbXBvcnQgeyBTcGxpbmVDdXJ2ZSB9IGZyb20gJy4uL2N1cnZlcy9TcGxpbmVDdXJ2ZS5qcyc7XHJcbmltcG9ydCB7IEN1YmljQmV6aWVyQ3VydmUgfSBmcm9tICcuLi9jdXJ2ZXMvQ3ViaWNCZXppZXJDdXJ2ZS5qcyc7XHJcbmltcG9ydCB7IFF1YWRyYXRpY0JlemllckN1cnZlIH0gZnJvbSAnLi4vY3VydmVzL1F1YWRyYXRpY0JlemllckN1cnZlLmpzJztcclxuaW1wb3J0IHsgTGluZUN1cnZlIH0gZnJvbSAnLi4vY3VydmVzL0xpbmVDdXJ2ZS5qcyc7XHJcblxyXG4vKipcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKiBDcmVhdGVzIGZyZWUgZm9ybSAyZCBwYXRoIHVzaW5nIHNlcmllcyBvZiBwb2ludHMsIGxpbmVzIG9yIGN1cnZlcy5cclxuICoqL1xyXG5cclxuZnVuY3Rpb24gUGF0aCggcG9pbnRzICkge1xyXG5cclxuXHRDdXJ2ZVBhdGguY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnUGF0aCc7XHJcblxyXG5cdHRoaXMuY3VycmVudFBvaW50ID0gbmV3IFZlY3RvcjIoKTtcclxuXHJcblx0aWYgKCBwb2ludHMgKSB7XHJcblxyXG5cdFx0dGhpcy5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuUGF0aC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBDdXJ2ZVBhdGgucHJvdG90eXBlICksIHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFBhdGgsXHJcblxyXG5cdHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICggcG9pbnRzICkge1xyXG5cclxuXHRcdHRoaXMubW92ZVRvKCBwb2ludHNbIDAgXS54LCBwb2ludHNbIDAgXS55ICk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAxLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmxpbmVUbyggcG9pbnRzWyBpIF0ueCwgcG9pbnRzWyBpIF0ueSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0bW92ZVRvOiBmdW5jdGlvbiAoIHgsIHkgKSB7XHJcblxyXG5cdFx0dGhpcy5jdXJyZW50UG9pbnQuc2V0KCB4LCB5ICk7IC8vIFRPRE8gY29uc2lkZXIgcmVmZXJlbmNpbmcgdmVjdG9ycyBpbnN0ZWFkIG9mIGNvcHlpbmc/XHJcblxyXG5cdH0sXHJcblxyXG5cdGxpbmVUbzogZnVuY3Rpb24gKCB4LCB5ICkge1xyXG5cclxuXHRcdHZhciBjdXJ2ZSA9IG5ldyBMaW5lQ3VydmUoIHRoaXMuY3VycmVudFBvaW50LmNsb25lKCksIG5ldyBWZWN0b3IyKCB4LCB5ICkgKTtcclxuXHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XHJcblxyXG5cdFx0dGhpcy5jdXJyZW50UG9pbnQuc2V0KCB4LCB5ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uICggYUNQeCwgYUNQeSwgYVgsIGFZICkge1xyXG5cclxuXHRcdHZhciBjdXJ2ZSA9IG5ldyBRdWFkcmF0aWNCZXppZXJDdXJ2ZShcclxuXHRcdFx0dGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKSxcclxuXHRcdFx0bmV3IFZlY3RvcjIoIGFDUHgsIGFDUHkgKSxcclxuXHRcdFx0bmV3IFZlY3RvcjIoIGFYLCBhWSApXHJcblx0XHQpO1xyXG5cclxuXHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XHJcblxyXG5cdFx0dGhpcy5jdXJyZW50UG9pbnQuc2V0KCBhWCwgYVkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0YmV6aWVyQ3VydmVUbzogZnVuY3Rpb24gKCBhQ1AxeCwgYUNQMXksIGFDUDJ4LCBhQ1AyeSwgYVgsIGFZICkge1xyXG5cclxuXHRcdHZhciBjdXJ2ZSA9IG5ldyBDdWJpY0JlemllckN1cnZlKFxyXG5cdFx0XHR0aGlzLmN1cnJlbnRQb2ludC5jbG9uZSgpLFxyXG5cdFx0XHRuZXcgVmVjdG9yMiggYUNQMXgsIGFDUDF5ICksXHJcblx0XHRcdG5ldyBWZWN0b3IyKCBhQ1AyeCwgYUNQMnkgKSxcclxuXHRcdFx0bmV3IFZlY3RvcjIoIGFYLCBhWSApXHJcblx0XHQpO1xyXG5cclxuXHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XHJcblxyXG5cdFx0dGhpcy5jdXJyZW50UG9pbnQuc2V0KCBhWCwgYVkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0c3BsaW5lVGhydTogZnVuY3Rpb24gKCBwdHMgLypBcnJheSBvZiBWZWN0b3IqLyApIHtcclxuXHJcblx0XHR2YXIgbnB0cyA9IFsgdGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKSBdLmNvbmNhdCggcHRzICk7XHJcblxyXG5cdFx0dmFyIGN1cnZlID0gbmV3IFNwbGluZUN1cnZlKCBucHRzICk7XHJcblx0XHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xyXG5cclxuXHRcdHRoaXMuY3VycmVudFBvaW50LmNvcHkoIHB0c1sgcHRzLmxlbmd0aCAtIDEgXSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhcmM6IGZ1bmN0aW9uICggYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xyXG5cclxuXHRcdHZhciB4MCA9IHRoaXMuY3VycmVudFBvaW50Lng7XHJcblx0XHR2YXIgeTAgPSB0aGlzLmN1cnJlbnRQb2ludC55O1xyXG5cclxuXHRcdHRoaXMuYWJzYXJjKCBhWCArIHgwLCBhWSArIHkwLCBhUmFkaXVzLFxyXG5cdFx0XHRhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFic2FyYzogZnVuY3Rpb24gKCBhWCwgYVksIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XHJcblxyXG5cdFx0dGhpcy5hYnNlbGxpcHNlKCBhWCwgYVksIGFSYWRpdXMsIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZWxsaXBzZTogZnVuY3Rpb24gKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApIHtcclxuXHJcblx0XHR2YXIgeDAgPSB0aGlzLmN1cnJlbnRQb2ludC54O1xyXG5cdFx0dmFyIHkwID0gdGhpcy5jdXJyZW50UG9pbnQueTtcclxuXHJcblx0XHR0aGlzLmFic2VsbGlwc2UoIGFYICsgeDAsIGFZICsgeTAsIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhYnNlbGxpcHNlOiBmdW5jdGlvbiAoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICkge1xyXG5cclxuXHRcdHZhciBjdXJ2ZSA9IG5ldyBFbGxpcHNlQ3VydmUoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmN1cnZlcy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0Ly8gaWYgYSBwcmV2aW91cyBjdXJ2ZSBpcyBwcmVzZW50LCBhdHRlbXB0IHRvIGpvaW5cclxuXHRcdFx0dmFyIGZpcnN0UG9pbnQgPSBjdXJ2ZS5nZXRQb2ludCggMCApO1xyXG5cclxuXHRcdFx0aWYgKCAhIGZpcnN0UG9pbnQuZXF1YWxzKCB0aGlzLmN1cnJlbnRQb2ludCApICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmxpbmVUbyggZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcclxuXHJcblx0XHR2YXIgbGFzdFBvaW50ID0gY3VydmUuZ2V0UG9pbnQoIDEgKTtcclxuXHRcdHRoaXMuY3VycmVudFBvaW50LmNvcHkoIGxhc3RQb2ludCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0XHRDdXJ2ZVBhdGgucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdFx0dGhpcy5jdXJyZW50UG9pbnQuY29weSggc291cmNlLmN1cnJlbnRQb2ludCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0pTT046IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgZGF0YSA9IEN1cnZlUGF0aC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHRkYXRhLmN1cnJlbnRQb2ludCA9IHRoaXMuY3VycmVudFBvaW50LnRvQXJyYXkoKTtcclxuXHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0fSxcclxuXHJcblx0ZnJvbUpTT046IGZ1bmN0aW9uICgganNvbiApIHtcclxuXHJcblx0XHRDdXJ2ZVBhdGgucHJvdG90eXBlLmZyb21KU09OLmNhbGwoIHRoaXMsIGpzb24gKTtcclxuXHJcblx0XHR0aGlzLmN1cnJlbnRQb2ludC5mcm9tQXJyYXkoIGpzb24uY3VycmVudFBvaW50ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuXHJcblxyXG5leHBvcnQgeyBQYXRoIH07XHJcbiIsImltcG9ydCB7IFBhdGggfSBmcm9tICcuL1BhdGguanMnO1xyXG5pbXBvcnQgeyBfTWF0aCB9IGZyb20gJy4uLy4uL21hdGgvTWF0aC5qcyc7XHJcblxyXG4vKipcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKiBEZWZpbmVzIGEgMmQgc2hhcGUgcGxhbmUgdXNpbmcgcGF0aHMuXHJcbiAqKi9cclxuXHJcbi8vIFNURVAgMSBDcmVhdGUgYSBwYXRoLlxyXG4vLyBTVEVQIDIgVHVybiBwYXRoIGludG8gc2hhcGUuXHJcbi8vIFNURVAgMyBFeHRydWRlR2VvbWV0cnkgdGFrZXMgaW4gU2hhcGUvU2hhcGVzXHJcbi8vIFNURVAgM2EgLSBFeHRyYWN0IHBvaW50cyBmcm9tIGVhY2ggc2hhcGUsIHR1cm4gdG8gdmVydGljZXNcclxuLy8gU1RFUCAzYiAtIFRyaWFuZ3VsYXRlIGVhY2ggc2hhcGUsIGFkZCBmYWNlcy5cclxuXHJcbmZ1bmN0aW9uIFNoYXBlKCBwb2ludHMgKSB7XHJcblxyXG5cdFBhdGguY2FsbCggdGhpcywgcG9pbnRzICk7XHJcblxyXG5cdHRoaXMudXVpZCA9IF9NYXRoLmdlbmVyYXRlVVVJRCgpO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnU2hhcGUnO1xyXG5cclxuXHR0aGlzLmhvbGVzID0gW107XHJcblxyXG59XHJcblxyXG5TaGFwZS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBQYXRoLnByb3RvdHlwZSApLCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBTaGFwZSxcclxuXHJcblx0Z2V0UG9pbnRzSG9sZXM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xyXG5cclxuXHRcdHZhciBob2xlc1B0cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGhvbGVzUHRzWyBpIF0gPSB0aGlzLmhvbGVzWyBpIF0uZ2V0UG9pbnRzKCBkaXZpc2lvbnMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGhvbGVzUHRzO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBnZXQgcG9pbnRzIG9mIHNoYXBlIGFuZCBob2xlcyAoa2V5cG9pbnRzIGJhc2VkIG9uIHNlZ21lbnRzIHBhcmFtZXRlcilcclxuXHJcblx0ZXh0cmFjdFBvaW50czogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHJcblx0XHRcdHNoYXBlOiB0aGlzLmdldFBvaW50cyggZGl2aXNpb25zICksXHJcblx0XHRcdGhvbGVzOiB0aGlzLmdldFBvaW50c0hvbGVzKCBkaXZpc2lvbnMgKVxyXG5cclxuXHRcdH07XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdFBhdGgucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdFx0dGhpcy5ob2xlcyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHNvdXJjZS5ob2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGhvbGUgPSBzb3VyY2UuaG9sZXNbIGkgXTtcclxuXHJcblx0XHRcdHRoaXMuaG9sZXMucHVzaCggaG9sZS5jbG9uZSgpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0pTT046IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgZGF0YSA9IFBhdGgucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xyXG5cdFx0ZGF0YS5ob2xlcyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBob2xlID0gdGhpcy5ob2xlc1sgaSBdO1xyXG5cdFx0XHRkYXRhLmhvbGVzLnB1c2goIGhvbGUudG9KU09OKCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGRhdGE7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21KU09OOiBmdW5jdGlvbiAoIGpzb24gKSB7XHJcblxyXG5cdFx0UGF0aC5wcm90b3R5cGUuZnJvbUpTT04uY2FsbCggdGhpcywganNvbiApO1xyXG5cclxuXHRcdHRoaXMudXVpZCA9IGpzb24udXVpZDtcclxuXHRcdHRoaXMuaG9sZXMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgaG9sZSA9IGpzb24uaG9sZXNbIGkgXTtcclxuXHRcdFx0dGhpcy5ob2xlcy5wdXNoKCBuZXcgUGF0aCgpLmZyb21KU09OKCBob2xlICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuXHJcblxyXG5leHBvcnQgeyBTaGFwZSB9O1xyXG4iLCJpbXBvcnQge1ZlY3RvcjN9IGZyb20gXCIuLi9tYXRoL1ZlY3RvcjNcIjtcclxuaW1wb3J0IHtWZWN0b3IyfSBmcm9tIFwiLi4vbWF0aC9WZWN0b3IyXCI7XHJcbmltcG9ydCB7U3BoZXJlfSBmcm9tIFwiLi4vbWF0aC9TcGhlcmVcIjtcclxuaW1wb3J0IHtCb3gzfSBmcm9tIFwiLi4vbWF0aC9Cb3gzXCI7XHJcbmltcG9ydCB7RXh0cnVkZUJ1ZmZlckdlb21ldHJ5fSBmcm9tIFwiLi4vbG9hZGVyL0V4dHJ1ZGVHZW9tZXRyeVwiO1xyXG5pbXBvcnQge1NoYXBlfSBmcm9tIFwiLi4vZXh0cmFzL2NvcmUvU2hhcGVcIjtcclxuXHJcbmNsYXNzIFRleHRHZW9tZXRyeSB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbSkge1xyXG4gICAgICAgIHBhcmFtID0gcGFyYW0gfHwge307XHJcblxyXG4gICAgICAgIHRoaXMudGV4dCA9IHBhcmFtLnRleHQgPT0gdW5kZWZpbmVkID8gJzAnIDogcGFyYW0udGV4dDtcclxuXHJcbiAgICAgICAgaWYodGhpcy50ZXh0ID09ICcyJyl7XHJcblxyXG4gICAgICAgICAgICB2YXIgcHRzID0gW107XHJcblxyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDAsIDEwICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA1LCAxMCApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNSwgNC41ICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAxLCA0LjUgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDEsIDEgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDUsIDEgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDUsIDAgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDAsIDAgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDAsIDUuNSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNCwgNS41ICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA0LCA5ICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAwLCA5ICkgKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IG5ldyBTaGFwZSggcHRzICk7XHJcbiAgICAgICAgICAgIHZhciBleHRydWRlU2V0dGluZ3MgPSB7XHJcbiAgICAgICAgICAgICAgICBkZXB0aDogMyxcclxuICAgICAgICAgICAgICAgIHN0ZXBzOiAxLFxyXG4gICAgICAgICAgICAgICAgYmV2ZWxFbmFibGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGJldmVsVGhpY2tuZXNzOiAyLFxyXG4gICAgICAgICAgICAgICAgYmV2ZWxTaXplOiA0LFxyXG4gICAgICAgICAgICAgICAgYmV2ZWxTZWdtZW50czogMVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgZXh0cnVkZUdlb21ldHJ5ID0gbmV3IEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeSggc2hhcGUsIGV4dHJ1ZGVTZXR0aW5ncyApO1xyXG5cclxuICAgICAgICAgICAgdmFyIGluZGljZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8ZXh0cnVkZUdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXkubGVuZ3RoLzM7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goaSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHBhcmFtLnZlcnRpY2VzID0gZXh0cnVkZUdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcbiAgICAgICAgICAgIHBhcmFtLm5vcm1hbCA9IGV4dHJ1ZGVHZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcclxuICAgICAgICAgICAgcGFyYW0udXYgPSBleHRydWRlR2VvbWV0cnkuYXR0cmlidXRlcy51di5hcnJheTtcclxuICAgICAgICAgICAgcGFyYW0uaW5kaWNlcyA9IGluZGljZXM7XHJcblxyXG5cclxuICAgICAgICB9ZWxzZSBpZih0aGlzLnRleHQgPT0gJzEnKXtcclxuXHJcbiAgICAgICAgICAgIHZhciBwdHMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNC41LCAwICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA0LjUsIDEwICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA1LjUsIDEwICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA1LjUsIDAgKSApO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IG5ldyBTaGFwZSggcHRzICk7XHJcbiAgICAgICAgICAgIHZhciBleHRydWRlU2V0dGluZ3MgPSB7XHJcbiAgICAgICAgICAgICAgICBkZXB0aDogMyxcclxuICAgICAgICAgICAgICAgIHN0ZXBzOiAxLFxyXG4gICAgICAgICAgICAgICAgYmV2ZWxFbmFibGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGJldmVsVGhpY2tuZXNzOiAyLFxyXG4gICAgICAgICAgICAgICAgYmV2ZWxTaXplOiA0LFxyXG4gICAgICAgICAgICAgICAgYmV2ZWxTZWdtZW50czogMVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgZXh0cnVkZUdlb21ldHJ5ID0gbmV3IEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeSggc2hhcGUsIGV4dHJ1ZGVTZXR0aW5ncyApO1xyXG5cclxuICAgICAgICAgICAgdmFyIGluZGljZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8ZXh0cnVkZUdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXkubGVuZ3RoLzM7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goaSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHBhcmFtLnZlcnRpY2VzID0gZXh0cnVkZUdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcbiAgICAgICAgICAgIHBhcmFtLm5vcm1hbCA9IGV4dHJ1ZGVHZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcclxuICAgICAgICAgICAgcGFyYW0udXYgPSBleHRydWRlR2VvbWV0cnkuYXR0cmlidXRlcy51di5hcnJheTtcclxuICAgICAgICAgICAgcGFyYW0uaW5kaWNlcyA9IGluZGljZXM7XHJcblxyXG5cclxuICAgICAgICB9ZWxzZSBpZih0aGlzLnRleHQgPT0gJzMnKXtcclxuXHJcbiAgICAgICAgICAgIHZhciBwdHMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMCwgMCApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMCwgMSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNCwgMSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNCwgNC41ICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAwLCA0LjUgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDAsIDUuNSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNCwgNS41ICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA0LCA5ICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAwLCA5ICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAwLCAxMCApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNSwgMTAgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDUsIDAgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDUsIDAgKSApO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBuZXcgU2hhcGUoIHB0cyApO1xyXG4gICAgICAgICAgICB2YXIgZXh0cnVkZVNldHRpbmdzID0ge1xyXG4gICAgICAgICAgICAgICAgZGVwdGg6IDMsXHJcbiAgICAgICAgICAgICAgICBzdGVwczogMSxcclxuICAgICAgICAgICAgICAgIGJldmVsRW5hYmxlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBiZXZlbFRoaWNrbmVzczogMixcclxuICAgICAgICAgICAgICAgIGJldmVsU2l6ZTogNCxcclxuICAgICAgICAgICAgICAgIGJldmVsU2VnbWVudHM6IDFcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGV4dHJ1ZGVHZW9tZXRyeSA9IG5ldyBFeHRydWRlQnVmZmVyR2VvbWV0cnkoIHNoYXBlLCBleHRydWRlU2V0dGluZ3MgKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBpbmRpY2VzID0gW107XHJcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPGV4dHJ1ZGVHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5Lmxlbmd0aC8zOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwYXJhbS52ZXJ0aWNlcyA9IGV4dHJ1ZGVHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xyXG4gICAgICAgICAgICBwYXJhbS5ub3JtYWwgPSBleHRydWRlR2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XHJcbiAgICAgICAgICAgIHBhcmFtLnV2ID0gZXh0cnVkZUdlb21ldHJ5LmF0dHJpYnV0ZXMudXYuYXJyYXk7XHJcbiAgICAgICAgICAgIHBhcmFtLmluZGljZXMgPSBpbmRpY2VzO1xyXG5cclxuXHJcbiAgICAgICAgfWVsc2UgaWYodGhpcy50ZXh0ID09ICc0Jyl7XHJcblxyXG4gICAgICAgICAgICB2YXIgcHRzID0gW107XHJcblxyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDAsIDEwICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAxLCAxMCApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMSwgNS41ICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA0LCA1LjUgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDQsIDEwICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA1LCAxMCApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNSwgMCApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNCwgMCApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNCwgNC41ICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAwLCA0LjUgKSApO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IG5ldyBTaGFwZSggcHRzICk7XHJcbiAgICAgICAgICAgIHZhciBleHRydWRlU2V0dGluZ3MgPSB7XHJcbiAgICAgICAgICAgICAgICBkZXB0aDogMyxcclxuICAgICAgICAgICAgICAgIHN0ZXBzOiAxLFxyXG4gICAgICAgICAgICAgICAgYmV2ZWxFbmFibGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGJldmVsVGhpY2tuZXNzOiAyLFxyXG4gICAgICAgICAgICAgICAgYmV2ZWxTaXplOiA0LFxyXG4gICAgICAgICAgICAgICAgYmV2ZWxTZWdtZW50czogMVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgZXh0cnVkZUdlb21ldHJ5ID0gbmV3IEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeSggc2hhcGUsIGV4dHJ1ZGVTZXR0aW5ncyApO1xyXG5cclxuICAgICAgICAgICAgdmFyIGluZGljZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8ZXh0cnVkZUdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXkubGVuZ3RoLzM7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goaSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHBhcmFtLnZlcnRpY2VzID0gZXh0cnVkZUdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcbiAgICAgICAgICAgIHBhcmFtLm5vcm1hbCA9IGV4dHJ1ZGVHZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcclxuICAgICAgICAgICAgcGFyYW0udXYgPSBleHRydWRlR2VvbWV0cnkuYXR0cmlidXRlcy51di5hcnJheTtcclxuICAgICAgICAgICAgcGFyYW0uaW5kaWNlcyA9IGluZGljZXM7XHJcblxyXG5cclxuICAgICAgICB9ZWxzZSBpZih0aGlzLnRleHQgPT0gJzUnKXtcclxuXHJcbiAgICAgICAgICAgIHZhciBwdHMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMCwgMCApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMCwgMSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNCwgMSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNCwgNC41ICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAwLCA0LjUgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDAsIDEwICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA1LCAxMCApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNSwgOSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMSwgOSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMSwgNS41ICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA1LCA1LjUgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDUsIDAgKSApO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IG5ldyBTaGFwZSggcHRzICk7XHJcbiAgICAgICAgICAgIHZhciBleHRydWRlU2V0dGluZ3MgPSB7XHJcbiAgICAgICAgICAgICAgICBkZXB0aDogMyxcclxuICAgICAgICAgICAgICAgIHN0ZXBzOiAxLFxyXG4gICAgICAgICAgICAgICAgYmV2ZWxFbmFibGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGJldmVsVGhpY2tuZXNzOiAyLFxyXG4gICAgICAgICAgICAgICAgYmV2ZWxTaXplOiA0LFxyXG4gICAgICAgICAgICAgICAgYmV2ZWxTZWdtZW50czogMVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgZXh0cnVkZUdlb21ldHJ5ID0gbmV3IEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeSggc2hhcGUsIGV4dHJ1ZGVTZXR0aW5ncyApO1xyXG5cclxuICAgICAgICAgICAgdmFyIGluZGljZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8ZXh0cnVkZUdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXkubGVuZ3RoLzM7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goaSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHBhcmFtLnZlcnRpY2VzID0gZXh0cnVkZUdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcbiAgICAgICAgICAgIHBhcmFtLm5vcm1hbCA9IGV4dHJ1ZGVHZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcclxuICAgICAgICAgICAgcGFyYW0udXYgPSBleHRydWRlR2VvbWV0cnkuYXR0cmlidXRlcy51di5hcnJheTtcclxuICAgICAgICAgICAgcGFyYW0uaW5kaWNlcyA9IGluZGljZXM7XHJcbiAgICAgICAgfWVsc2UgaWYodGhpcy50ZXh0ID09ICc2Jyl7XHJcblxyXG4gICAgICAgICAgICB2YXIgcHRzID0gW107XHJcblxyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDUsIDEwICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAwLCAxMCApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMCwgMCApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNSwgMCApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNSwgNS41ICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAxLCA1LjUgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDEsIDQuNSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNCwgNC41ICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA0LCAxICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAxLCAxICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAxLCA5ICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA1LCA5ICkgKTtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gbmV3IFNoYXBlKCBwdHMgKTtcclxuICAgICAgICAgICAgdmFyIGV4dHJ1ZGVTZXR0aW5ncyA9IHtcclxuICAgICAgICAgICAgICAgIGRlcHRoOiAzLFxyXG4gICAgICAgICAgICAgICAgc3RlcHM6IDEsXHJcbiAgICAgICAgICAgICAgICBiZXZlbEVuYWJsZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgYmV2ZWxUaGlja25lc3M6IDIsXHJcbiAgICAgICAgICAgICAgICBiZXZlbFNpemU6IDQsXHJcbiAgICAgICAgICAgICAgICBiZXZlbFNlZ21lbnRzOiAxXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBleHRydWRlR2VvbWV0cnkgPSBuZXcgRXh0cnVkZUJ1ZmZlckdlb21ldHJ5KCBzaGFwZSwgZXh0cnVkZVNldHRpbmdzICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgaW5kaWNlcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxleHRydWRlR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheS5sZW5ndGgvMzsgaSsrKXtcclxuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcGFyYW0udmVydGljZXMgPSBleHRydWRlR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcclxuICAgICAgICAgICAgcGFyYW0ubm9ybWFsID0gZXh0cnVkZUdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xyXG4gICAgICAgICAgICBwYXJhbS51diA9IGV4dHJ1ZGVHZW9tZXRyeS5hdHRyaWJ1dGVzLnV2LmFycmF5O1xyXG4gICAgICAgICAgICBwYXJhbS5pbmRpY2VzID0gaW5kaWNlcztcclxuICAgICAgICB9ZWxzZSBpZih0aGlzLnRleHQgPT0gJzcnKXtcclxuXHJcbiAgICAgICAgICAgIHZhciBwdHMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMCwgMTAgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDUsIDEwICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA1LCAwICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA0LCAwICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA0LCA5ICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAwLCA5ICkgKTtcclxuXHJcblxyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBuZXcgU2hhcGUoIHB0cyApO1xyXG4gICAgICAgICAgICB2YXIgZXh0cnVkZVNldHRpbmdzID0ge1xyXG4gICAgICAgICAgICAgICAgZGVwdGg6IDMsXHJcbiAgICAgICAgICAgICAgICBzdGVwczogMSxcclxuICAgICAgICAgICAgICAgIGJldmVsRW5hYmxlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBiZXZlbFRoaWNrbmVzczogMixcclxuICAgICAgICAgICAgICAgIGJldmVsU2l6ZTogNCxcclxuICAgICAgICAgICAgICAgIGJldmVsU2VnbWVudHM6IDFcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGV4dHJ1ZGVHZW9tZXRyeSA9IG5ldyBFeHRydWRlQnVmZmVyR2VvbWV0cnkoIHNoYXBlLCBleHRydWRlU2V0dGluZ3MgKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBpbmRpY2VzID0gW107XHJcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPGV4dHJ1ZGVHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5Lmxlbmd0aC8zOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwYXJhbS52ZXJ0aWNlcyA9IGV4dHJ1ZGVHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xyXG4gICAgICAgICAgICBwYXJhbS5ub3JtYWwgPSBleHRydWRlR2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XHJcbiAgICAgICAgICAgIHBhcmFtLnV2ID0gZXh0cnVkZUdlb21ldHJ5LmF0dHJpYnV0ZXMudXYuYXJyYXk7XHJcbiAgICAgICAgICAgIHBhcmFtLmluZGljZXMgPSBpbmRpY2VzO1xyXG4gICAgICAgIH1lbHNlIGlmKHRoaXMudGV4dCA9PSAnOCcpe1xyXG5cclxuICAgICAgICAgICAgdmFyIHB0cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA1LCAxMCApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMCwgMTAgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDAsIDAgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDUsIDAgKSApO1xyXG5cclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA1LCA5ICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA0LCA5ICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA0LCA1LjUgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDEsIDUuNSApICk7XHJcblxyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDEsIDQuNSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNCwgNC41ICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA0LCAxICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAxLCAxICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAxLCA5ICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA1LCA5ICkgKTtcclxuXHJcblxyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBuZXcgU2hhcGUoIHB0cyApO1xyXG4gICAgICAgICAgICB2YXIgZXh0cnVkZVNldHRpbmdzID0ge1xyXG4gICAgICAgICAgICAgICAgZGVwdGg6IDMsXHJcbiAgICAgICAgICAgICAgICBzdGVwczogMSxcclxuICAgICAgICAgICAgICAgIGJldmVsRW5hYmxlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBiZXZlbFRoaWNrbmVzczogMixcclxuICAgICAgICAgICAgICAgIGJldmVsU2l6ZTogNCxcclxuICAgICAgICAgICAgICAgIGJldmVsU2VnbWVudHM6IDFcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGV4dHJ1ZGVHZW9tZXRyeSA9IG5ldyBFeHRydWRlQnVmZmVyR2VvbWV0cnkoIHNoYXBlLCBleHRydWRlU2V0dGluZ3MgKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBpbmRpY2VzID0gW107XHJcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPGV4dHJ1ZGVHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5Lmxlbmd0aC8zOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwYXJhbS52ZXJ0aWNlcyA9IGV4dHJ1ZGVHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xyXG4gICAgICAgICAgICBwYXJhbS5ub3JtYWwgPSBleHRydWRlR2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XHJcbiAgICAgICAgICAgIHBhcmFtLnV2ID0gZXh0cnVkZUdlb21ldHJ5LmF0dHJpYnV0ZXMudXYuYXJyYXk7XHJcbiAgICAgICAgICAgIHBhcmFtLmluZGljZXMgPSBpbmRpY2VzO1xyXG4gICAgICAgIH1lbHNlIGlmKHRoaXMudGV4dCA9PSAnOScpe1xyXG5cclxuICAgICAgICAgICAgdmFyIHB0cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAwLCAxMCApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMSwgMTAgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDEsIDUuNSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNCwgNS41ICkgKTtcclxuXHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNCwgOSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMSwgOSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMSwgMTAgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDUsIDEwICkgKTtcclxuXHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNSwgMCApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNCwgMCApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNCwgNC41ICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAwLCA0LjUgKSApO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IG5ldyBTaGFwZSggcHRzICk7XHJcbiAgICAgICAgICAgIHZhciBleHRydWRlU2V0dGluZ3MgPSB7XHJcbiAgICAgICAgICAgICAgICBkZXB0aDogMyxcclxuICAgICAgICAgICAgICAgIHN0ZXBzOiAxLFxyXG4gICAgICAgICAgICAgICAgYmV2ZWxFbmFibGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGJldmVsVGhpY2tuZXNzOiAyLFxyXG4gICAgICAgICAgICAgICAgYmV2ZWxTaXplOiA0LFxyXG4gICAgICAgICAgICAgICAgYmV2ZWxTZWdtZW50czogMVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgZXh0cnVkZUdlb21ldHJ5ID0gbmV3IEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeSggc2hhcGUsIGV4dHJ1ZGVTZXR0aW5ncyApO1xyXG5cclxuICAgICAgICAgICAgdmFyIGluZGljZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8ZXh0cnVkZUdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXkubGVuZ3RoLzM7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goaSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHBhcmFtLnZlcnRpY2VzID0gZXh0cnVkZUdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcbiAgICAgICAgICAgIHBhcmFtLm5vcm1hbCA9IGV4dHJ1ZGVHZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcclxuICAgICAgICAgICAgcGFyYW0udXYgPSBleHRydWRlR2VvbWV0cnkuYXR0cmlidXRlcy51di5hcnJheTtcclxuICAgICAgICAgICAgcGFyYW0uaW5kaWNlcyA9IGluZGljZXM7XHJcbiAgICAgICAgfWVsc2UgaWYodGhpcy50ZXh0ID09ICcwJyl7XHJcblxyXG4gICAgICAgICAgICB2YXIgcHRzID0gW107XHJcblxyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDUsIDEwICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAwLCAxMCApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMCwgMCApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNSwgMCApICk7XHJcblxyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDUsIDkgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDQsIDkgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDQsIDEgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDEsIDEgKSApO1xyXG5cclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAxLCA5ICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA1LCA5ICkgKTtcclxuXHJcblxyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBuZXcgU2hhcGUoIHB0cyApO1xyXG4gICAgICAgICAgICB2YXIgZXh0cnVkZVNldHRpbmdzID0ge1xyXG4gICAgICAgICAgICAgICAgZGVwdGg6IDMsXHJcbiAgICAgICAgICAgICAgICBzdGVwczogMSxcclxuICAgICAgICAgICAgICAgIGJldmVsRW5hYmxlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBiZXZlbFRoaWNrbmVzczogMixcclxuICAgICAgICAgICAgICAgIGJldmVsU2l6ZTogNCxcclxuICAgICAgICAgICAgICAgIGJldmVsU2VnbWVudHM6IDFcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGV4dHJ1ZGVHZW9tZXRyeSA9IG5ldyBFeHRydWRlQnVmZmVyR2VvbWV0cnkoIHNoYXBlLCBleHRydWRlU2V0dGluZ3MgKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBpbmRpY2VzID0gW107XHJcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPGV4dHJ1ZGVHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5Lmxlbmd0aC8zOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwYXJhbS52ZXJ0aWNlcyA9IGV4dHJ1ZGVHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xyXG4gICAgICAgICAgICBwYXJhbS5ub3JtYWwgPSBleHRydWRlR2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XHJcbiAgICAgICAgICAgIHBhcmFtLnV2ID0gZXh0cnVkZUdlb21ldHJ5LmF0dHJpYnV0ZXMudXYuYXJyYXk7XHJcbiAgICAgICAgICAgIHBhcmFtLmluZGljZXMgPSBpbmRpY2VzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy51diA9IHBhcmFtLnV2IHx8IG5ldyBGbG9hdDMyQXJyYXkoWyAgIC8vIFZlcnRleCBjb29yZGluYXRlc1xyXG5cclxuICAgICAgICAgICAgMSwxLCAwLDEsIDAsMCwgMSwwLCAgLy8gdjAtdjEtdjItdjMgZnJvbnRcclxuICAgICAgICAgICAgMCwxLCAwLDAsIDEsMCwgMSwxLCAgLy8gdjAtdjMtdjQtdjUgcmlnaHRcclxuICAgICAgICAgICAgMSwwLCAxLDEsIDAsMSwgMCwwLCAgLy8gdjAtdjUtdjYtdjEgdXBcclxuICAgICAgICAgICAgMSwxLCAwLDEsIDAsMCwgMSwwLCAgLy8gdjEtdjYtdjctdjIgbGVmdFxyXG4gICAgICAgICAgICAwLDEsIDEsMSwgMSwwLCAwLDAsICAvLyB2Ny12NC12My12MiBkb3duXHJcbiAgICAgICAgICAgIDEsMCwgMCwwLCAwLDEsIDEsMSAgIC8vIHY0LXY3LXY2LXY1IGJhY2tcclxuXHJcbiAgICAgICAgXSk7XHJcblxyXG4gICAgICAgIHRoaXMudmVydGljZXMgPSBwYXJhbS52ZXJ0aWNlcyB8fCBuZXcgRmxvYXQzMkFycmF5KFsgICAvLyBWZXJ0ZXggY29vcmRpbmF0ZXNcclxuICAgICAgICAgICAgMC41LCAwLjUsIDAuNSwgIC0wLjUsIDAuNSwgMC41LCAgLTAuNSwtMC41LCAwLjUsICAgMC41LC0wLjUsIDAuNSwgIC8vIHYwLXYxLXYyLXYzIGZyb250XHJcbiAgICAgICAgICAgIDAuNSwgMC41LCAwLjUsICAgMC41LC0wLjUsIDAuNSwgICAwLjUsLTAuNSwtMC41LCAgIDAuNSwgMC41LC0wLjUsICAvLyB2MC12My12NC12NSByaWdodFxyXG4gICAgICAgICAgICAwLjUsIDAuNSwgMC41LCAgIDAuNSwgMC41LC0wLjUsICAtMC41LCAwLjUsLTAuNSwgIC0wLjUsIDAuNSwgMC41LCAgLy8gdjAtdjUtdjYtdjEgdXBcclxuICAgICAgICAgICAgLTAuNSwgMC41LCAwLjUsICAtMC41LCAwLjUsLTAuNSwgIC0wLjUsLTAuNSwtMC41LCAgLTAuNSwtMC41LCAwLjUsICAvLyB2MS12Ni12Ny12MiBsZWZ0XHJcbiAgICAgICAgICAgIC0wLjUsLTAuNSwtMC41LCAgIDAuNSwtMC41LC0wLjUsICAgMC41LC0wLjUsIDAuNSwgIC0wLjUsLTAuNSwgMC41LCAgLy8gdjctdjQtdjMtdjIgZG93blxyXG4gICAgICAgICAgICAwLjUsLTAuNSwtMC41LCAgLTAuNSwtMC41LC0wLjUsICAtMC41LCAwLjUsLTAuNSwgICAwLjUsIDAuNSwtMC41ICAgLy8gdjQtdjctdjYtdjUgYmFja1xyXG4gICAgICAgIF0pO1xyXG5cclxuICAgICAgICB0aGlzLm5vcm1hbCA9IHBhcmFtLm5vcm1hbCB8fCB0aGlzLnZlcnRpY2VzO1xyXG5cclxuICAgICAgICB0aGlzLmluZGljZXMgPSBuZXcgVWludDE2QXJyYXkocGFyYW0uaW5kaWNlcyk7XHJcblxyXG4gICAgICAgIHRoaXMubW9ycGhBdHRyaWJ1dGVzID0gcGFyYW0ubW9ycGhBdHRyaWJ1dGVzO1xyXG5cclxuICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSgpO1xyXG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgQm94MygpO1xyXG4gICAgICAgIHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XHJcblxyXG4gICAgICAgIC8vIHRoaXMudXBkYXRlTm9ybWFsKCk7XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRhQnVmZmVyKCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0YUJ1ZmZlcigpe1xyXG4gICAgICAgIHZhciBidWZmZXIgPSBbXTtcclxuICAgICAgICB2YXIgdXYgPSB0aGlzLnV2O1xyXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XHJcbiAgICAgICAgdmFyIG5vcm1hbCA9IHRoaXMubm9ybWFsO1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHZlcnRpY2VzLmxlbmd0aDsgaSs9Myl7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKHZlcnRpY2VzW2krMF0pO1xyXG4gICAgICAgICAgICBidWZmZXIucHVzaCh2ZXJ0aWNlc1tpKzFdKTtcclxuICAgICAgICAgICAgYnVmZmVyLnB1c2godmVydGljZXNbaSsyXSk7XHJcblxyXG4gICAgICAgICAgICBidWZmZXIucHVzaChub3JtYWxbaSswXSk7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKG5vcm1hbFtpKzFdKTtcclxuICAgICAgICAgICAgYnVmZmVyLnB1c2gobm9ybWFsW2krMl0pO1xyXG5cclxuICAgICAgICAgICAgYnVmZmVyLnB1c2godXZbaS8zKjIrMF0pO1xyXG4gICAgICAgICAgICBidWZmZXIucHVzaCh1dltpLzMqMisxXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVOb3JtYWwoKXtcclxuICAgICAgICB2YXIgbm9ybWFsID0gW107XHJcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcclxuICAgICAgICBmb3IodmFyIGk9MDsgaTx2ZXJ0aWNlcy5sZW5ndGg7IGkrPTMqNCl7XHJcbiAgICAgICAgICAgIHZhciBsaW5lMSA9IG5ldyBWZWN0b3IzKCkuc3ViVmVjdG9ycyhcclxuICAgICAgICAgICAgICAgIG5ldyBWZWN0b3IzKHZlcnRpY2VzW2krMF0sIHZlcnRpY2VzW2krMV0sIHZlcnRpY2VzW2krMl0pLFxyXG4gICAgICAgICAgICAgICAgbmV3IFZlY3RvcjModmVydGljZXNbaSszXSwgdmVydGljZXNbaSs0XSwgdmVydGljZXNbaSs1XSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgdmFyIGxpbmUyID0gbmV3IFZlY3RvcjMoKS5zdWJWZWN0b3JzKFxyXG4gICAgICAgICAgICAgICAgbmV3IFZlY3RvcjModmVydGljZXNbaSszXSwgdmVydGljZXNbaSs0XSwgdmVydGljZXNbaSs1XSksXHJcbiAgICAgICAgICAgICAgICBuZXcgVmVjdG9yMyh2ZXJ0aWNlc1tpKzZdLCB2ZXJ0aWNlc1tpKzddLCB2ZXJ0aWNlc1tpKzhdKSxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgdmFyIGN1cl9ub3JtYWwgPSBuZXcgVmVjdG9yMygpLmNyb3NzVmVjdG9ycyhcclxuICAgICAgICAgICAgICAgIGxpbmUxLFxyXG4gICAgICAgICAgICAgICAgbGluZTJcclxuICAgICAgICAgICAgKS50b0FycmF5KCk7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaj0wIDtqPDQ7IGorKyl7XHJcbiAgICAgICAgICAgICAgICBub3JtYWwucHVzaChjdXJfbm9ybWFsWzBdLCBjdXJfbm9ybWFsWzFdLCBjdXJfbm9ybWFsWzJdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm5vcm1hbCA9IG5ldyBGbG9hdDMyQXJyYXkobm9ybWFsKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgY29tcHV0ZUJvdW5kaW5nQm94ICgpIHtcclxuICAgICAgICB2YXIgdmVydGljZXNWMyA9IFtdO1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHRoaXMudmVydGljZXMubGVuZ3RoOyBpKz0zKXtcclxuICAgICAgICAgICAgdmVydGljZXNWMy5wdXNoKG5ldyBWZWN0b3IzKHRoaXMudmVydGljZXNbaV0sIHRoaXMudmVydGljZXNbaSsxXSwgdGhpcy52ZXJ0aWNlc1tpKzJdKSlcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5zZXRGcm9tUG9pbnRzKHZlcnRpY2VzVjMpO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgVGV4dEdlb21ldHJ5O1xyXG4iLCJpbXBvcnQgVGV4dHVyZSBmcm9tIFwiLi9UZXh0dXJlXCI7XHJcblxyXG5jbGFzcyBDdWJlVGV4dHVyZSBleHRlbmRzIFRleHR1cmV7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtKTtcclxuXHJcbiAgICAgICAgcGFyYW0gPSBwYXJhbSB8fCB7fTtcclxuICAgICAgICB0aGlzLnVybHMgPSBwYXJhbS51cmxzO1xyXG5cclxuICAgICAgICB0aGlzLmltYWdlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuaW1nTG9hZENvdW50ID0gMDtcclxuICAgICAgICB0aGlzLmltZ1JlYWR5ID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgdXJscyA9IHRoaXMudXJscztcclxuICAgICAgICBmb3IodmFyIGkgaW4gdXJscyl7XHJcbiAgICAgICAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgICAgICB0aGF0LmltYWdlcy5wdXNoKGltYWdlKTtcclxuICAgICAgICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5pbWdMb2FkQ291bnQgKys7XHJcbiAgICAgICAgICAgICAgICBpZih0aGF0LmltZ0xvYWRDb3VudCA9PSA2KXtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LmltZ1JlYWR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGltYWdlLnNyYyA9IHVybHNbaV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBjbG9uZSgpe1xyXG5cclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEN1YmVUZXh0dXJlO1xyXG4iLCJcclxuaW1wb3J0IFJlbmRlcmVyIGZyb20gJy4vY29yZS9SZW5kZXJlci5qcyc7XHJcbmltcG9ydCBNZXNoIGZyb20gXCIuL2NvcmUvTWVzaC5qc1wiO1xyXG5pbXBvcnQgQ2FtZXJhIGZyb20gXCIuL2NhbWVyYS9DYW1lcmEuanNcIjtcclxuaW1wb3J0IENhbWVyYUNvbnRyb2xsZXIgZnJvbSBcIi4vY2FtZXJhL0NhbWVyYUNvbnRyb2xsZXIuanNcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuL2NvcmUvU2NlbmUuanNcIjtcclxuaW1wb3J0IE1hdGVyaWFsIGZyb20gXCIuL21hdGVyaWFsL01hdGVyaWFsXCI7XHJcbmltcG9ydCBUZXh0dXJlIGZyb20gXCIuL21hdGVyaWFsL1RleHR1cmVcIjtcclxuaW1wb3J0IE1lc2hCYXNpY01hdGVyaWFsIGZyb20gXCIuL21hdGVyaWFsL01lc2hCYXNpY01hdGVyaWFsXCI7XHJcbmltcG9ydCBNZXNoTGFtYmVydE1hdGVyaWFsIGZyb20gXCIuL21hdGVyaWFsL01lc2hMYW1iZXJ0TWF0ZXJpYWxcIjtcclxuaW1wb3J0IEFtYmllbnRMaWdodCBmcm9tIFwiLi9saWdodC9BbWJpZW50TGlnaHRcIjtcclxuaW1wb3J0IERpcmVjdGlvbmFsTGlnaHQgZnJvbSBcIi4vbGlnaHQvRGlyZWN0aW9uYWxMaWdodFwiO1xyXG5pbXBvcnQgTWVzaFN0YW5kYXJkTWF0ZXJpYWwgZnJvbSBcIi4vbWF0ZXJpYWwvTWVzaFN0YW5kYXJkTWF0ZXJpYWxcIjtcclxuaW1wb3J0IEdlb21ldHJ5IGZyb20gXCIuL2NvcmUvR2VvbWV0cnlcIjtcclxuaW1wb3J0IEJveEdlb21ldHJ5IGZyb20gXCIuL2NvcmUvQm94R2VvbWV0cnlcIjtcclxuaW1wb3J0IFNwaGVyZUdlb21ldHJ5IGZyb20gXCIuL2NvcmUvU3BoZXJlR2VvbWV0cnlcIjtcclxuXHJcbi8vIGltcG9ydCBfR0xURkxvYWRlciBmcm9tIFwiLi9jb3JlL0dMVEZMb2FkZXJcIjtcclxuaW1wb3J0IEdMVEZMb2FkZXIgZnJvbSBcIi4vY29yZS9HTFRGTG9hZGVyMlwiO1xyXG5cclxuaW1wb3J0IE9ydGhvQ2FtZXJhIGZyb20gXCIuL2NhbWVyYS9PcnRob0NhbWVyYVwiO1xyXG5pbXBvcnQgQW5pbWF0aW9uIGZyb20gXCIuL2FuaW1hdGlvbi9BbmltYXRpb25cIjtcclxuaW1wb3J0IHtSYXljYXN0ZXJ9IGZyb20gXCIuL2NvcmUvUmF5Y2FzdGVyXCI7XHJcblxyXG5pbXBvcnQge1ZlY3RvcjJ9IGZyb20gXCIuL21hdGgvVmVjdG9yMlwiO1xyXG5pbXBvcnQge1ZlY3RvcjN9IGZyb20gXCIuL21hdGgvVmVjdG9yM1wiO1xyXG5pbXBvcnQge0V4dHJ1ZGVHZW9tZXRyeX0gZnJvbSBcIi4vbG9hZGVyL0V4dHJ1ZGVHZW9tZXRyeVwiO1xyXG5pbXBvcnQge0V4dHJ1ZGVCdWZmZXJHZW9tZXRyeX0gZnJvbSBcIi4vbG9hZGVyL0V4dHJ1ZGVHZW9tZXRyeVwiO1xyXG5pbXBvcnQge1NoYXBlfSBmcm9tIFwiLi9leHRyYXMvY29yZS9TaGFwZS5qc1wiO1xyXG5pbXBvcnQgVGV4dEdlb21ldHJ5IGZyb20gXCIuL2NvcmUvVGV4dEdlb21ldHJ5XCI7XHJcbmltcG9ydCBDdWJlVGV4dHVyZSBmcm9tIFwiLi9tYXRlcmlhbC9DdWJlVGV4dHVyZVwiO1xyXG5cclxuXHJcbnZhciBDT09MID0gd2luZG93LkNPT0wgPSB7fTtcclxuXHJcbkNPT0wuTElORUFSID0gOTcyOTtcclxuQ09PTC5ORUFSRVNUID0gOTcyODtcclxuXHJcbkNPT0wuQ0xBTVBfVE9fRURHRSA9IDMzMDcxO1xyXG5DT09MLlJFUEVBVCA9IDEwNDk3O1xyXG5DT09MLk1JUlJPUkVEX1JFUEVBVCA9IDMzNjQ4O1xyXG5cclxuQ09PTC5SZW5kZXJlciA9IFJlbmRlcmVyO1xyXG5DT09MLk1lc2ggPSBNZXNoO1xyXG5DT09MLkNhbWVyYSA9IENhbWVyYTtcclxuQ09PTC5PcnRob0NhbWVyYSA9IE9ydGhvQ2FtZXJhO1xyXG5DT09MLkNhbWVyYUNvbnRyb2xsZXIgPSBDYW1lcmFDb250cm9sbGVyO1xyXG5DT09MLlNjZW5lID0gU2NlbmU7XHJcbkNPT0wuTWF0ZXJpYWwgPSBNYXRlcmlhbDtcclxuQ09PTC5NZXNoQmFzaWNNYXRlcmlhbCA9IE1lc2hCYXNpY01hdGVyaWFsO1xyXG5DT09MLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgPSBNZXNoTGFtYmVydE1hdGVyaWFsO1xyXG5DT09MLk1lc2hTdGFuZGFyZE1hdGVyaWFsID0gTWVzaFN0YW5kYXJkTWF0ZXJpYWw7XHJcblxyXG5DT09MLlRleHR1cmUgPSBUZXh0dXJlO1xyXG5DT09MLkN1YmVUZXh0dXJlID0gQ3ViZVRleHR1cmU7XHJcblxyXG5DT09MLkFtYmllbnRMaWdodCA9IEFtYmllbnRMaWdodDtcclxuQ09PTC5EaXJlY3Rpb25hbExpZ2h0ID0gRGlyZWN0aW9uYWxMaWdodDtcclxuXHJcbkNPT0wuR2VvbWV0cnkgPSBHZW9tZXRyeTtcclxuQ09PTC5Cb3hHZW9tZXRyeSA9IEJveEdlb21ldHJ5O1xyXG5DT09MLlNwaGVyZUdlb21ldHJ5ID0gU3BoZXJlR2VvbWV0cnk7XHJcblxyXG4vLyBDT09MLkdMVEZMb2FkZXIgPSBfR0xURkxvYWRlcjtcclxuQ09PTC5HTFRGTG9hZGVyMiA9IEdMVEZMb2FkZXI7XHJcblxyXG5DT09MLkFuaW1hdGlvbiA9IEFuaW1hdGlvbjtcclxuXHJcbkNPT0wuUmF5Y2FzdGVyID0gUmF5Y2FzdGVyO1xyXG5cclxuQ09PTC5WZWN0b3IyID0gVmVjdG9yMjtcclxuQ09PTC5WZWN0b3IzID0gVmVjdG9yMztcclxuXHJcbkNPT0wuRXh0cnVkZUdlb21ldHJ5ID0gRXh0cnVkZUdlb21ldHJ5O1xyXG5DT09MLkV4dHJ1ZGVCdWZmZXJHZW9tZXRyeSA9IEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeTtcclxuQ09PTC5UZXh0R2VvbWV0cnkgPSBUZXh0R2VvbWV0cnk7XHJcbkNPT0wuU2hhcGUgPSBTaGFwZTtcclxuXHJcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3MUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1bkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN3VCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdm1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3bEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM2VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNycUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbllBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNTNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMTVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWUE7OztBQzdhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDalJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3htQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6eUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdGVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n")}]);