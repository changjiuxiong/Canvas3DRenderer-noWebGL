!function(t){var c={};function n(r){if(c[r])return c[r].exports;var g=c[r]={i:r,l:!1,exports:{}};return t[r].call(g.exports,g,g.exports,n),g.l=!0,g.exports}n.m=t,n.c=c,n.d=function(t,c,r){n.o(t,c)||Object.defineProperty(t,c,{enumerable:!0,get:r})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,c){if(1&c&&(t=n(t)),8&c)return t;if(4&c&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&c&&"string"!=typeof t)for(var g in t)n.d(r,g,function(c){return t[c]}.bind(null,g));return r},n.n=function(t){var c=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(c,"a",c),c},n.o=function(t,c){return Object.prototype.hasOwnProperty.call(t,c)},n.p="",n(n.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\nvar Curves_namespaceObject = {};\n__webpack_require__.r(Curves_namespaceObject);\n__webpack_require__.d(Curves_namespaceObject, \"ArcCurve\", function() { return ArcCurve; });\n__webpack_require__.d(Curves_namespaceObject, \"CatmullRomCurve3\", function() { return CatmullRomCurve3; });\n__webpack_require__.d(Curves_namespaceObject, \"CubicBezierCurve\", function() { return CubicBezierCurve; });\n__webpack_require__.d(Curves_namespaceObject, \"CubicBezierCurve3\", function() { return CubicBezierCurve3; });\n__webpack_require__.d(Curves_namespaceObject, \"EllipseCurve\", function() { return EllipseCurve; });\n__webpack_require__.d(Curves_namespaceObject, \"LineCurve\", function() { return LineCurve; });\n__webpack_require__.d(Curves_namespaceObject, \"LineCurve3\", function() { return LineCurve3; });\n__webpack_require__.d(Curves_namespaceObject, \"QuadraticBezierCurve\", function() { return QuadraticBezierCurve; });\n__webpack_require__.d(Curves_namespaceObject, \"QuadraticBezierCurve3\", function() { return QuadraticBezierCurve3; });\n__webpack_require__.d(Curves_namespaceObject, \"SplineCurve\", function() { return SplineCurve; });\n\n// CONCATENATED MODULE: ./src/math/Math.js\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nvar _Math = {\r\n\r\n\tDEG2RAD: Math.PI / 180,\r\n\tRAD2DEG: 180 / Math.PI,\r\n\r\n\tgenerateUUID: ( function () {\r\n\r\n\t\t// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\r\n\r\n\t\tvar lut = [];\r\n\r\n\t\tfor ( var i = 0; i < 256; i ++ ) {\r\n\r\n\t\t\tlut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );\r\n\r\n\t\t}\r\n\r\n\t\treturn function generateUUID() {\r\n\r\n\t\t\tvar d0 = Math.random() * 0xffffffff | 0;\r\n\t\t\tvar d1 = Math.random() * 0xffffffff | 0;\r\n\t\t\tvar d2 = Math.random() * 0xffffffff | 0;\r\n\t\t\tvar d3 = Math.random() * 0xffffffff | 0;\r\n\t\t\tvar uuid = lut[ d0 & 0xff ] + lut[ d0 >> 8 & 0xff ] + lut[ d0 >> 16 & 0xff ] + lut[ d0 >> 24 & 0xff ] + '-' +\r\n\t\t\t\tlut[ d1 & 0xff ] + lut[ d1 >> 8 & 0xff ] + '-' + lut[ d1 >> 16 & 0x0f | 0x40 ] + lut[ d1 >> 24 & 0xff ] + '-' +\r\n\t\t\t\tlut[ d2 & 0x3f | 0x80 ] + lut[ d2 >> 8 & 0xff ] + '-' + lut[ d2 >> 16 & 0xff ] + lut[ d2 >> 24 & 0xff ] +\r\n\t\t\t\tlut[ d3 & 0xff ] + lut[ d3 >> 8 & 0xff ] + lut[ d3 >> 16 & 0xff ] + lut[ d3 >> 24 & 0xff ];\r\n\r\n\t\t\t// .toUpperCase() here flattens concatenated strings to save heap memory space.\r\n\t\t\treturn uuid.toUpperCase();\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n\tclamp: function ( value, min, max ) {\r\n\r\n\t\treturn Math.max( min, Math.min( max, value ) );\r\n\r\n\t},\r\n\r\n\t// compute euclidian modulo of m % n\r\n\t// https://en.wikipedia.org/wiki/Modulo_operation\r\n\r\n\teuclideanModulo: function ( n, m ) {\r\n\r\n\t\treturn ( ( n % m ) + m ) % m;\r\n\r\n\t},\r\n\r\n\t// Linear mapping from range <a1, a2> to range <b1, b2>\r\n\r\n\tmapLinear: function ( x, a1, a2, b1, b2 ) {\r\n\r\n\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\r\n\r\n\t},\r\n\r\n\t// https://en.wikipedia.org/wiki/Linear_interpolation\r\n\r\n\tlerp: function ( x, y, t ) {\r\n\r\n\t\treturn ( 1 - t ) * x + t * y;\r\n\r\n\t},\r\n\r\n\t// http://en.wikipedia.org/wiki/Smoothstep\r\n\r\n\tsmoothstep: function ( x, min, max ) {\r\n\r\n\t\tif ( x <= min ) return 0;\r\n\t\tif ( x >= max ) return 1;\r\n\r\n\t\tx = ( x - min ) / ( max - min );\r\n\r\n\t\treturn x * x * ( 3 - 2 * x );\r\n\r\n\t},\r\n\r\n\tsmootherstep: function ( x, min, max ) {\r\n\r\n\t\tif ( x <= min ) return 0;\r\n\t\tif ( x >= max ) return 1;\r\n\r\n\t\tx = ( x - min ) / ( max - min );\r\n\r\n\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\r\n\r\n\t},\r\n\r\n\t// Random integer from <low, high> interval\r\n\r\n\trandInt: function ( low, high ) {\r\n\r\n\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\r\n\r\n\t},\r\n\r\n\t// Random float from <low, high> interval\r\n\r\n\trandFloat: function ( low, high ) {\r\n\r\n\t\treturn low + Math.random() * ( high - low );\r\n\r\n\t},\r\n\r\n\t// Random float from <-range/2, range/2> interval\r\n\r\n\trandFloatSpread: function ( range ) {\r\n\r\n\t\treturn range * ( 0.5 - Math.random() );\r\n\r\n\t},\r\n\r\n\tdegToRad: function ( degrees ) {\r\n\r\n\t\treturn degrees * _Math.DEG2RAD;\r\n\r\n\t},\r\n\r\n\tradToDeg: function ( radians ) {\r\n\r\n\t\treturn radians * _Math.RAD2DEG;\r\n\r\n\t},\r\n\r\n\tisPowerOfTwo: function ( value ) {\r\n\r\n\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\r\n\r\n\t},\r\n\r\n\tceilPowerOfTwo: function ( value ) {\r\n\r\n\t\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\r\n\r\n\t},\r\n\r\n\tfloorPowerOfTwo: function ( value ) {\r\n\r\n\t\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\r\n\r\n\t}\r\n\r\n};\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/math/Vector4.js\n/**\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author egraether / http://egraether.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nfunction Vector4( x, y, z, w ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\tthis.z = z || 0;\r\n\tthis.w = ( w !== undefined ) ? w : 1;\r\n\r\n\tthis.elements = [this.x,this.y,this.z,this.w];\r\n}\r\n\r\nObject.assign( Vector4.prototype, {\r\n\r\n\tisVector4: true,\r\n\r\n\tset: function ( x, y, z, w ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\t\tthis.w = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetScalar: function ( scalar ) {\r\n\r\n\t\tthis.x = scalar;\r\n\t\tthis.y = scalar;\r\n\t\tthis.z = scalar;\r\n\t\tthis.w = scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetZ: function ( z ) {\r\n\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetW: function ( w ) {\r\n\r\n\t\tthis.w = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tcase 2: this.z = value; break;\r\n\t\t\tcase 3: this.w = value; break;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tcase 2: return this.z;\r\n\t\t\tcase 3: return this.w;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\t\tthis.z = v.z;\r\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\t\tthis.z += v.z;\r\n\t\tthis.w += v.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\t\tthis.z += s;\r\n\t\tthis.w += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\t\tthis.z = a.z + b.z;\r\n\t\tthis.w = a.w + b.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScaledVector: function ( v, s ) {\r\n\r\n\t\tthis.x += v.x * s;\r\n\t\tthis.y += v.y * s;\r\n\t\tthis.z += v.z * s;\r\n\t\tthis.w += v.w * s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\t\tthis.z -= v.z;\r\n\t\tthis.w -= v.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubScalar: function ( s ) {\r\n\r\n\t\tthis.x -= s;\r\n\t\tthis.y -= s;\r\n\t\tthis.z -= s;\r\n\t\tthis.w -= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\t\tthis.z = a.z - b.z;\r\n\t\tthis.w = a.w - b.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( scalar ) {\r\n\r\n\t\tthis.x *= scalar;\r\n\t\tthis.y *= scalar;\r\n\t\tthis.z *= scalar;\r\n\t\tthis.w *= scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( m ) {\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z, w = this.w;\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\r\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\r\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\r\n\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( scalar ) {\r\n\r\n\t\treturn this.multiplyScalar( 1 / scalar );\r\n\r\n\t},\r\n\r\n\tsetAxisAngleFromQuaternion: function ( q ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\r\n\r\n\t\t// q is assumed to be normalized\r\n\r\n\t\tthis.w = 2 * Math.acos( q.w );\r\n\r\n\t\tvar s = Math.sqrt( 1 - q.w * q.w );\r\n\r\n\t\tif ( s < 0.0001 ) {\r\n\r\n\t\t\tthis.x = 1;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.z = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.x = q.x / s;\r\n\t\t\tthis.y = q.y / s;\r\n\t\t\tthis.z = q.z / s;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetAxisAngleFromRotationMatrix: function ( m ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tvar angle, x, y, z,\t\t// variables for result\r\n\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\r\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\r\n\r\n\t\t\tte = m.elements,\r\n\r\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\r\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\r\n\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\r\n\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\r\n\r\n\t\t\t// singularity found\r\n\t\t\t// first check for identity matrix which must have +1 for all terms\r\n\t\t\t// in leading diagonal and zero in other terms\r\n\r\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\r\n\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\r\n\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\r\n\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\r\n\r\n\t\t\t\t// this singularity is identity matrix so angle = 0\r\n\r\n\t\t\t\tthis.set( 1, 0, 0, 0 );\r\n\r\n\t\t\t\treturn this; // zero angle, arbitrary axis\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// otherwise this singularity is angle = 180\r\n\r\n\t\t\tangle = Math.PI;\r\n\r\n\t\t\tvar xx = ( m11 + 1 ) / 2;\r\n\t\t\tvar yy = ( m22 + 1 ) / 2;\r\n\t\t\tvar zz = ( m33 + 1 ) / 2;\r\n\t\t\tvar xy = ( m12 + m21 ) / 4;\r\n\t\t\tvar xz = ( m13 + m31 ) / 4;\r\n\t\t\tvar yz = ( m23 + m32 ) / 4;\r\n\r\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\r\n\r\n\t\t\t\t// m11 is the largest diagonal term\r\n\r\n\t\t\t\tif ( xx < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0;\r\n\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\tz = 0.707106781;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tx = Math.sqrt( xx );\r\n\t\t\t\t\ty = xy / x;\r\n\t\t\t\t\tz = xz / x;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( yy > zz ) {\r\n\r\n\t\t\t\t// m22 is the largest diagonal term\r\n\r\n\t\t\t\tif ( yy < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\ty = 0;\r\n\t\t\t\t\tz = 0.707106781;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ty = Math.sqrt( yy );\r\n\t\t\t\t\tx = xy / y;\r\n\t\t\t\t\tz = yz / y;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// m33 is the largest diagonal term so base result on this\r\n\r\n\t\t\t\tif ( zz < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\tz = 0;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tz = Math.sqrt( zz );\r\n\t\t\t\t\tx = xz / z;\r\n\t\t\t\t\ty = yz / z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.set( x, y, z, angle );\r\n\r\n\t\t\treturn this; // return 180 deg rotation\r\n\r\n\t\t}\r\n\r\n\t\t// as we have reached here there are no singularities so we can handle normally\r\n\r\n\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\r\n\t\t                   ( m13 - m31 ) * ( m13 - m31 ) +\r\n\t\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\r\n\r\n\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\r\n\r\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\r\n\t\t// caught by singularity test above, but I've left it in just in case\r\n\r\n\t\tthis.x = ( m32 - m23 ) / s;\r\n\t\tthis.y = ( m13 - m31 ) / s;\r\n\t\tthis.z = ( m21 - m12 ) / s;\r\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tthis.x = Math.min( this.x, v.x );\r\n\t\tthis.y = Math.min( this.y, v.y );\r\n\t\tthis.z = Math.min( this.z, v.z );\r\n\t\tthis.w = Math.min( this.w, v.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tthis.x = Math.max( this.x, v.x );\r\n\t\tthis.y = Math.max( this.y, v.y );\r\n\t\tthis.z = Math.max( this.z, v.z );\r\n\t\tthis.w = Math.max( this.w, v.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// assumes min < max, componentwise\r\n\r\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\r\n\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclampScalar: function () {\r\n\r\n\t\tvar min, max;\r\n\r\n\t\treturn function clampScalar( minVal, maxVal ) {\r\n\r\n\t\t\tif ( min === undefined ) {\r\n\r\n\t\t\t\tmin = new Vector4();\r\n\t\t\t\tmax = new Vector4();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmin.set( minVal, minVal, minVal, minVal );\r\n\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\r\n\r\n\t\t\treturn this.clamp( min, max );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclampLength: function ( min, max ) {\r\n\r\n\t\tvar length = this.length();\r\n\r\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\r\n\r\n\t},\r\n\r\n\tfloor: function () {\r\n\r\n\t\tthis.x = Math.floor( this.x );\r\n\t\tthis.y = Math.floor( this.y );\r\n\t\tthis.z = Math.floor( this.z );\r\n\t\tthis.w = Math.floor( this.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tceil: function () {\r\n\r\n\t\tthis.x = Math.ceil( this.x );\r\n\t\tthis.y = Math.ceil( this.y );\r\n\t\tthis.z = Math.ceil( this.z );\r\n\t\tthis.w = Math.ceil( this.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tround: function () {\r\n\r\n\t\tthis.x = Math.round( this.x );\r\n\t\tthis.y = Math.round( this.y );\r\n\t\tthis.z = Math.round( this.z );\r\n\t\tthis.w = Math.round( this.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\troundToZero: function () {\r\n\r\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.x = - this.x;\r\n\t\tthis.y = - this.y;\r\n\t\tthis.z = - this.z;\r\n\t\tthis.w = - this.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\r\n\r\n\t},\r\n\r\n\tmanhattanLength: function () {\r\n\r\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() || 1 );\r\n\r\n\t},\r\n\r\n\tsetLength: function ( length ) {\r\n\r\n\t\treturn this.normalize().multiplyScalar( length );\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\t\tthis.w += ( v.w - this.w ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerpVectors: function ( v1, v2, alpha ) {\r\n\r\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.x = array[ offset ];\r\n\t\tthis.y = array[ offset + 1 ];\r\n\t\tthis.z = array[ offset + 2 ];\r\n\t\tthis.w = array[ offset + 3 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this.x;\r\n\t\tarray[ offset + 1 ] = this.y;\r\n\t\tarray[ offset + 2 ] = this.z;\r\n\t\tarray[ offset + 3 ] = this.w;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tfromBufferAttribute: function ( attribute, index, offset ) {\r\n\r\n\t\tif ( offset !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Vector4: offset has been removed from .fromBufferAttribute().' );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x = attribute.getX( index );\r\n\t\tthis.y = attribute.getY( index );\r\n\t\tthis.z = attribute.getZ( index );\r\n\t\tthis.w = attribute.getW( index );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/math/Matrix4.js\n\r\n\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author jordi_ros / http://plattsoft.com\r\n * @author D1plo1d / http://github.com/D1plo1d\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author timknip / http://www.floorplanner.com/\r\n * @author bhouston / http://clara.io\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nfunction Matrix4() {\r\n\r\n\tthis.elements = [\r\n\r\n\t\t1, 0, 0, 0,\r\n\t\t0, 1, 0, 0,\r\n\t\t0, 0, 1, 0,\r\n\t\t0, 0, 0, 1\r\n\r\n\t];\r\n\r\n\tif ( arguments.length > 0 ) {\r\n\r\n\t\tconsole.error( 'COOL.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\r\n\r\n\t}\r\n\r\n}\r\n\r\nObject.assign( Matrix4.prototype, {\r\n\r\n\tisMatrix4: true,\r\n\r\n\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\r\n\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\r\n\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\r\n\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n    setIdentity :function() {\r\n        var e = this.elements;\r\n        e[0] = 1;   e[4] = 0;   e[8]  = 0;   e[12] = 0;\r\n        e[1] = 0;   e[5] = 1;   e[9]  = 0;   e[13] = 0;\r\n        e[2] = 0;   e[6] = 0;   e[10] = 1;   e[14] = 0;\r\n        e[3] = 0;   e[7] = 0;   e[11] = 0;   e[15] = 1;\r\n        return this;\r\n    },\r\n\r\n    multiplyVector3 :function(pos) {\r\n        var e = this.elements;\r\n        var p = pos.elements;\r\n        var v = new Vector3();\r\n        var result = v.elements;\r\n\r\n        result[0] = p[0] * e[0] + p[1] * e[4] + p[2] * e[ 8] + e[11];\r\n        result[1] = p[0] * e[1] + p[1] * e[5] + p[2] * e[ 9] + e[12];\r\n        result[2] = p[0] * e[2] + p[1] * e[6] + p[2] * e[10] + e[13];\r\n\r\n        return v;\r\n    },\r\n\r\n    multiplyVector4 :function(pos) {\r\n        var e = this.elements;\r\n        var p = pos.elements;\r\n        var v = new Vector4();\r\n        var result = v.elements;\r\n\r\n        result[0] = p[0] * e[0] + p[1] * e[4] + p[2] * e[ 8] + p[3] * e[12];\r\n        result[1] = p[0] * e[1] + p[1] * e[5] + p[2] * e[ 9] + p[3] * e[13];\r\n        result[2] = p[0] * e[2] + p[1] * e[6] + p[2] * e[10] + p[3] * e[14];\r\n        result[3] = p[0] * e[3] + p[1] * e[7] + p[2] * e[11] + p[3] * e[15];\r\n\r\n        v = new Vector4(result[0],result[1],result[2],result[3]);\r\n        return v;\r\n    },\r\n\r\n    setInverseOf :function(other) {\r\n        var i, s, d, inv, det;\r\n\r\n        s = other.elements;\r\n        d = this.elements;\r\n        inv = new Float32Array(16);\r\n\r\n        inv[0]  =   s[5]*s[10]*s[15] - s[5] *s[11]*s[14] - s[9] *s[6]*s[15]\r\n            + s[9]*s[7] *s[14] + s[13]*s[6] *s[11] - s[13]*s[7]*s[10];\r\n        inv[4]  = - s[4]*s[10]*s[15] + s[4] *s[11]*s[14] + s[8] *s[6]*s[15]\r\n            - s[8]*s[7] *s[14] - s[12]*s[6] *s[11] + s[12]*s[7]*s[10];\r\n        inv[8]  =   s[4]*s[9] *s[15] - s[4] *s[11]*s[13] - s[8] *s[5]*s[15]\r\n            + s[8]*s[7] *s[13] + s[12]*s[5] *s[11] - s[12]*s[7]*s[9];\r\n        inv[12] = - s[4]*s[9] *s[14] + s[4] *s[10]*s[13] + s[8] *s[5]*s[14]\r\n            - s[8]*s[6] *s[13] - s[12]*s[5] *s[10] + s[12]*s[6]*s[9];\r\n\r\n        inv[1]  = - s[1]*s[10]*s[15] + s[1] *s[11]*s[14] + s[9] *s[2]*s[15]\r\n            - s[9]*s[3] *s[14] - s[13]*s[2] *s[11] + s[13]*s[3]*s[10];\r\n        inv[5]  =   s[0]*s[10]*s[15] - s[0] *s[11]*s[14] - s[8] *s[2]*s[15]\r\n            + s[8]*s[3] *s[14] + s[12]*s[2] *s[11] - s[12]*s[3]*s[10];\r\n        inv[9]  = - s[0]*s[9] *s[15] + s[0] *s[11]*s[13] + s[8] *s[1]*s[15]\r\n            - s[8]*s[3] *s[13] - s[12]*s[1] *s[11] + s[12]*s[3]*s[9];\r\n        inv[13] =   s[0]*s[9] *s[14] - s[0] *s[10]*s[13] - s[8] *s[1]*s[14]\r\n            + s[8]*s[2] *s[13] + s[12]*s[1] *s[10] - s[12]*s[2]*s[9];\r\n\r\n        inv[2]  =   s[1]*s[6]*s[15] - s[1] *s[7]*s[14] - s[5] *s[2]*s[15]\r\n            + s[5]*s[3]*s[14] + s[13]*s[2]*s[7]  - s[13]*s[3]*s[6];\r\n        inv[6]  = - s[0]*s[6]*s[15] + s[0] *s[7]*s[14] + s[4] *s[2]*s[15]\r\n            - s[4]*s[3]*s[14] - s[12]*s[2]*s[7]  + s[12]*s[3]*s[6];\r\n        inv[10] =   s[0]*s[5]*s[15] - s[0] *s[7]*s[13] - s[4] *s[1]*s[15]\r\n            + s[4]*s[3]*s[13] + s[12]*s[1]*s[7]  - s[12]*s[3]*s[5];\r\n        inv[14] = - s[0]*s[5]*s[14] + s[0] *s[6]*s[13] + s[4] *s[1]*s[14]\r\n            - s[4]*s[2]*s[13] - s[12]*s[1]*s[6]  + s[12]*s[2]*s[5];\r\n\r\n        inv[3]  = - s[1]*s[6]*s[11] + s[1]*s[7]*s[10] + s[5]*s[2]*s[11]\r\n            - s[5]*s[3]*s[10] - s[9]*s[2]*s[7]  + s[9]*s[3]*s[6];\r\n        inv[7]  =   s[0]*s[6]*s[11] - s[0]*s[7]*s[10] - s[4]*s[2]*s[11]\r\n            + s[4]*s[3]*s[10] + s[8]*s[2]*s[7]  - s[8]*s[3]*s[6];\r\n        inv[11] = - s[0]*s[5]*s[11] + s[0]*s[7]*s[9]  + s[4]*s[1]*s[11]\r\n            - s[4]*s[3]*s[9]  - s[8]*s[1]*s[7]  + s[8]*s[3]*s[5];\r\n        inv[15] =   s[0]*s[5]*s[10] - s[0]*s[6]*s[9]  - s[4]*s[1]*s[10]\r\n            + s[4]*s[2]*s[9]  + s[8]*s[1]*s[6]  - s[8]*s[2]*s[5];\r\n\r\n        det = s[0]*inv[0] + s[1]*inv[4] + s[2]*inv[8] + s[3]*inv[12];\r\n        if (det === 0) {\r\n            return this;\r\n        }\r\n\r\n        det = 1 / det;\r\n        for (i = 0; i < 16; i++) {\r\n            d[i] = inv[i] * det;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    invert :function() {\r\n        return this.setInverseOf(this);\r\n    },\r\n\r\n    ortho :function(left, right, bottom, top, near, far) {\r\n        return this.concat(new Matrix4().setOrtho(left, right, bottom, top, near, far));\r\n    },\r\n\r\n    setFrustum :function(left, right, bottom, top, near, far) {\r\n        var e, rw, rh, rd;\r\n\r\n        if (left === right || top === bottom || near === far) {\r\n            throw 'null frustum';\r\n        }\r\n        if (near <= 0) {\r\n            throw 'near <= 0';\r\n        }\r\n        if (far <= 0) {\r\n            throw 'far <= 0';\r\n        }\r\n\r\n        rw = 1 / (right - left);\r\n        rh = 1 / (top - bottom);\r\n        rd = 1 / (far - near);\r\n\r\n        e = this.elements;\r\n\r\n        e[ 0] = 2 * near * rw;\r\n        e[ 1] = 0;\r\n        e[ 2] = 0;\r\n        e[ 3] = 0;\r\n\r\n        e[ 4] = 0;\r\n        e[ 5] = 2 * near * rh;\r\n        e[ 6] = 0;\r\n        e[ 7] = 0;\r\n\r\n        e[ 8] = (right + left) * rw;\r\n        e[ 9] = (top + bottom) * rh;\r\n        e[10] = -(far + near) * rd;\r\n        e[11] = -1;\r\n\r\n        e[12] = 0;\r\n        e[13] = 0;\r\n        e[14] = -2 * near * far * rd;\r\n        e[15] = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    setOrtho :function(left, right, bottom, top, near, far) {\r\n        var e, rw, rh, rd;\r\n\r\n        if (left === right || bottom === top || near === far) {\r\n            throw 'null frustum';\r\n        }\r\n\r\n        rw = 1 / (right - left);\r\n        rh = 1 / (top - bottom);\r\n        rd = 1 / (far - near);\r\n\r\n        e = this.elements;\r\n\r\n        e[0]  = 2 * rw;\r\n        e[1]  = 0;\r\n        e[2]  = 0;\r\n        e[3]  = 0;\r\n\r\n        e[4]  = 0;\r\n        e[5]  = 2 * rh;\r\n        e[6]  = 0;\r\n        e[7]  = 0;\r\n\r\n        e[8]  = 0;\r\n        e[9]  = 0;\r\n        e[10] = -2 * rd;\r\n        e[11] = 0;\r\n\r\n        e[12] = -(right + left) * rw;\r\n        e[13] = -(top + bottom) * rh;\r\n        e[14] = -(far + near) * rd;\r\n        e[15] = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    concat :function(other) {\r\n        var i, e, a, b, ai0, ai1, ai2, ai3;\r\n\r\n        // Calculate e = a * b\r\n        e = this.elements;\r\n        a = this.elements;\r\n        b = other.elements;\r\n\r\n        // If e equals b, copy b to temporary matrix.\r\n        if (e === b) {\r\n            b = new Float32Array(16);\r\n            for (i = 0; i < 16; ++i) {\r\n                b[i] = e[i];\r\n            }\r\n        }\r\n\r\n        for (i = 0; i < 4; i++) {\r\n            ai0=a[i];  ai1=a[i+4];  ai2=a[i+8];  ai3=a[i+12];\r\n            e[i]    = ai0 * b[0]  + ai1 * b[1]  + ai2 * b[2]  + ai3 * b[3];\r\n            e[i+4]  = ai0 * b[4]  + ai1 * b[5]  + ai2 * b[6]  + ai3 * b[7];\r\n            e[i+8]  = ai0 * b[8]  + ai1 * b[9]  + ai2 * b[10] + ai3 * b[11];\r\n            e[i+12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    frustum :function(left, right, bottom, top, near, far) {\r\n        return this.concat(new Matrix4().setFrustum(left, right, bottom, top, near, far));\r\n    },\r\n\r\n    setPerspective :function(fovy, aspect, near, far) {\r\n        var e, rd, s, ct;\r\n\r\n        if (near === far || aspect === 0) {\r\n            throw 'null frustum';\r\n        }\r\n        if (near <= 0) {\r\n            throw 'near <= 0';\r\n        }\r\n        if (far <= 0) {\r\n            throw 'far <= 0';\r\n        }\r\n\r\n        fovy = Math.PI * fovy / 180 / 2;\r\n        s = Math.sin(fovy);\r\n        if (s === 0) {\r\n            throw 'null frustum';\r\n        }\r\n\r\n        rd = 1 / (far - near);\r\n        ct = Math.cos(fovy) / s;\r\n\r\n        e = this.elements;\r\n\r\n        e[0]  = ct / aspect;\r\n        e[1]  = 0;\r\n        e[2]  = 0;\r\n        e[3]  = 0;\r\n\r\n        e[4]  = 0;\r\n        e[5]  = ct;\r\n        e[6]  = 0;\r\n        e[7]  = 0;\r\n\r\n        e[8]  = 0;\r\n        e[9]  = 0;\r\n        e[10] = -(far + near) * rd;\r\n        e[11] = -1;\r\n\r\n        e[12] = 0;\r\n        e[13] = 0;\r\n        e[14] = -2 * near * far * rd;\r\n        e[15] = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    perspective :function(fovy, aspect, near, far) {\r\n        return this.concat(new Matrix4().setPerspective(fovy, aspect, near, far));\r\n    },\r\n\r\n    setScale :function(x, y, z) {\r\n        var e = this.elements;\r\n        e[0] = x;  e[4] = 0;  e[8]  = 0;  e[12] = 0;\r\n        e[1] = 0;  e[5] = y;  e[9]  = 0;  e[13] = 0;\r\n        e[2] = 0;  e[6] = 0;  e[10] = z;  e[14] = 0;\r\n        e[3] = 0;  e[7] = 0;  e[11] = 0;  e[15] = 1;\r\n        return this;\r\n    },\r\n\r\n    scale :function(x, y, z) {\r\n        var e = this.elements;\r\n        e[0] *= x;  e[4] *= y;  e[8]  *= z;\r\n        e[1] *= x;  e[5] *= y;  e[9]  *= z;\r\n        e[2] *= x;  e[6] *= y;  e[10] *= z;\r\n        e[3] *= x;  e[7] *= y;  e[11] *= z;\r\n        return this;\r\n    },\r\n\r\n\tidentity: function () {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0, 0,\r\n\t\t\t0, 1, 0, 0,\r\n\t\t\t0, 0, 1, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new Matrix4().fromArray( this.elements );\r\n\r\n\t},\r\n\r\n\tcopy: function ( m ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar me = m.elements;\r\n\r\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];\r\n\t\tte[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];\r\n\t\tte[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];\r\n\t\tte[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyPosition: function ( m ) {\r\n\r\n\t\tvar te = this.elements, me = m.elements;\r\n\r\n\t\tte[ 12 ] = me[ 12 ];\r\n\t\tte[ 13 ] = me[ 13 ];\r\n\t\tte[ 14 ] = me[ 14 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\textractBasis: function ( xAxis, yAxis, zAxis ) {\r\n\r\n\t\txAxis.setFromMatrixColumn( this, 0 );\r\n\t\tyAxis.setFromMatrixColumn( this, 1 );\r\n\t\tzAxis.setFromMatrixColumn( this, 2 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\r\n\r\n\t\tthis.set(\r\n\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\r\n\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\r\n\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\r\n\t\t\t0, 0, 0, 1\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\textractRotation: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function extractRotation( m ) {\r\n\r\n\t\t\t// this method does not support reflection matrices\r\n\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar me = m.elements;\r\n\r\n\t\t\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\r\n\t\t\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\r\n\t\t\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\r\n\r\n\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\r\n\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\r\n\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\r\n\t\t\tte[ 3 ] = 0;\r\n\r\n\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\r\n\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\r\n\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\r\n\t\t\tte[ 7 ] = 0;\r\n\r\n\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\r\n\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\r\n\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\r\n\t\t\tte[ 11 ] = 0;\r\n\r\n\t\t\tte[ 12 ] = 0;\r\n\t\t\tte[ 13 ] = 0;\r\n\t\t\tte[ 14 ] = 0;\r\n\t\t\tte[ 15 ] = 1;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmakeRotationFromEuler: function ( euler ) {\r\n\r\n\t\tif ( ! ( euler && euler.isEuler ) ) {\r\n\r\n\t\t\tconsole.error( 'COOL.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\r\n\t\t}\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar x = euler.x, y = euler.y, z = euler.z;\r\n\t\tvar a = Math.cos( x ), b = Math.sin( x );\r\n\t\tvar c = Math.cos( y ), d = Math.sin( y );\r\n\t\tvar e = Math.cos( z ), f = Math.sin( z );\r\n\r\n\t\tif ( euler.order === 'XYZ' ) {\r\n\r\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = - c * f;\r\n\t\t\tte[ 8 ] = d;\r\n\r\n\t\t\tte[ 1 ] = af + be * d;\r\n\t\t\tte[ 5 ] = ae - bf * d;\r\n\t\t\tte[ 9 ] = - b * c;\r\n\r\n\t\t\tte[ 2 ] = bf - ae * d;\r\n\t\t\tte[ 6 ] = be + af * d;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'YXZ' ) {\r\n\r\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n\t\t\tte[ 0 ] = ce + df * b;\r\n\t\t\tte[ 4 ] = de * b - cf;\r\n\t\t\tte[ 8 ] = a * d;\r\n\r\n\t\t\tte[ 1 ] = a * f;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = - b;\r\n\r\n\t\t\tte[ 2 ] = cf * b - de;\r\n\t\t\tte[ 6 ] = df + ce * b;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'ZXY' ) {\r\n\r\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n\t\t\tte[ 0 ] = ce - df * b;\r\n\t\t\tte[ 4 ] = - a * f;\r\n\t\t\tte[ 8 ] = de + cf * b;\r\n\r\n\t\t\tte[ 1 ] = cf + de * b;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = df - ce * b;\r\n\r\n\t\t\tte[ 2 ] = - a * d;\r\n\t\t\tte[ 6 ] = b;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'ZYX' ) {\r\n\r\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = be * d - af;\r\n\t\t\tte[ 8 ] = ae * d + bf;\r\n\r\n\t\t\tte[ 1 ] = c * f;\r\n\t\t\tte[ 5 ] = bf * d + ae;\r\n\t\t\tte[ 9 ] = af * d - be;\r\n\r\n\t\t\tte[ 2 ] = - d;\r\n\t\t\tte[ 6 ] = b * c;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'YZX' ) {\r\n\r\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = bd - ac * f;\r\n\t\t\tte[ 8 ] = bc * f + ad;\r\n\r\n\t\t\tte[ 1 ] = f;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = - b * e;\r\n\r\n\t\t\tte[ 2 ] = - d * e;\r\n\t\t\tte[ 6 ] = ad * f + bc;\r\n\t\t\tte[ 10 ] = ac - bd * f;\r\n\r\n\t\t} else if ( euler.order === 'XZY' ) {\r\n\r\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = - f;\r\n\t\t\tte[ 8 ] = d * e;\r\n\r\n\t\t\tte[ 1 ] = ac * f + bd;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = ad * f - bc;\r\n\r\n\t\t\tte[ 2 ] = bc * f - ad;\r\n\t\t\tte[ 6 ] = b * e;\r\n\t\t\tte[ 10 ] = bd * f + ac;\r\n\r\n\t\t}\r\n\r\n\t\t// bottom row\r\n\t\tte[ 3 ] = 0;\r\n\t\tte[ 7 ] = 0;\r\n\t\tte[ 11 ] = 0;\r\n\r\n\t\t// last column\r\n\t\tte[ 12 ] = 0;\r\n\t\tte[ 13 ] = 0;\r\n\t\tte[ 14 ] = 0;\r\n\t\tte[ 15 ] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationFromQuaternion: function () {\r\n\r\n\t\tvar zero = new Vector3( 0, 0, 0 );\r\n\t\tvar one = new Vector3( 1, 1, 1 );\r\n\r\n\t\treturn function makeRotationFromQuaternion( q ) {\r\n\r\n\t\t\treturn this.compose( zero, q, one );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlookAt: function () {\r\n\r\n\t\tvar x = new Vector3();\r\n\t\tvar y = new Vector3();\r\n\t\tvar z = new Vector3();\r\n\r\n\t\treturn function lookAt( eye, target, up ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tz.subVectors( eye, target );\r\n\r\n\t\t\tif ( z.lengthSq() === 0 ) {\r\n\r\n\t\t\t\t// eye and target are in the same position\r\n\r\n\t\t\t\tz.z = 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tz.normalize();\r\n\t\t\tx.crossVectors( up, z );\r\n\r\n\t\t\tif ( x.lengthSq() === 0 ) {\r\n\r\n\t\t\t\t// up and z are parallel\r\n\r\n\t\t\t\tif ( Math.abs( up.z ) === 1 ) {\r\n\r\n\t\t\t\t\tz.x += 0.0001;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tz.z += 0.0001;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tz.normalize();\r\n\t\t\t\tx.crossVectors( up, z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tx.normalize();\r\n\t\t\ty.crossVectors( z, x );\r\n\r\n\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\r\n\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\r\n\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmultiply: function ( m, n ) {\r\n\r\n\t\tif ( n !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\r\n\t\t\treturn this.multiplyMatrices( m, n );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.multiplyMatrices( this, m );\r\n\r\n\t},\r\n\r\n\tpremultiply: function ( m ) {\r\n\r\n\t\treturn this.multiplyMatrices( m, this );\r\n\r\n\t},\r\n\r\n\tmultiplyMatrices: function ( a, b ) {\r\n\r\n\t\tvar ae = a.elements;\r\n\t\tvar be = b.elements;\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\r\n\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\r\n\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\r\n\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\r\n\r\n\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\r\n\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\r\n\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\r\n\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\r\n\r\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\r\n\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\r\n\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\r\n\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\r\n\r\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\r\n\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\r\n\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\r\n\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\r\n\r\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\r\n\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\r\n\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\r\n\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\r\n\r\n\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\r\n\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\r\n\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\r\n\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\r\n\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\r\n\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\r\n\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyToBufferAttribute: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function applyToBufferAttribute( attribute ) {\r\n\r\n\t\t\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\r\n\r\n\t\t\t\tv1.x = attribute.getX( i );\r\n\t\t\t\tv1.y = attribute.getY( i );\r\n\t\t\t\tv1.z = attribute.getZ( i );\r\n\r\n\t\t\t\tv1.applyMatrix4( this );\r\n\r\n\t\t\t\tattribute.setXYZ( i, v1.x, v1.y, v1.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn attribute;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tdeterminant: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\r\n\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\r\n\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\r\n\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\r\n\r\n\t\t//TODO: make this more efficient\r\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\r\n\r\n\t\treturn (\r\n\t\t\tn41 * (\r\n\t\t\t\t+ n14 * n23 * n32\r\n\t\t\t\t - n13 * n24 * n32\r\n\t\t\t\t - n14 * n22 * n33\r\n\t\t\t\t + n12 * n24 * n33\r\n\t\t\t\t + n13 * n22 * n34\r\n\t\t\t\t - n12 * n23 * n34\r\n\t\t\t) +\r\n\t\t\tn42 * (\r\n\t\t\t\t+ n11 * n23 * n34\r\n\t\t\t\t - n11 * n24 * n33\r\n\t\t\t\t + n14 * n21 * n33\r\n\t\t\t\t - n13 * n21 * n34\r\n\t\t\t\t + n13 * n24 * n31\r\n\t\t\t\t - n14 * n23 * n31\r\n\t\t\t) +\r\n\t\t\tn43 * (\r\n\t\t\t\t+ n11 * n24 * n32\r\n\t\t\t\t - n11 * n22 * n34\r\n\t\t\t\t - n14 * n21 * n32\r\n\t\t\t\t + n12 * n21 * n34\r\n\t\t\t\t + n14 * n22 * n31\r\n\t\t\t\t - n12 * n24 * n31\r\n\t\t\t) +\r\n\t\t\tn44 * (\r\n\t\t\t\t- n13 * n22 * n31\r\n\t\t\t\t - n11 * n23 * n32\r\n\t\t\t\t + n11 * n22 * n33\r\n\t\t\t\t + n13 * n21 * n32\r\n\t\t\t\t - n12 * n21 * n33\r\n\t\t\t\t + n12 * n23 * n31\r\n\t\t\t)\r\n\r\n\t\t);\r\n\r\n\t},\r\n\r\n\ttranspose: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar tmp;\r\n\r\n\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\r\n\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\r\n\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\r\n\r\n\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\r\n\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\r\n\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetPosition: function ( v ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 12 ] = v.x;\r\n\t\tte[ 13 ] = v.y;\r\n\t\tte[ 14 ] = v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetInverse: function ( m, throwOnDegenerate ) {\r\n\r\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\r\n\t\tvar te = this.elements,\r\n\t\t\tme = m.elements,\r\n\r\n\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\r\n\t\t\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\r\n\t\t\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\r\n\t\t\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\r\n\r\n\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\r\n\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\r\n\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\r\n\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\r\n\r\n\t\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\r\n\r\n\t\tif ( det === 0 ) {\r\n\r\n\t\t\tvar msg = \"COOL.Matrix4: .getInverse() can't invert matrix, determinant is 0\";\r\n\r\n\t\t\tif ( throwOnDegenerate === true ) {\r\n\r\n\t\t\t\tthrow new Error( msg );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( msg );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.identity();\r\n\r\n\t\t}\r\n\r\n\t\tvar detInv = 1 / det;\r\n\r\n\t\tte[ 0 ] = t11 * detInv;\r\n\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\r\n\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\r\n\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\r\n\r\n\t\tte[ 4 ] = t12 * detInv;\r\n\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\r\n\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\r\n\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\r\n\r\n\t\tte[ 8 ] = t13 * detInv;\r\n\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\r\n\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\r\n\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\r\n\r\n\t\tte[ 12 ] = t14 * detInv;\r\n\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\r\n\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\r\n\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tscale: function ( v ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar x = v.x, y = v.y, z = v.z;\r\n\r\n\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\r\n\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\r\n\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\r\n\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n    setTranslate :function(x, y, z) {\r\n        var e = this.elements;\r\n        e[0] = 1;  e[4] = 0;  e[8]  = 0;  e[12] = x;\r\n        e[1] = 0;  e[5] = 1;  e[9]  = 0;  e[13] = y;\r\n        e[2] = 0;  e[6] = 0;  e[10] = 1;  e[14] = z;\r\n        e[3] = 0;  e[7] = 0;  e[11] = 0;  e[15] = 1;\r\n        return this;\r\n    },\r\n\r\n    translate :function(x, y, z) {\r\n        var e = this.elements;\r\n        e[12] += e[0] * x + e[4] * y + e[8]  * z;\r\n        e[13] += e[1] * x + e[5] * y + e[9]  * z;\r\n        e[14] += e[2] * x + e[6] * y + e[10] * z;\r\n        e[15] += e[3] * x + e[7] * y + e[11] * z;\r\n        return this;\r\n    },\r\n\r\n    setRotate :function(angle, x, y, z) {\r\n        var e, s, c, len, rlen, nc, xy, yz, zx, xs, ys, zs;\r\n\r\n        angle = Math.PI * angle / 180;\r\n        e = this.elements;\r\n\r\n        s = Math.sin(angle);\r\n        c = Math.cos(angle);\r\n\r\n        if (0 !== x && 0 === y && 0 === z) {\r\n            // Rotation around X axis\r\n            if (x < 0) {\r\n                s = -s;\r\n            }\r\n            e[0] = 1;  e[4] = 0;  e[ 8] = 0;  e[12] = 0;\r\n            e[1] = 0;  e[5] = c;  e[ 9] =-s;  e[13] = 0;\r\n            e[2] = 0;  e[6] = s;  e[10] = c;  e[14] = 0;\r\n            e[3] = 0;  e[7] = 0;  e[11] = 0;  e[15] = 1;\r\n        } else if (0 === x && 0 !== y && 0 === z) {\r\n            // Rotation around Y axis\r\n            if (y < 0) {\r\n                s = -s;\r\n            }\r\n            e[0] = c;  e[4] = 0;  e[ 8] = s;  e[12] = 0;\r\n            e[1] = 0;  e[5] = 1;  e[ 9] = 0;  e[13] = 0;\r\n            e[2] =-s;  e[6] = 0;  e[10] = c;  e[14] = 0;\r\n            e[3] = 0;  e[7] = 0;  e[11] = 0;  e[15] = 1;\r\n        } else if (0 === x && 0 === y && 0 !== z) {\r\n            // Rotation around Z axis\r\n            if (z < 0) {\r\n                s = -s;\r\n            }\r\n            e[0] = c;  e[4] =-s;  e[ 8] = 0;  e[12] = 0;\r\n            e[1] = s;  e[5] = c;  e[ 9] = 0;  e[13] = 0;\r\n            e[2] = 0;  e[6] = 0;  e[10] = 1;  e[14] = 0;\r\n            e[3] = 0;  e[7] = 0;  e[11] = 0;  e[15] = 1;\r\n        } else {\r\n            // Rotation around another axis\r\n            len = Math.sqrt(x*x + y*y + z*z);\r\n            if (len !== 1) {\r\n                rlen = 1 / len;\r\n                x *= rlen;\r\n                y *= rlen;\r\n                z *= rlen;\r\n            }\r\n            nc = 1 - c;\r\n            xy = x * y;\r\n            yz = y * z;\r\n            zx = z * x;\r\n            xs = x * s;\r\n            ys = y * s;\r\n            zs = z * s;\r\n\r\n            e[ 0] = x*x*nc +  c;\r\n            e[ 1] = xy *nc + zs;\r\n            e[ 2] = zx *nc - ys;\r\n            e[ 3] = 0;\r\n\r\n            e[ 4] = xy *nc - zs;\r\n            e[ 5] = y*y*nc +  c;\r\n            e[ 6] = yz *nc + xs;\r\n            e[ 7] = 0;\r\n\r\n            e[ 8] = zx *nc + ys;\r\n            e[ 9] = yz *nc - xs;\r\n            e[10] = z*z*nc +  c;\r\n            e[11] = 0;\r\n\r\n            e[12] = 0;\r\n            e[13] = 0;\r\n            e[14] = 0;\r\n            e[15] = 1;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    rotate :function(angle, x, y, z) {\r\n        return this.concat(new Matrix4().setRotate(angle, x, y, z));\r\n    },\r\n\r\n    setLookAt :function(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) {\r\n        var e, fx, fy, fz, rlf, sx, sy, sz, rls, ux, uy, uz;\r\n\r\n        fx = centerX - eyeX;\r\n        fy = centerY - eyeY;\r\n        fz = centerZ - eyeZ;\r\n\r\n        // Normalize f.\r\n        rlf = 1 / Math.sqrt(fx*fx + fy*fy + fz*fz);\r\n        fx *= rlf;\r\n        fy *= rlf;\r\n        fz *= rlf;\r\n\r\n        // Calculate cross product of f and up.\r\n        sx = fy * upZ - fz * upY;\r\n        sy = fz * upX - fx * upZ;\r\n        sz = fx * upY - fy * upX;\r\n\r\n        // Normalize s.\r\n        rls = 1 / Math.sqrt(sx*sx + sy*sy + sz*sz);\r\n        sx *= rls;\r\n        sy *= rls;\r\n        sz *= rls;\r\n\r\n        // Calculate cross product of s and f.\r\n        ux = sy * fz - sz * fy;\r\n        uy = sz * fx - sx * fz;\r\n        uz = sx * fy - sy * fx;\r\n\r\n        // Set to this.\r\n        e = this.elements;\r\n        e[0] = sx;\r\n        e[1] = ux;\r\n        e[2] = -fx;\r\n        e[3] = 0;\r\n\r\n        e[4] = sy;\r\n        e[5] = uy;\r\n        e[6] = -fy;\r\n        e[7] = 0;\r\n\r\n        e[8] = sz;\r\n        e[9] = uz;\r\n        e[10] = -fz;\r\n        e[11] = 0;\r\n\r\n        e[12] = 0;\r\n        e[13] = 0;\r\n        e[14] = 0;\r\n        e[15] = 1;\r\n\r\n        // Translate.\r\n        return this.translate(-eyeX, -eyeY, -eyeZ);\r\n    },\r\n\r\n    lookAt2 :function(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) {\r\n        return this.concat(new Matrix4().setLookAt(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ));\r\n    },\r\n\r\n\tgetMaxScaleOnAxis: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\r\n\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\r\n\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\r\n\r\n\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\r\n\r\n\t},\r\n\r\n\tmakeTranslation: function ( x, y, z ) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0, x,\r\n\t\t\t0, 1, 0, y,\r\n\t\t\t0, 0, 1, z,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationX: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0, 0,\r\n\t\t\t0, c, - s, 0,\r\n\t\t\t0, s, c, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationY: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t c, 0, s, 0,\r\n\t\t\t 0, 1, 0, 0,\r\n\t\t\t- s, 0, c, 0,\r\n\t\t\t 0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationZ: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tc, - s, 0, 0,\r\n\t\t\ts, c, 0, 0,\r\n\t\t\t0, 0, 1, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationAxis: function ( axis, angle ) {\r\n\r\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\r\n\r\n\t\tvar c = Math.cos( angle );\r\n\t\tvar s = Math.sin( angle );\r\n\t\tvar t = 1 - c;\r\n\t\tvar x = axis.x, y = axis.y, z = axis.z;\r\n\t\tvar tx = t * x, ty = t * y;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\r\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\r\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\t return this;\r\n\r\n\t},\r\n\r\n\tmakeScale: function ( x, y, z ) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tx, 0, 0, 0,\r\n\t\t\t0, y, 0, 0,\r\n\t\t\t0, 0, z, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeShear: function ( x, y, z ) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, y, z, 0,\r\n\t\t\tx, 1, z, 0,\r\n\t\t\tx, y, 1, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcompose: function ( position, quaternion, scale ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;\r\n\t\tvar x2 = x + x,\ty2 = y + y, z2 = z + z;\r\n\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\r\n\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\r\n\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\r\n\r\n\t\tvar sx = scale.x, sy = scale.y, sz = scale.z;\r\n\r\n\t        te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;\r\n\t        te[ 1 ] = ( xy + wz ) * sx;\r\n\t        te[ 2 ] = ( xz - wy ) * sx;\r\n\t        te[ 3 ] = 0;\r\n\r\n\t        te[ 4 ] = ( xy - wz ) * sy;\r\n\t        te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;\r\n\t        te[ 6 ] = ( yz + wx ) * sy;\r\n\t        te[ 7 ] = 0;\r\n\r\n\t        te[ 8 ] = ( xz + wy ) * sz;\r\n\t        te[ 9 ] = ( yz - wx ) * sz;\r\n\t        te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;\r\n\t        te[ 11 ] = 0;\r\n\r\n\t        te[ 12 ] = position.x;\r\n\t        te[ 13 ] = position.y;\r\n\t        te[ 14 ] = position.z;\r\n\t        te[ 15 ] = 1;\r\n\r\n\t        return this;\r\n\r\n\t},\r\n\r\n\tdecompose: function () {\r\n\r\n\t\tvar vector = new Vector3();\r\n\t\tvar matrix = new Matrix4();\r\n\r\n\t\treturn function decompose( position, quaternion, scale ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\r\n\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\r\n\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\r\n\r\n\t\t\t// if determine is negative, we need to invert one scale\r\n\t\t\tvar det = this.determinant();\r\n\t\t\tif ( det < 0 ) sx = - sx;\r\n\r\n\t\t\tposition.x = te[ 12 ];\r\n\t\t\tposition.y = te[ 13 ];\r\n\t\t\tposition.z = te[ 14 ];\r\n\r\n\t\t\t// scale the rotation part\r\n\t\t\tmatrix.copy( this );\r\n\r\n\t\t\tvar invSX = 1 / sx;\r\n\t\t\tvar invSY = 1 / sy;\r\n\t\t\tvar invSZ = 1 / sz;\r\n\r\n\t\t\tmatrix.elements[ 0 ] *= invSX;\r\n\t\t\tmatrix.elements[ 1 ] *= invSX;\r\n\t\t\tmatrix.elements[ 2 ] *= invSX;\r\n\r\n\t\t\tmatrix.elements[ 4 ] *= invSY;\r\n\t\t\tmatrix.elements[ 5 ] *= invSY;\r\n\t\t\tmatrix.elements[ 6 ] *= invSY;\r\n\r\n\t\t\tmatrix.elements[ 8 ] *= invSZ;\r\n\t\t\tmatrix.elements[ 9 ] *= invSZ;\r\n\t\t\tmatrix.elements[ 10 ] *= invSZ;\r\n\r\n\t\t\tquaternion.setFromRotationMatrix( matrix );\r\n\r\n\t\t\tscale.x = sx;\r\n\t\t\tscale.y = sy;\r\n\t\t\tscale.z = sz;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmakePerspective: function ( left, right, top, bottom, near, far ) {\r\n\r\n\t\tif ( far === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );\r\n\r\n\t\t}\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar x = 2 * near / ( right - left );\r\n\t\tvar y = 2 * near / ( top - bottom );\r\n\r\n\t\tvar a = ( right + left ) / ( right - left );\r\n\t\tvar b = ( top + bottom ) / ( top - bottom );\r\n\t\tvar c = - ( far + near ) / ( far - near );\r\n\t\tvar d = - 2 * far * near / ( far - near );\r\n\r\n\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\r\n\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\r\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\r\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar w = 1.0 / ( right - left );\r\n\t\tvar h = 1.0 / ( top - bottom );\r\n\t\tvar p = 1.0 / ( far - near );\r\n\r\n\t\tvar x = ( right + left ) * w;\r\n\t\tvar y = ( top + bottom ) * h;\r\n\t\tvar z = ( far + near ) * p;\r\n\r\n\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\r\n\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\r\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\r\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( matrix ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar me = matrix.elements;\r\n\r\n\t\tfor ( var i = 0; i < 16; i ++ ) {\r\n\r\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tfor ( var i = 0; i < 16; i ++ ) {\r\n\r\n\t\t\tthis.elements[ i ] = array[ i + offset ];\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tarray[ offset ] = te[ 0 ];\r\n\t\tarray[ offset + 1 ] = te[ 1 ];\r\n\t\tarray[ offset + 2 ] = te[ 2 ];\r\n\t\tarray[ offset + 3 ] = te[ 3 ];\r\n\r\n\t\tarray[ offset + 4 ] = te[ 4 ];\r\n\t\tarray[ offset + 5 ] = te[ 5 ];\r\n\t\tarray[ offset + 6 ] = te[ 6 ];\r\n\t\tarray[ offset + 7 ] = te[ 7 ];\r\n\r\n\t\tarray[ offset + 8 ] = te[ 8 ];\r\n\t\tarray[ offset + 9 ] = te[ 9 ];\r\n\t\tarray[ offset + 10 ] = te[ 10 ];\r\n\t\tarray[ offset + 11 ] = te[ 11 ];\r\n\r\n\t\tarray[ offset + 12 ] = te[ 12 ];\r\n\t\tarray[ offset + 13 ] = te[ 13 ];\r\n\t\tarray[ offset + 14 ] = te[ 14 ];\r\n\t\tarray[ offset + 15 ] = te[ 15 ];\r\n\r\n\t\treturn array;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/math/Quaternion.js\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\n\r\n\r\n\r\nfunction Quaternion( x, y, z, w ) {\r\n\r\n\tthis._x = x || 0;\r\n\tthis._y = y || 0;\r\n\tthis._z = z || 0;\r\n\tthis._w = ( w !== undefined ) ? w : 1;\r\n\r\n}\r\n\r\nObject.assign( Quaternion, {\r\n\r\n\tslerp: function ( qa, qb, qm, t ) {\r\n\r\n\t\treturn qm.copy( qa ).slerp( qb, t );\r\n\r\n\t},\r\n\r\n\tslerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\r\n\r\n\t\t// fuzz-free, array-based Quaternion SLERP operation\r\n\r\n\t\tvar x0 = src0[ srcOffset0 + 0 ],\r\n\t\t\ty0 = src0[ srcOffset0 + 1 ],\r\n\t\t\tz0 = src0[ srcOffset0 + 2 ],\r\n\t\t\tw0 = src0[ srcOffset0 + 3 ],\r\n\r\n\t\t\tx1 = src1[ srcOffset1 + 0 ],\r\n\t\t\ty1 = src1[ srcOffset1 + 1 ],\r\n\t\t\tz1 = src1[ srcOffset1 + 2 ],\r\n\t\t\tw1 = src1[ srcOffset1 + 3 ];\r\n\r\n\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\r\n\r\n\t\t\tvar s = 1 - t,\r\n\r\n\t\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\r\n\r\n\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\r\n\t\t\t\tsqrSin = 1 - cos * cos;\r\n\r\n\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\r\n\t\t\tif ( sqrSin > Number.EPSILON ) {\r\n\r\n\t\t\t\tvar sin = Math.sqrt( sqrSin ),\r\n\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\r\n\r\n\t\t\t\ts = Math.sin( s * len ) / sin;\r\n\t\t\t\tt = Math.sin( t * len ) / sin;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar tDir = t * dir;\r\n\r\n\t\t\tx0 = x0 * s + x1 * tDir;\r\n\t\t\ty0 = y0 * s + y1 * tDir;\r\n\t\t\tz0 = z0 * s + z1 * tDir;\r\n\t\t\tw0 = w0 * s + w1 * tDir;\r\n\r\n\t\t\t// Normalize in case we just did a lerp:\r\n\t\t\tif ( s === 1 - t ) {\r\n\r\n\t\t\t\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\r\n\r\n\t\t\t\tx0 *= f;\r\n\t\t\t\ty0 *= f;\r\n\t\t\t\tz0 *= f;\r\n\t\t\t\tw0 *= f;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tdst[ dstOffset ] = x0;\r\n\t\tdst[ dstOffset + 1 ] = y0;\r\n\t\tdst[ dstOffset + 2 ] = z0;\r\n\t\tdst[ dstOffset + 3 ] = w0;\r\n\r\n\t}\r\n\r\n} );\r\n\r\nObject.defineProperties( Quaternion.prototype, {\r\n\r\n\tx: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this._x;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tthis._x = value;\r\n\t\t\tthis.onChangeCallback();\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ty: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this._y;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tthis._y = value;\r\n\t\t\tthis.onChangeCallback();\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tz: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this._z;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tthis._z = value;\r\n\t\t\tthis.onChangeCallback();\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tw: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this._w;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tthis._w = value;\r\n\t\t\tthis.onChangeCallback();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\r\n\r\nObject.assign( Quaternion.prototype, {\r\n\r\n\tisQuaternion: true,\r\n\r\n\tset: function ( x, y, z, w ) {\r\n\r\n\t\tthis._x = x;\r\n\t\tthis._y = y;\r\n\t\tthis._z = z;\r\n\t\tthis._w = w;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\r\n\r\n\t},\r\n\r\n\tcopy: function ( quaternion ) {\r\n\r\n\t\tthis._x = quaternion.x;\r\n\t\tthis._y = quaternion.y;\r\n\t\tthis._z = quaternion.z;\r\n\t\tthis._w = quaternion.w;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromEuler: function ( euler, update ) {\r\n\r\n\t\tif ( ! ( euler && euler.isEuler ) ) {\r\n\r\n\t\t\tthrow new Error( 'COOL.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );\r\n\r\n\t\t}\r\n\r\n\t\tvar x = euler._x, y = euler._y, z = euler._z, order = euler.order;\r\n\r\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\r\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\r\n\t\t//\tcontent/SpinCalc.m\r\n\r\n\t\tvar cos = Math.cos;\r\n\t\tvar sin = Math.sin;\r\n\r\n\t\tvar c1 = cos( x / 2 );\r\n\t\tvar c2 = cos( y / 2 );\r\n\t\tvar c3 = cos( z / 2 );\r\n\r\n\t\tvar s1 = sin( x / 2 );\r\n\t\tvar s2 = sin( y / 2 );\r\n\t\tvar s3 = sin( z / 2 );\r\n\r\n\t\tif ( order === 'XYZ' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'YXZ' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'ZXY' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'ZYX' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'YZX' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'XZY' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t}\r\n\r\n\t\tif ( update !== false ) this.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromAxisAngle: function ( axis, angle ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\r\n\r\n\t\t// assumes axis is normalized\r\n\r\n\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\r\n\r\n\t\tthis._x = axis.x * s;\r\n\t\tthis._y = axis.y * s;\r\n\t\tthis._z = axis.z * s;\r\n\t\tthis._w = Math.cos( halfAngle );\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromRotationMatrix: function ( m ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tvar te = m.elements,\r\n\r\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\r\n\r\n\t\t\ttrace = m11 + m22 + m33,\r\n\t\t\ts;\r\n\r\n\t\tif ( trace > 0 ) {\r\n\r\n\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\r\n\r\n\t\t\tthis._w = 0.25 / s;\r\n\t\t\tthis._x = ( m32 - m23 ) * s;\r\n\t\t\tthis._y = ( m13 - m31 ) * s;\r\n\t\t\tthis._z = ( m21 - m12 ) * s;\r\n\r\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\r\n\r\n\t\t\tthis._w = ( m32 - m23 ) / s;\r\n\t\t\tthis._x = 0.25 * s;\r\n\t\t\tthis._y = ( m12 + m21 ) / s;\r\n\t\t\tthis._z = ( m13 + m31 ) / s;\r\n\r\n\t\t} else if ( m22 > m33 ) {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\r\n\r\n\t\t\tthis._w = ( m13 - m31 ) / s;\r\n\t\t\tthis._x = ( m12 + m21 ) / s;\r\n\t\t\tthis._y = 0.25 * s;\r\n\t\t\tthis._z = ( m23 + m32 ) / s;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\r\n\r\n\t\t\tthis._w = ( m21 - m12 ) / s;\r\n\t\t\tthis._x = ( m13 + m31 ) / s;\r\n\t\t\tthis._y = ( m23 + m32 ) / s;\r\n\t\t\tthis._z = 0.25 * s;\r\n\r\n\t\t}\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromUnitVectors: function () {\r\n\r\n\t\t// assumes direction vectors vFrom and vTo are normalized\r\n\r\n\t\tvar v1 = new Vector3();\r\n\t\tvar r;\r\n\r\n\t\tvar EPS = 0.000001;\r\n\r\n\t\treturn function setFromUnitVectors( vFrom, vTo ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new Vector3();\r\n\r\n\t\t\tr = vFrom.dot( vTo ) + 1;\r\n\r\n\t\t\tif ( r < EPS ) {\r\n\r\n\t\t\t\tr = 0;\r\n\r\n\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\r\n\r\n\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tv1.crossVectors( vFrom, vTo );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis._x = v1.x;\r\n\t\t\tthis._y = v1.y;\r\n\t\t\tthis._z = v1.z;\r\n\t\t\tthis._w = r;\r\n\r\n\t\t\treturn this.normalize();\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tangleTo: function ( q ) {\r\n\r\n\t\treturn 2 * Math.acos( Math.abs( _Math.clamp( this.dot( q ), - 1, 1 ) ) );\r\n\r\n\t},\r\n\r\n\trotateTowards: function ( q, step ) {\r\n\r\n\t\tvar angle = this.angleTo( q );\r\n\r\n\t\tif ( angle === 0 ) return this;\r\n\r\n\t\tvar t = Math.min( 1, step / angle );\r\n\r\n\t\tthis.slerp( q, t );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tinverse: function () {\r\n\r\n\t\t// quaternion is assumed to have unit length\r\n\r\n\t\treturn this.conjugate();\r\n\r\n\t},\r\n\r\n\tconjugate: function () {\r\n\r\n\t\tthis._x *= - 1;\r\n\t\tthis._y *= - 1;\r\n\t\tthis._z *= - 1;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\tvar l = this.length();\r\n\r\n\t\tif ( l === 0 ) {\r\n\r\n\t\t\tthis._x = 0;\r\n\t\t\tthis._y = 0;\r\n\t\t\tthis._z = 0;\r\n\t\t\tthis._w = 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tl = 1 / l;\r\n\r\n\t\t\tthis._x = this._x * l;\r\n\t\t\tthis._y = this._y * l;\r\n\t\t\tthis._z = this._z * l;\r\n\t\t\tthis._w = this._w * l;\r\n\r\n\t\t}\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( q, p ) {\r\n\r\n\t\tif ( p !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\r\n\t\t\treturn this.multiplyQuaternions( q, p );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.multiplyQuaternions( this, q );\r\n\r\n\t},\r\n\r\n\tpremultiply: function ( q ) {\r\n\r\n\t\treturn this.multiplyQuaternions( q, this );\r\n\r\n\t},\r\n\r\n\tmultiplyQuaternions: function ( a, b ) {\r\n\r\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\r\n\r\n\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\r\n\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\r\n\r\n\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\r\n\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\r\n\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\r\n\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tslerp: function ( qb, t ) {\r\n\r\n\t\tif ( t === 0 ) return this;\r\n\t\tif ( t === 1 ) return this.copy( qb );\r\n\r\n\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\r\n\r\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\r\n\r\n\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\r\n\r\n\t\tif ( cosHalfTheta < 0 ) {\r\n\r\n\t\t\tthis._w = - qb._w;\r\n\t\t\tthis._x = - qb._x;\r\n\t\t\tthis._y = - qb._y;\r\n\t\t\tthis._z = - qb._z;\r\n\r\n\t\t\tcosHalfTheta = - cosHalfTheta;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.copy( qb );\r\n\r\n\t\t}\r\n\r\n\t\tif ( cosHalfTheta >= 1.0 ) {\r\n\r\n\t\t\tthis._w = w;\r\n\t\t\tthis._x = x;\r\n\t\t\tthis._y = y;\r\n\t\t\tthis._z = z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tvar sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\r\n\r\n\t\tif ( sqrSinHalfTheta <= Number.EPSILON ) {\r\n\r\n\t\t\tvar s = 1 - t;\r\n\t\t\tthis._w = s * w + t * this._w;\r\n\t\t\tthis._x = s * x + t * this._x;\r\n\t\t\tthis._y = s * y + t * this._y;\r\n\t\t\tthis._z = s * z + t * this._z;\r\n\r\n\t\t\treturn this.normalize();\r\n\r\n\t\t}\r\n\r\n\t\tvar sinHalfTheta = Math.sqrt( sqrSinHalfTheta );\r\n\t\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\r\n\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\r\n\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\r\n\r\n\t\tthis._w = ( w * ratioA + this._w * ratioB );\r\n\t\tthis._x = ( x * ratioA + this._x * ratioB );\r\n\t\tthis._y = ( y * ratioA + this._y * ratioB );\r\n\t\tthis._z = ( z * ratioA + this._z * ratioB );\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( quaternion ) {\r\n\r\n\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis._x = array[ offset ];\r\n\t\tthis._y = array[ offset + 1 ];\r\n\t\tthis._z = array[ offset + 2 ];\r\n\t\tthis._w = array[ offset + 3 ];\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this._x;\r\n\t\tarray[ offset + 1 ] = this._y;\r\n\t\tarray[ offset + 2 ] = this._z;\r\n\t\tarray[ offset + 3 ] = this._w;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tonChange: function ( callback ) {\r\n\r\n\t\tthis.onChangeCallback = callback;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tonChangeCallback: function () {}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/math/Vector3.js\n\r\n\r\n\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author kile / http://kile.stravaganza.org/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author egraether / http://egraether.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nfunction Vector3( x, y, z ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\tthis.z = z || 0;\r\n\r\n}\r\n\r\nObject.assign( Vector3.prototype, {\r\n\r\n\tisVector3: true,\r\n\r\n\tset: function ( x, y, z ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetScalar: function ( scalar ) {\r\n\r\n\t\tthis.x = scalar;\r\n\t\tthis.y = scalar;\r\n\t\tthis.z = scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetZ: function ( z ) {\r\n\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tcase 2: this.z = value; break;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tcase 2: return this.z;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.x, this.y, this.z );\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\t\tthis.z = v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\t\tthis.z += v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\t\tthis.z += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\t\tthis.z = a.z + b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScaledVector: function ( v, s ) {\r\n\r\n\t\tthis.x += v.x * s;\r\n\t\tthis.y += v.y * s;\r\n\t\tthis.z += v.z * s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\t\tthis.z -= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubScalar: function ( s ) {\r\n\r\n\t\tthis.x -= s;\r\n\t\tthis.y -= s;\r\n\t\tthis.z -= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n    scaleVectors :function(v1,scale){\r\n        return new Vector3(v1.x*scale, v1.y*scale, v1.z*scale );\r\n    },\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\t\tthis.z = a.z - b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\r\n\t\t\treturn this.multiplyVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x *= v.x;\r\n\t\tthis.y *= v.y;\r\n\t\tthis.z *= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( scalar ) {\r\n\r\n\t\tthis.x *= scalar;\r\n\t\tthis.y *= scalar;\r\n\t\tthis.z *= scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x * b.x;\r\n\t\tthis.y = a.y * b.y;\r\n\t\tthis.z = a.z * b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyEuler: function () {\r\n\r\n\t\tvar quaternion = new Quaternion();\r\n\r\n\t\treturn function applyEuler( euler ) {\r\n\r\n\t\t\tif ( ! ( euler && euler.isEuler ) ) {\r\n\r\n\t\t\t\tconsole.error( 'COOL.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.applyQuaternion( quaternion.setFromEuler( euler ) );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyAxisAngle: function () {\r\n\r\n\t\tvar quaternion = new Quaternion();\r\n\r\n\t\treturn function applyAxisAngle( axis, angle ) {\r\n\r\n\t\t\treturn this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyMatrix3: function ( m ) {\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\r\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\r\n\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( m ) {\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\tvar e = m.elements;\r\n\r\n\t\tvar w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );\r\n\r\n\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;\r\n\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;\r\n\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyQuaternion: function ( q ) {\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\tvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;\r\n\r\n\t\t// calculate quat * vector\r\n\r\n\t\tvar ix = qw * x + qy * z - qz * y;\r\n\t\tvar iy = qw * y + qz * x - qx * z;\r\n\t\tvar iz = qw * z + qx * y - qy * x;\r\n\t\tvar iw = - qx * x - qy * y - qz * z;\r\n\r\n\t\t// calculate result * inverse quat\r\n\r\n\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\r\n\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\r\n\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tproject: function ( camera ) {\r\n\r\n\t\treturn this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );\r\n\r\n\t},\r\n\r\n\tunproject: function () {\r\n\r\n\t\tvar matrix = new Matrix4();\r\n\r\n\t\treturn function unproject( camera ) {\r\n\r\n\t\t\treturn this.applyMatrix4( matrix.getInverse( camera.projectionMatrix ) ).applyMatrix4( camera.matrixWorld );\r\n            // return this.applyMatrix4( matrix.getInverse( camera.VPmatrix ) ); 等价\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttransformDirection: function ( m ) {\r\n\r\n\t\t// input: COOL.Matrix4 affine matrix\r\n\t\t// vector interpreted as a direction\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\r\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\r\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\r\n\r\n\t\treturn this.normalize();\r\n\r\n\t},\r\n\r\n\tdivide: function ( v ) {\r\n\r\n\t\tthis.x /= v.x;\r\n\t\tthis.y /= v.y;\r\n\t\tthis.z /= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( scalar ) {\r\n\r\n\t\treturn this.multiplyScalar( 1 / scalar );\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tthis.x = Math.min( this.x, v.x );\r\n\t\tthis.y = Math.min( this.y, v.y );\r\n\t\tthis.z = Math.min( this.z, v.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tthis.x = Math.max( this.x, v.x );\r\n\t\tthis.y = Math.max( this.y, v.y );\r\n\t\tthis.z = Math.max( this.z, v.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// assumes min < max, componentwise\r\n\r\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclampScalar: function () {\r\n\r\n\t\tvar min = new Vector3();\r\n\t\tvar max = new Vector3();\r\n\r\n\t\treturn function clampScalar( minVal, maxVal ) {\r\n\r\n\t\t\tmin.set( minVal, minVal, minVal );\r\n\t\t\tmax.set( maxVal, maxVal, maxVal );\r\n\r\n\t\t\treturn this.clamp( min, max );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclampLength: function ( min, max ) {\r\n\r\n\t\tvar length = this.length();\r\n\r\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\r\n\r\n\t},\r\n\r\n\tfloor: function () {\r\n\r\n\t\tthis.x = Math.floor( this.x );\r\n\t\tthis.y = Math.floor( this.y );\r\n\t\tthis.z = Math.floor( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tceil: function () {\r\n\r\n\t\tthis.x = Math.ceil( this.x );\r\n\t\tthis.y = Math.ceil( this.y );\r\n\t\tthis.z = Math.ceil( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tround: function () {\r\n\r\n\t\tthis.x = Math.round( this.x );\r\n\t\tthis.y = Math.round( this.y );\r\n\t\tthis.z = Math.round( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\troundToZero: function () {\r\n\r\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.x = - this.x;\r\n\t\tthis.y = - this.y;\r\n\t\tthis.z = - this.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\r\n\r\n\t},\r\n\r\n\t// TODO lengthSquared?\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\r\n\r\n\t},\r\n\r\n\tmanhattanLength: function () {\r\n\r\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() || 1 );\r\n\r\n\t},\r\n\r\n\tsetLength: function ( length ) {\r\n\r\n\t\treturn this.normalize().multiplyScalar( length );\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerpVectors: function ( v1, v2, alpha ) {\r\n\r\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n\t},\r\n\r\n\tcross: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\r\n\t\t\treturn this.crossVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.crossVectors( this, v );\r\n\r\n\t},\r\n\r\n\tcrossVectors: function ( a, b ) {\r\n\r\n\t\tvar ax = a.x, ay = a.y, az = a.z;\r\n\t\tvar bx = b.x, by = b.y, bz = b.z;\r\n\r\n\t\tthis.x = ay * bz - az * by;\r\n\t\tthis.y = az * bx - ax * bz;\r\n\t\tthis.z = ax * by - ay * bx;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tprojectOnVector: function ( vector ) {\r\n\r\n\t\tvar scalar = vector.dot( this ) / vector.lengthSq();\r\n\r\n\t\treturn this.copy( vector ).multiplyScalar( scalar );\r\n\r\n\t},\r\n\r\n\tprojectOnPlane: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function projectOnPlane( planeNormal ) {\r\n\r\n\t\t\tv1.copy( this ).projectOnVector( planeNormal );\r\n\r\n\t\t\treturn this.sub( v1 );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\treflect: function () {\r\n\r\n\t\t// reflect incident vector off plane orthogonal to normal\r\n\t\t// normal is assumed to have unit length\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function reflect( normal ) {\r\n\r\n\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tangleTo: function ( v ) {\r\n\r\n\t\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\r\n\r\n\t\t// clamp, to handle numerical problems\r\n\r\n\t\treturn Math.acos( _Math.clamp( theta, - 1, 1 ) );\r\n\r\n\t},\r\n\r\n\tdistanceTo: function ( v ) {\r\n\r\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n\t},\r\n\r\n\tdistanceToSquared: function ( v ) {\r\n\r\n\t\tvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\r\n\r\n\t\treturn dx * dx + dy * dy + dz * dz;\r\n\r\n\t},\r\n\r\n\tmanhattanDistanceTo: function ( v ) {\r\n\r\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\r\n\r\n\t},\r\n\r\n\tsetFromSpherical: function ( s ) {\r\n\r\n\t\treturn this.setFromSphericalCoords( s.radius, s.phi, s.theta );\r\n\r\n\t},\r\n\r\n\tsetFromSphericalCoords: function ( radius, phi, theta ) {\r\n\r\n\t\tvar sinPhiRadius = Math.sin( phi ) * radius;\r\n\r\n\t\tthis.x = sinPhiRadius * Math.sin( theta );\r\n\t\tthis.y = Math.cos( phi ) * radius;\r\n\t\tthis.z = sinPhiRadius * Math.cos( theta );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCylindrical: function ( c ) {\r\n\r\n\t\treturn this.setFromCylindricalCoords( c.radius, c.theta, c.y );\r\n\r\n\t},\r\n\r\n\tsetFromCylindricalCoords: function ( radius, theta, y ) {\r\n\r\n\t\tthis.x = radius * Math.sin( theta );\r\n\t\tthis.y = y;\r\n\t\tthis.z = radius * Math.cos( theta );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrixPosition: function ( m ) {\r\n\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 12 ];\r\n\t\tthis.y = e[ 13 ];\r\n\t\tthis.z = e[ 14 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrixScale: function ( m ) {\r\n\r\n\t\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\r\n\t\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\r\n\t\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\r\n\r\n\t\tthis.x = sx;\r\n\t\tthis.y = sy;\r\n\t\tthis.z = sz;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrixColumn: function ( m, index ) {\r\n\r\n\t\treturn this.fromArray( m.elements, index * 4 );\r\n\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\r\n\r\n\t},\r\n\r\n    rotateByVector :function(vec1, vec2, angle) {\r\n        var v1 = vec1.toArray();\r\n        var v2 = vec2.toArray();\r\n        angle = - angle;\r\n        var pos = [];\r\n        pos[0] = v1[0] * Math.cos(angle) + (v2[1] * v1[2] - v2[2] * v1[1]) * Math.sin(angle) + v2[0] * (v2[0] * v1[0] + v2[1] * v1[1] + v2[2] * v1[2]) * (1 - Math.cos(angle));\r\n        pos[1] = v1[1] * Math.cos(angle) + (v2[2] * v1[0] - v2[0] * v1[2]) * Math.sin(angle) + v2[1] * (v2[0] * v1[0] + v2[1] * v1[1] + v2[2] * v1[2]) * (1 - Math.cos(angle));\r\n        pos[2] = v1[2] * Math.cos(angle) + (v2[0] * v1[1] - v2[1] * v1[0]) * Math.sin(angle) + v2[2] * (v2[0] * v1[0] + v2[1] * v1[1] + v2[2] * v1[2]) * (1 - Math.cos(angle));\r\n        return new Vector3().fromArray(pos);\r\n    },\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.x = array[ offset ];\r\n\t\tthis.y = array[ offset + 1 ];\r\n\t\tthis.z = array[ offset + 2 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this.x;\r\n\t\tarray[ offset + 1 ] = this.y;\r\n\t\tarray[ offset + 2 ] = this.z;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tfromBufferAttribute: function ( attribute, index, offset ) {\r\n\r\n\t\tif ( offset !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Vector3: offset has been removed from .fromBufferAttribute().' );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x = attribute.getX( index );\r\n\t\tthis.y = attribute.getY( index );\r\n\t\tthis.z = attribute.getZ( index );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/math/Box3.js\n\r\n\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nfunction Box3( min, max ) {\r\n\r\n\tthis.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );\r\n\tthis.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );\r\n\r\n}\r\n\r\nObject.assign( Box3.prototype, {\r\n\r\n\tisBox3: true,\r\n\r\n\tset: function ( min, max ) {\r\n\r\n\t\tthis.min.copy( min );\r\n\t\tthis.max.copy( max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromArray: function ( array ) {\r\n\r\n\t\tvar minX = + Infinity;\r\n\t\tvar minY = + Infinity;\r\n\t\tvar minZ = + Infinity;\r\n\r\n\t\tvar maxX = - Infinity;\r\n\t\tvar maxY = - Infinity;\r\n\t\tvar maxZ = - Infinity;\r\n\r\n\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\r\n\r\n\t\t\tvar x = array[ i ];\r\n\t\t\tvar y = array[ i + 1 ];\r\n\t\t\tvar z = array[ i + 2 ];\r\n\r\n\t\t\tif ( x < minX ) minX = x;\r\n\t\t\tif ( y < minY ) minY = y;\r\n\t\t\tif ( z < minZ ) minZ = z;\r\n\r\n\t\t\tif ( x > maxX ) maxX = x;\r\n\t\t\tif ( y > maxY ) maxY = y;\r\n\t\t\tif ( z > maxZ ) maxZ = z;\r\n\r\n\t\t}\r\n\r\n\t\tthis.min.set( minX, minY, minZ );\r\n\t\tthis.max.set( maxX, maxY, maxZ );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromBufferAttribute: function ( attribute ) {\r\n\r\n\t\tvar minX = + Infinity;\r\n\t\tvar minY = + Infinity;\r\n\t\tvar minZ = + Infinity;\r\n\r\n\t\tvar maxX = - Infinity;\r\n\t\tvar maxY = - Infinity;\r\n\t\tvar maxZ = - Infinity;\r\n\r\n\t\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\r\n\r\n\t\t\tvar x = attribute.getX( i );\r\n\t\t\tvar y = attribute.getY( i );\r\n\t\t\tvar z = attribute.getZ( i );\r\n\r\n\t\t\tif ( x < minX ) minX = x;\r\n\t\t\tif ( y < minY ) minY = y;\r\n\t\t\tif ( z < minZ ) minZ = z;\r\n\r\n\t\t\tif ( x > maxX ) maxX = x;\r\n\t\t\tif ( y > maxY ) maxY = y;\r\n\t\t\tif ( z > maxZ ) maxZ = z;\r\n\r\n\t\t}\r\n\r\n\t\tthis.min.set( minX, minY, minZ );\r\n\t\tthis.max.set( maxX, maxY, maxZ );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function ( points ) {\r\n\r\n\t\tthis.makeEmpty();\r\n\r\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.expandByPoint( points[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCenterAndSize: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function setFromCenterAndSize( center, size ) {\r\n\r\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\r\n\t\t\tthis.min.copy( center ).sub( halfSize );\r\n\t\t\tthis.max.copy( center ).add( halfSize );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetFromObject: function ( object ) {\r\n\r\n\t\tthis.makeEmpty();\r\n\r\n\t\treturn this.expandByObject( object );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( box ) {\r\n\r\n\t\tthis.min.copy( box.min );\r\n\t\tthis.max.copy( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeEmpty: function () {\r\n\r\n\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\r\n\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tisEmpty: function () {\r\n\r\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\r\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\r\n\r\n\t},\r\n\r\n\tgetCenter: function ( target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Box3: .getCenter() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\r\n\t},\r\n\r\n\tgetSize: function ( target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Box3: .getSize() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );\r\n\r\n\t},\r\n\r\n\texpandByPoint: function ( point ) {\r\n\r\n\t\tthis.min.min( point );\r\n\t\tthis.max.max( point );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByVector: function ( vector ) {\r\n\r\n\t\tthis.min.sub( vector );\r\n\t\tthis.max.add( vector );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByScalar: function ( scalar ) {\r\n\r\n\t\tthis.min.addScalar( - scalar );\r\n\t\tthis.max.addScalar( scalar );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByObject: function () {\r\n\r\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\r\n\t\t// accounting for both the object's, and children's, world transforms\r\n\r\n\t\tvar scope, i, l;\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\tfunction traverse( node ) {\r\n\r\n\t\t\tvar geometry = node.geometry;\r\n\r\n\t\t\tif ( geometry !== undefined ) {\r\n\r\n\t\t\t\tif ( geometry.isGeometry ) {\r\n\r\n\t\t\t\t\tvar vertices = geometry.vertices;\r\n\r\n\t\t\t\t\tfor ( i = 0, l = vertices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\tv1.copy( vertices[ i ] );\r\n\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\r\n\r\n\t\t\t\t\t\tscope.expandByPoint( v1 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( geometry.isBufferGeometry ) {\r\n\r\n\t\t\t\t\tvar attribute = geometry.attributes.position;\r\n\r\n\t\t\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\t\t\tfor ( i = 0, l = attribute.count; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tv1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );\r\n\r\n\t\t\t\t\t\t\tscope.expandByPoint( v1 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn function expandByObject( object ) {\r\n\r\n\t\t\tscope = this;\r\n\r\n\t\t\tobject.updateMatrixWorld( true );\r\n\r\n\t\t\tobject.traverse( traverse );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\treturn point.x < this.min.x || point.x > this.max.x ||\r\n\t\t\tpoint.y < this.min.y || point.y > this.max.y ||\r\n\t\t\tpoint.z < this.min.z || point.z > this.max.z ? false : true;\r\n\r\n\t},\r\n\r\n\tcontainsBox: function ( box ) {\r\n\r\n\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\r\n\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y &&\r\n\t\t\tthis.min.z <= box.min.z && box.max.z <= this.max.z;\r\n\r\n\t},\r\n\r\n\tgetParameter: function ( point, target ) {\r\n\r\n\t\t// This can potentially have a divide by zero if the box\r\n\t\t// has a size dimension of 0.\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Box3: .getParameter() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\treturn target.set(\r\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\r\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\r\n\t\t);\r\n\r\n\t},\r\n\r\n\tintersectsBox: function ( box ) {\r\n\r\n\t\t// using 6 splitting planes to rule out intersections.\r\n\t\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\r\n\t\t\tbox.max.y < this.min.y || box.min.y > this.max.y ||\r\n\t\t\tbox.max.z < this.min.z || box.min.z > this.max.z ? false : true;\r\n\r\n\t},\r\n\r\n\tintersectsSphere: ( function () {\r\n\r\n\t\tvar closestPoint = new Vector3();\r\n\r\n\t\treturn function intersectsSphere( sphere ) {\r\n\r\n\t\t\t// Find the point on the AABB closest to the sphere center.\r\n\t\t\tthis.clampPoint( sphere.center, closestPoint );\r\n\r\n\t\t\t// If that point is inside the sphere, the AABB and sphere intersect.\r\n\t\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n\tintersectsPlane: function ( plane ) {\r\n\r\n\t\t// We compute the minimum and maximum dot product values. If those values\r\n\t\t// are on the same side (back or front) of the plane, then there is no intersection.\r\n\r\n\t\tvar min, max;\r\n\r\n\t\tif ( plane.normal.x > 0 ) {\r\n\r\n\t\t\tmin = plane.normal.x * this.min.x;\r\n\t\t\tmax = plane.normal.x * this.max.x;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmin = plane.normal.x * this.max.x;\r\n\t\t\tmax = plane.normal.x * this.min.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( plane.normal.y > 0 ) {\r\n\r\n\t\t\tmin += plane.normal.y * this.min.y;\r\n\t\t\tmax += plane.normal.y * this.max.y;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmin += plane.normal.y * this.max.y;\r\n\t\t\tmax += plane.normal.y * this.min.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( plane.normal.z > 0 ) {\r\n\r\n\t\t\tmin += plane.normal.z * this.min.z;\r\n\t\t\tmax += plane.normal.z * this.max.z;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmin += plane.normal.z * this.max.z;\r\n\t\t\tmax += plane.normal.z * this.min.z;\r\n\r\n\t\t}\r\n\r\n\t\treturn ( min <= - plane.constant && max >= - plane.constant );\r\n\r\n\t},\r\n\r\n\tintersectsTriangle: ( function () {\r\n\r\n\t\t// triangle centered vertices\r\n\t\tvar v0 = new Vector3();\r\n\t\tvar v1 = new Vector3();\r\n\t\tvar v2 = new Vector3();\r\n\r\n\t\t// triangle edge vectors\r\n\t\tvar f0 = new Vector3();\r\n\t\tvar f1 = new Vector3();\r\n\t\tvar f2 = new Vector3();\r\n\r\n\t\tvar testAxis = new Vector3();\r\n\r\n\t\tvar center = new Vector3();\r\n\t\tvar extents = new Vector3();\r\n\r\n\t\tvar triangleNormal = new Vector3();\r\n\r\n\t\tfunction satForAxes( axes ) {\r\n\r\n\t\t\tvar i, j;\r\n\r\n\t\t\tfor ( i = 0, j = axes.length - 3; i <= j; i += 3 ) {\r\n\r\n\t\t\t\ttestAxis.fromArray( axes, i );\r\n\t\t\t\t// project the aabb onto the seperating axis\r\n\t\t\t\tvar r = extents.x * Math.abs( testAxis.x ) + extents.y * Math.abs( testAxis.y ) + extents.z * Math.abs( testAxis.z );\r\n\t\t\t\t// project all 3 vertices of the triangle onto the seperating axis\r\n\t\t\t\tvar p0 = v0.dot( testAxis );\r\n\t\t\t\tvar p1 = v1.dot( testAxis );\r\n\t\t\t\tvar p2 = v2.dot( testAxis );\r\n\t\t\t\t// actual test, basically see if either of the most extreme of the triangle points intersects r\r\n\t\t\t\tif ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\r\n\r\n\t\t\t\t\t// points of the projected triangle are outside the projected half-length of the aabb\r\n\t\t\t\t\t// the axis is seperating and we can exit\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn function intersectsTriangle( triangle ) {\r\n\r\n\t\t\tif ( this.isEmpty() ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// compute box center and extents\r\n\t\t\tthis.getCenter( center );\r\n\t\t\textents.subVectors( this.max, center );\r\n\r\n\t\t\t// translate triangle to aabb origin\r\n\t\t\tv0.subVectors( triangle.a, center );\r\n\t\t\tv1.subVectors( triangle.b, center );\r\n\t\t\tv2.subVectors( triangle.c, center );\r\n\r\n\t\t\t// compute edge vectors for triangle\r\n\t\t\tf0.subVectors( v1, v0 );\r\n\t\t\tf1.subVectors( v2, v1 );\r\n\t\t\tf2.subVectors( v0, v2 );\r\n\r\n\t\t\t// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\r\n\t\t\t// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\r\n\t\t\t// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\r\n\t\t\tvar axes = [\r\n\t\t\t\t0, - f0.z, f0.y, 0, - f1.z, f1.y, 0, - f2.z, f2.y,\r\n\t\t\t\tf0.z, 0, - f0.x, f1.z, 0, - f1.x, f2.z, 0, - f2.x,\r\n\t\t\t\t- f0.y, f0.x, 0, - f1.y, f1.x, 0, - f2.y, f2.x, 0\r\n\t\t\t];\r\n\t\t\tif ( ! satForAxes( axes ) ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// test 3 face normals from the aabb\r\n\t\t\taxes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];\r\n\t\t\tif ( ! satForAxes( axes ) ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// finally testing the face normal of the triangle\r\n\t\t\t// use already existing triangle edge vectors here\r\n\t\t\ttriangleNormal.crossVectors( f0, f1 );\r\n\t\t\taxes = [ triangleNormal.x, triangleNormal.y, triangleNormal.z ];\r\n\t\t\treturn satForAxes( axes );\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n\tclampPoint: function ( point, target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Box3: .clampPoint() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\treturn target.copy( point ).clamp( this.min, this.max );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function distanceToPoint( point ) {\r\n\r\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n\t\t\treturn clampedPoint.sub( point ).length();\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetBoundingSphere: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function getBoundingSphere( target ) {\r\n\r\n\t\t\tif ( target === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'COOL.Box3: .getBoundingSphere() target is now required' );\r\n\t\t\t\ttarget = new Sphere();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.getCenter( target.center );\r\n\r\n\t\t\ttarget.radius = this.getSize( v1 ).length() * 0.5;\r\n\r\n\t\t\treturn target;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersect: function ( box ) {\r\n\r\n\t\tthis.min.max( box.min );\r\n\t\tthis.max.min( box.max );\r\n\r\n\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\r\n\t\tif ( this.isEmpty() ) this.makeEmpty();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tunion: function ( box ) {\r\n\r\n\t\tthis.min.min( box.min );\r\n\t\tthis.max.max( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function () {\r\n\r\n\t\tvar points = [\r\n\t\t\tnew Vector3(),\r\n\t\t\tnew Vector3(),\r\n\t\t\tnew Vector3(),\r\n\t\t\tnew Vector3(),\r\n\t\t\tnew Vector3(),\r\n\t\t\tnew Vector3(),\r\n\t\t\tnew Vector3(),\r\n\t\t\tnew Vector3()\r\n\t\t];\r\n\r\n\t\treturn function applyMatrix4( matrix ) {\r\n\r\n\t\t\t// transform of empty box is an empty box.\r\n\t\t\tif ( this.isEmpty() ) return this;\r\n\r\n\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\r\n\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\r\n\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\r\n\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\r\n\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\r\n\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\r\n\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\r\n\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\r\n\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111\r\n\r\n\t\t\tthis.setFromPoints( points );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.min.add( offset );\r\n\t\tthis.max.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( box ) {\r\n\r\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/math/Sphere.js\n\r\n\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nfunction Sphere( center, radius ) {\r\n\r\n\tthis.center = ( center !== undefined ) ? center : new Vector3();\r\n\tthis.radius = ( radius !== undefined ) ? radius : 0;\r\n\r\n}\r\n\r\nObject.assign( Sphere.prototype, {\r\n\r\n\tset: function ( center, radius ) {\r\n\r\n\t\tthis.center.copy( center );\r\n\t\tthis.radius = radius;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function () {\r\n\r\n\t\tvar box = new Box3();\r\n\r\n\t\treturn function setFromPoints( points, optionalCenter ) {\r\n\r\n\t\t\tvar center = this.center;\r\n\r\n\t\t\tif ( optionalCenter !== undefined ) {\r\n\r\n\t\t\t\tcenter.copy( optionalCenter );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbox.setFromPoints( points ).getCenter( center );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar maxRadiusSq = 0;\r\n\r\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( sphere ) {\r\n\r\n\t\tthis.center.copy( sphere.center );\r\n\t\tthis.radius = sphere.radius;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tempty: function () {\r\n\r\n\t\treturn ( this.radius <= 0 );\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function ( point ) {\r\n\r\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\r\n\r\n\t},\r\n\r\n\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\tvar radiusSum = this.radius + sphere.radius;\r\n\r\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\r\n\r\n\t},\r\n\r\n\tintersectsBox: function ( box ) {\r\n\r\n\t\treturn box.intersectsSphere( this );\r\n\r\n\t},\r\n\r\n\tintersectsPlane: function ( plane ) {\r\n\r\n\t\treturn Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;\r\n\r\n\t},\r\n\r\n\tclampPoint: function ( point, target ) {\r\n\r\n\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Sphere: .clampPoint() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\ttarget.copy( point );\r\n\r\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\r\n\r\n\t\t\ttarget.sub( this.center ).normalize();\r\n\t\t\ttarget.multiplyScalar( this.radius ).add( this.center );\r\n\r\n\t\t}\r\n\r\n\t\treturn target;\r\n\r\n\t},\r\n\r\n\tgetBoundingBox: function ( target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Sphere: .getBoundingBox() target is now required' );\r\n\t\t\ttarget = new Box3();\r\n\r\n\t\t}\r\n\r\n\t\ttarget.set( this.center, this.center );\r\n\t\ttarget.expandByScalar( this.radius );\r\n\r\n\t\treturn target;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( matrix ) {\r\n\r\n\t\tthis.center.applyMatrix4( matrix );\r\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.center.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( sphere ) {\r\n\r\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/core/BoxGeometry.js\n\r\n\r\n\r\n\r\nclass BoxGeometry_BoxGeometry {\r\n    constructor(param) {\r\n        param = param || {};\r\n\r\n        this.uv = param.uv || new Float32Array([   // Vertex coordinates\r\n\r\n            1,1, 0,1, 0,0, 1,0,  // v0-v1-v2-v3 front\r\n            0,1, 0,0, 1,0, 1,1,  // v0-v3-v4-v5 right\r\n            1,0, 1,1, 0,1, 0,0,  // v0-v5-v6-v1 up\r\n            1,1, 0,1, 0,0, 1,0,  // v1-v6-v7-v2 left\r\n            0,1, 1,1, 1,0, 0,0,  // v7-v4-v3-v2 down\r\n            1,0, 0,0, 0,1, 1,1   // v4-v7-v6-v5 back\r\n\r\n        ]);\r\n\r\n        this.vertices = param.indices || new Float32Array([   // Vertex coordinates\r\n            0.5, 0.5, 0.5,  -0.5, 0.5, 0.5,  -0.5,-0.5, 0.5,   0.5,-0.5, 0.5,  // v0-v1-v2-v3 front\r\n            0.5, 0.5, 0.5,   0.5,-0.5, 0.5,   0.5,-0.5,-0.5,   0.5, 0.5,-0.5,  // v0-v3-v4-v5 right\r\n            0.5, 0.5, 0.5,   0.5, 0.5,-0.5,  -0.5, 0.5,-0.5,  -0.5, 0.5, 0.5,  // v0-v5-v6-v1 up\r\n            -0.5, 0.5, 0.5,  -0.5, 0.5,-0.5,  -0.5,-0.5,-0.5,  -0.5,-0.5, 0.5,  // v1-v6-v7-v2 left\r\n            -0.5,-0.5,-0.5,   0.5,-0.5,-0.5,   0.5,-0.5, 0.5,  -0.5,-0.5, 0.5,  // v7-v4-v3-v2 down\r\n            0.5,-0.5,-0.5,  -0.5,-0.5,-0.5,  -0.5, 0.5,-0.5,   0.5, 0.5,-0.5   // v4-v7-v6-v5 back\r\n        ]);\r\n\r\n        this.normal = param.normal || this.vertices;\r\n\r\n        this.indices = param.indices || new Uint16Array([       // Indices of the vertices\r\n            0, 1, 2,   0, 2, 3,    // front\r\n            4, 5, 6,   4, 6, 7,    // right\r\n            8, 9,10,   8,10,11,    // up\r\n            12,13,14,  12,14,15,    // left\r\n            16,17,18,  16,18,19,    // down\r\n            20,21,22,  20,22,23     // back\r\n        ]);\r\n\r\n        this.boundingSphere = new Sphere();\r\n        this.boundingBox = new Box3();\r\n        this.computeBoundingBox();\r\n        // this.computeBoundingSphere();\r\n\r\n        this.updateNormal();\r\n\r\n        this.updataBuffer();\r\n\r\n    }\r\n\r\n    updataBuffer(){\r\n        var buffer = [];\r\n        var uv = this.uv;\r\n        var vertices = this.vertices;\r\n        var normal = this.normal;\r\n        for(var i=0; i<vertices.length; i+=3){\r\n            buffer.push(vertices[i+0]);\r\n            buffer.push(vertices[i+1]);\r\n            buffer.push(vertices[i+2]);\r\n\r\n            buffer.push(normal[i+0]);\r\n            buffer.push(normal[i+1]);\r\n            buffer.push(normal[i+2]);\r\n\r\n            buffer.push(uv[i/3*2+0]);\r\n            buffer.push(uv[i/3*2+1]);\r\n        }\r\n\r\n        this.buffer = new Float32Array(buffer);\r\n    }\r\n\r\n    updateNormal(){\r\n        var normal = [];\r\n        var vertices = this.vertices;\r\n        for(var i=0; i<vertices.length; i+=3*4){\r\n            var line1 = new Vector3().subVectors(\r\n                new Vector3(vertices[i+0], vertices[i+1], vertices[i+2]),\r\n                new Vector3(vertices[i+3], vertices[i+4], vertices[i+5])\r\n            );\r\n            var line2 = new Vector3().subVectors(\r\n                new Vector3(vertices[i+3], vertices[i+4], vertices[i+5]),\r\n                new Vector3(vertices[i+6], vertices[i+7], vertices[i+8]),\r\n            );\r\n            var cur_normal = new Vector3().crossVectors(\r\n                line1,\r\n                line2\r\n            ).toArray();\r\n            for(var j=0 ;j<4; j++){\r\n                normal.push(cur_normal[0], cur_normal[1], cur_normal[2]);\r\n            }\r\n        }\r\n        this.normal = new Float32Array(normal);\r\n\r\n    }\r\n\r\n    computeBoundingSphere(){\r\n\r\n        // if ( this.boundingSphere === null ) {\r\n        //     this.boundingSphere = new Sphere();\r\n        // }\r\n        // this.boundingSphere.setFromPoints( this.vertices );\r\n    }\r\n\r\n    computeBoundingBox () {\r\n        var verticesV3 = [];\r\n        for(var i=0; i<this.vertices.length; i+=3){\r\n            verticesV3.push(new Vector3(this.vertices[i], this.vertices[i+1], this.vertices[i+2]))\r\n        }\r\n        this.boundingBox.setFromPoints(verticesV3);\r\n    }\r\n\r\n    clone(){\r\n        var geometry = new BoxGeometry_BoxGeometry({\r\n            vertices: this.vertices.slice(0),\r\n            indices: this.indices.slice(0)\r\n        });\r\n\r\n        return geometry;\r\n    }\r\n}\r\n\r\n/* harmony default export */ var core_BoxGeometry = (BoxGeometry_BoxGeometry);\r\n\n// CONCATENATED MODULE: ./src/material/Material.js\n\r\nclass Material {\r\n    constructor(param) {\r\n        param = param || {};\r\n        this.type = 'Material';\r\n        this.map = param.map;\r\n        this.envMap = param.envMap;\r\n        this.color = param.color || [1,1,1,1];\r\n        this.opacity = this.color[3];\r\n        if(this.color[3] && this.color[3]<1){\r\n            this.transparent = true;\r\n        }else {\r\n            this.transparent = false;\r\n        }\r\n        this.metalness = param.metalness == undefined ? 0.5 : param.metalness;\r\n\r\n        this.wireframe = param.wireframe == undefined ? false : param.wireframe;\r\n\r\n        var VSHADER_SOURCE =\r\n\r\n            'precision highp int;\\n' +\r\n            'precision highp float;\\n' +\r\n            'attribute vec4 a_Position;\\n' +\r\n            'uniform mat4 u_MvMatrix;\\n' +\r\n            'uniform mat4 u_PMatrix;\\n' +\r\n\r\n            '#ifdef USE_Shadow\\n' +\r\n            'uniform mat4 u_PMatrixFromLight;\\n' +\r\n            'varying vec4 v_PositionFromLight;\\n' +\r\n            '#endif\\n' +\r\n\r\n            'attribute vec2 a_TexCoord;\\n' +\r\n            'varying vec2 v_TexCoord;\\n' +\r\n            'attribute vec3 a_Normal;\\n' +\r\n            'varying vec3 v_Normal;\\n' +\r\n\r\n            '#ifdef USE_SColor\\n' +\r\n            'varying vec3 v_PositionV3;\\n' +\r\n            '#else\\n' +\r\n            '   #ifdef USE_envMap\\n' +\r\n            '   varying vec3 v_PositionV3;\\n' +\r\n            '   #endif\\n' +\r\n            '#endif\\n' +\r\n\r\n            'void main() {\\n' +\r\n            '  vec4 positionV4 = u_PMatrix * u_MvMatrix * a_Position;\\n' +\r\n            '  gl_Position = positionV4;\\n' +\r\n            '  v_TexCoord = a_TexCoord;\\n' +\r\n            '  v_Normal = mat3(u_MvMatrix) * a_Normal;\\n' +\r\n            // '  v_Normal = (u_MvMatrix * vec4(a_Normal, 0.0)).xyz;\\n' +\r\n            // '  v_Normal = a_Normal;\\n' +\r\n\r\n            '#ifdef USE_Shadow\\n' +\r\n            '  v_PositionFromLight = u_PMatrixFromLight * u_MvMatrix * a_Position;\\n' +\r\n            '#endif\\n' +\r\n\r\n            '#ifdef USE_SColor\\n' +\r\n            '  vec4 positionV4Rel = u_MvMatrix * a_Position;\\n' +\r\n            '  v_PositionV3 = positionV4Rel.xyz / positionV4Rel.w;\\n' +\r\n            '#else\\n' +\r\n            '   #ifdef USE_envMap\\n' +\r\n            '   vec4 positionV4Rel = u_MvMatrix * a_Position;\\n' +\r\n            '   v_PositionV3 = positionV4Rel.xyz / positionV4Rel.w;\\n' +\r\n            '   #endif\\n' +\r\n            '#endif\\n' +\r\n\r\n            '}\\n';\r\n\r\n        var FSHADER_SOURCE =\r\n            'precision highp int;\\n' +\r\n            'precision highp float;\\n' +\r\n            'uniform vec4 u_Color;\\n' +\r\n            'varying vec2 v_TexCoord;\\n' +\r\n            'varying vec3 v_Normal;\\n' +\r\n\r\n            'uniform float u_Metalness;\\n' +\r\n\r\n            '#ifdef USE_Map\\n' +\r\n            'uniform sampler2D u_Sampler;\\n' +\r\n            '#endif\\n' +\r\n\r\n            '#ifdef USE_envMap\\n' +\r\n            'uniform samplerCube u_envMap;\\n' +\r\n            '#endif\\n' +\r\n\r\n            '#ifdef USE_AmbientLight\\n' +\r\n            'uniform vec3 u_AmbientLight_Color;\\n' +\r\n            '#endif\\n' +\r\n\r\n            '#ifdef USE_DirectionalLight\\n' +\r\n            'uniform vec3 u_DirectionalLight_Direction;\\n' +\r\n            'uniform vec3 u_DirectionalLight_Color;\\n' +\r\n            '#endif\\n' +\r\n\r\n            '#ifdef USE_SColor\\n' +\r\n            'uniform vec3 u_Camera_Position;\\n' +\r\n            'varying vec3 v_PositionV3;\\n' +\r\n            '#else\\n' +\r\n            '   #ifdef USE_envMap\\n' +\r\n            '   uniform vec3 u_Camera_Position;\\n' +\r\n            '   varying vec3 v_PositionV3;\\n' +\r\n            '   #endif\\n' +\r\n            '#endif\\n' +\r\n\r\n            '#ifdef USE_Shadow\\n' +\r\n            'uniform sampler2D u_ShadowMap;\\n' +\r\n            'varying vec4 v_PositionFromLight;\\n' +\r\n\r\n            'float unpackDepth(const in vec4 rgbaDepth) {\\n' +\r\n            '  const vec4 bitShift = vec4(1.0, 1.0/256.0, 1.0/(256.0*256.0), 1.0/(256.0*256.0*256.0));\\n' +\r\n            '  float depth = dot(rgbaDepth, bitShift);\\n' + // Use dot() since the calculations is same\r\n            '  return depth;\\n' +\r\n            '}\\n' +\r\n\r\n            '#endif\\n' +\r\n\r\n            'void main() {\\n' +\r\n            '  vec4 color = u_Color;\\n' +\r\n            '  vec3 v_Normal0 = normalize(v_Normal);\\n' +\r\n\r\n            '#ifdef USE_Map\\n' +\r\n            '  color = texture2D(u_Sampler, v_TexCoord);\\n' +\r\n            '#endif\\n' +\r\n\r\n            '  vec3 colorV3 = color.rgb;\\n' +\r\n            '  float useLight = 0.0;\\n' +\r\n            '  vec3 finalColorV3 = colorV3.rgb;\\n' +\r\n\r\n            '#ifdef USE_AmbientLight\\n' +\r\n            '  vec3 A_color = colorV3 * u_AmbientLight_Color * 0.5;\\n' +\r\n            '  finalColorV3 = A_color;\\n' +\r\n            '  useLight = 1.0;\\n' +\r\n            '#endif\\n' +\r\n\r\n            '#ifdef USE_DirectionalLight\\n' +\r\n            '  float D_weight = max(dot(u_DirectionalLight_Direction, v_Normal0), 0.0);\\n' +\r\n            '  vec3 D_color = colorV3 * u_DirectionalLight_Color * D_weight * (1.0 - u_Metalness);\\n' +\r\n\r\n            '  if(useLight>0.5){\\n' +\r\n            '    finalColorV3 = finalColorV3 + D_color;\\n' +\r\n            '  }else{\\n' +\r\n            '    finalColorV3 = D_color;\\n' +\r\n            '  }\\n' +\r\n            '  useLight = 1.0;\\n' +\r\n            '#endif\\n' +\r\n\r\n            '#ifdef USE_SColor\\n' +\r\n            '  vec3 r = normalize( reflect(-u_DirectionalLight_Direction, v_Normal0) );\\n' +\r\n            '  vec3 v = normalize( u_Camera_Position - v_PositionV3 );\\n' +\r\n            '  float rdotv = max( dot(r ,v), 0.0 );\\n' +\r\n            '  float S_weight = pow( rdotv, 100.0 );\\n' +\r\n            '  vec3 S_color = colorV3 * u_DirectionalLight_Color * S_weight * u_Metalness;\\n' +\r\n\r\n            '  if(useLight>0.5){\\n' +\r\n            '    finalColorV3 = finalColorV3 + S_color;\\n' +\r\n            '  }else{\\n' +\r\n            '    finalColorV3 = S_color;\\n' +\r\n            '  }\\n' +\r\n            '  useLight = 1.0;\\n' +\r\n            '#endif\\n' +\r\n\r\n            '  color = vec4(finalColorV3, color.a);\\n' +\r\n\r\n            '#ifdef USE_envMap\\n' +\r\n            // '   vec3 v1 = normalize( u_Camera_Position - v_PositionV3 );\\n' +\r\n            // '   vec3 r1 = normalize( reflect(v1, v_Normal0) );\\n' +\r\n            '   vec3 v1 = u_Camera_Position - v_PositionV3;\\n' +\r\n            '   vec3 r1 = reflect(-v1, v_Normal0);\\n' +\r\n\r\n            '   vec4 envMapColor = textureCube(u_envMap, r1);\\n' +\r\n            // '   vec3 ref = v1 - 2.0 * dot(v_Normal0, v1) * v_Normal0;\\n'+\r\n            // '   vec4 envMapColor = textureCube(u_envMap, ref);\\n' +\r\n            '   color = vec4(envMapColor.rgb, color.a);\\n' +\r\n            '#endif\\n' +\r\n\r\n\r\n            '#ifdef USE_Shadow\\n' +\r\n            '  vec3 shadowCoord = (v_PositionFromLight.xyz/v_PositionFromLight.w)/2.0 + 0.5;\\n' +\r\n            '  vec4 rgbaDepth = texture2D(u_ShadowMap, shadowCoord.xy);\\n' +\r\n            '  float depth = unpackDepth(rgbaDepth);\\n' +\r\n            '  float visibility = (shadowCoord.z > depth + 0.0015) ? 0.7 : 1.0;\\n' +\r\n            '  color = vec4(color.rgb * visibility, color.a);\\n' +\r\n            '#endif\\n' +\r\n\r\n            '  gl_FragColor = color;\\n' +\r\n\r\n            '}\\n';\r\n\r\n        this.vshaderSource = VSHADER_SOURCE;\r\n        this.fshaderSource = FSHADER_SOURCE;\r\n    }\r\n\r\n    setOpacity(opacity){\r\n        this.opacity = opacity;\r\n        this.color[3] = opacity;\r\n        this.transparent = opacity<1;\r\n    }\r\n\r\n    clone(){\r\n\r\n        var material = new Material({\r\n            map: this.map,\r\n            color: this.color.slice(0)\r\n        });\r\n\r\n        return material;\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ var material_Material = (Material);\r\n\n// CONCATENATED MODULE: ./src/math/Euler.js\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nfunction Euler( x, y, z, order ) {\r\n\r\n\tthis._x = x || 0;\r\n\tthis._y = y || 0;\r\n\tthis._z = z || 0;\r\n\tthis._order = order || Euler.DefaultOrder;\r\n\r\n}\r\n\r\nEuler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\r\n\r\nEuler.DefaultOrder = 'XYZ';\r\n\r\nObject.defineProperties( Euler.prototype, {\r\n\r\n\tx: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this._x;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tthis._x = value;\r\n\t\t\tthis.onChangeCallback();\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ty: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this._y;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tthis._y = value;\r\n\t\t\tthis.onChangeCallback();\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tz: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this._z;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tthis._z = value;\r\n\t\t\tthis.onChangeCallback();\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\torder: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this._order;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tthis._order = value;\r\n\t\t\tthis.onChangeCallback();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\r\n\r\nObject.assign( Euler.prototype, {\r\n\r\n\tisEuler: true,\r\n\r\n\tset: function ( x, y, z, order ) {\r\n\r\n\t\tthis._x = x;\r\n\t\tthis._y = y;\r\n\t\tthis._z = z;\r\n\t\tthis._order = order || this._order;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\r\n\r\n\t},\r\n\r\n\tcopy: function ( euler ) {\r\n\r\n\t\tthis._x = euler._x;\r\n\t\tthis._y = euler._y;\r\n\t\tthis._z = euler._z;\r\n\t\tthis._order = euler._order;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromRotationMatrix: function ( m, order, update ) {\r\n\r\n\t\tvar clamp = _Math.clamp;\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tvar te = m.elements;\r\n\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\r\n\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\r\n\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\r\n\t\torder = order || this._order;\r\n\r\n\t\tif ( order === 'XYZ' ) {\r\n\r\n\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\r\n\t\t\t\tthis._z = Math.atan2( - m12, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\r\n\t\t\t\tthis._z = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'YXZ' ) {\r\n\r\n\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\r\n\t\t\t\tthis._z = Math.atan2( m21, m22 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\r\n\t\t\t\tthis._z = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'ZXY' ) {\r\n\r\n\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._y = Math.atan2( - m31, m33 );\r\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._y = 0;\r\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'ZYX' ) {\r\n\r\n\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( m32, m33 );\r\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = 0;\r\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'YZX' ) {\r\n\r\n\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( - m23, m22 );\r\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = 0;\r\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'XZY' ) {\r\n\r\n\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\r\n\t\t\t\tthis._y = Math.atan2( m13, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\r\n\t\t\t\tthis._y = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( 'COOL.Euler: .setFromRotationMatrix() given unsupported order: ' + order );\r\n\r\n\t\t}\r\n\r\n\t\tthis._order = order;\r\n\r\n\t\tif ( update !== false ) this.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromQuaternion: function () {\r\n\r\n\t\tvar matrix = new Matrix4();\r\n\r\n\t\treturn function setFromQuaternion( q, order, update ) {\r\n\r\n\t\t\tmatrix.makeRotationFromQuaternion( q );\r\n\r\n\t\t\treturn this.setFromRotationMatrix( matrix, order, update );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetFromVector3: function ( v, order ) {\r\n\r\n\t\treturn this.set( v.x, v.y, v.z, order || this._order );\r\n\r\n\t},\r\n\r\n\treorder: function () {\r\n\r\n\t\t// WARNING: this discards revolution information -bhouston\r\n\r\n\t\tvar q = new Quaternion();\r\n\r\n\t\treturn function reorder( newOrder ) {\r\n\r\n\t\t\tq.setFromEuler( this );\r\n\r\n\t\t\treturn this.setFromQuaternion( q, newOrder );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tequals: function ( euler ) {\r\n\r\n\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array ) {\r\n\r\n\t\tthis._x = array[ 0 ];\r\n\t\tthis._y = array[ 1 ];\r\n\t\tthis._z = array[ 2 ];\r\n\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this._x;\r\n\t\tarray[ offset + 1 ] = this._y;\r\n\t\tarray[ offset + 2 ] = this._z;\r\n\t\tarray[ offset + 3 ] = this._order;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\ttoVector3: function ( optionalResult ) {\r\n\r\n\t\tif ( optionalResult ) {\r\n\r\n\t\t\treturn optionalResult.set( this._x, this._y, this._z );\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn new Vector3( this._x, this._y, this._z );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tonChange: function ( callback ) {\r\n\r\n\t\tthis.onChangeCallback = callback;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tonChangeCallback: function () {}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/math/Vector2.js\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author egraether / http://egraether.com/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\nfunction Vector2( x, y ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\r\n}\r\n\r\nObject.defineProperties( Vector2.prototype, {\r\n\r\n\t\"width\": {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this.x;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tthis.x = value;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t\"height\": {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this.y;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tthis.y = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\r\n\r\nObject.assign( Vector2.prototype, {\r\n\r\n\tisVector2: true,\r\n\r\n\tset: function ( x, y ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetScalar: function ( scalar ) {\r\n\r\n\t\tthis.x = scalar;\r\n\t\tthis.y = scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.x, this.y );\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScaledVector: function ( v, s ) {\r\n\r\n\t\tthis.x += v.x * s;\r\n\t\tthis.y += v.y * s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubScalar: function ( s ) {\r\n\r\n\t\tthis.x -= s;\r\n\t\tthis.y -= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( v ) {\r\n\r\n\t\tthis.x *= v.x;\r\n\t\tthis.y *= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( scalar ) {\r\n\r\n\t\tthis.x *= scalar;\r\n\t\tthis.y *= scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivide: function ( v ) {\r\n\r\n\t\tthis.x /= v.x;\r\n\t\tthis.y /= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( scalar ) {\r\n\r\n\t\treturn this.multiplyScalar( 1 / scalar );\r\n\r\n\t},\r\n\r\n\tapplyMatrix3: function ( m ) {\r\n\r\n\t\tvar x = this.x, y = this.y;\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];\r\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tthis.x = Math.min( this.x, v.x );\r\n\t\tthis.y = Math.min( this.y, v.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tthis.x = Math.max( this.x, v.x );\r\n\t\tthis.y = Math.max( this.y, v.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// assumes min < max, componentwise\r\n\r\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclampScalar: function () {\r\n\r\n\t\tvar min = new Vector2();\r\n\t\tvar max = new Vector2();\r\n\r\n\t\treturn function clampScalar( minVal, maxVal ) {\r\n\r\n\t\t\tmin.set( minVal, minVal );\r\n\t\t\tmax.set( maxVal, maxVal );\r\n\r\n\t\t\treturn this.clamp( min, max );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclampLength: function ( min, max ) {\r\n\r\n\t\tvar length = this.length();\r\n\r\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\r\n\r\n\t},\r\n\r\n\tfloor: function () {\r\n\r\n\t\tthis.x = Math.floor( this.x );\r\n\t\tthis.y = Math.floor( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tceil: function () {\r\n\r\n\t\tthis.x = Math.ceil( this.x );\r\n\t\tthis.y = Math.ceil( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tround: function () {\r\n\r\n\t\tthis.x = Math.round( this.x );\r\n\t\tthis.y = Math.round( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\troundToZero: function () {\r\n\r\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.x = - this.x;\r\n\t\tthis.y = - this.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y;\r\n\r\n\t},\r\n\r\n\tcross: function ( v ) {\r\n\r\n\t\treturn this.x * v.y - this.y * v.x;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\r\n\r\n\t},\r\n\r\n\tmanhattanLength: function () {\r\n\r\n\t\treturn Math.abs( this.x ) + Math.abs( this.y );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() || 1 );\r\n\r\n\t},\r\n\r\n\tangle: function () {\r\n\r\n\t\t// computes the angle in radians with respect to the positive x-axis\r\n\r\n\t\tvar angle = Math.atan2( this.y, this.x );\r\n\r\n\t\tif ( angle < 0 ) angle += 2 * Math.PI;\r\n\r\n\t\treturn angle;\r\n\r\n\t},\r\n\r\n\tdistanceTo: function ( v ) {\r\n\r\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n\t},\r\n\r\n\tdistanceToSquared: function ( v ) {\r\n\r\n\t\tvar dx = this.x - v.x, dy = this.y - v.y;\r\n\t\treturn dx * dx + dy * dy;\r\n\r\n\t},\r\n\r\n\tmanhattanDistanceTo: function ( v ) {\r\n\r\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\r\n\r\n\t},\r\n\r\n\tsetLength: function ( length ) {\r\n\r\n\t\treturn this.normalize().multiplyScalar( length );\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerpVectors: function ( v1, v2, alpha ) {\r\n\r\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.x = array[ offset ];\r\n\t\tthis.y = array[ offset + 1 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this.x;\r\n\t\tarray[ offset + 1 ] = this.y;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tfromBufferAttribute: function ( attribute, index, offset ) {\r\n\r\n\t\tif ( offset !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Vector2: offset has been removed from .fromBufferAttribute().' );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x = attribute.getX( index );\r\n\t\tthis.y = attribute.getY( index );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trotateAround: function ( center, angle ) {\r\n\r\n\t\tvar c = Math.cos( angle ), s = Math.sin( angle );\r\n\r\n\t\tvar x = this.x - center.x;\r\n\t\tvar y = this.y - center.y;\r\n\r\n\t\tthis.x = x * c - y * s + center.x;\r\n\t\tthis.y = x * s + y * c + center.y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/math/Ray.js\n\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nfunction Ray( origin, direction ) {\r\n\r\n\tthis.origin = ( origin !== undefined ) ? origin : new Vector3();\r\n\tthis.direction = ( direction !== undefined ) ? direction : new Vector3();\r\n\r\n}\r\n\r\nObject.assign( Ray.prototype, {\r\n\r\n\tset: function ( origin, direction ) {\r\n\r\n\t\tthis.origin.copy( origin );\r\n\t\tthis.direction.copy( direction );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( ray ) {\r\n\r\n\t\tthis.origin.copy( ray.origin );\r\n\t\tthis.direction.copy( ray.direction );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tat: function ( t, target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Ray: .at() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\treturn target.copy( this.direction ).multiplyScalar( t ).add( this.origin );\r\n\r\n\t},\r\n\r\n\tlookAt: function ( v ) {\r\n\r\n\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trecast: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function recast( t ) {\r\n\r\n\t\t\tthis.origin.copy( this.at( t, v1 ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclosestPointToPoint: function ( point, target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Ray: .closestPointToPoint() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\ttarget.subVectors( point, this.origin );\r\n\r\n\t\tvar directionDistance = target.dot( this.direction );\r\n\r\n\t\tif ( directionDistance < 0 ) {\r\n\r\n\t\t\treturn target.copy( this.origin );\r\n\r\n\t\t}\r\n\r\n\t\treturn target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function ( point ) {\r\n\r\n\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\r\n\r\n\t},\r\n\r\n\tdistanceSqToPoint: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function distanceSqToPoint( point ) {\r\n\r\n\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\r\n\r\n\t\t\t// point behind the ray\r\n\r\n\t\t\tif ( directionDistance < 0 ) {\r\n\r\n\t\t\t\treturn this.origin.distanceToSquared( point );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\r\n\t\t\treturn v1.distanceToSquared( point );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tdistanceSqToSegment: function () {\r\n\r\n\t\tvar segCenter = new Vector3();\r\n\t\tvar segDir = new Vector3();\r\n\t\tvar diff = new Vector3();\r\n\r\n\t\treturn function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\r\n\r\n\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\r\n\t\t\t// It returns the min distance between the ray and the segment\r\n\t\t\t// defined by v0 and v1\r\n\t\t\t// It can also set two optional targets :\r\n\t\t\t// - The closest point on the ray\r\n\t\t\t// - The closest point on the segment\r\n\r\n\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\r\n\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\r\n\t\t\tdiff.copy( this.origin ).sub( segCenter );\r\n\r\n\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\r\n\t\t\tvar a01 = - this.direction.dot( segDir );\r\n\t\t\tvar b0 = diff.dot( this.direction );\r\n\t\t\tvar b1 = - diff.dot( segDir );\r\n\t\t\tvar c = diff.lengthSq();\r\n\t\t\tvar det = Math.abs( 1 - a01 * a01 );\r\n\t\t\tvar s0, s1, sqrDist, extDet;\r\n\r\n\t\t\tif ( det > 0 ) {\r\n\r\n\t\t\t\t// The ray and segment are not parallel.\r\n\r\n\t\t\t\ts0 = a01 * b1 - b0;\r\n\t\t\t\ts1 = a01 * b0 - b1;\r\n\t\t\t\textDet = segExtent * det;\r\n\r\n\t\t\t\tif ( s0 >= 0 ) {\r\n\r\n\t\t\t\t\tif ( s1 >= - extDet ) {\r\n\r\n\t\t\t\t\t\tif ( s1 <= extDet ) {\r\n\r\n\t\t\t\t\t\t\t// region 0\r\n\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\r\n\r\n\t\t\t\t\t\t\tvar invDet = 1 / det;\r\n\t\t\t\t\t\t\ts0 *= invDet;\r\n\t\t\t\t\t\t\ts1 *= invDet;\r\n\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t// region 1\r\n\r\n\t\t\t\t\t\t\ts1 = segExtent;\r\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// region 5\r\n\r\n\t\t\t\t\t\ts1 = - segExtent;\r\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( s1 <= - extDet ) {\r\n\r\n\t\t\t\t\t\t// region 4\r\n\r\n\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\r\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t} else if ( s1 <= extDet ) {\r\n\r\n\t\t\t\t\t\t// region 3\r\n\r\n\t\t\t\t\t\ts0 = 0;\r\n\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// region 2\r\n\r\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\r\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Ray and segment are parallel.\r\n\r\n\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\r\n\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( optionalPointOnRay ) {\r\n\r\n\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( optionalPointOnSegment ) {\r\n\r\n\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn sqrDist;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersectSphere: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function intersectSphere( sphere, target ) {\r\n\r\n\t\t\tv1.subVectors( sphere.center, this.origin );\r\n\t\t\tvar tca = v1.dot( this.direction );\r\n\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\r\n\t\t\tvar radius2 = sphere.radius * sphere.radius;\r\n\r\n\t\t\tif ( d2 > radius2 ) return null;\r\n\r\n\t\t\tvar thc = Math.sqrt( radius2 - d2 );\r\n\r\n\t\t\t// t0 = first intersect point - entrance on front of sphere\r\n\t\t\tvar t0 = tca - thc;\r\n\r\n\t\t\t// t1 = second intersect point - exit point on back of sphere\r\n\t\t\tvar t1 = tca + thc;\r\n\r\n\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\r\n\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\r\n\r\n\t\t\t// test to see if t0 is behind the ray:\r\n\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\r\n\t\t\t// in order to always return an intersect point that is in front of the ray.\r\n\t\t\tif ( t0 < 0 ) return this.at( t1, target );\r\n\r\n\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\r\n\t\t\treturn this.at( t0, target );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\treturn this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );\r\n\r\n\t},\r\n\r\n\tdistanceToPlane: function ( plane ) {\r\n\r\n\t\tvar denominator = plane.normal.dot( this.direction );\r\n\r\n\t\tif ( denominator === 0 ) {\r\n\r\n\t\t\t// line is coplanar, return origin\r\n\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\r\n\r\n\t\t\t\treturn 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\r\n\r\n\t\t// Return if the ray never intersects the plane\r\n\r\n\t\treturn t >= 0 ? t : null;\r\n\r\n\t},\r\n\r\n\tintersectPlane: function ( plane, target ) {\r\n\r\n\t\tvar t = this.distanceToPlane( plane );\r\n\r\n\t\tif ( t === null ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\treturn this.at( t, target );\r\n\r\n\t},\r\n\r\n\tintersectsPlane: function ( plane ) {\r\n\r\n\t\t// check if the ray lies on the plane first\r\n\r\n\t\tvar distToPoint = plane.distanceToPoint( this.origin );\r\n\r\n\t\tif ( distToPoint === 0 ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\tvar denominator = plane.normal.dot( this.direction );\r\n\r\n\t\tif ( denominator * distToPoint < 0 ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\t// ray origin is behind the plane (and is pointing behind it)\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tintersectBox: function ( box, target ) {\r\n\r\n\t\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\r\n\r\n\t\tvar invdirx = 1 / this.direction.x,\r\n\t\t\tinvdiry = 1 / this.direction.y,\r\n\t\t\tinvdirz = 1 / this.direction.z;\r\n\r\n\t\tvar origin = this.origin;\r\n\r\n\t\tif ( invdirx >= 0 ) {\r\n\r\n\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\r\n\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\r\n\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\r\n\r\n\t\t}\r\n\r\n\t\tif ( invdiry >= 0 ) {\r\n\r\n\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\r\n\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\r\n\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\r\n\r\n\t\t// These lines also handle the case where tmin or tmax is NaN\r\n\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\r\n\r\n\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\r\n\r\n\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\r\n\r\n\t\tif ( invdirz >= 0 ) {\r\n\r\n\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\r\n\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\r\n\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\r\n\r\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\r\n\r\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\r\n\r\n\t\t//return point closest to the ray (positive side)\r\n\r\n\t\tif ( tmax < 0 ) return null;\r\n\r\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, target );\r\n\r\n\t},\r\n\r\n\tintersectsBox: ( function () {\r\n\r\n\t\tvar v = new Vector3();\r\n\r\n\t\treturn function intersectsBox( box ) {\r\n\r\n\t\t\treturn this.intersectBox( box, v ) !== null;\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n\tintersectTriangle: function () {\r\n\r\n\t\t// Compute the offset origin, edges, and normal.\r\n\t\tvar diff = new Vector3();\r\n\t\tvar edge1 = new Vector3();\r\n\t\tvar edge2 = new Vector3();\r\n\t\tvar normal = new Vector3();\r\n\r\n\t\treturn function intersectTriangle( a, b, c, backfaceCulling, target ) {\r\n\r\n\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\r\n\r\n\t\t\tedge1.subVectors( b, a );\r\n\t\t\tedge2.subVectors( c, a );\r\n\t\t\tnormal.crossVectors( edge1, edge2 );\r\n\r\n\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\r\n\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\r\n\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\r\n\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\r\n\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\r\n\t\t\tvar DdN = this.direction.dot( normal );\r\n\t\t\tvar sign;\r\n\r\n\t\t\tif ( DdN > 0 ) {\r\n\r\n\t\t\t\tif ( backfaceCulling ) return null;\r\n\t\t\t\tsign = 1;\r\n\r\n\t\t\t} else if ( DdN < 0 ) {\r\n\r\n\t\t\t\tsign = - 1;\r\n\t\t\t\tDdN = - DdN;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdiff.subVectors( this.origin, a );\r\n\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\r\n\r\n\t\t\t// b1 < 0, no intersection\r\n\t\t\tif ( DdQxE2 < 0 ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\r\n\r\n\t\t\t// b2 < 0, no intersection\r\n\t\t\tif ( DdE1xQ < 0 ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// b1+b2 > 1, no intersection\r\n\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Line intersects triangle, check if ray does.\r\n\t\t\tvar QdN = - sign * diff.dot( normal );\r\n\r\n\t\t\t// t < 0, no intersection\r\n\t\t\tif ( QdN < 0 ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Ray intersects triangle.\r\n\t\t\treturn this.at( QdN / DdN, target );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyMatrix4: function ( matrix4 ) {\r\n\r\n\t\tthis.origin.applyMatrix4( matrix4 );\r\n\t\tthis.direction.transformDirection( matrix4 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( ray ) {\r\n\r\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/math/Triangle.js\n\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nfunction Triangle( a, b, c ) {\r\n\r\n\tthis.a = ( a !== undefined ) ? a : new Vector3();\r\n\tthis.b = ( b !== undefined ) ? b : new Vector3();\r\n\tthis.c = ( c !== undefined ) ? c : new Vector3();\r\n\r\n}\r\n\r\nObject.assign( Triangle, {\r\n\r\n\tgetNormal: function () {\r\n\r\n\t\tvar v0 = new Vector3();\r\n\r\n\t\treturn function getNormal( a, b, c, target ) {\r\n\r\n\t\t\tif ( target === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'COOL.Triangle: .getNormal() target is now required' );\r\n\t\t\t\ttarget = new Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttarget.subVectors( c, b );\r\n\t\t\tv0.subVectors( a, b );\r\n\t\t\ttarget.cross( v0 );\r\n\r\n\t\t\tvar targetLengthSq = target.lengthSq();\r\n\t\t\tif ( targetLengthSq > 0 ) {\r\n\r\n\t\t\t\treturn target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn target.set( 0, 0, 0 );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\t// static/instance method to calculate barycentric coordinates\r\n\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\r\n\tgetBarycoord: function () {\r\n\r\n\t\tvar v0 = new Vector3();\r\n\t\tvar v1 = new Vector3();\r\n\t\tvar v2 = new Vector3();\r\n\r\n\t\treturn function getBarycoord( point, a, b, c, target ) {\r\n\r\n\t\t\tv0.subVectors( c, a );\r\n\t\t\tv1.subVectors( b, a );\r\n\t\t\tv2.subVectors( point, a );\r\n\r\n\t\t\tvar dot00 = v0.dot( v0 );\r\n\t\t\tvar dot01 = v0.dot( v1 );\r\n\t\t\tvar dot02 = v0.dot( v2 );\r\n\t\t\tvar dot11 = v1.dot( v1 );\r\n\t\t\tvar dot12 = v1.dot( v2 );\r\n\r\n\t\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\r\n\r\n\t\t\tif ( target === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'COOL.Triangle: .getBarycoord() target is now required' );\r\n\t\t\t\ttarget = new Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// collinear or singular triangle\r\n\t\t\tif ( denom === 0 ) {\r\n\r\n\t\t\t\t// arbitrary location outside of triangle?\r\n\t\t\t\t// not sure if this is the best idea, maybe should be returning undefined\r\n\t\t\t\treturn target.set( - 2, - 1, - 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar invDenom = 1 / denom;\r\n\t\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\r\n\t\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\r\n\r\n\t\t\t// barycentric coordinates must always sum to 1\r\n\t\t\treturn target.set( 1 - u - v, v, u );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcontainsPoint: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function containsPoint( point, a, b, c ) {\r\n\r\n\t\t\tTriangle.getBarycoord( point, a, b, c, v1 );\r\n\r\n\t\t\treturn ( v1.x >= 0 ) && ( v1.y >= 0 ) && ( ( v1.x + v1.y ) <= 1 );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetUV: function () {\r\n\r\n\t\tvar barycoord = new Vector3();\r\n\r\n\t\treturn function getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {\r\n\r\n\t\t\tthis.getBarycoord( point, p1, p2, p3, barycoord );\r\n\r\n\t\t\ttarget.set( 0, 0 );\r\n\t\t\ttarget.addScaledVector( uv1, barycoord.x );\r\n\t\t\ttarget.addScaledVector( uv2, barycoord.y );\r\n\t\t\ttarget.addScaledVector( uv3, barycoord.z );\r\n\r\n\t\t\treturn target;\r\n\r\n\t\t};\r\n\r\n\t}()\r\n\r\n} );\r\n\r\nObject.assign( Triangle.prototype, {\r\n\r\n\tset: function ( a, b, c ) {\r\n\r\n\t\tthis.a.copy( a );\r\n\t\tthis.b.copy( b );\r\n\t\tthis.c.copy( c );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\r\n\r\n\t\tthis.a.copy( points[ i0 ] );\r\n\t\tthis.b.copy( points[ i1 ] );\r\n\t\tthis.c.copy( points[ i2 ] );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( triangle ) {\r\n\r\n\t\tthis.a.copy( triangle.a );\r\n\t\tthis.b.copy( triangle.b );\r\n\t\tthis.c.copy( triangle.c );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetArea: function () {\r\n\r\n\t\tvar v0 = new Vector3();\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function getArea() {\r\n\r\n\t\t\tv0.subVectors( this.c, this.b );\r\n\t\t\tv1.subVectors( this.a, this.b );\r\n\r\n\t\t\treturn v0.cross( v1 ).length() * 0.5;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetMidpoint: function ( target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Triangle: .getMidpoint() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\treturn target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\r\n\r\n\t},\r\n\r\n\tgetNormal: function ( target ) {\r\n\r\n\t\treturn Triangle.getNormal( this.a, this.b, this.c, target );\r\n\r\n\t},\r\n\r\n\tgetPlane: function ( target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Triangle: .getPlane() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\treturn target.setFromCoplanarPoints( this.a, this.b, this.c );\r\n\r\n\t},\r\n\r\n\tgetBarycoord: function ( point, target ) {\r\n\r\n\t\treturn Triangle.getBarycoord( point, this.a, this.b, this.c, target );\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\r\n\r\n\t},\r\n\r\n\tgetUV: function ( point, uv1, uv2, uv3, result ) {\r\n\r\n\t\treturn Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, result );\r\n\r\n\t},\r\n\r\n\tintersectsBox: function ( box ) {\r\n\r\n\t\treturn box.intersectsTriangle( this );\r\n\r\n\t},\r\n\r\n\tclosestPointToPoint: function () {\r\n\r\n\t\tvar vab = new Vector3();\r\n\t\tvar vac = new Vector3();\r\n\t\tvar vbc = new Vector3();\r\n\t\tvar vap = new Vector3();\r\n\t\tvar vbp = new Vector3();\r\n\t\tvar vcp = new Vector3();\r\n\r\n\t\treturn function closestPointToPoint( p, target ) {\r\n\r\n\t\t\tif ( target === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'COOL.Triangle: .closestPointToPoint() target is now required' );\r\n\t\t\t\ttarget = new Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar a = this.a, b = this.b, c = this.c;\r\n\t\t\tvar v, w;\r\n\r\n\t\t\t// algorithm thanks to Real-Time Collision Detection by Christer Ericson,\r\n\t\t\t// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,\r\n\t\t\t// under the accompanying license; see chapter 5.1.5 for detailed explanation.\r\n\t\t\t// basically, we're distinguishing which of the voronoi regions of the triangle\r\n\t\t\t// the point lies in with the minimum amount of redundant computation.\r\n\r\n\t\t\tvab.subVectors( b, a );\r\n\t\t\tvac.subVectors( c, a );\r\n\t\t\tvap.subVectors( p, a );\r\n\t\t\tvar d1 = vab.dot( vap );\r\n\t\t\tvar d2 = vac.dot( vap );\r\n\t\t\tif ( d1 <= 0 && d2 <= 0 ) {\r\n\r\n\t\t\t\t// vertex region of A; barycentric coords (1, 0, 0)\r\n\t\t\t\treturn target.copy( a );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvbp.subVectors( p, b );\r\n\t\t\tvar d3 = vab.dot( vbp );\r\n\t\t\tvar d4 = vac.dot( vbp );\r\n\t\t\tif ( d3 >= 0 && d4 <= d3 ) {\r\n\r\n\t\t\t\t// vertex region of B; barycentric coords (0, 1, 0)\r\n\t\t\t\treturn target.copy( b );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar vc = d1 * d4 - d3 * d2;\r\n\t\t\tif ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {\r\n\r\n\t\t\t\tv = d1 / ( d1 - d3 );\r\n\t\t\t\t// edge region of AB; barycentric coords (1-v, v, 0)\r\n\t\t\t\treturn target.copy( a ).addScaledVector( vab, v );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvcp.subVectors( p, c );\r\n\t\t\tvar d5 = vab.dot( vcp );\r\n\t\t\tvar d6 = vac.dot( vcp );\r\n\t\t\tif ( d6 >= 0 && d5 <= d6 ) {\r\n\r\n\t\t\t\t// vertex region of C; barycentric coords (0, 0, 1)\r\n\t\t\t\treturn target.copy( c );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar vb = d5 * d2 - d1 * d6;\r\n\t\t\tif ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {\r\n\r\n\t\t\t\tw = d2 / ( d2 - d6 );\r\n\t\t\t\t// edge region of AC; barycentric coords (1-w, 0, w)\r\n\t\t\t\treturn target.copy( a ).addScaledVector( vac, w );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar va = d3 * d6 - d5 * d4;\r\n\t\t\tif ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {\r\n\r\n\t\t\t\tvbc.subVectors( c, b );\r\n\t\t\t\tw = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );\r\n\t\t\t\t// edge region of BC; barycentric coords (0, 1-w, w)\r\n\t\t\t\treturn target.copy( b ).addScaledVector( vbc, w ); // edge region of BC\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// face region\r\n\t\t\tvar denom = 1 / ( va + vb + vc );\r\n\t\t\t// u = va * denom\r\n\t\t\tv = vb * denom;\r\n\t\t\tw = vc * denom;\r\n\t\t\treturn target.copy( a ).addScaledVector( vab, v ).addScaledVector( vac, w );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tequals: function ( triangle ) {\r\n\r\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/math/Color.js\n\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nvar ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\r\n\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\r\n\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\r\n\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\r\n\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\r\n\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\r\n\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\r\n\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\r\n\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\r\n\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\r\n\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\r\n\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\r\n\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\r\n\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\r\n\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\r\n\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\r\n\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\r\n\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\r\n\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\r\n\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\r\n\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\r\n\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\r\n\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\r\n\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\r\n\r\nfunction Color( r, g, b ) {\r\n\r\n\tif ( g === undefined && b === undefined ) {\r\n\r\n\t\t// r is COOL.Color, hex or string\r\n\t\treturn this.set( r );\r\n\r\n\t}\r\n\r\n\treturn this.setRGB( r, g, b );\r\n\r\n}\r\n\r\nObject.assign( Color.prototype, {\r\n\r\n\tisColor: true,\r\n\r\n\tr: 1, g: 1, b: 1,\r\n\r\n\tset: function ( value ) {\r\n\r\n\t\tif ( value && value.isColor ) {\r\n\r\n\t\t\tthis.copy( value );\r\n\r\n\t\t} else if ( typeof value === 'number' ) {\r\n\r\n\t\t\tthis.setHex( value );\r\n\r\n\t\t} else if ( typeof value === 'string' ) {\r\n\r\n\t\t\tthis.setStyle( value );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetScalar: function ( scalar ) {\r\n\r\n\t\tthis.r = scalar;\r\n\t\tthis.g = scalar;\r\n\t\tthis.b = scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetHex: function ( hex ) {\r\n\r\n\t\thex = Math.floor( hex );\r\n\r\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\r\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\r\n\t\tthis.b = ( hex & 255 ) / 255;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetRGB: function ( r, g, b ) {\r\n\r\n\t\tthis.r = r;\r\n\t\tthis.g = g;\r\n\t\tthis.b = b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetHSL: function () {\r\n\r\n\t\tfunction hue2rgb( p, q, t ) {\r\n\r\n\t\t\tif ( t < 0 ) t += 1;\r\n\t\t\tif ( t > 1 ) t -= 1;\r\n\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\r\n\t\t\tif ( t < 1 / 2 ) return q;\r\n\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\r\n\t\t\treturn p;\r\n\r\n\t\t}\r\n\r\n\t\treturn function setHSL( h, s, l ) {\r\n\r\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\t\t\th = _Math.euclideanModulo( h, 1 );\r\n\t\t\ts = _Math.clamp( s, 0, 1 );\r\n\t\t\tl = _Math.clamp( l, 0, 1 );\r\n\r\n\t\t\tif ( s === 0 ) {\r\n\r\n\t\t\t\tthis.r = this.g = this.b = l;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\r\n\t\t\t\tvar q = ( 2 * l ) - p;\r\n\r\n\t\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\r\n\t\t\t\tthis.g = hue2rgb( q, p, h );\r\n\t\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetStyle: function ( style ) {\r\n\r\n\t\tfunction handleAlpha( string ) {\r\n\r\n\t\t\tif ( string === undefined ) return;\r\n\r\n\t\t\tif ( parseFloat( string ) < 1 ) {\r\n\r\n\t\t\t\tconsole.warn( 'COOL.Color: Alpha component of ' + style + ' will be ignored.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\tvar m;\r\n\r\n\t\tif ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\r\n\r\n\t\t\t// rgb / hsl\r\n\r\n\t\t\tvar color;\r\n\t\t\tvar name = m[ 1 ];\r\n\t\t\tvar components = m[ 2 ];\r\n\r\n\t\t\tswitch ( name ) {\r\n\r\n\t\t\t\tcase 'rgb':\r\n\t\t\t\tcase 'rgba':\r\n\r\n\t\t\t\t\tif ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\r\n\r\n\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\r\n\t\t\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\r\n\t\t\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\r\n\t\t\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\r\n\r\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\r\n\r\n\t\t\t\t\t\treturn this;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\r\n\r\n\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\r\n\t\t\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\r\n\t\t\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\r\n\t\t\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\r\n\r\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\r\n\r\n\t\t\t\t\t\treturn this;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'hsl':\r\n\t\t\t\tcase 'hsla':\r\n\r\n\t\t\t\t\tif ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\r\n\r\n\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\r\n\t\t\t\t\t\tvar h = parseFloat( color[ 1 ] ) / 360;\r\n\t\t\t\t\t\tvar s = parseInt( color[ 2 ], 10 ) / 100;\r\n\t\t\t\t\t\tvar l = parseInt( color[ 3 ], 10 ) / 100;\r\n\r\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\r\n\r\n\t\t\t\t\t\treturn this.setHSL( h, s, l );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\r\n\r\n\t\t\t// hex color\r\n\r\n\t\t\tvar hex = m[ 1 ];\r\n\t\t\tvar size = hex.length;\r\n\r\n\t\t\tif ( size === 3 ) {\r\n\r\n\t\t\t\t// #ff0\r\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\r\n\t\t\t\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\r\n\t\t\t\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\r\n\r\n\t\t\t\treturn this;\r\n\r\n\t\t\t} else if ( size === 6 ) {\r\n\r\n\t\t\t\t// #ff0000\r\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\r\n\t\t\t\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\r\n\t\t\t\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\r\n\r\n\t\t\t\treturn this;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( style && style.length > 0 ) {\r\n\r\n\t\t\t// color keywords\r\n\t\t\tvar hex = ColorKeywords[ style ];\r\n\r\n\t\t\tif ( hex !== undefined ) {\r\n\r\n\t\t\t\t// red\r\n\t\t\t\tthis.setHex( hex );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// unknown color\r\n\t\t\t\tconsole.warn( 'COOL.Color: Unknown color ' + style );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.r, this.g, this.b );\r\n\r\n\t},\r\n\r\n\tcopy: function ( color ) {\r\n\r\n\t\tthis.r = color.r;\r\n\t\tthis.g = color.g;\r\n\t\tthis.b = color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyGammaToLinear: function ( color, gammaFactor ) {\r\n\r\n\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\r\n\r\n\t\tthis.r = Math.pow( color.r, gammaFactor );\r\n\t\tthis.g = Math.pow( color.g, gammaFactor );\r\n\t\tthis.b = Math.pow( color.b, gammaFactor );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyLinearToGamma: function ( color, gammaFactor ) {\r\n\r\n\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\r\n\r\n\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\r\n\r\n\t\tthis.r = Math.pow( color.r, safeInverse );\r\n\t\tthis.g = Math.pow( color.g, safeInverse );\r\n\t\tthis.b = Math.pow( color.b, safeInverse );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconvertGammaToLinear: function ( gammaFactor ) {\r\n\r\n\t\tthis.copyGammaToLinear( this, gammaFactor );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconvertLinearToGamma: function ( gammaFactor ) {\r\n\r\n\t\tthis.copyLinearToGamma( this, gammaFactor );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopySRGBToLinear: function () {\r\n\r\n\t\tfunction SRGBToLinear( c ) {\r\n\r\n\t\t\treturn ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\r\n\r\n\t\t}\r\n\r\n\t\treturn function copySRGBToLinear( color ) {\r\n\r\n\t\t\tthis.r = SRGBToLinear( color.r );\r\n\t\t\tthis.g = SRGBToLinear( color.g );\r\n\t\t\tthis.b = SRGBToLinear( color.b );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcopyLinearToSRGB: function () {\r\n\r\n\t\tfunction LinearToSRGB( c ) {\r\n\r\n\t\t\treturn ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;\r\n\r\n\t\t}\r\n\r\n\t\treturn function copyLinearToSRGB( color ) {\r\n\r\n\t\t\tthis.r = LinearToSRGB( color.r );\r\n\t\t\tthis.g = LinearToSRGB( color.g );\r\n\t\t\tthis.b = LinearToSRGB( color.b );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tconvertSRGBToLinear: function () {\r\n\r\n\t\tthis.copySRGBToLinear( this );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconvertLinearToSRGB: function () {\r\n\r\n\t\tthis.copyLinearToSRGB( this );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetHex: function () {\r\n\r\n\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\r\n\r\n\t},\r\n\r\n\tgetHexString: function () {\r\n\r\n\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\r\n\r\n\t},\r\n\r\n\tgetHSL: function ( target ) {\r\n\r\n\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Color: .getHSL() target is now required' );\r\n\t\t\ttarget = { h: 0, s: 0, l: 0 };\r\n\r\n\t\t}\r\n\r\n\t\tvar r = this.r, g = this.g, b = this.b;\r\n\r\n\t\tvar max = Math.max( r, g, b );\r\n\t\tvar min = Math.min( r, g, b );\r\n\r\n\t\tvar hue, saturation;\r\n\t\tvar lightness = ( min + max ) / 2.0;\r\n\r\n\t\tif ( min === max ) {\r\n\r\n\t\t\thue = 0;\r\n\t\t\tsaturation = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar delta = max - min;\r\n\r\n\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\r\n\r\n\t\t\tswitch ( max ) {\r\n\r\n\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\r\n\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\r\n\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\r\n\r\n\t\t\t}\r\n\r\n\t\t\thue /= 6;\r\n\r\n\t\t}\r\n\r\n\t\ttarget.h = hue;\r\n\t\ttarget.s = saturation;\r\n\t\ttarget.l = lightness;\r\n\r\n\t\treturn target;\r\n\r\n\t},\r\n\r\n\tgetStyle: function () {\r\n\r\n\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\r\n\r\n\t},\r\n\r\n\toffsetHSL: function () {\r\n\r\n\t\tvar hsl = {};\r\n\r\n\t\treturn function ( h, s, l ) {\r\n\r\n\t\t\tthis.getHSL( hsl );\r\n\r\n\t\t\thsl.h += h; hsl.s += s; hsl.l += l;\r\n\r\n\t\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tadd: function ( color ) {\r\n\r\n\t\tthis.r += color.r;\r\n\t\tthis.g += color.g;\r\n\t\tthis.b += color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddColors: function ( color1, color2 ) {\r\n\r\n\t\tthis.r = color1.r + color2.r;\r\n\t\tthis.g = color1.g + color2.g;\r\n\t\tthis.b = color1.b + color2.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.r += s;\r\n\t\tthis.g += s;\r\n\t\tthis.b += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( color ) {\r\n\r\n\t\tthis.r = Math.max( 0, this.r - color.r );\r\n\t\tthis.g = Math.max( 0, this.g - color.g );\r\n\t\tthis.b = Math.max( 0, this.b - color.b );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( color ) {\r\n\r\n\t\tthis.r *= color.r;\r\n\t\tthis.g *= color.g;\r\n\t\tthis.b *= color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tthis.r *= s;\r\n\t\tthis.g *= s;\r\n\t\tthis.b *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerp: function ( color, alpha ) {\r\n\r\n\t\tthis.r += ( color.r - this.r ) * alpha;\r\n\t\tthis.g += ( color.g - this.g ) * alpha;\r\n\t\tthis.b += ( color.b - this.b ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerpHSL: function () {\r\n\r\n\t\tvar hslA = { h: 0, s: 0, l: 0 };\r\n\t\tvar hslB = { h: 0, s: 0, l: 0 };\r\n\r\n\t\treturn function lerpHSL( color, alpha ) {\r\n\r\n\t\t\tthis.getHSL( hslA );\r\n\t\t\tcolor.getHSL( hslB );\r\n\r\n\t\t\tvar h = _Math.lerp( hslA.h, hslB.h, alpha );\r\n\t\t\tvar s = _Math.lerp( hslA.s, hslB.s, alpha );\r\n\t\t\tvar l = _Math.lerp( hslA.l, hslB.l, alpha );\r\n\r\n\t\t\tthis.setHSL( h, s, l );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tequals: function ( c ) {\r\n\r\n\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.r = array[ offset ];\r\n\t\tthis.g = array[ offset + 1 ];\r\n\t\tthis.b = array[ offset + 2 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this.r;\r\n\t\tarray[ offset + 1 ] = this.g;\r\n\t\tarray[ offset + 2 ] = this.b;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\treturn this.getHex();\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/core/Face3.js\n\r\n\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nfunction Face3( a, b, c, normal, color, materialIndex ) {\r\n\r\n\tthis.a = a;\r\n\tthis.b = b;\r\n\tthis.c = c;\r\n\r\n\tthis.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();\r\n\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\r\n\r\n\tthis.color = ( color && color.isColor ) ? color : new Color();\r\n\tthis.vertexColors = Array.isArray( color ) ? color : [];\r\n\r\n\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\r\n\r\n}\r\n\r\nObject.assign( Face3.prototype, {\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.a = source.a;\r\n\t\tthis.b = source.b;\r\n\t\tthis.c = source.c;\r\n\r\n\t\tthis.normal.copy( source.normal );\r\n\t\tthis.color.copy( source.color );\r\n\r\n\t\tthis.materialIndex = source.materialIndex;\r\n\r\n\t\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/core/Mesh.js\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass Mesh_Mesh {\r\n    constructor(param) {\r\n        this.type = 'Mesh';\r\n        param = param || {};\r\n        this.geometry = param.geometry;\r\n        this.material = param.material || new material_Material();\r\n\r\n        this.position = param.position || [0,0,0];\r\n        this.rotation = param.rotation || new Euler();\r\n        this.scale = param.scale || [1,1,1];\r\n\r\n        this.quaternion = new Quaternion().setFromEuler( this.rotation, false );\r\n\r\n        this.children = [];\r\n        this.parent = null;\r\n\r\n        this.matrix = new Matrix4();\r\n        this.matrixWorld = new Matrix4();\r\n        this.updateMatrix();\r\n\r\n    }\r\n\r\n    setPosition(position){\r\n        this.position = position;\r\n        this.updateMatrix();\r\n    }\r\n\r\n    setRotation(rotationArray){\r\n        this.rotation = new Euler().fromArray(rotationArray);\r\n        var quaternion = new Quaternion().setFromEuler( this.rotation, false );\r\n        this.setQuaternion(quaternion);\r\n    }\r\n\r\n    setQuaternion(quaternion){\r\n\r\n        this.quaternion = quaternion;\r\n        this.rotation.setFromQuaternion( quaternion, undefined, false );\r\n        this.updateMatrix();\r\n    }\r\n\r\n    setScale(scaleArray){\r\n        this.scale = scaleArray;\r\n        this.updateMatrix();\r\n    }\r\n\r\n    updateMatrix(){\r\n        this.matrix.compose( new Vector3().fromArray(this.position), this.quaternion, new Vector3().fromArray(this.scale) );\r\n        this.updateMatrixWorld ();\r\n    }\r\n\r\n    setMatrix(matrix){\r\n        this.matrix = matrix;\r\n        this.updateMatrixWorld ();\r\n    }\r\n\r\n    updateMatrixWorld () {\r\n\r\n        // this.updateMatrix();\r\n\r\n        if ( this.parent === null ) {\r\n\r\n            this.matrixWorld = this.matrix.clone();\r\n\r\n        } else {\r\n\r\n            this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n        }\r\n\r\n        this.updateChildrenMatrixWorld();\r\n\r\n    }\r\n\r\n    getWorldPosition() {\r\n\r\n        var target = new Vector3();\r\n\r\n        // this.updateMatrixWorld();\r\n\r\n        return target.setFromMatrixPosition( this.matrixWorld );\r\n\r\n    }\r\n\r\n    updateChildrenMatrixWorld(){\r\n\r\n        for(var i in this.children){\r\n            this.children[i].updateMatrixWorld();\r\n        }\r\n\r\n    }\r\n\r\n    clone(){\r\n        var mesh = new Mesh_Mesh({\r\n            geometry: this.geometry.clone(),\r\n            material: this.material.clone(),\r\n            position: this.position.slice(0),\r\n            rotation: this.rotation.clone(),\r\n            scale: this.scale.slice(0)\r\n        });\r\n\r\n        return mesh;\r\n    }\r\n\r\n    add(mesh){\r\n        this.children.push(mesh);\r\n        mesh.parent = this;\r\n        mesh.updateMatrix();\r\n    }\r\n\r\n    rotateOnAxis (axis, angle) {\r\n\r\n        var q1 = new Quaternion();\r\n        q1.setFromAxisAngle( axis, angle );\r\n        var quaternion = this.quaternion.multiply( q1 );\r\n        this.setQuaternion(quaternion);\r\n\r\n    }\r\n\r\n    rotateX (angle) {\r\n\r\n        this.rotateOnAxis( new Vector3(1,0,0), angle );\r\n\r\n    }\r\n\r\n    rotateY (angle) {\r\n\r\n        this.rotateOnAxis( new Vector3(0,1,0), angle );\r\n\r\n    }\r\n\r\n    rotateZ (angle) {\r\n\r\n        this.rotateOnAxis( new Vector3(0,0,1), angle );\r\n\r\n    }\r\n\r\n\r\n\r\n    raycast( raycaster, intersects ) {\r\n\r\n        var that = this;\r\n\r\n        var inverseMatrix = new Matrix4();\r\n        var ray = new Ray();\r\n        var sphere = new Sphere();\r\n\r\n        var vA = new Vector3();\r\n        var vB = new Vector3();\r\n        var vC = new Vector3();\r\n\r\n        var tempA = new Vector3();\r\n        var tempB = new Vector3();\r\n        var tempC = new Vector3();\r\n\r\n        var uvA = new Vector2();\r\n        var uvB = new Vector2();\r\n        var uvC = new Vector2();\r\n\r\n        var intersectionPoint = new Vector3();\r\n        var intersectionPointWorld = new Vector3();\r\n\r\n        function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {\r\n\r\n            var intersect;\r\n\r\n            if ( material.side === BackSide ) {\r\n\r\n                intersect = ray.intersectTriangle( pC, pB, pA, true, point );\r\n\r\n            } else {\r\n\r\n                intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );\r\n\r\n            }\r\n\r\n            if ( intersect === null ) return null;\r\n\r\n            intersectionPointWorld.copy( point );\r\n            intersectionPointWorld.applyMatrix4( object.matrixWorld );\r\n\r\n            var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\r\n\r\n            if ( distance < raycaster.near || distance > raycaster.far ) return null;\r\n\r\n            return {\r\n                distance: distance,\r\n                point: intersectionPointWorld.clone(),\r\n                object: object\r\n            };\r\n\r\n        }\r\n\r\n        function checkBufferGeometryIntersection( object, material, raycaster, ray, position, uv, a, b, c ) {\r\n\r\n            vA.fromBufferAttribute( position, a );\r\n            vB.fromBufferAttribute( position, b );\r\n            vC.fromBufferAttribute( position, c );\r\n\r\n            var intersection = checkIntersection( object, material, raycaster, ray, vA, vB, vC, intersectionPoint );\r\n\r\n            if ( intersection ) {\r\n\r\n                if ( uv ) {\r\n\r\n                    uvA.fromBufferAttribute( uv, a );\r\n                    uvB.fromBufferAttribute( uv, b );\r\n                    uvC.fromBufferAttribute( uv, c );\r\n\r\n                    intersection.uv = Triangle.getUV( intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2() );\r\n\r\n                }\r\n\r\n                var face = new Face3( a, b, c );\r\n                Triangle.getNormal( vA, vB, vC, face.normal );\r\n\r\n                intersection.face = face;\r\n\r\n            }\r\n\r\n            return intersection;\r\n\r\n        }\r\n\r\n        var geometry = this.geometry;\r\n        var material = this.material;\r\n        var matrixWorld = this.matrixWorld;\r\n\r\n        if ( material === undefined ) return;\r\n\r\n        // Checking boundingSphere distance to ray\r\n\r\n        if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n        sphere.copy( geometry.boundingSphere );\r\n        sphere.applyMatrix4( matrixWorld );\r\n\r\n        var box3 = new Box3().copy(geometry.boundingBox);\r\n        box3.applyMatrix4( matrixWorld );\r\n\r\n        // raycaster.ray.intersectsSphere( sphere ) ||\r\n        if ( raycaster.ray.intersectsBox( box3 ) ) {\r\n            var worldPosition = new Vector3().setFromMatrixPosition( this.matrixWorld );\r\n            that.distance = raycaster.ray.origin.distanceTo( worldPosition );\r\n            intersects.push(that);\r\n        }\r\n\r\n        //\r\n        // inverseMatrix.getInverse( matrixWorld );\r\n        // ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n        //\r\n        // // Check boundingBox before continuing\r\n        //\r\n        // if ( geometry.boundingBox !== null ) {\r\n        //\r\n        //     if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\r\n        //\r\n        // }\r\n        //\r\n        // var intersection;\r\n        //\r\n        // if ( geometry.isBufferGeometry ) {\r\n        //\r\n        //     var a, b, c;\r\n        //     var index = geometry.index;\r\n        //     var position = geometry.attributes.position;\r\n        //     var uv = geometry.attributes.uv;\r\n        //     var groups = geometry.groups;\r\n        //     var drawRange = geometry.drawRange;\r\n        //     var i, j, il, jl;\r\n        //     var group, groupMaterial;\r\n        //     var start, end;\r\n        //\r\n        //     if ( index !== null ) {\r\n        //\r\n        //         // indexed buffer geometry\r\n        //\r\n        //         if ( Array.isArray( material ) ) {\r\n        //\r\n        //             for ( i = 0, il = groups.length; i < il; i ++ ) {\r\n        //\r\n        //                 group = groups[ i ];\r\n        //                 groupMaterial = material[ group.materialIndex ];\r\n        //\r\n        //                 start = Math.max( group.start, drawRange.start );\r\n        //                 end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\r\n        //\r\n        //                 for ( j = start, jl = end; j < jl; j += 3 ) {\r\n        //\r\n        //                     a = index.getX( j );\r\n        //                     b = index.getX( j + 1 );\r\n        //                     c = index.getX( j + 2 );\r\n        //\r\n        //                     intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, ray, position, uv, a, b, c );\r\n        //\r\n        //                     if ( intersection ) {\r\n        //\r\n        //                         intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics\r\n        //                         intersects.push( intersection );\r\n        //\r\n        //                     }\r\n        //\r\n        //                 }\r\n        //\r\n        //             }\r\n        //\r\n        //         } else {\r\n        //\r\n        //             start = Math.max( 0, drawRange.start );\r\n        //             end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\r\n        //\r\n        //             for ( i = start, il = end; i < il; i += 3 ) {\r\n        //\r\n        //                 a = index.getX( i );\r\n        //                 b = index.getX( i + 1 );\r\n        //                 c = index.getX( i + 2 );\r\n        //\r\n        //                 intersection = checkBufferGeometryIntersection( this, material, raycaster, ray, position, uv, a, b, c );\r\n        //\r\n        //                 if ( intersection ) {\r\n        //\r\n        //                     intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics\r\n        //                     intersects.push( intersection );\r\n        //\r\n        //                 }\r\n        //\r\n        //             }\r\n        //\r\n        //         }\r\n        //\r\n        //     } else if ( position !== undefined ) {\r\n        //\r\n        //         // non-indexed buffer geometry\r\n        //\r\n        //         if ( Array.isArray( material ) ) {\r\n        //\r\n        //             for ( i = 0, il = groups.length; i < il; i ++ ) {\r\n        //\r\n        //                 group = groups[ i ];\r\n        //                 groupMaterial = material[ group.materialIndex ];\r\n        //\r\n        //                 start = Math.max( group.start, drawRange.start );\r\n        //                 end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\r\n        //\r\n        //                 for ( j = start, jl = end; j < jl; j += 3 ) {\r\n        //\r\n        //                     a = j;\r\n        //                     b = j + 1;\r\n        //                     c = j + 2;\r\n        //\r\n        //                     intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, ray, position, uv, a, b, c );\r\n        //\r\n        //                     if ( intersection ) {\r\n        //\r\n        //                         intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics\r\n        //                         intersects.push( intersection );\r\n        //\r\n        //                     }\r\n        //\r\n        //                 }\r\n        //\r\n        //             }\r\n        //\r\n        //         } else {\r\n        //\r\n        //             start = Math.max( 0, drawRange.start );\r\n        //             end = Math.min( position.count, ( drawRange.start + drawRange.count ) );\r\n        //\r\n        //             for ( i = start, il = end; i < il; i += 3 ) {\r\n        //\r\n        //                 a = i;\r\n        //                 b = i + 1;\r\n        //                 c = i + 2;\r\n        //\r\n        //                 intersection = checkBufferGeometryIntersection( this, material, raycaster, ray, position, uv, a, b, c );\r\n        //\r\n        //                 if ( intersection ) {\r\n        //\r\n        //                     intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics\r\n        //                     intersects.push( intersection );\r\n        //\r\n        //                 }\r\n        //\r\n        //             }\r\n        //\r\n        //         }\r\n        //\r\n        //     }\r\n        //\r\n        // } else if ( geometry.isGeometry ) {\r\n        //\r\n        //     var fvA, fvB, fvC;\r\n        //     var isMultiMaterial = Array.isArray( material );\r\n        //\r\n        //     var vertices = geometry.vertices;\r\n        //     var faces = geometry.faces;\r\n        //     var uvs;\r\n        //\r\n        //     var faceVertexUvs = geometry.faceVertexUvs[ 0 ];\r\n        //     if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\r\n        //\r\n        //     for ( var f = 0, fl = faces.length; f < fl; f ++ ) {\r\n        //\r\n        //         var face = faces[ f ];\r\n        //         var faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;\r\n        //\r\n        //         if ( faceMaterial === undefined ) continue;\r\n        //\r\n        //         fvA = vertices[ face.a ];\r\n        //         fvB = vertices[ face.b ];\r\n        //         fvC = vertices[ face.c ];\r\n        //\r\n        //         if ( faceMaterial.morphTargets === true ) {\r\n        //\r\n        //             var morphTargets = geometry.morphTargets;\r\n        //             var morphInfluences = this.morphTargetInfluences;\r\n        //\r\n        //             vA.set( 0, 0, 0 );\r\n        //             vB.set( 0, 0, 0 );\r\n        //             vC.set( 0, 0, 0 );\r\n        //\r\n        //             for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\r\n        //\r\n        //                 var influence = morphInfluences[ t ];\r\n        //\r\n        //                 if ( influence === 0 ) continue;\r\n        //\r\n        //                 var targets = morphTargets[ t ].vertices;\r\n        //\r\n        //                 vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\r\n        //                 vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\r\n        //                 vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\r\n        //\r\n        //             }\r\n        //\r\n        //             vA.add( fvA );\r\n        //             vB.add( fvB );\r\n        //             vC.add( fvC );\r\n        //\r\n        //             fvA = vA;\r\n        //             fvB = vB;\r\n        //             fvC = vC;\r\n        //\r\n        //         }\r\n        //\r\n        //         intersection = checkIntersection( this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\r\n        //\r\n        //         if ( intersection ) {\r\n        //\r\n        //             if ( uvs && uvs[ f ] ) {\r\n        //\r\n        //                 var uvs_f = uvs[ f ];\r\n        //                 uvA.copy( uvs_f[ 0 ] );\r\n        //                 uvB.copy( uvs_f[ 1 ] );\r\n        //                 uvC.copy( uvs_f[ 2 ] );\r\n        //\r\n        //                 intersection.uv = Triangle.getUV( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC, new Vector2() );\r\n        //\r\n        //             }\r\n        //\r\n        //             intersection.face = face;\r\n        //             intersection.faceIndex = f;\r\n        //             intersects.push( intersection );\r\n        //\r\n        //         }\r\n        //\r\n        //     }\r\n        //\r\n        // }\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n/* harmony default export */ var core_Mesh = (Mesh_Mesh);\r\n\n// CONCATENATED MODULE: ./src/util/webgl-utils.js\n/*\r\n * Copyright 2010, Google Inc.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are\r\n * met:\r\n *\r\n *     * Redistributions of source code must retain the above copyright\r\n * notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above\r\n * copyright notice, this list of conditions and the following disclaimer\r\n * in the documentation and/or other materials provided with the\r\n * distribution.\r\n *     * Neither the name of Google Inc. nor the names of its\r\n * contributors may be used to endorse or promote products derived from\r\n * this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n\r\n/**\r\n * @fileoverview This file contains functions every webgl program will need\r\n * a version of one way or another.\r\n *\r\n * Instead of setting up a context manually it is recommended to\r\n * use. This will check for success or failure. On failure it\r\n * will attempt to present an approriate message to the user.\r\n *\r\n *       gl = WebGLUtils.setupWebGL(canvas);\r\n *\r\n * For animated WebGL apps use of setTimeout or setInterval are\r\n * discouraged. It is recommended you structure your rendering\r\n * loop like this.\r\n *\r\n *       function render() {\r\n *         window.requestAnimationFrame(render, canvas);\r\n *\r\n *         // do rendering\r\n *         ...\r\n *       }\r\n *       render();\r\n *\r\n * This will call your rendering function up to the refresh rate\r\n * of your display but will stop rendering if your app is not\r\n * visible.\r\n */\r\n\r\nvar WebGLUtils = function() {\r\n\r\n/**\r\n * Creates the HTLM for a failure message\r\n * @param {string} canvasContainerId id of container of th\r\n *        canvas.\r\n * @return {string} The html.\r\n */\r\nvar makeFailHTML = function(msg) {\r\n  return '' +\r\n        '<div style=\"margin: auto; width:500px;z-index:10000;margin-top:20em;text-align:center;\">' + msg + '</div>';\r\n  return '' +\r\n    '<table style=\"background-color: #8CE; width: 100%; height: 100%;\"><tr>' +\r\n    '<td align=\"center\">' +\r\n    '<div style=\"display: table-cell; vertical-align: middle;\">' +\r\n    '<div style=\"\">' + msg + '</div>' +\r\n    '</div>' +\r\n    '</td></tr></table>';\r\n};\r\n\r\n/**\r\n * Mesasge for getting a webgl browser\r\n * @type {string}\r\n */\r\nvar GET_A_WEBGL_BROWSER = '' +\r\n  'This page requires a browser that supports WebGL.<br/>' +\r\n  '<a href=\"http://get.webgl.org\">Click here to upgrade your browser.</a>';\r\n\r\n/**\r\n * Mesasge for need better hardware\r\n * @type {string}\r\n */\r\nvar OTHER_PROBLEM = '' +\r\n  \"It doesn't appear your computer can support WebGL.<br/>\" +\r\n  '<a href=\"http://get.webgl.org\">Click here for more information.</a>';\r\n\r\n/**\r\n * Creates a webgl context. If creation fails it will\r\n * change the contents of the container of the <canvas>\r\n * tag to an error message with the correct links for WebGL.\r\n * @param {Element} canvas. The canvas element to create a\r\n *     context from.\r\n * @param {WebGLContextCreationAttirbutes} opt_attribs Any\r\n *     creation attributes you want to pass in.\r\n * @param {function:(msg)} opt_onError An function to call\r\n *     if there is an error during creation.\r\n * @return {WebGLRenderingContext} The created context.\r\n */\r\nvar setupWebGL = function(canvas, opt_attribs, opt_onError) {\r\n  function handleCreationError(msg) {\r\n      var container = document.getElementsByTagName(\"body\")[0];\r\n    //var container = canvas.parentNode;\r\n    if (container) {\r\n      var str = window.WebGLRenderingContext ?\r\n           OTHER_PROBLEM :\r\n           GET_A_WEBGL_BROWSER;\r\n      if (msg) {\r\n        str += \"<br/><br/>Status: \" + msg;\r\n      }\r\n      container.innerHTML = makeFailHTML(str);\r\n    }\r\n  };\r\n\r\n  opt_onError = opt_onError || handleCreationError;\r\n\r\n  if (canvas.addEventListener) {\r\n    canvas.addEventListener(\"webglcontextcreationerror\", function(event) {\r\n          opt_onError(event.statusMessage);\r\n        }, false);\r\n  }\r\n  var context = create3DContext(canvas, opt_attribs);\r\n  if (!context) {\r\n    if (!window.WebGLRenderingContext) {\r\n      opt_onError(\"\");\r\n    } else {\r\n      opt_onError(\"\");\r\n    }\r\n  }\r\n\r\n  return context;\r\n};\r\n\r\n/**\r\n * Creates a webgl context.\r\n * @param {!Canvas} canvas The canvas tag to get context\r\n *     from. If one is not passed in one will be created.\r\n * @return {!WebGLContext} The created context.\r\n */\r\nvar create3DContext = function(canvas, opt_attribs) {\r\n  var names = [\"webgl\", \"experimental-webgl\", \"webkit-3d\", \"moz-webgl\"];\r\n  var context = null;\r\n  for (var ii = 0; ii < names.length; ++ii) {\r\n    try {\r\n      context = canvas.getContext(names[ii], opt_attribs);\r\n    } catch(e) {}\r\n    if (context) {\r\n      break;\r\n    }\r\n  }\r\n  return context;\r\n}\r\n\r\nreturn {\r\n  create3DContext: create3DContext,\r\n  setupWebGL: setupWebGL\r\n};\r\n}();\r\n\r\n/**\r\n * Provides requestAnimationFrame in a cross browser\r\n * way.\r\n */\r\nif (!window.requestAnimationFrame) {\r\n  window.requestAnimationFrame = (function() {\r\n    return window.requestAnimationFrame ||\r\n           window.webkitRequestAnimationFrame ||\r\n           window.mozRequestAnimationFrame ||\r\n           window.oRequestAnimationFrame ||\r\n           window.msRequestAnimationFrame ||\r\n           function(/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {\r\n             window.setTimeout(callback, 1000/60);\r\n           };\r\n  })();\r\n}\r\n\r\n/** * ERRATA: 'cancelRequestAnimationFrame' renamed to 'cancelAnimationFrame' to reflect an update to the W3C Animation-Timing Spec. \r\n * \r\n * Cancels an animation frame request. \r\n * Checks for cross-browser support, falls back to clearTimeout. \r\n * @param {number}  Animation frame request. */\r\nif (!window.cancelAnimationFrame) {\r\n  window.cancelAnimationFrame = (window.cancelRequestAnimationFrame ||\r\n                                 window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame ||\r\n                                 window.mozCancelAnimationFrame || window.mozCancelRequestAnimationFrame ||\r\n                                 window.msCancelAnimationFrame || window.msCancelRequestAnimationFrame ||\r\n                                 window.oCancelAnimationFrame || window.oCancelRequestAnimationFrame ||\r\n                                 window.clearTimeout);\r\n}\r\n\r\n/* harmony default export */ var webgl_utils = (WebGLUtils);\n// CONCATENATED MODULE: ./src/util/webgl-debug.js\n//Copyright (c) 2009 The Chromium Authors. All rights reserved.\r\n//Use of this source code is governed by a BSD-style license that can be\r\n//found in the LICENSE file.\r\n\r\n// Various functions for helping debug WebGL apps.\r\n\r\nvar WebGLDebugUtils = function() {\r\n\r\n/**\r\n * Wrapped logging function.\r\n * @param {string} msg Message to log.\r\n */\r\nvar log = function(msg) {\r\n  if (window.console && window.console.log) {\r\n    window.console.log(msg);\r\n  }\r\n};\r\n\r\n/**\r\n * Which arguements are enums.\r\n * @type {!Object.<number, string>}\r\n */\r\nvar glValidEnumContexts = {\r\n\r\n  // Generic setters and getters\r\n\r\n  'enable': { 0:true },\r\n  'disable': { 0:true },\r\n  'getParameter': { 0:true },\r\n\r\n  // Rendering\r\n\r\n  'drawArrays': { 0:true },\r\n  'drawElements': { 0:true, 2:true },\r\n\r\n  // Shaders\r\n\r\n  'createShader': { 0:true },\r\n  'getShaderParameter': { 1:true },\r\n  'getProgramParameter': { 1:true },\r\n\r\n  // Vertex attributes\r\n\r\n  'getVertexAttrib': { 1:true },\r\n  'vertexAttribPointer': { 2:true },\r\n\r\n  // Textures\r\n\r\n  'bindTexture': { 0:true },\r\n  'activeTexture': { 0:true },\r\n  'getTexParameter': { 0:true, 1:true },\r\n  'texParameterf': { 0:true, 1:true },\r\n  'texParameteri': { 0:true, 1:true, 2:true },\r\n  'texImage2D': { 0:true, 2:true, 6:true, 7:true },\r\n  'texSubImage2D': { 0:true, 6:true, 7:true },\r\n  'copyTexImage2D': { 0:true, 2:true },\r\n  'copyTexSubImage2D': { 0:true },\r\n  'generateMipmap': { 0:true },\r\n\r\n  // Buffer objects\r\n\r\n  'bindBuffer': { 0:true },\r\n  'bufferData': { 0:true, 2:true },\r\n  'bufferSubData': { 0:true },\r\n  'getBufferParameter': { 0:true, 1:true },\r\n\r\n  // Renderbuffers and framebuffers\r\n\r\n  'pixelStorei': { 0:true, 1:true },\r\n  'readPixels': { 4:true, 5:true },\r\n  'bindRenderbuffer': { 0:true },\r\n  'bindFramebuffer': { 0:true },\r\n  'checkFramebufferStatus': { 0:true },\r\n  'framebufferRenderbuffer': { 0:true, 1:true, 2:true },\r\n  'framebufferTexture2D': { 0:true, 1:true, 2:true },\r\n  'getFramebufferAttachmentParameter': { 0:true, 1:true, 2:true },\r\n  'getRenderbufferParameter': { 0:true, 1:true },\r\n  'renderbufferStorage': { 0:true, 1:true },\r\n\r\n  // Frame buffer operations (clear, blend, depth test, stencil)\r\n\r\n  'clear': { 0:true },\r\n  'depthFunc': { 0:true },\r\n  'blendFunc': { 0:true, 1:true },\r\n  'blendFuncSeparate': { 0:true, 1:true, 2:true, 3:true },\r\n  'blendEquation': { 0:true },\r\n  'blendEquationSeparate': { 0:true, 1:true },\r\n  'stencilFunc': { 0:true },\r\n  'stencilFuncSeparate': { 0:true, 1:true },\r\n  'stencilMaskSeparate': { 0:true },\r\n  'stencilOp': { 0:true, 1:true, 2:true },\r\n  'stencilOpSeparate': { 0:true, 1:true, 2:true, 3:true },\r\n\r\n  // Culling\r\n\r\n  'cullFace': { 0:true },\r\n  'frontFace': { 0:true },\r\n};\r\n\r\n/**\r\n * Map of numbers to names.\r\n * @type {Object}\r\n */\r\nvar glEnums = null;\r\n\r\n/**\r\n * Initializes this module. Safe to call more than once.\r\n * @param {!WebGLRenderingContext} ctx A WebGL context. If\r\n *    you have more than one context it doesn't matter which one\r\n *    you pass in, it is only used to pull out constants.\r\n */\r\nfunction init(ctx) {\r\n  if (glEnums == null) {\r\n    glEnums = { };\r\n    for (var propertyName in ctx) {\r\n      if (typeof ctx[propertyName] == 'number') {\r\n        glEnums[ctx[propertyName]] = propertyName;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Checks the utils have been initialized.\r\n */\r\nfunction checkInit() {\r\n  if (glEnums == null) {\r\n    throw 'WebGLDebugUtils.init(ctx) not called';\r\n  }\r\n}\r\n\r\n/**\r\n * Returns true or false if value matches any WebGL enum\r\n * @param {*} value Value to check if it might be an enum.\r\n * @return {boolean} True if value matches one of the WebGL defined enums\r\n */\r\nfunction mightBeEnum(value) {\r\n  checkInit();\r\n  return (glEnums[value] !== undefined);\r\n}\r\n\r\n/**\r\n * Gets an string version of an WebGL enum.\r\n *\r\n * Example:\r\n *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());\r\n *\r\n * @param {number} value Value to return an enum for\r\n * @return {string} The string version of the enum.\r\n */\r\nfunction glEnumToString(value) {\r\n  checkInit();\r\n  var name = glEnums[value];\r\n  return (name !== undefined) ? name :\r\n      (\"*UNKNOWN WebGL ENUM (0x\" + value.toString(16) + \")\");\r\n}\r\n\r\n/**\r\n * Returns the string version of a WebGL argument.\r\n * Attempts to convert enum arguments to strings.\r\n * @param {string} functionName the name of the WebGL function.\r\n * @param {number} argumentIndx the index of the argument.\r\n * @param {*} value The value of the argument.\r\n * @return {string} The value as a string.\r\n */\r\nfunction glFunctionArgToString(functionName, argumentIndex, value) {\r\n  var funcInfo = glValidEnumContexts[functionName];\r\n  if (funcInfo !== undefined) {\r\n    if (funcInfo[argumentIndex]) {\r\n      return glEnumToString(value);\r\n    }\r\n  }\r\n  return value.toString();\r\n}\r\n\r\n/**\r\n * Given a WebGL context returns a wrapped context that calls\r\n * gl.getError after every command and calls a function if the\r\n * result is not gl.NO_ERROR.\r\n *\r\n * @param {!WebGLRenderingContext} ctx The webgl context to\r\n *        wrap.\r\n * @param {!function(err, funcName, args): void} opt_onErrorFunc\r\n *        The function to call when gl.getError returns an\r\n *        error. If not specified the default function calls\r\n *        console.log with a message.\r\n */\r\nfunction makeDebugContext(ctx, opt_onErrorFunc) {\r\n  init(ctx);\r\n  opt_onErrorFunc = opt_onErrorFunc || function(err, functionName, args) {\r\n        // apparently we can't do args.join(\",\");\r\n        var argStr = \"\";\r\n        for (var ii = 0; ii < args.length; ++ii) {\r\n          argStr += ((ii == 0) ? '' : ', ') +\r\n              glFunctionArgToString(functionName, ii, args[ii]);\r\n        }\r\n        log(\"WebGL error \"+ glEnumToString(err) + \" in \"+ functionName +\r\n            \"(\" + argStr + \")\");\r\n      };\r\n\r\n  // Holds booleans for each GL error so after we get the error ourselves\r\n  // we can still return it to the client app.\r\n  var glErrorShadow = { };\r\n\r\n  // Makes a function that calls a WebGL function and then calls getError.\r\n  function makeErrorWrapper(ctx, functionName) {\r\n    return function() {\r\n      var result = ctx[functionName].apply(ctx, arguments);\r\n      var err = ctx.getError();\r\n      if (err != 0) {\r\n        glErrorShadow[err] = true;\r\n        opt_onErrorFunc(err, functionName, arguments);\r\n      }\r\n      return result;\r\n    };\r\n  }\r\n\r\n  // Make a an object that has a copy of every property of the WebGL context\r\n  // but wraps all functions.\r\n  var wrapper = {};\r\n  for (var propertyName in ctx) {\r\n    if (typeof ctx[propertyName] == 'function') {\r\n       wrapper[propertyName] = makeErrorWrapper(ctx, propertyName);\r\n     } else {\r\n       wrapper[propertyName] = ctx[propertyName];\r\n     }\r\n  }\r\n\r\n  // Override the getError function with one that returns our saved results.\r\n  wrapper.getError = function() {\r\n    for (var err in glErrorShadow) {\r\n      if (glErrorShadow[err]) {\r\n        glErrorShadow[err] = false;\r\n        return err;\r\n      }\r\n    }\r\n    return ctx.NO_ERROR;\r\n  };\r\n\r\n  return wrapper;\r\n}\r\n\r\nfunction resetToInitialState(ctx) {\r\n  var numAttribs = ctx.getParameter(ctx.MAX_VERTEX_ATTRIBS);\r\n  var tmp = ctx.createBuffer();\r\n  ctx.bindBuffer(ctx.ARRAY_BUFFER, tmp);\r\n  for (var ii = 0; ii < numAttribs; ++ii) {\r\n    ctx.disableVertexAttribArray(ii);\r\n    ctx.vertexAttribPointer(ii, 4, ctx.FLOAT, false, 0, 0);\r\n    ctx.vertexAttrib1f(ii, 0);\r\n  }\r\n  ctx.deleteBuffer(tmp);\r\n\r\n  var numTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);\r\n  for (var ii = 0; ii < numTextureUnits; ++ii) {\r\n    ctx.activeTexture(ctx.TEXTURE0 + ii);\r\n    ctx.bindTexture(ctx.TEXTURE_CUBE_MAP, null);\r\n    ctx.bindTexture(ctx.TEXTURE_2D, null);\r\n  }\r\n\r\n  ctx.activeTexture(ctx.TEXTURE0);\r\n  ctx.useProgram(null);\r\n  ctx.bindBuffer(ctx.ARRAY_BUFFER, null);\r\n  ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, null);\r\n  ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);\r\n  ctx.bindRenderbuffer(ctx.RENDERBUFFER, null);\r\n  ctx.disable(ctx.BLEND);\r\n  ctx.disable(ctx.CULL_FACE);\r\n  ctx.disable(ctx.DEPTH_TEST);\r\n  ctx.disable(ctx.DITHER);\r\n  ctx.disable(ctx.SCISSOR_TEST);\r\n  ctx.blendColor(0, 0, 0, 0);\r\n  ctx.blendEquation(ctx.FUNC_ADD);\r\n  ctx.blendFunc(ctx.ONE, ctx.ZERO);\r\n  ctx.clearColor(0, 0, 0, 0);\r\n  ctx.clearDepth(1);\r\n  ctx.clearStencil(-1);\r\n  ctx.colorMask(true, true, true, true);\r\n  ctx.cullFace(ctx.BACK);\r\n  ctx.depthFunc(ctx.LESS);\r\n  ctx.depthMask(true);\r\n  ctx.depthRange(0, 1);\r\n  ctx.frontFace(ctx.CCW);\r\n  ctx.hint(ctx.GENERATE_MIPMAP_HINT, ctx.DONT_CARE);\r\n  ctx.lineWidth(1);\r\n  ctx.pixelStorei(ctx.PACK_ALIGNMENT, 4);\r\n  ctx.pixelStorei(ctx.UNPACK_ALIGNMENT, 4);\r\n  ctx.pixelStorei(ctx.UNPACK_FLIP_Y_WEBGL, false);\r\n  ctx.pixelStorei(ctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\r\n  // TODO: Delete this IF.\r\n  if (ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL) {\r\n    ctx.pixelStorei(ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL, ctx.BROWSER_DEFAULT_WEBGL);\r\n  }\r\n  ctx.polygonOffset(0, 0);\r\n  ctx.sampleCoverage(1, false);\r\n  ctx.scissor(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n  ctx.stencilFunc(ctx.ALWAYS, 0, 0xFFFFFFFF);\r\n  ctx.stencilMask(0xFFFFFFFF);\r\n  ctx.stencilOp(ctx.KEEP, ctx.KEEP, ctx.KEEP);\r\n  ctx.viewport(0, 0, ctx.canvas.clientWidth, ctx.canvas.clientHeight);\r\n  ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT | ctx.STENCIL_BUFFER_BIT);\r\n\r\n  // TODO: This should NOT be needed but Firefox fails with 'hint'\r\n  while(ctx.getError());\r\n}\r\n\r\nfunction makeLostContextSimulatingContext(ctx) {\r\n  var wrapper_ = {};\r\n  var contextId_ = 1;\r\n  var contextLost_ = false;\r\n  var resourceId_ = 0;\r\n  var resourceDb_ = [];\r\n  var onLost_ = undefined;\r\n  var onRestored_ = undefined;\r\n  var nextOnRestored_ = undefined;\r\n\r\n  // Holds booleans for each GL error so can simulate errors.\r\n  var glErrorShadow_ = { };\r\n\r\n  function isWebGLObject(obj) {\r\n    //return false;\r\n    return (obj instanceof WebGLBuffer ||\r\n            obj instanceof WebGLFramebuffer ||\r\n            obj instanceof WebGLProgram ||\r\n            obj instanceof WebGLRenderbuffer ||\r\n            obj instanceof WebGLShader ||\r\n            obj instanceof WebGLTexture);\r\n  }\r\n\r\n  function checkResources(args) {\r\n    for (var ii = 0; ii < args.length; ++ii) {\r\n      var arg = args[ii];\r\n      if (isWebGLObject(arg)) {\r\n        return arg.__webglDebugContextLostId__ == contextId_;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  function clearErrors() {\r\n    var k = Object.keys(glErrorShadow_);\r\n    for (var ii = 0; ii < k.length; ++ii) {\r\n      delete glErrorShdow_[k];\r\n    }\r\n  }\r\n\r\n  // Makes a function that simulates WebGL when out of context.\r\n  function makeLostContextWrapper(ctx, functionName) {\r\n    var f = ctx[functionName];\r\n    return function() {\r\n      // Only call the functions if the context is not lost.\r\n      if (!contextLost_) {\r\n        if (!checkResources(arguments)) {\r\n          glErrorShadow_[ctx.INVALID_OPERATION] = true;\r\n          return;\r\n        }\r\n        var result = f.apply(ctx, arguments);\r\n        return result;\r\n      }\r\n    };\r\n  }\r\n\r\n  for (var propertyName in ctx) {\r\n    if (typeof ctx[propertyName] == 'function') {\r\n       wrapper_[propertyName] = makeLostContextWrapper(ctx, propertyName);\r\n     } else {\r\n       wrapper_[propertyName] = ctx[propertyName];\r\n     }\r\n  }\r\n\r\n  function makeWebGLContextEvent(statusMessage) {\r\n    return {statusMessage: statusMessage};\r\n  }\r\n\r\n  function freeResources() {\r\n    for (var ii = 0; ii < resourceDb_.length; ++ii) {\r\n      var resource = resourceDb_[ii];\r\n      if (resource instanceof WebGLBuffer) {\r\n        ctx.deleteBuffer(resource);\r\n      } else if (resource instanceof WebctxFramebuffer) {\r\n        ctx.deleteFramebuffer(resource);\r\n      } else if (resource instanceof WebctxProgram) {\r\n        ctx.deleteProgram(resource);\r\n      } else if (resource instanceof WebctxRenderbuffer) {\r\n        ctx.deleteRenderbuffer(resource);\r\n      } else if (resource instanceof WebctxShader) {\r\n        ctx.deleteShader(resource);\r\n      } else if (resource instanceof WebctxTexture) {\r\n        ctx.deleteTexture(resource);\r\n      }\r\n    }\r\n  }\r\n\r\n  wrapper_.loseContext = function() {\r\n    if (!contextLost_) {\r\n      contextLost_ = true;\r\n      ++contextId_;\r\n      while (ctx.getError());\r\n      clearErrors();\r\n      glErrorShadow_[ctx.CONTEXT_LOST_WEBGL] = true;\r\n      setTimeout(function() {\r\n          if (onLost_) {\r\n            onLost_(makeWebGLContextEvent(\"context lost\"));\r\n          }\r\n        }, 0);\r\n    }\r\n  };\r\n\r\n  wrapper_.restoreContext = function() {\r\n    if (contextLost_) {\r\n      if (onRestored_) {\r\n        setTimeout(function() {\r\n            freeResources();\r\n            resetToInitialState(ctx);\r\n            contextLost_ = false;\r\n            if (onRestored_) {\r\n              var callback = onRestored_;\r\n              onRestored_ = nextOnRestored_;\r\n              nextOnRestored_ = undefined;\r\n              callback(makeWebGLContextEvent(\"context restored\"));\r\n            }\r\n          }, 0);\r\n      } else {\r\n        throw \"You can not restore the context without a listener\"\r\n      }\r\n    }\r\n  };\r\n\r\n  // Wrap a few functions specially.\r\n  wrapper_.getError = function() {\r\n    if (!contextLost_) {\r\n      var err;\r\n      while (err = ctx.getError()) {\r\n        glErrorShadow_[err] = true;\r\n      }\r\n    }\r\n    for (var err in glErrorShadow_) {\r\n      if (glErrorShadow_[err]) {\r\n        delete glErrorShadow_[err];\r\n        return err;\r\n      }\r\n    }\r\n    return ctx.NO_ERROR;\r\n  };\r\n\r\n  var creationFunctions = [\r\n    \"createBuffer\",\r\n    \"createFramebuffer\",\r\n    \"createProgram\",\r\n    \"createRenderbuffer\",\r\n    \"createShader\",\r\n    \"createTexture\"\r\n  ];\r\n  for (var ii = 0; ii < creationFunctions.length; ++ii) {\r\n    var functionName = creationFunctions[ii];\r\n    wrapper_[functionName] = function(f) {\r\n      return function() {\r\n        if (contextLost_) {\r\n          return null;\r\n        }\r\n        var obj = f.apply(ctx, arguments);\r\n        obj.__webglDebugContextLostId__ = contextId_;\r\n        resourceDb_.push(obj);\r\n        return obj;\r\n      };\r\n    }(ctx[functionName]);\r\n  }\r\n\r\n  var functionsThatShouldReturnNull = [\r\n    \"getActiveAttrib\",\r\n    \"getActiveUniform\",\r\n    \"getBufferParameter\",\r\n    \"getContextAttributes\",\r\n    \"getAttachedShaders\",\r\n    \"getFramebufferAttachmentParameter\",\r\n    \"getParameter\",\r\n    \"getProgramParameter\",\r\n    \"getProgramInfoLog\",\r\n    \"getRenderbufferParameter\",\r\n    \"getShaderParameter\",\r\n    \"getShaderInfoLog\",\r\n    \"getShaderSource\",\r\n    \"getTexParameter\",\r\n    \"getUniform\",\r\n    \"getUniformLocation\",\r\n    \"getVertexAttrib\"\r\n  ];\r\n  for (var ii = 0; ii < functionsThatShouldReturnNull.length; ++ii) {\r\n    var functionName = functionsThatShouldReturnNull[ii];\r\n    wrapper_[functionName] = function(f) {\r\n      return function() {\r\n        if (contextLost_) {\r\n          return null;\r\n        }\r\n        return f.apply(ctx, arguments);\r\n      }\r\n    }(wrapper_[functionName]);\r\n  }\r\n\r\n  var isFunctions = [\r\n    \"isBuffer\",\r\n    \"isEnabled\",\r\n    \"isFramebuffer\",\r\n    \"isProgram\",\r\n    \"isRenderbuffer\",\r\n    \"isShader\",\r\n    \"isTexture\"\r\n  ];\r\n  for (var ii = 0; ii < isFunctions.length; ++ii) {\r\n    var functionName = isFunctions[ii];\r\n    wrapper_[functionName] = function(f) {\r\n      return function() {\r\n        if (contextLost_) {\r\n          return false;\r\n        }\r\n        return f.apply(ctx, arguments);\r\n      }\r\n    }(wrapper_[functionName]);\r\n  }\r\n\r\n  wrapper_.checkFramebufferStatus = function(f) {\r\n    return function() {\r\n      if (contextLost_) {\r\n        return ctx.FRAMEBUFFER_UNSUPPORTED;\r\n      }\r\n      return f.apply(ctx, arguments);\r\n    };\r\n  }(wrapper_.checkFramebufferStatus);\r\n\r\n  wrapper_.getAttribLocation = function(f) {\r\n    return function() {\r\n      if (contextLost_) {\r\n        return -1;\r\n      }\r\n      return f.apply(ctx, arguments);\r\n    };\r\n  }(wrapper_.getAttribLocation);\r\n\r\n  wrapper_.getVertexAttribOffset = function(f) {\r\n    return function() {\r\n      if (contextLost_) {\r\n        return 0;\r\n      }\r\n      return f.apply(ctx, arguments);\r\n    };\r\n  }(wrapper_.getVertexAttribOffset);\r\n\r\n  wrapper_.isContextLost = function() {\r\n    return contextLost_;\r\n  };\r\n\r\n  function wrapEvent(listener) {\r\n    if (typeof(listener) == \"function\") {\r\n      return listener;\r\n    } else {\r\n      return function(info) {\r\n        listener.handleEvent(info);\r\n      }\r\n    }\r\n  }\r\n\r\n  wrapper_.registerOnContextLostListener = function(listener) {\r\n    onLost_ = wrapEvent(listener);\r\n  };\r\n\r\n  wrapper_.registerOnContextRestoredListener = function(listener) {\r\n    if (contextLost_) {\r\n      nextOnRestored_ = wrapEvent(listener);\r\n    } else {\r\n      onRestored_ = wrapEvent(listener);\r\n    }\r\n  }\r\n\r\n  return wrapper_;\r\n}\r\n\r\nreturn {\r\n  /**\r\n   * Initializes this module. Safe to call more than once.\r\n   * @param {!WebGLRenderingContext} ctx A WebGL context. If\r\n   *    you have more than one context it doesn't matter which one\r\n   *    you pass in, it is only used to pull out constants.\r\n   */\r\n  'init': init,\r\n\r\n  /**\r\n   * Returns true or false if value matches any WebGL enum\r\n   * @param {*} value Value to check if it might be an enum.\r\n   * @return {boolean} True if value matches one of the WebGL defined enums\r\n   */\r\n  'mightBeEnum': mightBeEnum,\r\n\r\n  /**\r\n   * Gets an string version of an WebGL enum.\r\n   *\r\n   * Example:\r\n   *   WebGLDebugUtil.init(ctx);\r\n   *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());\r\n   *\r\n   * @param {number} value Value to return an enum for\r\n   * @return {string} The string version of the enum.\r\n   */\r\n  'glEnumToString': glEnumToString,\r\n\r\n  /**\r\n   * Converts the argument of a WebGL function to a string.\r\n   * Attempts to convert enum arguments to strings.\r\n   *\r\n   * Example:\r\n   *   WebGLDebugUtil.init(ctx);\r\n   *   var str = WebGLDebugUtil.glFunctionArgToString('bindTexture', 0, gl.TEXTURE_2D);\r\n   *\r\n   * would return 'TEXTURE_2D'\r\n   *\r\n   * @param {string} functionName the name of the WebGL function.\r\n   * @param {number} argumentIndx the index of the argument.\r\n   * @param {*} value The value of the argument.\r\n   * @return {string} The value as a string.\r\n   */\r\n  'glFunctionArgToString': glFunctionArgToString,\r\n\r\n  /**\r\n   * Given a WebGL context returns a wrapped context that calls\r\n   * gl.getError after every command and calls a function if the\r\n   * result is not NO_ERROR.\r\n   *\r\n   * You can supply your own function if you want. For example, if you'd like\r\n   * an exception thrown on any GL error you could do this\r\n   *\r\n   *    function throwOnGLError(err, funcName, args) {\r\n   *      throw WebGLDebugUtils.glEnumToString(err) + \" was caused by call to\" +\r\n   *            funcName;\r\n   *    };\r\n   *\r\n   *    ctx = WebGLDebugUtils.makeDebugContext(\r\n   *        canvas.getContext(\"webgl\"), throwOnGLError);\r\n   *\r\n   * @param {!WebGLRenderingContext} ctx The webgl context to wrap.\r\n   * @param {!function(err, funcName, args): void} opt_onErrorFunc The function\r\n   *     to call when gl.getError returns an error. If not specified the default\r\n   *     function calls console.log with a message.\r\n   */\r\n  'makeDebugContext': makeDebugContext,\r\n\r\n  /**\r\n   * Given a WebGL context returns a wrapped context that adds 4\r\n   * functions.\r\n   *\r\n   * ctx.loseContext:\r\n   *   simulates a lost context event.\r\n   *\r\n   * ctx.restoreContext:\r\n   *   simulates the context being restored.\r\n   *\r\n   * ctx.registerOnContextLostListener(listener):\r\n   *   lets you register a listener for context lost. Use instead\r\n   *   of addEventListener('webglcontextlostevent', listener);\r\n   *\r\n   * ctx.registerOnContextRestoredListener(listener):\r\n   *   lets you register a listener for context restored. Use\r\n   *   instead of addEventListener('webglcontextrestored',\r\n   *   listener);\r\n   *\r\n   * @param {!WebGLRenderingContext} ctx The webgl context to wrap.\r\n   */\r\n  'makeLostContextSimulatingContext': makeLostContextSimulatingContext,\r\n\r\n  /**\r\n   * Resets a context to the initial state.\r\n   * @param {!WebGLRenderingContext} ctx The webgl context to\r\n   *     reset.\r\n   */\r\n  'resetToInitialState': resetToInitialState\r\n};\r\n\r\n}();\r\n\r\n/* harmony default export */ var webgl_debug = (WebGLDebugUtils);\n// CONCATENATED MODULE: ./src/util/Util.js\n\r\n\r\n\r\nconst Util = {\r\n    initShaders: function(gl, vshader, fshader) {\r\n        var program = Util.createProgram(gl, vshader, fshader);\r\n        if (!program) {\r\n            console.log('Failed to create program');\r\n            return false;\r\n        }\r\n\r\n        gl.useProgram(program);\r\n        gl.program = program;\r\n\r\n        return true;\r\n    },\r\n\r\n    createProgram: function(gl, vshader, fshader) {\r\n        // Create shader object\r\n        var vertexShader = Util.loadShader(gl, gl.VERTEX_SHADER, vshader);\r\n        var fragmentShader = Util.loadShader(gl, gl.FRAGMENT_SHADER, fshader);\r\n        if (!vertexShader || !fragmentShader) {\r\n            return null;\r\n        }\r\n\r\n        // Create a program object\r\n        var program = gl.createProgram();\r\n        if (!program) {\r\n            return null;\r\n        }\r\n\r\n        // Attach the shader objects\r\n        gl.attachShader(program, vertexShader);\r\n        gl.attachShader(program, fragmentShader);\r\n\r\n        // Link the program object\r\n        gl.linkProgram(program);\r\n\r\n        // Check the result of linking\r\n        var linked = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n        if (!linked) {\r\n            var error = gl.getProgramInfoLog(program);\r\n            console.log('Failed to link program: ' + error);\r\n            gl.deleteProgram(program);\r\n            gl.deleteShader(fragmentShader);\r\n            gl.deleteShader(vertexShader);\r\n            return null;\r\n        }\r\n        return program;\r\n    },\r\n\r\n    loadShader: function(gl, type, source) {\r\n        // Create shader object\r\n        var shader = gl.createShader(type);\r\n        if (shader == null) {\r\n            console.log('unable to create shader');\r\n            return null;\r\n        }\r\n\r\n        // Set the shader program\r\n        gl.shaderSource(shader, source);\r\n\r\n        // Compile the shader\r\n        gl.compileShader(shader);\r\n\r\n        // Check the result of compilation\r\n        var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n        if (!compiled) {\r\n            var error = gl.getShaderInfoLog(shader);\r\n            console.log('Failed to compile shader: ' + error);\r\n            gl.deleteShader(shader);\r\n            return null;\r\n        }\r\n\r\n        return shader;\r\n    },\r\n\r\n    getWebGLContext: function(canvas, opt_debug) {\r\n        // Get the rendering context for WebGL\r\n        var gl = webgl_utils.setupWebGL(canvas);\r\n        if (!gl) return null;\r\n\r\n        // if opt_debug is explicitly false, create the context for debugging\r\n        if (arguments.length < 2 || opt_debug) {\r\n            gl = webgl_debug.makeDebugContext(gl);\r\n        }\r\n\r\n        return gl;\r\n    },\r\n\r\n    create3DContext : function(canvas, opt_attribs) {\r\n        var names = [\"webgl\", \"experimental-webgl\", \"webkit-3d\", \"moz-webgl\"];\r\n        var context = null;\r\n        for (var ii = 0; ii < names.length; ++ii) {\r\n            try {\r\n                context = canvas.getContext(names[ii], opt_attribs);\r\n            } catch(e) {}\r\n            if (context) {\r\n                break;\r\n            }\r\n        }\r\n        return context;\r\n    }\r\n}\r\n\r\n/* harmony default export */ var util_Util = (Util);\n// CONCATENATED MODULE: ./src/light/Light.js\n\r\nclass Light {\r\n    constructor(param) {\r\n        this.type = 'Light';\r\n\r\n        param = param || {};\r\n        this.color = param.color || [1,1,1];\r\n        this.intensity = param.intensity !== undefined ? param.intensity : 1;\r\n        this.castShadow = param.castShadow;\r\n    }\r\n}\r\n\r\n/* harmony default export */ var light_Light = (Light);\r\n\n// CONCATENATED MODULE: ./src/light/AmbientLight.js\n\r\n\r\nclass AmbientLight_AmbientLight extends light_Light{\r\n    constructor(param) {\r\n        super(param);\r\n        this.type = 'AmbientLight';\r\n    }\r\n}\r\n\r\n/* harmony default export */ var light_AmbientLight = (AmbientLight_AmbientLight);\r\n\n// CONCATENATED MODULE: ./src/light/DirectionalLight.js\n\r\n\r\n\r\nclass DirectionalLight_DirectionalLight extends light_Light{\r\n    constructor(param) {\r\n        super(param);\r\n        this.type = 'DirectionalLight';\r\n        this.direction = [1,1,1];\r\n        this.setDirection(param.direction || [1,1,1]);\r\n    }\r\n\r\n    setDirection(direction){\r\n        this.direction =  new Vector3().fromArray(direction).normalize().toArray();\r\n    }\r\n}\r\n\r\n/* harmony default export */ var light_DirectionalLight = (DirectionalLight_DirectionalLight);\r\n\n// CONCATENATED MODULE: ./src/core/Renderer.js\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass Renderer_Renderer {\r\n    constructor(param) {\r\n        var that = this;\r\n        param = param || {};\r\n        this.bufferList = [];\r\n\r\n        this.programList = {};\r\n\r\n        this.curCameraPosition = null;\r\n        this.renderList = {\r\n            opacityList:[],\r\n            transparentList:[]\r\n        };\r\n\r\n        this.camera = null;\r\n\r\n        var canvas = document.getElementById('webgl');\r\n        var gl = this.gl = canvas.getContext('2d');\r\n\r\n    }\r\n\r\n\r\n    render(scene, camera){\r\n        var that = this;\r\n        that.camera = camera;\r\n        that.curCameraPosition = camera.position;\r\n\r\n        var renderList = that.sortRenderList(scene);\r\n\r\n        var gl = that.gl;\r\n\r\n        gl.clearRect(0,0,600,600);\r\n\r\n        var ambientLight = null;\r\n        var directionalLight = null;\r\n\r\n        for(var i in scene.lights){\r\n            if(scene.lights[i].type === 'DirectionalLight'){\r\n                directionalLight = scene.lights[i];\r\n            }else if(scene.lights[i].type === 'AmbientLight'){\r\n                ambientLight = scene.lights[i];\r\n            }\r\n        }\r\n\r\n        ambientLight = ambientLight || new light_AmbientLight({intensity:0});\r\n        directionalLight = directionalLight || new light_DirectionalLight({intensity:0});\r\n\r\n        for(var i in renderList){\r\n            this.renderOneMesh(renderList[i], camera, ambientLight, directionalLight);\r\n        }\r\n\r\n    }\r\n\r\n    renderOneMesh(mesh, camera, ambientLight, directionalLight){\r\n        var that = this;\r\n\r\n        var mesh = mesh || new core_Mesh();\r\n        var geometry = mesh.geometry;\r\n        var indices = geometry.indices;\r\n        var vertices = geometry.vertices;\r\n\r\n\r\n        var material = mesh.material;\r\n        var map = material.map;\r\n        var color = material.color;\r\n\r\n        var ctx = that.gl;\r\n\r\n        for(var i=0; i<indices.length; i+=3){\r\n            var point1x = vertices[indices[i]*3];\r\n            var point1y = vertices[indices[i]*3+1];\r\n            var point1z = vertices[indices[i]*3+2];\r\n\r\n            var point2x = vertices[indices[i+1]*3];\r\n            var point2y = vertices[indices[i+1]*3+1];\r\n            var point2z = vertices[indices[i+1]*3+2];\r\n\r\n            var point3x = vertices[indices[i+2]*3];\r\n            var point3y = vertices[indices[i+2]*3+1];\r\n            var point3z = vertices[indices[i+2]*3+2];\r\n\r\n            that.drawTriangle(\r\n                new Vector3().fromArray([point1x,point1y,point1z]),\r\n                new Vector3().fromArray([point2x,point2y,point2z]),\r\n                new Vector3().fromArray([point3x,point3y,point3z]),\r\n                mesh\r\n            );\r\n        }\r\n\r\n    }\r\n\r\n    v3Tov2(v3, mesh){\r\n        var that = this;\r\n\r\n        var vpMatrix = that.camera.VPmatrix.clone();\r\n        var v4 = vpMatrix.concat(mesh.matrixWorld).multiplyVector4(new Vector4(v3.x, v3.y, v3.z, 1));\r\n        var v3GL = new Vector3(v4.x/v4.w, v4.y/v4.w, v4.z/v4.w);\r\n        var v2GL = new Vector2(v3GL.x, v3GL.y);\r\n        var v2 = new Vector2((v2GL.x/2+0.5)*600, (0.5-v2GL.y/2)*600);\r\n\r\n        return v2;\r\n    }\r\n\r\n    drawTriangle(a,b,c, mesh){\r\n        var that = this;\r\n        var ctx = that.gl;\r\n\r\n        var a1 = that.v3Tov2(a, mesh);\r\n        var b1 = that.v3Tov2(b, mesh);\r\n        var c1 = that.v3Tov2(c, mesh);\r\n\r\n        ctx.fillStyle = '#ff0000';\r\n        ctx.strokeStyle = '#ff0000';\r\n        // ctx.beginPath();\r\n        // ctx.moveTo(a1.x,a1.y);\r\n        // ctx.lineTo(b1.x,b1.y);\r\n        // ctx.lineTo(c1.x,c1.y);\r\n        // ctx.closePath();\r\n        // ctx.stroke();\r\n\r\n        function sortTByY(a,b) {\r\n            return a.y - b.y;\r\n        }\r\n\r\n        var triangleList = [a1,b1,c1].sort(sortTByY);\r\n        var a2 = triangleList[0];\r\n        var b2 = triangleList[1];\r\n        var c2 = triangleList[2];\r\n        var flatTop,flatBottom;\r\n        if(b2.y === a2.y){\r\n            flatTop = [c2,a2,b2];\r\n        }else if(b2.y === c2.y){\r\n            flatBottom = [a2,b2,c2];\r\n        }else{\r\n            var alpha = (b2.y-a2.y)/(c2.y-a2.y);\r\n            var ac = new Vector2().subVectors(c2,a2);\r\n            var d = a2.clone().addScaledVector(ac, alpha);\r\n\r\n            flatBottom = [a2,b2,d];\r\n            flatTop = [c2,b2,d];\r\n        }\r\n\r\n        if(flatBottom){\r\n            that.drawFlatT(flatBottom,mesh);\r\n        }\r\n        if(flatTop){\r\n            that.drawFlatT(flatTop,mesh);\r\n        }\r\n\r\n    }\r\n\r\n    drawT(t){\r\n        var that = this;\r\n        var ctx = that.gl;\r\n\r\n        var a1 = t[0];\r\n        var b1 = t[1];\r\n        var c1 = t[2];\r\n\r\n        ctx.fillStyle = '#ff0000';\r\n        ctx.strokeStyle = '#ff0000';\r\n        ctx.beginPath();\r\n        ctx.moveTo(a1.x,a1.y);\r\n        ctx.lineTo(b1.x,b1.y);\r\n        ctx.lineTo(c1.x,c1.y);\r\n        ctx.closePath();\r\n        ctx.stroke();\r\n    }\r\n\r\n    drawFlatT(t, mesh){\r\n        var that = this;\r\n        var ctx = that.gl;\r\n\r\n        var a = t[0];\r\n        var b;\r\n        var c;\r\n\r\n        if(t[1].x<t[2].x){\r\n            b = t[1];\r\n            c = t[2];\r\n        }else{\r\n            c = t[1];\r\n            b = t[2];\r\n        }\r\n\r\n        var startY = Math.round(a.y);\r\n        var endY = Math.round(b.y);\r\n        var height = Math.abs(endY - startY);\r\n\r\n        var ab = new Vector2().subVectors(b,a);\r\n        var ac = new Vector2().subVectors(c,a);\r\n\r\n        let dy = 1;\r\n        if(endY<startY){\r\n            dy = -1;\r\n        }\r\n\r\n        for(var y=startY; (y-startY)*(y-endY)<=0; y+=dy){\r\n            if(y<0||y>600){\r\n                continue;\r\n            }\r\n\r\n            var alpha = Math.abs(y-startY)/height;\r\n            var startV2 = a.clone().addScaledVector(ab,alpha);\r\n            var endV2 = a.clone().addScaledVector(ac,alpha);\r\n            var startX = Math.round(startV2.x);\r\n            var endX = Math.round(endV2.x);\r\n\r\n            for(var x=startX; x<=endX; x++){\r\n                if(x<0||x>600){\r\n                    continue;\r\n                }\r\n                ctx.fillStyle = 'rgb('+x+','+y+',0)';\r\n                ctx.fillRect(x,y,1,1);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    getAllObjList(obj, allObjList){\r\n        var that = this;\r\n        for(var i in obj.children){\r\n            if(obj.children[i].geometry){\r\n                allObjList.push(obj.children[i]);\r\n            }\r\n            that.getAllObjList(obj.children[i],allObjList);\r\n        }\r\n        return allObjList;\r\n    }\r\n\r\n    sortRenderList(scene){\r\n        var that = this;\r\n\r\n        var allObjList = that.getAllObjList(scene ,[]);\r\n\r\n        for(var i in allObjList){\r\n            var pa = allObjList[i].getWorldPosition();\r\n            var pc = new Vector3().fromArray(that.curCameraPosition);\r\n            var da = pc.distanceTo(pa);\r\n            allObjList[i].distanceToCamera = da;\r\n        }\r\n        var allObjSortedList = allObjList.sort(that.sortFun);\r\n        return allObjSortedList;\r\n    }\r\n\r\n    sortFun(a, b){\r\n        return b.distanceToCamera - a.distanceToCamera;\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ var core_Renderer = (Renderer_Renderer);\r\n\n// CONCATENATED MODULE: ./src/camera/Camera.js\n\r\n\r\n\r\n\r\n\r\nclass Camera_Camera {\r\n    constructor(fov, aspect, near, far) {\r\n        this.fov = fov;\r\n        this.aspect = aspect;\r\n        this.near = near;\r\n        this.far = far;\r\n\r\n        this.position = [0, 0, 10];\r\n        this.target = [0,0,0];\r\n        this.up = [0,1,0];\r\n\r\n        this.VPmatrix = new Matrix4();\r\n\r\n        this.direction = [0,0,-1];\r\n        this.right = [1,0,0];\r\n\r\n        this.scale = [1,1,1];\r\n        this.quaternion = new Quaternion();\r\n        this.matrix = new Matrix4();\r\n        this.matrixWorld = this.matrix;\r\n        this.projectionMatrix = new Matrix4();\r\n\r\n        this.updateAll();\r\n    }\r\n\r\n    updateAll(){\r\n        this.updateOption();\r\n        this.updateMatrix();\r\n        this.updateVPMatrix();\r\n    }\r\n\r\n    updateMatrix(){\r\n        var quaternionD = new Quaternion().setFromUnitVectors(new Vector3(0,0,-1), new Vector3().fromArray(this.direction));\r\n        var right2 = new Vector3(1,0,0).applyQuaternion(quaternionD);\r\n        var quaternionR = new Quaternion().setFromUnitVectors(right2, new Vector3().fromArray(this.right));\r\n        var quaternion = new Quaternion().multiplyQuaternions(quaternionR, quaternionD);\r\n        this.quaternion = quaternion;\r\n\r\n        this.matrix.compose( new Vector3().fromArray(this.position), this.quaternion, new Vector3().fromArray(this.scale) );\r\n        this.projectionMatrix = new Matrix4().setPerspective(this.fov, this.aspect, this.near, this.far);\r\n        // this.updateMatrixWorld ();\r\n    }\r\n\r\n    updateOption(){\r\n        var targetV3 = new Vector3().fromArray(this.target);\r\n        var positionV3 = new Vector3().fromArray(this.position);\r\n        var upV3 = new Vector3().fromArray(this.up);\r\n\r\n        var directionV3 = new Vector3().subVectors(targetV3, positionV3).normalize();\r\n        this.direction = directionV3.toArray();\r\n\r\n        var rightV3 = new Vector3().crossVectors(directionV3, upV3).normalize();\r\n        this.right = rightV3.toArray();\r\n\r\n        // this.up = new Vector3().crossVectors(rightV3, directionV3).normalize().toArray();\r\n    }\r\n\r\n    setPosition(position){\r\n        this.position = position;\r\n        this.updateAll();\r\n    }\r\n\r\n    setTarget(target){\r\n        this.target = target;\r\n        this.updateAll();\r\n    }\r\n\r\n    setUp(up){\r\n        this.up = new Vector3().fromArray(up).normalize().toArray();\r\n        this.updateAll();\r\n    }\r\n\r\n\r\n\r\n    updateVPMatrix(){\r\n        this.VPmatrix = new Matrix4().setPerspective(this.fov, this.aspect, this.near, this.far);\r\n        var Vmatrix = new Matrix4().getInverse(this.matrix);\r\n        this.VPmatrix.concat(Vmatrix);\r\n        //等价\r\n        // this.VPmatrix.lookAt2(this.position[0],this.position[1],this.position[2], this.target[0],this.target[1],this.target[2], this.up[0],this.up[1],this.up[2]);\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ var camera_Camera = (Camera_Camera);\r\n\r\n\n// CONCATENATED MODULE: ./src/camera/CameraController.js\n\r\n\r\n\r\nclass CameraController_CameraController {\r\n    constructor(camera) {\r\n        this.camera = camera;\r\n\r\n        this.mouse0State = 'up';\r\n        this.mouse1State = 'up';\r\n        this.mouse2State = 'up';\r\n\r\n        this.x = -1;\r\n        this.y = -1;\r\n\r\n        this.minTilt = 0.1;\r\n        this.maxTilt = 3.04;\r\n    }\r\n\r\n    update(){\r\n        var that = this;\r\n\r\n        window.addEventListener('mousedown',function (e) {\r\n            // console.log(e.button+' down '+e.clientX+','+e.clientY);\r\n            var dom =  window.document.getElementsByTagName('canvas')[0];\r\n            if(!dom){\r\n                return;\r\n            }\r\n            var rect = dom.getBoundingClientRect();\r\n            if(e.clientX < rect.left || e.clientX > rect.right || e.clientY < rect.top || e.clientY > rect.bottom){\r\n                return;\r\n            }\r\n            if(e.button == 0){\r\n                that.mouse0State = 'down';\r\n            }else if(e.button == 1){\r\n                that.mouse1State = 'down';\r\n            }else if(e.button == 2){\r\n                that.mouse2State = 'down';\r\n            }\r\n        });\r\n\r\n        window.addEventListener('mouseup',function (e) {\r\n            // console.log(e.button+' up '+e.clientX+','+e.clientY);\r\n            if(e.button == 0){\r\n                that.mouse0State = 'up';\r\n            }else if(e.button == 1){\r\n                that.mouse1State = 'up';\r\n            }else if(e.button == 2){\r\n                that.mouse2State = 'up';\r\n            }\r\n        });\r\n\r\n        window.addEventListener('mousemove',function (e) {\r\n            // console.log(e.button+' move '+e.clientX+','+e.clientY);\r\n\r\n            var camera = that.camera;\r\n            if(that.mouse0State == 'down'){\r\n                var deltaX = e.clientX - that.x;\r\n                var deltaY = e.clientY - that.y;\r\n\r\n                // var angle = Math.sqrt(deltaX*deltaX + deltaY*deltaY)/80;\r\n                //\r\n                // var upV3 = new Vector3(camera.up);\r\n                // var rightV3 = new Vector3(camera.right);\r\n                //\r\n                // var axisV3 = new Vector3().addVectors( new Vector3().scaleVectors(upV3,deltaX) , new Vector3().scaleVectors(rightV3,deltaY)).normalize();\r\n                //\r\n                // var oldPositionV3 = new Vector3(camera.position);\r\n                // var newPositionV3 = new Vector3().rotateByVector(oldPositionV3, axisV3, angle);\r\n                // var newPosition = newPositionV3.toArray();\r\n                //\r\n                // camera.setPosition(newPosition);\r\n\r\n                var axisYV3 = new Vector3(0,1,0);\r\n                var angleY = deltaX/200;\r\n                var oldPositionV3 = new Vector3().fromArray(camera.position);\r\n                var newPositionV3 = new Vector3().rotateByVector(oldPositionV3, axisYV3, angleY);\r\n                var newPosition = newPositionV3.toArray();\r\n                camera.setPosition(newPosition);\r\n\r\n\r\n                var angleX = deltaY/200;\r\n                var tilt = that.getTilt();\r\n                var endTilt = tilt - angleX;\r\n\r\n                if(endTilt<that.maxTilt && endTilt>that.minTilt){\r\n\r\n                    var axisXV3 = new Vector3(camera.right[0], camera.right[1], camera.right[2]);\r\n                    oldPositionV3 = new Vector3().fromArray(camera.position);\r\n                    newPositionV3 = new Vector3().rotateByVector(oldPositionV3, axisXV3, angleX);\r\n                    newPosition = newPositionV3.toArray();\r\n                    camera.setPosition(newPosition);\r\n                }\r\n\r\n            }\r\n\r\n            if(that.mouse2State == 'down'){\r\n                var deltaX = e.clientX - that.x;\r\n                var deltaY = e.clientY - that.y;\r\n\r\n                var tempUp = new Vector3().crossVectors(new Vector3().fromArray(camera.right), new Vector3().fromArray(camera.direction));\r\n                var axisYV3 = tempUp;\r\n\r\n                var oldTargetV3 = new Vector3().fromArray(camera.target);\r\n                var newTargetV3 = new Vector3().addVectors(oldTargetV3, new Vector3().scaleVectors(axisYV3, deltaY/30));\r\n                var newTargetV3 = newTargetV3.toArray();\r\n                camera.setTarget(newTargetV3);\r\n\r\n                var oldPositionV3 = new Vector3().fromArray(camera.position);\r\n                var newPositionV3 = new Vector3().addVectors(oldPositionV3, new Vector3().scaleVectors(axisYV3, deltaY/30));\r\n                var newPosition = newPositionV3.toArray();\r\n                camera.setPosition(newPosition);\r\n\r\n                var axisXV3 = new Vector3().fromArray(camera.right);\r\n\r\n                oldTargetV3 = new Vector3().fromArray(camera.target);\r\n                newTargetV3 = new Vector3().addVectors(oldTargetV3, new Vector3().scaleVectors(axisXV3, -deltaX/30));\r\n                newTargetV3 = newTargetV3.toArray();\r\n                camera.setTarget(newTargetV3);\r\n\r\n                oldPositionV3 = new Vector3().fromArray(camera.position);\r\n                var newPositionV3 = new Vector3().addVectors(oldPositionV3, new Vector3().scaleVectors(axisXV3, -deltaX/30));\r\n                newPosition = newPositionV3.toArray();\r\n                camera.setPosition(newPosition);\r\n\r\n            }\r\n\r\n            that.x = e.clientX;\r\n            that.y = e.clientY;\r\n        });\r\n\r\n        window.addEventListener('mousewheel',function (e) {\r\n            // console.log(e.button+' wheel '+e.wheelDelta);\r\n\r\n            var camera = that.camera;\r\n\r\n            var delta = e.wheelDelta;\r\n\r\n            if(delta == 0 || typeof(delta) != 'number'){\r\n                return;\r\n            }\r\n            delta = Math.abs(delta)/delta;\r\n\r\n            var directionV3 = new Vector3().fromArray(camera.direction);\r\n\r\n            var oldPositionV3 = new Vector3().fromArray(camera.position);\r\n            var dis = oldPositionV3.lengthSq();\r\n            dis = Math.sqrt(dis);\r\n            var newPositionV3 = new Vector3().addVectors(oldPositionV3, new Vector3().scaleVectors(directionV3, dis/10*delta));\r\n            var newPosition = newPositionV3.toArray();\r\n\r\n            camera.setPosition(newPosition);\r\n\r\n        });\r\n    }\r\n\r\n    getTilt(){\r\n        var camera = this.camera;\r\n        var dir = camera.direction;\r\n        var axixY = new Vector3(0,-1,0);\r\n        var dirV3 = new Vector3().fromArray(dir);\r\n\r\n        var tilt = axixY.angleTo(dirV3);\r\n        return tilt;\r\n\r\n    }\r\n}\r\n\r\n/* harmony default export */ var camera_CameraController = (CameraController_CameraController);\r\n\n// CONCATENATED MODULE: ./src/core/Scene.js\n\r\n\r\n\r\nclass Scene {\r\n    constructor(param) {\r\n        param = param || {};\r\n        this.children = [];\r\n        this.lights = [];\r\n    }\r\n\r\n    add(obj){\r\n        if(obj.type == 'Mesh'){\r\n            this.children.push(obj);\r\n        }else{\r\n            this.lights.push(obj);\r\n        }\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\n/* harmony default export */ var core_Scene = (Scene);\n// CONCATENATED MODULE: ./src/material/Texture.js\n\r\nclass Texture {\r\n    constructor(param) {\r\n        param = param || {};\r\n        this.image = param.image || new Image();\r\n        this.wrapS = param.wrapS || COOL.REPEAT;\r\n        this.wrapT = param.wrapT || COOL.REPEAT;\r\n        this.magFilter = param.magFilter || COOL.NEAREST;\r\n        this.minFilter = param.minFilter || COOL.NEAREST;\r\n    }\r\n\r\n    clone(){\r\n\r\n        var image = new Image();\r\n        image.src = this.image.src;\r\n\r\n        var texture = new Texture({\r\n            image: image,\r\n            wrapS: this.wrapS,\r\n            wrapT: this.wrapT,\r\n            magFilter: this.magFilter,\r\n            minFilter: this.minFilter\r\n        });\r\n\r\n        return texture;\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ var material_Texture = (Texture);\r\n\n// CONCATENATED MODULE: ./src/material/MeshBasicMaterial.js\n\r\n\r\nclass MeshBasicMaterial_MeshBasicMaterial extends material_Material{\r\n    constructor(param) {\r\n        super(param);\r\n        this.type = 'MeshBasicMaterial';\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ var material_MeshBasicMaterial = (MeshBasicMaterial_MeshBasicMaterial);\r\n\n// CONCATENATED MODULE: ./src/material/MeshLambertMaterial.js\n\r\n\r\nclass MeshLambertMaterial_MeshLambertMaterial extends material_Material{\r\n    constructor(param) {\r\n        super(param);\r\n        this.type = 'MeshLambertMaterial';\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ var material_MeshLambertMaterial = (MeshLambertMaterial_MeshLambertMaterial);\r\n\n// CONCATENATED MODULE: ./src/material/MeshStandardMaterial.js\n\r\n\r\nclass MeshStandardMaterial_MeshStandardMaterial extends material_Material{\r\n    constructor(param) {\r\n        super(param);\r\n        this.type = 'MeshStandardMaterial';\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ var material_MeshStandardMaterial = (MeshStandardMaterial_MeshStandardMaterial);\r\n\n// CONCATENATED MODULE: ./src/core/Geometry.js\n\r\n\r\n\r\n\r\nclass Geometry_Geometry {\r\n    constructor(param) {\r\n        param = param || {};\r\n\r\n        // Create a cube\r\n        //    v6----- v5\r\n        //   /|      /|\r\n        //  v1------v0|\r\n        //  | |     | |\r\n        //  | |v7---|-|v4\r\n        //  |/      |/\r\n        //  v2------v3\r\n\r\n        this.uv = param.uv || new Float32Array([   // Vertex coordinates\r\n\r\n            1,1, 0,1, 0,0, 1,0,  // v0-v1-v2-v3 front\r\n            0,1, 0,0, 1,0, 1,1,  // v0-v3-v4-v5 right\r\n            1,0, 1,1, 0,1, 0,0,  // v0-v5-v6-v1 up\r\n            1,1, 0,1, 0,0, 1,0,  // v1-v6-v7-v2 left\r\n            0,1, 1,1, 1,0, 0,0,  // v7-v4-v3-v2 down\r\n            1,0, 0,0, 0,1, 1,1   // v4-v7-v6-v5 back\r\n\r\n        ]);\r\n\r\n        this.vertices = param.vertices || new Float32Array([   // Vertex coordinates\r\n            0.5, 0.5, 0.5,  -0.5, 0.5, 0.5,  -0.5,-0.5, 0.5,   0.5,-0.5, 0.5,  // v0-v1-v2-v3 front\r\n            0.5, 0.5, 0.5,   0.5,-0.5, 0.5,   0.5,-0.5,-0.5,   0.5, 0.5,-0.5,  // v0-v3-v4-v5 right\r\n            0.5, 0.5, 0.5,   0.5, 0.5,-0.5,  -0.5, 0.5,-0.5,  -0.5, 0.5, 0.5,  // v0-v5-v6-v1 up\r\n            -0.5, 0.5, 0.5,  -0.5, 0.5,-0.5,  -0.5,-0.5,-0.5,  -0.5,-0.5, 0.5,  // v1-v6-v7-v2 left\r\n            -0.5,-0.5,-0.5,   0.5,-0.5,-0.5,   0.5,-0.5, 0.5,  -0.5,-0.5, 0.5,  // v7-v4-v3-v2 down\r\n            0.5,-0.5,-0.5,  -0.5,-0.5,-0.5,  -0.5, 0.5,-0.5,   0.5, 0.5,-0.5   // v4-v7-v6-v5 back\r\n        ]);\r\n\r\n        this.normal = param.normal || this.vertices;\r\n\r\n        if(param.indices){\r\n            this.indices = new Uint16Array(param.indices);\r\n        }else{\r\n            var indicesArray = [];\r\n            for(var i=0; i<param.vertices.length/3; i++){\r\n                indicesArray.push(i);\r\n            }\r\n            this.indices = new Uint16Array(indicesArray);\r\n        }\r\n\r\n\r\n        this.morphAttributes = param.morphAttributes;\r\n\r\n        this.boundingSphere = new Sphere();\r\n        this.boundingBox = new Box3();\r\n        this.computeBoundingBox();\r\n\r\n        // this.updateNormal();\r\n\r\n        this.updataBuffer();\r\n\r\n    }\r\n\r\n    updataBuffer(){\r\n        var buffer = [];\r\n        var uv = this.uv;\r\n        var vertices = this.vertices;\r\n        var normal = this.normal;\r\n        for(var i=0; i<vertices.length; i+=3){\r\n            buffer.push(vertices[i+0]);\r\n            buffer.push(vertices[i+1]);\r\n            buffer.push(vertices[i+2]);\r\n\r\n            buffer.push(normal[i+0]);\r\n            buffer.push(normal[i+1]);\r\n            buffer.push(normal[i+2]);\r\n\r\n            buffer.push(uv[i/3*2+0]);\r\n            buffer.push(uv[i/3*2+1]);\r\n        }\r\n\r\n        this.buffer = new Float32Array(buffer);\r\n    }\r\n\r\n    updateNormal(){\r\n        var normal = [];\r\n        var vertices = this.vertices;\r\n        for(var i=0; i<vertices.length; i+=3*4){\r\n            var line1 = new Vector3().subVectors(\r\n                new Vector3(vertices[i+0], vertices[i+1], vertices[i+2]),\r\n                new Vector3(vertices[i+3], vertices[i+4], vertices[i+5])\r\n            );\r\n            var line2 = new Vector3().subVectors(\r\n                new Vector3(vertices[i+3], vertices[i+4], vertices[i+5]),\r\n                new Vector3(vertices[i+6], vertices[i+7], vertices[i+8]),\r\n            );\r\n            var cur_normal = new Vector3().crossVectors(\r\n                line1,\r\n                line2\r\n            ).toArray();\r\n            for(var j=0 ;j<4; j++){\r\n                normal.push(cur_normal[0], cur_normal[1], cur_normal[2]);\r\n            }\r\n        }\r\n        this.normal = new Float32Array(normal);\r\n\r\n    }\r\n\r\n    computeBoundingBox () {\r\n        var verticesV3 = [];\r\n        for(var i=0; i<this.vertices.length; i+=3){\r\n            verticesV3.push(new Vector3(this.vertices[i], this.vertices[i+1], this.vertices[i+2]))\r\n        }\r\n        this.boundingBox.setFromPoints(verticesV3);\r\n    }\r\n\r\n    clone(){\r\n        var geometry = new Geometry_Geometry({\r\n            vertices: this.vertices.slice(0),\r\n            indices: this.indices.slice(0)\r\n        });\r\n\r\n        return geometry;\r\n    }\r\n}\r\n\r\n/* harmony default export */ var core_Geometry = (Geometry_Geometry);\r\n\n// CONCATENATED MODULE: ./src/core/SphereGeometry.js\n\r\n\r\n\r\n\r\nclass SphereGeometry_SphereGeometry {\r\n    constructor( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\r\n\r\n        radius = radius || 1;\r\n\r\n        widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\r\n        heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\r\n\r\n        phiStart = phiStart !== undefined ? phiStart : 0;\r\n        phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\r\n\r\n        thetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\r\n\r\n        var thetaEnd = thetaStart + thetaLength;\r\n\r\n        var ix, iy;\r\n\r\n        var index = 0;\r\n        var grid = [];\r\n\r\n        var vertex = new Vector3();\r\n        var normal = new Vector3();\r\n\r\n        // buffers\r\n\r\n        var indices = [];\r\n        var vertices = [];\r\n        var normals = [];\r\n        var uvs = [];\r\n\r\n        // generate vertices, normals and uvs\r\n\r\n        for ( iy = 0; iy <= heightSegments; iy ++ ) {\r\n\r\n            var verticesRow = [];\r\n\r\n            var v = iy / heightSegments;\r\n\r\n            for ( ix = 0; ix <= widthSegments; ix ++ ) {\r\n\r\n                var u = ix / widthSegments;\r\n\r\n                // vertex\r\n\r\n                vertex = new Vector3(\r\n                    - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength ),\r\n                    radius * Math.cos( thetaStart + v * thetaLength ),\r\n                    radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength )\r\n                );\r\n\r\n                vertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n                // normal\r\n\r\n                normal = vertex.clone().normalize();\r\n                normals.push( normal.x, normal.y, normal.z );\r\n\r\n                // uv\r\n\r\n                uvs.push( u, 1 - v );\r\n\r\n                verticesRow.push( index ++ );\r\n\r\n            }\r\n\r\n            grid.push( verticesRow );\r\n\r\n        }\r\n\r\n        // indices\r\n\r\n        for ( iy = 0; iy < heightSegments; iy ++ ) {\r\n\r\n            for ( ix = 0; ix < widthSegments; ix ++ ) {\r\n\r\n                var a = grid[ iy ][ ix + 1 ];\r\n                var b = grid[ iy ][ ix ];\r\n                var c = grid[ iy + 1 ][ ix ];\r\n                var d = grid[ iy + 1 ][ ix + 1 ];\r\n\r\n                if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );\r\n                if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );\r\n\r\n            }\r\n\r\n        }\r\n\r\n        this.vertices = new Float32Array(vertices);\r\n        this.normal = new Float32Array(normals);\r\n        this.uv = new Float32Array(uvs);\r\n\r\n        this.indices = new Uint16Array(indices);\r\n\r\n        var buffer = [];\r\n        var vertices = this.vertices;\r\n        var normal = this.normal;\r\n        var uv = this.uv;\r\n        for(var i=0; i<vertices.length; i+=3){\r\n            buffer.push(vertices[i+0]);\r\n            buffer.push(vertices[i+1]);\r\n            buffer.push(vertices[i+2]);\r\n\r\n            buffer.push(normal[i+0]);\r\n            buffer.push(normal[i+1]);\r\n            buffer.push(normal[i+2]);\r\n\r\n            buffer.push(uv[i/3*2+0]);\r\n            buffer.push(uv[i/3*2+1]);\r\n        }\r\n\r\n        this.buffer = new Float32Array(buffer);\r\n\r\n        this.boundingSphere = new Sphere();\r\n        this.boundingBox = new Box3();\r\n        this.computeBoundingBox();\r\n\r\n    }\r\n\r\n    computeBoundingBox () {\r\n        var verticesV3 = [];\r\n        for(var i=0; i<this.vertices.length; i+=3){\r\n            verticesV3.push(new Vector3(this.vertices[i], this.vertices[i+1], this.vertices[i+2]))\r\n        }\r\n        this.boundingBox.setFromPoints(verticesV3);\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ var core_SphereGeometry = (SphereGeometry_SphereGeometry);\r\n\n// CONCATENATED MODULE: ./src/core/GLTFLoader2.js\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass GLTFLoader2_GLTFLoader{\r\n    constructor(){\r\n        this.gltfObj = null;\r\n        this.urlBase = null;\r\n\r\n        this.arrayBuffers = [];\r\n        this.arrayBufferCount = 0;\r\n        this.dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\r\n    }\r\n\r\n    load(url, onLoadSuccess){\r\n        this.gltfObj = null;\r\n        this.urlBase = null;\r\n\r\n        this.arrayBuffers = [];\r\n        this.arrayBufferCount = 0;\r\n\r\n        var that = this;\r\n        var urlArray = url.split('/');\r\n        var jsonName = urlArray[urlArray.length-1];\r\n        that.urlBase = url.split(jsonName)[0];\r\n\r\n        var request = new XMLHttpRequest();\r\n        request.open(\"get\", url);\r\n        request.onload = function () {\r\n            if (request.status == 200) {\r\n                var gltfObj = JSON.parse(request.responseText);\r\n                that.gltfObj = gltfObj;\r\n                console.log(gltfObj);\r\n\r\n                that.arrayBufferCount = gltfObj.buffers.length;\r\n                var loadBufferCount = 0;\r\n\r\n                for(var i in gltfObj.buffers){\r\n\r\n                    var buffer = gltfObj.buffers[i];\r\n\r\n                    var dataUriRegexResult = buffer.uri.match( that.dataUriRegex );\r\n                    if(dataUriRegexResult){\r\n\r\n                        var buffer = that.base64ToArrayBuffer(dataUriRegexResult);\r\n                        if(buffer){\r\n                            that.arrayBuffers[i] = buffer;\r\n                            loadBufferCount ++;\r\n\r\n                            if(loadBufferCount = that.arrayBufferCount){\r\n\r\n                                var sceneObj = gltfObj.scenes[0];\r\n                                var scene = new core_Scene();\r\n                                for(var nodeindex in sceneObj.nodes){\r\n                                    var nodesIndex = sceneObj.nodes[nodeindex];\r\n                                    var nodesObj = gltfObj.nodes[nodesIndex];\r\n                                    var cur_mesh = that.nodeToMesh(nodesObj);\r\n                                    scene.add(cur_mesh);\r\n                                }\r\n                                onLoadSuccess(scene);\r\n\r\n                            }\r\n\r\n                        }\r\n\r\n                    }else{\r\n\r\n                        var bufferDataUri = that.urlBase + buffer.uri;\r\n\r\n                        var xhr = new XMLHttpRequest();\r\n                        xhr.open( 'GET', bufferDataUri, true );\r\n                        xhr.addEventListener( 'load', function ( event ) {\r\n\r\n                            var buffer = this.response;\r\n                            that.arrayBuffers[i] = buffer;\r\n                            loadBufferCount ++;\r\n\r\n                            if(loadBufferCount = that.arrayBufferCount){\r\n\r\n                                var sceneObj = gltfObj.scenes[0];\r\n                                var scene = new core_Scene();\r\n                                for(var nodeindex in sceneObj.nodes){\r\n                                    var nodesIndex = sceneObj.nodes[nodeindex];\r\n                                    var nodesObj = gltfObj.nodes[nodesIndex];\r\n                                    var cur_mesh = that.nodeToMesh(nodesObj);\r\n                                    scene.add(cur_mesh);\r\n                                }\r\n                                onLoadSuccess(scene);\r\n\r\n                            }\r\n\r\n\r\n                        }, false );\r\n                        xhr.responseType = 'arraybuffer';\r\n                        xhr.send( null );\r\n\r\n                    }\r\n\r\n\r\n                }\r\n\r\n\r\n            }\r\n        };\r\n        request.send(null);\r\n\r\n    }\r\n\r\n    nodeToMesh(node){\r\n        var that = this;\r\n\r\n        var meshIndex = node.mesh;\r\n        var mesh = null;\r\n\r\n        if(meshIndex != undefined){\r\n            var meshObj = that.gltfObj.meshes[meshIndex];\r\n            var geometryAndMaterial = that.meshToGeometry(meshObj);\r\n            mesh = new core_Mesh({\r\n                geometry:geometryAndMaterial[0],\r\n                material:geometryAndMaterial[1]\r\n            });\r\n        }else{\r\n            mesh = new core_Mesh();\r\n        }\r\n\r\n        var scale = node.scale;\r\n        if(scale){\r\n            mesh.setScale(scale);\r\n        }\r\n\r\n        var rotation = node.rotation;\r\n        if(rotation){\r\n            var quaternion = new Quaternion().fromArray(rotation);\r\n            mesh.setQuaternion(quaternion);\r\n        }\r\n\r\n        var translation = node.translation;\r\n        if(translation){\r\n            mesh.setPosition(translation);\r\n        }\r\n\r\n        var matrix = node.matrix;\r\n        if(matrix){\r\n            mesh.setMatrix(new Matrix4().fromArray(matrix));\r\n        }\r\n\r\n        for(var i in node.children){\r\n            var nodeChild = that.gltfObj.nodes[node.children[i]];\r\n            var meshChild = that.nodeToMesh(nodeChild);\r\n            mesh.add(meshChild);\r\n        }\r\n\r\n        return mesh;\r\n    }\r\n\r\n    meshToGeometry(mesh){\r\n        var that = this;\r\n\r\n        var primitive0 = mesh.primitives[0];\r\n        var attributes = primitive0.attributes;\r\n\r\n        var positionAccessorIndex = attributes.POSITION;\r\n        var positionAccessor = that.gltfObj.accessors[positionAccessorIndex];\r\n        var positionBufferViewIndex = positionAccessor.bufferView;\r\n        var positionBufferView = that.gltfObj.bufferViews[positionBufferViewIndex];\r\n        var positionData = that.getDataByBufferView(positionBufferView,positionAccessor);\r\n\r\n        var normalAccessorIndex = attributes.NORMAL;\r\n        var normalAccessor = that.gltfObj.accessors[normalAccessorIndex];\r\n        var normalBufferViewIndex = normalAccessor.bufferView;\r\n        var normalBufferView = that.gltfObj.bufferViews[normalBufferViewIndex];\r\n        var normalData = that.getDataByBufferView(normalBufferView,normalAccessor);\r\n\r\n        //TEXCOORD_0\r\n        var uv0AccessorIndex = attributes.TEXCOORD_0;\r\n        var uv0Accessor = that.gltfObj.accessors[uv0AccessorIndex];\r\n        var uv0BufferViewIndex = uv0Accessor.bufferView;\r\n        var uv0BufferView = that.gltfObj.bufferViews[uv0BufferViewIndex];\r\n        var uv0Data = that.getDataByBufferView(uv0BufferView,uv0Accessor);\r\n\r\n        var indicesData = null;\r\n        var indicesAccessorIndex = primitive0.indices;\r\n\r\n        if(indicesAccessorIndex != undefined){\r\n            var indicesAccessor = that.gltfObj.accessors[indicesAccessorIndex];\r\n            var indicesBufferViewIndex = indicesAccessor.bufferView;\r\n            var indicesBufferView = that.gltfObj.bufferViews[indicesBufferViewIndex];\r\n            indicesData = that.getDataByBufferView(indicesBufferView,indicesAccessor);\r\n        }\r\n\r\n        var materialIndex = primitive0.material;\r\n        var materialObj = that.gltfObj.materials[materialIndex];\r\n\r\n        if(materialObj.pbrMetallicRoughness.baseColorTexture){\r\n            var baseColorTextureIndex = materialObj.pbrMetallicRoughness.baseColorTexture.index;\r\n            var textureObj = that.gltfObj.textures[baseColorTextureIndex];\r\n            var imageIndex = textureObj.source;\r\n            var imageObj = that.gltfObj.images[imageIndex];\r\n            var imageUri = imageObj.uri;\r\n\r\n            var dataUriRegexResult = imageObj.uri.match( that.dataUriRegex );\r\n            if(!dataUriRegexResult){\r\n                imageUri = that.urlBase + imageObj.uri;\r\n            }\r\n\r\n            var samplerIndex = textureObj.sampler;\r\n            var sampler = that.gltfObj.samplers[samplerIndex];\r\n\r\n            var image = new Image();\r\n            image.crossOrigin = \"anonymous\";\r\n            image.src= imageUri;\r\n\r\n            var texture = new COOL.Texture({\r\n                image:image,\r\n                //这两个参数有问题，有的9729 9986是什么东西\r\n                // magFilter: sampler.magFilter,\r\n                // minFilter: sampler.minFilter,\r\n                wrapS: sampler.wrapS,\r\n                wrapT: sampler.wrapT,\r\n            });\r\n        }\r\n\r\n\r\n        var material = new COOL.MeshLambertMaterial({map:texture});\r\n\r\n        return [\r\n            new core_Geometry({\r\n                vertices: positionData,\r\n                indices: indicesData,\r\n                normal:normalData,\r\n                uv:uv0Data\r\n            }),\r\n            material\r\n        ];\r\n    }\r\n\r\n    getDataByBufferView(bufferView, accessor){\r\n        var that = this;\r\n        var bufferIndex = bufferView.buffer;\r\n\r\n        var byteLength = bufferView.byteLength || 0;\r\n        var byteOffset = bufferView.byteOffset || 0;\r\n\r\n        var buffer = that.gltfObj.buffers[bufferIndex];\r\n        var bufferDataUri = that.urlBase + buffer.uri;\r\n\r\n        var arrayBuffer = that.arrayBuffers[bufferIndex];\r\n\r\n        var cur_buffer = arrayBuffer.slice( byteOffset, byteOffset + byteLength );\r\n\r\n        var array = null;\r\n        var itemSize = null;\r\n\r\n        var accessorByteOffset = accessor.byteOffset || 0;\r\n\r\n        if(accessor.type == 'SCALAR'){\r\n            itemSize = 1;\r\n        }else if(accessor.type == 'VEC2'){\r\n            itemSize = 2;\r\n        }else if(accessor.type == 'VEC3'){\r\n            itemSize = 3;\r\n        }else if(accessor.type == 'VEC4'){\r\n            itemSize = 4;\r\n        }else{\r\n            console.warn('accessor.type undefined');\r\n        }\r\n\r\n        if(accessor.componentType == 5126){\r\n            array = new Float32Array( cur_buffer, accessorByteOffset, accessor.count * itemSize );\r\n        }else if(accessor.componentType == 5123){\r\n            array = new Uint16Array( cur_buffer, accessorByteOffset, accessor.count * itemSize );\r\n        }else if(accessor.componentType == 5120){\r\n            array = new Int8Array( cur_buffer, accessorByteOffset, accessor.count * itemSize );\r\n        }else if(accessor.componentType == 5121){\r\n            array = new Uint8Array( cur_buffer, accessorByteOffset, accessor.count * itemSize );\r\n        }else if(accessor.componentType == 5122){\r\n            array = new Int16Array( cur_buffer, accessorByteOffset, accessor.count * itemSize );\r\n        }else if(accessor.componentType == 5125){\r\n            array = new Uint32Array( cur_buffer, accessorByteOffset, accessor.count * itemSize );\r\n        }else{\r\n            console.warn('accessor.componentType undefined');\r\n        }\r\n\r\n        return array;\r\n\r\n\r\n    }\r\n\r\n    base64ToArrayBuffer(dataUriRegexResult){\r\n\r\n        var data = dataUriRegexResult[ 3 ];\r\n        data = decodeURIComponent( data );\r\n        data = atob( data );\r\n\r\n        try {\r\n\r\n            var view = new Uint8Array( data.length );\r\n            for ( var i = 0; i < data.length; i ++ ) {\r\n                view[ i ] = data.charCodeAt( i );\r\n            }\r\n\r\n            var arrayBuffer = view.buffer;\r\n            return arrayBuffer;\r\n\r\n        } catch ( error ) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ var GLTFLoader2 = (GLTFLoader2_GLTFLoader);\r\n\n// CONCATENATED MODULE: ./src/camera/OrthoCamera.js\n\r\n\r\n\r\n\r\nclass OrthoCamera_OrthoCamera {\r\n    constructor(left, right, bottom, top, near, far) {\r\n        this.left = left;\r\n        this._right = right;\r\n        this.bottom = bottom;\r\n        this.top = top;\r\n        this.near = near;\r\n        this.far = far;\r\n\r\n        this.position = [0, 0, 10];\r\n        this.target = [0,0,0];\r\n        this.up = [0,1,0];\r\n\r\n        this.VPmatrix = new Matrix4();\r\n\r\n        this.direction = [0,0,-1];\r\n        this.right = [1,0,0];\r\n\r\n        this.updateAll();\r\n    }\r\n\r\n    updateAll(){\r\n        this.updateOption();\r\n        this.updateVPMatrix();\r\n    }\r\n\r\n    updateOption(){\r\n        var targetV3 = new Vector3().fromArray(this.target);\r\n        var positionV3 = new Vector3().fromArray(this.position);\r\n        var upV3 = new Vector3().fromArray(this.up);\r\n\r\n        var directionV3 = new Vector3().subVectors(targetV3, positionV3).normalize();\r\n        this.direction = directionV3.toArray();\r\n\r\n        var rightV3 = new Vector3().crossVectors(directionV3, upV3).normalize();\r\n        this.right = rightV3.toArray();\r\n\r\n        // this.up = new Vector3().crossVectors(rightV3, directionV3).normalize().toArray();\r\n    }\r\n\r\n    setPosition(position){\r\n        this.position = position;\r\n        this.updateAll();\r\n    }\r\n\r\n    setTarget(target){\r\n        this.target = target;\r\n        this.updateAll();\r\n    }\r\n\r\n    setUp(up){\r\n        this.up = new Vector3().fromArray(up).normalize().toArray();\r\n        this.updateAll();\r\n    }\r\n\r\n\r\n\r\n    updateVPMatrix(){\r\n        this.VPmatrix = new Matrix4().setOrtho(this.left, this._right, this.bottom, this.top, this.near, this.far);\r\n        this.VPmatrix.lookAt2(this.position[0],this.position[1],this.position[2], this.target[0],this.target[1],this.target[2], this.up[0],this.up[1],this.up[2]);\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ var camera_OrthoCamera = (OrthoCamera_OrthoCamera);\r\n\r\n\n// CONCATENATED MODULE: ./src/animation/Animation.js\n\r\n\r\nclass Animation_Animation {\r\n    constructor(mesh){\r\n        this.mesh = mesh || new core_Mesh();\r\n        this.time = new Date().getTime();\r\n        this.index = 0;\r\n        this.frameCount = this.mesh.geometry.morphAttributes.position.length;\r\n    }\r\n\r\n    play(){\r\n        this.time = new Date().getTime();\r\n        this.index = 0;\r\n        this.animationLoop();\r\n    }\r\n\r\n    animationLoop(){\r\n        var that = this;\r\n        var curTime = new Date().getTime();\r\n        var curIndex = Math.floor((curTime - this.time)/1000*20)%this.frameCount;\r\n        if(curIndex != this.index){\r\n            this.mesh.geometry.vertices = this.mesh.geometry.morphAttributes.position[curIndex].array;\r\n            this.mesh.geometry.updataBuffer();\r\n            this.index = curIndex;\r\n        }\r\n        requestAnimationFrame(function () {\r\n            that.animationLoop();\r\n        });\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ var animation_Animation = (Animation_Animation);\r\n\n// CONCATENATED MODULE: ./src/core/Raycaster.js\n\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author bhouston / http://clara.io/\r\n * @author stephomi / http://stephaneginier.com/\r\n */\r\n\r\nfunction Raycaster( origin, direction, near, far ) {\r\n\r\n\tthis.ray = new Ray( origin, direction );\r\n\t// direction is assumed to be normalized (for accurate distance calculations)\r\n\r\n\tthis.near = near || 0;\r\n\tthis.far = far || Infinity;\r\n\r\n\tthis.params = {\r\n\t\tMesh: {},\r\n\t\tLine: {},\r\n\t\tLOD: {},\r\n\t\tPoints: { threshold: 1 },\r\n\t\tSprite: {}\r\n\t};\r\n\r\n\tObject.defineProperties( this.params, {\r\n\t\tPointCloud: {\r\n\t\t\tget: function () {\r\n\r\n\t\t\t\tconsole.warn( 'COOL.Raycaster: params.PointCloud has been renamed to params.Points.' );\r\n\t\t\t\treturn this.Points;\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\r\n}\r\n\r\nfunction ascSort( a, b ) {\r\n\r\n\treturn a.distance - b.distance;\r\n\r\n}\r\n\r\nfunction intersectObject( object, raycaster, intersects, recursive ) {\r\n\r\n\tif ( object.visible === false) return;\r\n\r\n\tif(object.geometry){\r\n        object.raycast( raycaster, intersects );\r\n\t}\r\n\r\n\tif ( recursive === true ) {\r\n\r\n\t\tvar children = object.children;\r\n\r\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nObject.assign( Raycaster.prototype, {\r\n\r\n\tlinePrecision: 1,\r\n\r\n\tset: function ( origin, direction ) {\r\n\r\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\r\n\r\n\t\tthis.ray.set( origin, direction );\r\n\r\n\t},\r\n\r\n\tsetFromCamera: function ( coords, camera ) {\r\n\r\n\t\tif ( true ) {\r\n\r\n\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\r\n\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\r\n\r\n\t\t}\r\n\t\t// else if ( ( camera && camera.isOrthographicCamera ) ) {\r\n\t\t//\r\n\t\t// \tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\r\n\t\t// \tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\r\n\t\t//\r\n\t\t// } else {\r\n\t\t//\r\n\t\t// \tconsole.error( 'COOL.Raycaster: Unsupported camera type.' );\r\n\t\t//\r\n\t\t// }\r\n\r\n\t},\r\n\r\n\tintersectObject: function ( object, recursive, optionalTarget ) {\r\n\r\n\t\tvar intersects = optionalTarget || [];\r\n\r\n\t\tintersectObject( object, this, intersects, recursive );\r\n\r\n\t\tintersects.sort( ascSort );\r\n\r\n\t\treturn intersects;\r\n\r\n\t},\r\n\r\n\tintersectObjects: function ( objects, recursive, optionalTarget ) {\r\n\r\n\t\tvar intersects = optionalTarget || [];\r\n\r\n\t\tif ( Array.isArray( objects ) === false ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Raycaster.intersectObjects: objects is not an Array.' );\r\n\t\t\treturn intersects;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\r\n\r\n\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\r\n\r\n\t\t}\r\n\r\n\t\tintersects.sort( ascSort );\r\n\r\n\t\treturn intersects;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/loader/EventDispatcher.js\n/**\r\n * https://github.com/mrdoob/eventdispatcher.js/\r\n */\r\n\r\nfunction EventDispatcher() {}\r\n\r\nObject.assign( EventDispatcher.prototype, {\r\n\r\n\taddEventListener: function ( type, listener ) {\r\n\r\n\t\tif ( this._listeners === undefined ) this._listeners = {};\r\n\r\n\t\tvar listeners = this._listeners;\r\n\r\n\t\tif ( listeners[ type ] === undefined ) {\r\n\r\n\t\t\tlisteners[ type ] = [];\r\n\r\n\t\t}\r\n\r\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\r\n\r\n\t\t\tlisteners[ type ].push( listener );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\thasEventListener: function ( type, listener ) {\r\n\r\n\t\tif ( this._listeners === undefined ) return false;\r\n\r\n\t\tvar listeners = this._listeners;\r\n\r\n\t\treturn listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\r\n\r\n\t},\r\n\r\n\tremoveEventListener: function ( type, listener ) {\r\n\r\n\t\tif ( this._listeners === undefined ) return;\r\n\r\n\t\tvar listeners = this._listeners;\r\n\t\tvar listenerArray = listeners[ type ];\r\n\r\n\t\tif ( listenerArray !== undefined ) {\r\n\r\n\t\t\tvar index = listenerArray.indexOf( listener );\r\n\r\n\t\t\tif ( index !== - 1 ) {\r\n\r\n\t\t\t\tlistenerArray.splice( index, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tdispatchEvent: function ( event ) {\r\n\r\n\t\tif ( this._listeners === undefined ) return;\r\n\r\n\t\tvar listeners = this._listeners;\r\n\t\tvar listenerArray = listeners[ event.type ];\r\n\r\n\t\tif ( listenerArray !== undefined ) {\r\n\r\n\t\t\tevent.target = this;\r\n\r\n\t\t\tvar array = listenerArray.slice( 0 );\r\n\r\n\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tarray[ i ].call( this, event );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/loader/Face3.js\n\r\n\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nfunction Face3_Face3( a, b, c, normal, color, materialIndex ) {\r\n\r\n\tthis.a = a;\r\n\tthis.b = b;\r\n\tthis.c = c;\r\n\r\n\tthis.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();\r\n\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\r\n\r\n\tthis.color = ( color && color.isColor ) ? color : new Color();\r\n\tthis.vertexColors = Array.isArray( color ) ? color : [];\r\n\r\n\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\r\n\r\n}\r\n\r\nObject.assign( Face3_Face3.prototype, {\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.a = source.a;\r\n\t\tthis.b = source.b;\r\n\t\tthis.c = source.c;\r\n\r\n\t\tthis.normal.copy( source.normal );\r\n\t\tthis.color.copy( source.color );\r\n\r\n\t\tthis.materialIndex = source.materialIndex;\r\n\r\n\t\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/math/Matrix3.js\n\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://clara.io\r\n * @author tschw\r\n */\r\n\r\nfunction Matrix3() {\r\n\r\n\tthis.elements = [\r\n\r\n\t\t1, 0, 0,\r\n\t\t0, 1, 0,\r\n\t\t0, 0, 1\r\n\r\n\t];\r\n\r\n\tif ( arguments.length > 0 ) {\r\n\r\n\t\tconsole.error( 'COOL.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\r\n\r\n\t}\r\n\r\n}\r\n\r\nObject.assign( Matrix3.prototype, {\r\n\r\n\tisMatrix3: true,\r\n\r\n\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\r\n\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\r\n\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tidentity: function () {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0,\r\n\t\t\t0, 1, 0,\r\n\t\t\t0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().fromArray( this.elements );\r\n\r\n\t},\r\n\r\n\tcopy: function ( m ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar me = m.elements;\r\n\r\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];\r\n\t\tte[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];\r\n\t\tte[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrix4: function ( m ) {\r\n\r\n\t\tvar me = m.elements;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tme[ 0 ], me[ 4 ], me[ 8 ],\r\n\t\t\tme[ 1 ], me[ 5 ], me[ 9 ],\r\n\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyToBufferAttribute: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function applyToBufferAttribute( attribute ) {\r\n\r\n\t\t\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\r\n\r\n\t\t\t\tv1.x = attribute.getX( i );\r\n\t\t\t\tv1.y = attribute.getY( i );\r\n\t\t\t\tv1.z = attribute.getZ( i );\r\n\r\n\t\t\t\tv1.applyMatrix3( this );\r\n\r\n\t\t\t\tattribute.setXYZ( i, v1.x, v1.y, v1.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn attribute;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmultiply: function ( m ) {\r\n\r\n\t\treturn this.multiplyMatrices( this, m );\r\n\r\n\t},\r\n\r\n\tpremultiply: function ( m ) {\r\n\r\n\t\treturn this.multiplyMatrices( m, this );\r\n\r\n\t},\r\n\r\n\tmultiplyMatrices: function ( a, b ) {\r\n\r\n\t\tvar ae = a.elements;\r\n\t\tvar be = b.elements;\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];\r\n\t\tvar a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];\r\n\t\tvar a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];\r\n\r\n\t\tvar b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];\r\n\t\tvar b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];\r\n\t\tvar b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];\r\n\r\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;\r\n\t\tte[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;\r\n\t\tte[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;\r\n\r\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;\r\n\t\tte[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;\r\n\t\tte[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;\r\n\r\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;\r\n\t\tte[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;\r\n\t\tte[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\r\n\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\r\n\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdeterminant: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\r\n\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\r\n\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\r\n\r\n\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\r\n\r\n\t},\r\n\r\n\tgetInverse: function ( matrix, throwOnDegenerate ) {\r\n\r\n\t\tif ( matrix && matrix.isMatrix4 ) {\r\n\r\n\t\t\tconsole.error( \"COOL.Matrix3: .getInverse() no longer takes a Matrix4 argument.\" );\r\n\r\n\t\t}\r\n\r\n\t\tvar me = matrix.elements,\r\n\t\t\tte = this.elements,\r\n\r\n\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\r\n\t\t\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\r\n\t\t\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\r\n\r\n\t\t\tt11 = n33 * n22 - n32 * n23,\r\n\t\t\tt12 = n32 * n13 - n33 * n12,\r\n\t\t\tt13 = n23 * n12 - n22 * n13,\r\n\r\n\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\r\n\r\n\t\tif ( det === 0 ) {\r\n\r\n\t\t\tvar msg = \"COOL.Matrix3: .getInverse() can't invert matrix, determinant is 0\";\r\n\r\n\t\t\tif ( throwOnDegenerate === true ) {\r\n\r\n\t\t\t\tthrow new Error( msg );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( msg );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.identity();\r\n\r\n\t\t}\r\n\r\n\t\tvar detInv = 1 / det;\r\n\r\n\t\tte[ 0 ] = t11 * detInv;\r\n\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\r\n\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\r\n\r\n\t\tte[ 3 ] = t12 * detInv;\r\n\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\r\n\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\r\n\r\n\t\tte[ 6 ] = t13 * detInv;\r\n\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\r\n\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranspose: function () {\r\n\r\n\t\tvar tmp, m = this.elements;\r\n\r\n\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\r\n\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\r\n\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetNormalMatrix: function ( matrix4 ) {\r\n\r\n\t\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\r\n\r\n\t},\r\n\r\n\ttransposeIntoArray: function ( r ) {\r\n\r\n\t\tvar m = this.elements;\r\n\r\n\t\tr[ 0 ] = m[ 0 ];\r\n\t\tr[ 1 ] = m[ 3 ];\r\n\t\tr[ 2 ] = m[ 6 ];\r\n\t\tr[ 3 ] = m[ 1 ];\r\n\t\tr[ 4 ] = m[ 4 ];\r\n\t\tr[ 5 ] = m[ 7 ];\r\n\t\tr[ 6 ] = m[ 2 ];\r\n\t\tr[ 7 ] = m[ 5 ];\r\n\t\tr[ 8 ] = m[ 8 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {\r\n\r\n\t\tvar c = Math.cos( rotation );\r\n\t\tvar s = Math.sin( rotation );\r\n\r\n\t\tthis.set(\r\n\t\t\tsx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,\r\n\t\t\t- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,\r\n\t\t\t0, 0, 1\r\n\t\t);\r\n\r\n\t},\r\n\r\n\tscale: function ( sx, sy ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;\r\n\t\tte[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trotate: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta );\r\n\t\tvar s = Math.sin( theta );\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];\r\n\t\tvar a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];\r\n\r\n\t\tte[ 0 ] = c * a11 + s * a21;\r\n\t\tte[ 3 ] = c * a12 + s * a22;\r\n\t\tte[ 6 ] = c * a13 + s * a23;\r\n\r\n\t\tte[ 1 ] = - s * a11 + c * a21;\r\n\t\tte[ 4 ] = - s * a12 + c * a22;\r\n\t\tte[ 7 ] = - s * a13 + c * a23;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranslate: function ( tx, ty ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];\r\n\t\tte[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( matrix ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar me = matrix.elements;\r\n\r\n\t\tfor ( var i = 0; i < 9; i ++ ) {\r\n\r\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tfor ( var i = 0; i < 9; i ++ ) {\r\n\r\n\t\t\tthis.elements[ i ] = array[ i + offset ];\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tarray[ offset ] = te[ 0 ];\r\n\t\tarray[ offset + 1 ] = te[ 1 ];\r\n\t\tarray[ offset + 2 ] = te[ 2 ];\r\n\r\n\t\tarray[ offset + 3 ] = te[ 3 ];\r\n\t\tarray[ offset + 4 ] = te[ 4 ];\r\n\t\tarray[ offset + 5 ] = te[ 5 ];\r\n\r\n\t\tarray[ offset + 6 ] = te[ 6 ];\r\n\t\tarray[ offset + 7 ] = te[ 7 ];\r\n\t\tarray[ offset + 8 ] = te[ 8 ];\r\n\r\n\t\treturn array;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/loader/Layers.js\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nfunction Layers() {\r\n\r\n\tthis.mask = 1 | 0;\r\n\r\n}\r\n\r\nObject.assign( Layers.prototype, {\r\n\r\n\tset: function ( channel ) {\r\n\r\n\t\tthis.mask = 1 << channel | 0;\r\n\r\n\t},\r\n\r\n\tenable: function ( channel ) {\r\n\r\n\t\tthis.mask |= 1 << channel | 0;\r\n\r\n\t},\r\n\r\n\ttoggle: function ( channel ) {\r\n\r\n\t\tthis.mask ^= 1 << channel | 0;\r\n\r\n\t},\r\n\r\n\tdisable: function ( channel ) {\r\n\r\n\t\tthis.mask &= ~ ( 1 << channel | 0 );\r\n\r\n\t},\r\n\r\n\ttest: function ( layers ) {\r\n\r\n\t\treturn ( this.mask & layers.mask ) !== 0;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/loader/Object3D.js\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author elephantatwork / www.elephantatwork.ch\r\n */\r\n\r\nvar object3DId = 0;\r\n\r\nfunction Object3D() {\r\n\r\n\tObject.defineProperty( this, 'id', { value: object3DId ++ } );\r\n\r\n\tthis.uuid = _Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'Object3D';\r\n\r\n\tthis.parent = null;\r\n\tthis.children = [];\r\n\r\n\tthis.up = Object3D.DefaultUp.clone();\r\n\r\n\tvar position = new Vector3();\r\n\tvar rotation = new Euler();\r\n\tvar quaternion = new Quaternion();\r\n\tvar scale = new Vector3( 1, 1, 1 );\r\n\r\n\tfunction onRotationChange() {\r\n\r\n\t\tquaternion.setFromEuler( rotation, false );\r\n\r\n\t}\r\n\r\n\tfunction onQuaternionChange() {\r\n\r\n\t\trotation.setFromQuaternion( quaternion, undefined, false );\r\n\r\n\t}\r\n\r\n\trotation.onChange( onRotationChange );\r\n\tquaternion.onChange( onQuaternionChange );\r\n\r\n\tObject.defineProperties( this, {\r\n\t\tposition: {\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: position\r\n\t\t},\r\n\t\trotation: {\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: rotation\r\n\t\t},\r\n\t\tquaternion: {\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: quaternion\r\n\t\t},\r\n\t\tscale: {\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: scale\r\n\t\t},\r\n\t\tmodelViewMatrix: {\r\n\t\t\tvalue: new Matrix4()\r\n\t\t},\r\n\t\tnormalMatrix: {\r\n\t\t\tvalue: new Matrix3()\r\n\t\t}\r\n\t} );\r\n\r\n\tthis.matrix = new Matrix4();\r\n\tthis.matrixWorld = new Matrix4();\r\n\r\n\tthis.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\r\n\tthis.matrixWorldNeedsUpdate = false;\r\n\r\n\tthis.layers = new Layers();\r\n\tthis.visible = true;\r\n\r\n\tthis.castShadow = false;\r\n\tthis.receiveShadow = false;\r\n\r\n\tthis.frustumCulled = true;\r\n\tthis.renderOrder = 0;\r\n\r\n\tthis.userData = {};\r\n\r\n}\r\n\r\nObject3D.DefaultUp = new Vector3( 0, 1, 0 );\r\nObject3D.DefaultMatrixAutoUpdate = true;\r\n\r\nObject3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\r\n\r\n\tconstructor: Object3D,\r\n\r\n\tisObject3D: true,\r\n\r\n\tonBeforeRender: function () {},\r\n\tonAfterRender: function () {},\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\r\n\r\n\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\r\n\r\n\t},\r\n\r\n\tapplyQuaternion: function ( q ) {\r\n\r\n\t\tthis.quaternion.premultiply( q );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetRotationFromAxisAngle: function ( axis, angle ) {\r\n\r\n\t\t// assumes axis is normalized\r\n\r\n\t\tthis.quaternion.setFromAxisAngle( axis, angle );\r\n\r\n\t},\r\n\r\n\tsetRotationFromEuler: function ( euler ) {\r\n\r\n\t\tthis.quaternion.setFromEuler( euler, true );\r\n\r\n\t},\r\n\r\n\tsetRotationFromMatrix: function ( m ) {\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tthis.quaternion.setFromRotationMatrix( m );\r\n\r\n\t},\r\n\r\n\tsetRotationFromQuaternion: function ( q ) {\r\n\r\n\t\t// assumes q is normalized\r\n\r\n\t\tthis.quaternion.copy( q );\r\n\r\n\t},\r\n\r\n\trotateOnAxis: function () {\r\n\r\n\t\t// rotate object on axis in object space\r\n\t\t// axis is assumed to be normalized\r\n\r\n\t\tvar q1 = new Quaternion();\r\n\r\n\t\treturn function rotateOnAxis( axis, angle ) {\r\n\r\n\t\t\tq1.setFromAxisAngle( axis, angle );\r\n\r\n\t\t\tthis.quaternion.multiply( q1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateOnWorldAxis: function () {\r\n\r\n\t\t// rotate object on axis in world space\r\n\t\t// axis is assumed to be normalized\r\n\t\t// method assumes no rotated parent\r\n\r\n\t\tvar q1 = new Quaternion();\r\n\r\n\t\treturn function rotateOnWorldAxis( axis, angle ) {\r\n\r\n\t\t\tq1.setFromAxisAngle( axis, angle );\r\n\r\n\t\t\tthis.quaternion.premultiply( q1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateX: function () {\r\n\r\n\t\tvar v1 = new Vector3( 1, 0, 0 );\r\n\r\n\t\treturn function rotateX( angle ) {\r\n\r\n\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateY: function () {\r\n\r\n\t\tvar v1 = new Vector3( 0, 1, 0 );\r\n\r\n\t\treturn function rotateY( angle ) {\r\n\r\n\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateZ: function () {\r\n\r\n\t\tvar v1 = new Vector3( 0, 0, 1 );\r\n\r\n\t\treturn function rotateZ( angle ) {\r\n\r\n\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateOnAxis: function () {\r\n\r\n\t\t// translate object by distance along axis in object space\r\n\t\t// axis is assumed to be normalized\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function translateOnAxis( axis, distance ) {\r\n\r\n\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\r\n\r\n\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateX: function () {\r\n\r\n\t\tvar v1 = new Vector3( 1, 0, 0 );\r\n\r\n\t\treturn function translateX( distance ) {\r\n\r\n\t\t\treturn this.translateOnAxis( v1, distance );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateY: function () {\r\n\r\n\t\tvar v1 = new Vector3( 0, 1, 0 );\r\n\r\n\t\treturn function translateY( distance ) {\r\n\r\n\t\t\treturn this.translateOnAxis( v1, distance );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateZ: function () {\r\n\r\n\t\tvar v1 = new Vector3( 0, 0, 1 );\r\n\r\n\t\treturn function translateZ( distance ) {\r\n\r\n\t\t\treturn this.translateOnAxis( v1, distance );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlocalToWorld: function ( vector ) {\r\n\r\n\t\treturn vector.applyMatrix4( this.matrixWorld );\r\n\r\n\t},\r\n\r\n\tworldToLocal: function () {\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function worldToLocal( vector ) {\r\n\r\n\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlookAt: function () {\r\n\r\n\t\t// This method does not support objects having non-uniformly-scaled parent(s)\r\n\r\n\t\tvar q1 = new Quaternion();\r\n\t\tvar m1 = new Matrix4();\r\n\t\tvar target = new Vector3();\r\n\t\tvar position = new Vector3();\r\n\r\n\t\treturn function lookAt( x, y, z ) {\r\n\r\n\t\t\tif ( x.isVector3 ) {\r\n\r\n\t\t\t\ttarget.copy( x );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttarget.set( x, y, z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar parent = this.parent;\r\n\r\n\t\t\tthis.updateWorldMatrix( true, false );\r\n\r\n\t\t\tposition.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t\t\tif ( this.isCamera || this.isLight ) {\r\n\r\n\t\t\t\tm1.lookAt( position, target, this.up );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tm1.lookAt( target, position, this.up );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\r\n\r\n\t\t\tif ( parent ) {\r\n\r\n\t\t\t\tm1.extractRotation( parent.matrixWorld );\r\n\t\t\t\tq1.setFromRotationMatrix( m1 );\r\n\t\t\t\tthis.quaternion.premultiply( q1.inverse() );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tadd: function ( object ) {\r\n\r\n\t\tif ( arguments.length > 1 ) {\r\n\r\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\r\n\r\n\t\t\t\tthis.add( arguments[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tif ( object === this ) {\r\n\r\n\t\t\tconsole.error( \"COOL.Object3D.add: object can't be added as a child of itself.\", object );\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ( object && object.isObject3D ) ) {\r\n\r\n\t\t\tif ( object.parent !== null ) {\r\n\r\n\t\t\t\tobject.parent.remove( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject.parent = this;\r\n\t\t\tobject.dispatchEvent( { type: 'added' } );\r\n\r\n\t\t\tthis.children.push( object );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.error( \"COOL.Object3D.add: object not an instance of COOL.Object3D.\", object );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tremove: function ( object ) {\r\n\r\n\t\tif ( arguments.length > 1 ) {\r\n\r\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\r\n\r\n\t\t\t\tthis.remove( arguments[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tvar index = this.children.indexOf( object );\r\n\r\n\t\tif ( index !== - 1 ) {\r\n\r\n\t\t\tobject.parent = null;\r\n\r\n\t\t\tobject.dispatchEvent( { type: 'removed' } );\r\n\r\n\t\t\tthis.children.splice( index, 1 );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetObjectById: function ( id ) {\r\n\r\n\t\treturn this.getObjectByProperty( 'id', id );\r\n\r\n\t},\r\n\r\n\tgetObjectByName: function ( name ) {\r\n\r\n\t\treturn this.getObjectByProperty( 'name', name );\r\n\r\n\t},\r\n\r\n\tgetObjectByProperty: function ( name, value ) {\r\n\r\n\t\tif ( this[ name ] === value ) return this;\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar child = this.children[ i ];\r\n\t\t\tvar object = child.getObjectByProperty( name, value );\r\n\r\n\t\t\tif ( object !== undefined ) {\r\n\r\n\t\t\t\treturn object;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn undefined;\r\n\r\n\t},\r\n\r\n\tgetWorldPosition: function ( target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Object3D: .getWorldPosition() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\treturn target.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t},\r\n\r\n\tgetWorldQuaternion: function () {\r\n\r\n\t\tvar position = new Vector3();\r\n\t\tvar scale = new Vector3();\r\n\r\n\t\treturn function getWorldQuaternion( target ) {\r\n\r\n\t\t\tif ( target === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'COOL.Object3D: .getWorldQuaternion() target is now required' );\r\n\t\t\t\ttarget = new Quaternion();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\t\tthis.matrixWorld.decompose( position, target, scale );\r\n\r\n\t\t\treturn target;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetWorldScale: function () {\r\n\r\n\t\tvar position = new Vector3();\r\n\t\tvar quaternion = new Quaternion();\r\n\r\n\t\treturn function getWorldScale( target ) {\r\n\r\n\t\t\tif ( target === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'COOL.Object3D: .getWorldScale() target is now required' );\r\n\t\t\t\ttarget = new Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\t\tthis.matrixWorld.decompose( position, quaternion, target );\r\n\r\n\t\t\treturn target;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetWorldDirection: function ( target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.Object3D: .getWorldDirection() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\tvar e = this.matrixWorld.elements;\r\n\r\n\t\treturn target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();\r\n\r\n\t},\r\n\r\n\traycast: function () {},\r\n\r\n\ttraverse: function ( callback ) {\r\n\r\n\t\tcallback( this );\r\n\r\n\t\tvar children = this.children;\r\n\r\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tchildren[ i ].traverse( callback );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttraverseVisible: function ( callback ) {\r\n\r\n\t\tif ( this.visible === false ) return;\r\n\r\n\t\tcallback( this );\r\n\r\n\t\tvar children = this.children;\r\n\r\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tchildren[ i ].traverseVisible( callback );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttraverseAncestors: function ( callback ) {\r\n\r\n\t\tvar parent = this.parent;\r\n\r\n\t\tif ( parent !== null ) {\r\n\r\n\t\t\tcallback( parent );\r\n\r\n\t\t\tparent.traverseAncestors( callback );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tupdateMatrix: function () {\r\n\r\n\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\r\n\r\n\t\tthis.matrixWorldNeedsUpdate = true;\r\n\r\n\t},\r\n\r\n\tupdateMatrixWorld: function ( force ) {\r\n\r\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\r\n\r\n\t\tif ( this.matrixWorldNeedsUpdate || force ) {\r\n\r\n\t\t\tif ( this.parent === null ) {\r\n\r\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.matrixWorldNeedsUpdate = false;\r\n\r\n\t\t\tforce = true;\r\n\r\n\t\t}\r\n\r\n\t\t// update children\r\n\r\n\t\tvar children = this.children;\r\n\r\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tchildren[ i ].updateMatrixWorld( force );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tupdateWorldMatrix: function ( updateParents, updateChildren ) {\r\n\r\n\t\tvar parent = this.parent;\r\n\r\n\t\tif ( updateParents === true && parent !== null ) {\r\n\r\n\t\t\tparent.updateWorldMatrix( true, false );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\r\n\r\n\t\tif ( this.parent === null ) {\r\n\r\n\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n\t\t}\r\n\r\n\t\t// update children\r\n\r\n\t\tif ( updateChildren === true ) {\r\n\r\n\t\t\tvar children = this.children;\r\n\r\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tchildren[ i ].updateWorldMatrix( false, true );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttoJSON: function ( meta ) {\r\n\r\n\t\t// meta is a string when called from JSON.stringify\r\n\t\tvar isRootObject = ( meta === undefined || typeof meta === 'string' );\r\n\r\n\t\tvar output = {};\r\n\r\n\t\t// meta is a hash used to collect geometries, materials.\r\n\t\t// not providing it implies that this is the root object\r\n\t\t// being serialized.\r\n\t\tif ( isRootObject ) {\r\n\r\n\t\t\t// initialize meta obj\r\n\t\t\tmeta = {\r\n\t\t\t\tgeometries: {},\r\n\t\t\t\tmaterials: {},\r\n\t\t\t\ttextures: {},\r\n\t\t\t\timages: {},\r\n\t\t\t\tshapes: {}\r\n\t\t\t};\r\n\r\n\t\t\toutput.metadata = {\r\n\t\t\t\tversion: 4.5,\r\n\t\t\t\ttype: 'Object',\r\n\t\t\t\tgenerator: 'Object3D.toJSON'\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\t// standard Object3D serialization\r\n\r\n\t\tvar object = {};\r\n\r\n\t\tobject.uuid = this.uuid;\r\n\t\tobject.type = this.type;\r\n\r\n\t\tif ( this.name !== '' ) object.name = this.name;\r\n\t\tif ( this.castShadow === true ) object.castShadow = true;\r\n\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\r\n\t\tif ( this.visible === false ) object.visible = false;\r\n\t\tif ( this.frustumCulled === false ) object.frustumCulled = false;\r\n\t\tif ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;\r\n\t\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\r\n\r\n\t\tobject.layers = this.layers.mask;\r\n\t\tobject.matrix = this.matrix.toArray();\r\n\r\n\t\tif ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;\r\n\r\n\t\t//\r\n\r\n\t\tfunction serialize( library, element ) {\r\n\r\n\t\t\tif ( library[ element.uuid ] === undefined ) {\r\n\r\n\t\t\t\tlibrary[ element.uuid ] = element.toJSON( meta );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn element.uuid;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.isMesh || this.isLine || this.isPoints ) {\r\n\r\n\t\t\tobject.geometry = serialize( meta.geometries, this.geometry );\r\n\r\n\t\t\tvar parameters = this.geometry.parameters;\r\n\r\n\t\t\tif ( parameters !== undefined && parameters.shapes !== undefined ) {\r\n\r\n\t\t\t\tvar shapes = parameters.shapes;\r\n\r\n\t\t\t\tif ( Array.isArray( shapes ) ) {\r\n\r\n\t\t\t\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar shape = shapes[ i ];\r\n\r\n\t\t\t\t\t\tserialize( meta.shapes, shape );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tserialize( meta.shapes, shapes );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.material !== undefined ) {\r\n\r\n\t\t\tif ( Array.isArray( this.material ) ) {\r\n\r\n\t\t\t\tvar uuids = [];\r\n\r\n\t\t\t\tfor ( var i = 0, l = this.material.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tuuids.push( serialize( meta.materials, this.material[ i ] ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tobject.material = uuids;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tobject.material = serialize( meta.materials, this.material );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( this.children.length > 0 ) {\r\n\r\n\t\t\tobject.children = [];\r\n\r\n\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\r\n\r\n\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( isRootObject ) {\r\n\r\n\t\t\tvar geometries = extractFromCache( meta.geometries );\r\n\t\t\tvar materials = extractFromCache( meta.materials );\r\n\t\t\tvar textures = extractFromCache( meta.textures );\r\n\t\t\tvar images = extractFromCache( meta.images );\r\n\t\t\tvar shapes = extractFromCache( meta.shapes );\r\n\r\n\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\r\n\t\t\tif ( materials.length > 0 ) output.materials = materials;\r\n\t\t\tif ( textures.length > 0 ) output.textures = textures;\r\n\t\t\tif ( images.length > 0 ) output.images = images;\r\n\t\t\tif ( shapes.length > 0 ) output.shapes = shapes;\r\n\r\n\t\t}\r\n\r\n\t\toutput.object = object;\r\n\r\n\t\treturn output;\r\n\r\n\t\t// extract data from the cache hash\r\n\t\t// remove metadata on each item\r\n\t\t// and return as array\r\n\t\tfunction extractFromCache( cache ) {\r\n\r\n\t\t\tvar values = [];\r\n\t\t\tfor ( var key in cache ) {\r\n\r\n\t\t\t\tvar data = cache[ key ];\r\n\t\t\t\tdelete data.metadata;\r\n\t\t\t\tvalues.push( data );\r\n\r\n\t\t\t}\r\n\t\t\treturn values;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tclone: function ( recursive ) {\r\n\r\n\t\treturn new this.constructor().copy( this, recursive );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source, recursive ) {\r\n\r\n\t\tif ( recursive === undefined ) recursive = true;\r\n\r\n\t\tthis.name = source.name;\r\n\r\n\t\tthis.up.copy( source.up );\r\n\r\n\t\tthis.position.copy( source.position );\r\n\t\tthis.quaternion.copy( source.quaternion );\r\n\t\tthis.scale.copy( source.scale );\r\n\r\n\t\tthis.matrix.copy( source.matrix );\r\n\t\tthis.matrixWorld.copy( source.matrixWorld );\r\n\r\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\r\n\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\r\n\r\n\t\tthis.layers.mask = source.layers.mask;\r\n\t\tthis.visible = source.visible;\r\n\r\n\t\tthis.castShadow = source.castShadow;\r\n\t\tthis.receiveShadow = source.receiveShadow;\r\n\r\n\t\tthis.frustumCulled = source.frustumCulled;\r\n\t\tthis.renderOrder = source.renderOrder;\r\n\r\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\r\n\r\n\t\tif ( recursive === true ) {\r\n\r\n\t\t\tfor ( var i = 0; i < source.children.length; i ++ ) {\r\n\r\n\t\t\t\tvar child = source.children[ i ];\r\n\t\t\t\tthis.add( child.clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/loader/Geometry.js\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author kile / http://kile.stravaganza.org/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nvar geometryId = 0; // Geometry uses even numbers as Id\r\n\r\nfunction loader_Geometry_Geometry() {\r\n\r\n\tObject.defineProperty( this, 'id', { value: geometryId += 2 } );\r\n\r\n\tthis.uuid = _Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'Geometry';\r\n\r\n\tthis.vertices = [];\r\n\tthis.colors = [];\r\n\tthis.faces = [];\r\n\tthis.faceVertexUvs = [[]];\r\n\r\n\tthis.morphTargets = [];\r\n\tthis.morphNormals = [];\r\n\r\n\tthis.skinWeights = [];\r\n\tthis.skinIndices = [];\r\n\r\n\tthis.lineDistances = [];\r\n\r\n\tthis.boundingBox = null;\r\n\tthis.boundingSphere = null;\r\n\r\n\t// update flags\r\n\r\n\tthis.elementsNeedUpdate = false;\r\n\tthis.verticesNeedUpdate = false;\r\n\tthis.uvsNeedUpdate = false;\r\n\tthis.normalsNeedUpdate = false;\r\n\tthis.colorsNeedUpdate = false;\r\n\tthis.lineDistancesNeedUpdate = false;\r\n\tthis.groupsNeedUpdate = false;\r\n\r\n}\r\n\r\nloader_Geometry_Geometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\r\n\r\n\tconstructor: loader_Geometry_Geometry,\r\n\r\n\tisGeometry: true,\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\r\n\r\n\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar vertex = this.vertices[ i ];\r\n\t\t\tvertex.applyMatrix4( matrix );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar face = this.faces[ i ];\r\n\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingBox !== null ) {\r\n\r\n\t\t\tthis.computeBoundingBox();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.computeBoundingSphere();\r\n\r\n\t\t}\r\n\r\n\t\tthis.verticesNeedUpdate = true;\r\n\t\tthis.normalsNeedUpdate = true;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trotateX: function () {\r\n\r\n\t\t// rotate geometry around world x-axis\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function rotateX( angle ) {\r\n\r\n\t\t\tm1.makeRotationX( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateY: function () {\r\n\r\n\t\t// rotate geometry around world y-axis\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function rotateY( angle ) {\r\n\r\n\t\t\tm1.makeRotationY( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateZ: function () {\r\n\r\n\t\t// rotate geometry around world z-axis\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function rotateZ( angle ) {\r\n\r\n\t\t\tm1.makeRotationZ( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function () {\r\n\r\n\t\t// translate geometry\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function translate( x, y, z ) {\r\n\r\n\t\t\tm1.makeTranslation( x, y, z );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tscale: function () {\r\n\r\n\t\t// scale geometry\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function scale( x, y, z ) {\r\n\r\n\t\t\tm1.makeScale( x, y, z );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlookAt: function () {\r\n\r\n\t\tvar obj = new Object3D();\r\n\r\n\t\treturn function lookAt( vector ) {\r\n\r\n\t\t\tobj.lookAt( vector );\r\n\r\n\t\t\tobj.updateMatrix();\r\n\r\n\t\t\tthis.applyMatrix( obj.matrix );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tfromBufferGeometry: function ( geometry ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\r\n\t\tvar attributes = geometry.attributes;\r\n\r\n\t\tvar positions = attributes.position.array;\r\n\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\r\n\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\r\n\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\r\n\t\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\r\n\r\n\t\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\r\n\r\n\t\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\r\n\r\n\t\t\tscope.vertices.push( new Vector3().fromArray( positions, i ) );\r\n\r\n\t\t\tif ( colors !== undefined ) {\r\n\r\n\t\t\t\tscope.colors.push( new Color().fromArray( colors, i ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction addFace( a, b, c, materialIndex ) {\r\n\r\n\t\t\tvar vertexColors = ( colors === undefined ) ? [] : [\r\n\t\t\t\tscope.colors[ a ].clone(),\r\n\t\t\t\tscope.colors[ b ].clone(),\r\n\t\t\t\tscope.colors[ c ].clone() ];\r\n\r\n\t\t\tvar vertexNormals = ( normals === undefined ) ? [] : [\r\n\t\t\t\tnew Vector3().fromArray( normals, a * 3 ),\r\n\t\t\t\tnew Vector3().fromArray( normals, b * 3 ),\r\n\t\t\t\tnew Vector3().fromArray( normals, c * 3 )\r\n\t\t\t];\r\n\r\n\t\t\tvar face = new Face3_Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\r\n\r\n\t\t\tscope.faces.push( face );\r\n\r\n\t\t\tif ( uvs !== undefined ) {\r\n\r\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [\r\n\t\t\t\t\tnew Vector2().fromArray( uvs, a * 2 ),\r\n\t\t\t\t\tnew Vector2().fromArray( uvs, b * 2 ),\r\n\t\t\t\t\tnew Vector2().fromArray( uvs, c * 2 )\r\n\t\t\t\t] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( uvs2 !== undefined ) {\r\n\r\n\t\t\t\tscope.faceVertexUvs[ 1 ].push( [\r\n\t\t\t\t\tnew Vector2().fromArray( uvs2, a * 2 ),\r\n\t\t\t\t\tnew Vector2().fromArray( uvs2, b * 2 ),\r\n\t\t\t\t\tnew Vector2().fromArray( uvs2, c * 2 )\r\n\t\t\t\t] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar groups = geometry.groups;\r\n\r\n\t\tif ( groups.length > 0 ) {\r\n\r\n\t\t\tfor ( var i = 0; i < groups.length; i ++ ) {\r\n\r\n\t\t\t\tvar group = groups[ i ];\r\n\r\n\t\t\t\tvar start = group.start;\r\n\t\t\t\tvar count = group.count;\r\n\r\n\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\r\n\r\n\t\t\t\t\tif ( indices !== undefined ) {\r\n\r\n\t\t\t\t\t\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\taddFace( j, j + 1, j + 2, group.materialIndex );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( indices !== undefined ) {\r\n\r\n\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\r\n\r\n\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\r\n\r\n\t\t\t\t\taddFace( i, i + 1, i + 2 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.computeFaceNormals();\r\n\r\n\t\tif ( geometry.boundingBox !== null ) {\r\n\r\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcenter: function () {\r\n\r\n\t\tvar offset = new Vector3();\r\n\r\n\t\treturn function center() {\r\n\r\n\t\t\tthis.computeBoundingBox();\r\n\r\n\t\t\tthis.boundingBox.getCenter( offset ).negate();\r\n\r\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tnormalize: function () {\r\n\r\n\t\tthis.computeBoundingSphere();\r\n\r\n\t\tvar center = this.boundingSphere.center;\r\n\t\tvar radius = this.boundingSphere.radius;\r\n\r\n\t\tvar s = radius === 0 ? 1 : 1.0 / radius;\r\n\r\n\t\tvar matrix = new Matrix4();\r\n\t\tmatrix.set(\r\n\t\t\ts, 0, 0, - s * center.x,\r\n\t\t\t0, s, 0, - s * center.y,\r\n\t\t\t0, 0, s, - s * center.z,\r\n\t\t\t0, 0, 0, 1\r\n\t\t);\r\n\r\n\t\tthis.applyMatrix( matrix );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcomputeFaceNormals: function () {\r\n\r\n\t\tvar cb = new Vector3(), ab = new Vector3();\r\n\r\n\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tvar face = this.faces[ f ];\r\n\r\n\t\t\tvar vA = this.vertices[ face.a ];\r\n\t\t\tvar vB = this.vertices[ face.b ];\r\n\t\t\tvar vC = this.vertices[ face.c ];\r\n\r\n\t\t\tcb.subVectors( vC, vB );\r\n\t\t\tab.subVectors( vA, vB );\r\n\t\t\tcb.cross( ab );\r\n\r\n\t\t\tcb.normalize();\r\n\r\n\t\t\tface.normal.copy( cb );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeVertexNormals: function ( areaWeighted ) {\r\n\r\n\t\tif ( areaWeighted === undefined ) areaWeighted = true;\r\n\r\n\t\tvar v, vl, f, fl, face, vertices;\r\n\r\n\t\tvertices = new Array( this.vertices.length );\r\n\r\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\tvertices[ v ] = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tif ( areaWeighted ) {\r\n\r\n\t\t\t// vertex normals weighted by triangle areas\r\n\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\r\n\r\n\t\t\tvar vA, vB, vC;\r\n\t\t\tvar cb = new Vector3(), ab = new Vector3();\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tvA = this.vertices[ face.a ];\r\n\t\t\t\tvB = this.vertices[ face.b ];\r\n\t\t\t\tvC = this.vertices[ face.c ];\r\n\r\n\t\t\t\tcb.subVectors( vC, vB );\r\n\t\t\t\tab.subVectors( vA, vB );\r\n\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\tvertices[ face.a ].add( cb );\r\n\t\t\t\tvertices[ face.b ].add( cb );\r\n\t\t\t\tvertices[ face.c ].add( cb );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.computeFaceNormals();\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tvertices[ face.a ].add( face.normal );\r\n\t\t\t\tvertices[ face.b ].add( face.normal );\r\n\t\t\t\tvertices[ face.c ].add( face.normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\tvertices[ v ].normalize();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tvar vertexNormals = face.vertexNormals;\r\n\r\n\t\t\tif ( vertexNormals.length === 3 ) {\r\n\r\n\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\r\n\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\r\n\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\r\n\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\r\n\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.faces.length > 0 ) {\r\n\r\n\t\t\tthis.normalsNeedUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeFlatVertexNormals: function () {\r\n\r\n\t\tvar f, fl, face;\r\n\r\n\t\tthis.computeFaceNormals();\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tvar vertexNormals = face.vertexNormals;\r\n\r\n\t\t\tif ( vertexNormals.length === 3 ) {\r\n\r\n\t\t\t\tvertexNormals[ 0 ].copy( face.normal );\r\n\t\t\t\tvertexNormals[ 1 ].copy( face.normal );\r\n\t\t\t\tvertexNormals[ 2 ].copy( face.normal );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvertexNormals[ 0 ] = face.normal.clone();\r\n\t\t\t\tvertexNormals[ 1 ] = face.normal.clone();\r\n\t\t\t\tvertexNormals[ 2 ] = face.normal.clone();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.faces.length > 0 ) {\r\n\r\n\t\t\tthis.normalsNeedUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeMorphNormals: function () {\r\n\r\n\t\tvar i, il, f, fl, face;\r\n\r\n\t\t// save original normals\r\n\t\t// - create temp variables on first access\r\n\t\t//   otherwise just copy (for faster repeated calls)\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tif ( ! face.__originalFaceNormal ) {\r\n\r\n\t\t\t\tface.__originalFaceNormal = face.normal.clone();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tface.__originalFaceNormal.copy( face.normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\r\n\r\n\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\r\n\r\n\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// use temp geometry to compute face and vertex normals for each morph\r\n\r\n\t\tvar tmpGeo = new loader_Geometry_Geometry();\r\n\t\ttmpGeo.faces = this.faces;\r\n\r\n\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\t\t// create on first access\r\n\r\n\t\t\tif ( ! this.morphNormals[ i ] ) {\r\n\r\n\t\t\t\tthis.morphNormals[ i ] = {};\r\n\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\r\n\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\r\n\r\n\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\r\n\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\r\n\r\n\t\t\t\tvar faceNormal, vertexNormals;\r\n\r\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\tfaceNormal = new Vector3();\r\n\t\t\t\t\tvertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };\r\n\r\n\t\t\t\t\tdstNormalsFace.push( faceNormal );\r\n\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar morphNormals = this.morphNormals[ i ];\r\n\r\n\t\t\t// set vertices to morph target\r\n\r\n\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\r\n\r\n\t\t\t// compute morph normals\r\n\r\n\t\t\ttmpGeo.computeFaceNormals();\r\n\t\t\ttmpGeo.computeVertexNormals();\r\n\r\n\t\t\t// store morph normals\r\n\r\n\t\t\tvar faceNormal, vertexNormals;\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\r\n\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\r\n\r\n\t\t\t\tfaceNormal.copy( face.normal );\r\n\r\n\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\r\n\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\r\n\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// restore original normals\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tface.normal = face.__originalFaceNormal;\r\n\t\t\tface.vertexNormals = face.__originalVertexNormals;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeBoundingBox: function () {\r\n\r\n\t\tif ( this.boundingBox === null ) {\r\n\r\n\t\t\tthis.boundingBox = new Box3();\r\n\r\n\t\t}\r\n\r\n\t\tthis.boundingBox.setFromPoints( this.vertices );\r\n\r\n\t},\r\n\r\n\tcomputeBoundingSphere: function () {\r\n\r\n\t\tif ( this.boundingSphere === null ) {\r\n\r\n\t\t\tthis.boundingSphere = new Sphere();\r\n\r\n\t\t}\r\n\r\n\t\tthis.boundingSphere.setFromPoints( this.vertices );\r\n\r\n\t},\r\n\r\n\tmerge: function ( geometry, matrix, materialIndexOffset ) {\r\n\r\n\t\tif ( ! ( geometry && geometry.isGeometry ) ) {\r\n\r\n\t\t\tconsole.error( 'COOL.Geometry.merge(): geometry not an instance of COOL.Geometry.', geometry );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar normalMatrix,\r\n\t\t\tvertexOffset = this.vertices.length,\r\n\t\t\tvertices1 = this.vertices,\r\n\t\t\tvertices2 = geometry.vertices,\r\n\t\t\tfaces1 = this.faces,\r\n\t\t\tfaces2 = geometry.faces,\r\n\t\t\tuvs1 = this.faceVertexUvs[ 0 ],\r\n\t\t\tuvs2 = geometry.faceVertexUvs[ 0 ],\r\n\t\t\tcolors1 = this.colors,\r\n\t\t\tcolors2 = geometry.colors;\r\n\r\n\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\r\n\r\n\t\tif ( matrix !== undefined ) {\r\n\r\n\t\t\tnormalMatrix = new Matrix3().getNormalMatrix( matrix );\r\n\r\n\t\t}\r\n\r\n\t\t// vertices\r\n\r\n\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar vertex = vertices2[ i ];\r\n\r\n\t\t\tvar vertexCopy = vertex.clone();\r\n\r\n\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\r\n\r\n\t\t\tvertices1.push( vertexCopy );\r\n\r\n\t\t}\r\n\r\n\t\t// colors\r\n\r\n\t\tfor ( var i = 0, il = colors2.length; i < il; i ++ ) {\r\n\r\n\t\t\tcolors1.push( colors2[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\t// faces\r\n\r\n\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\r\n\t\t\t\tfaceVertexNormals = face.vertexNormals,\r\n\t\t\t\tfaceVertexColors = face.vertexColors;\r\n\r\n\t\t\tfaceCopy = new Face3_Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\r\n\t\t\tfaceCopy.normal.copy( face.normal );\r\n\r\n\t\t\tif ( normalMatrix !== undefined ) {\r\n\r\n\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tnormal = faceVertexNormals[ j ].clone();\r\n\r\n\t\t\t\tif ( normalMatrix !== undefined ) {\r\n\r\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfaceCopy.vertexNormals.push( normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfaceCopy.color.copy( face.color );\r\n\r\n\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tcolor = faceVertexColors[ j ];\r\n\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\r\n\r\n\t\t\tfaces1.push( faceCopy );\r\n\r\n\t\t}\r\n\r\n\t\t// uvs\r\n\r\n\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar uv = uvs2[ i ], uvCopy = [];\r\n\r\n\t\t\tif ( uv === undefined ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tuvCopy.push( uv[ j ].clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuvs1.push( uvCopy );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tmergeMesh: function ( mesh ) {\r\n\r\n\t\tif ( ! ( mesh && mesh.isMesh ) ) {\r\n\r\n\t\t\tconsole.error( 'COOL.Geometry.mergeMesh(): mesh not an instance of COOL.Mesh.', mesh );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( mesh.matrixAutoUpdate ) mesh.updateMatrix();\r\n\r\n\t\tthis.merge( mesh.geometry, mesh.matrix );\r\n\r\n\t},\r\n\r\n\t/*\r\n\t * Checks for duplicate vertices with hashmap.\r\n\t * Duplicated vertices are removed\r\n\t * and faces' vertices are updated.\r\n\t */\r\n\r\n\tmergeVertices: function () {\r\n\r\n\t\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\r\n\t\tvar unique = [], changes = [];\r\n\r\n\t\tvar v, key;\r\n\t\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\r\n\t\tvar precision = Math.pow( 10, precisionPoints );\r\n\t\tvar i, il, face;\r\n\t\tvar indices, j, jl;\r\n\r\n\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tv = this.vertices[ i ];\r\n\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\r\n\r\n\t\t\tif ( verticesMap[ key ] === undefined ) {\r\n\r\n\t\t\t\tverticesMap[ key ] = i;\r\n\t\t\t\tunique.push( this.vertices[ i ] );\r\n\t\t\t\tchanges[ i ] = unique.length - 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\r\n\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\t// if faces are completely degenerate after merging vertices, we\r\n\t\t// have to remove them from the geometry.\r\n\t\tvar faceIndicesToRemove = [];\r\n\r\n\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tface = this.faces[ i ];\r\n\r\n\t\t\tface.a = changes[ face.a ];\r\n\t\t\tface.b = changes[ face.b ];\r\n\t\t\tface.c = changes[ face.c ];\r\n\r\n\t\t\tindices = [ face.a, face.b, face.c ];\r\n\r\n\t\t\t// if any duplicate vertices are found in a Face3\r\n\t\t\t// we have to remove the face as nothing can be saved\r\n\t\t\tfor ( var n = 0; n < 3; n ++ ) {\r\n\r\n\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\r\n\r\n\t\t\t\t\tfaceIndicesToRemove.push( i );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\r\n\r\n\t\t\tvar idx = faceIndicesToRemove[ i ];\r\n\r\n\t\t\tthis.faces.splice( idx, 1 );\r\n\r\n\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Use unique set of vertices\r\n\r\n\t\tvar diff = this.vertices.length - unique.length;\r\n\t\tthis.vertices = unique;\r\n\t\treturn diff;\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function ( points ) {\r\n\r\n\t\tthis.vertices = [];\r\n\r\n\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar point = points[ i ];\r\n\t\t\tthis.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsortFacesByMaterialIndex: function () {\r\n\r\n\t\tvar faces = this.faces;\r\n\t\tvar length = faces.length;\r\n\r\n\t\t// tag faces\r\n\r\n\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\r\n\t\t\tfaces[ i ]._id = i;\r\n\r\n\t\t}\r\n\r\n\t\t// sort faces\r\n\r\n\t\tfunction materialIndexSort( a, b ) {\r\n\r\n\t\t\treturn a.materialIndex - b.materialIndex;\r\n\r\n\t\t}\r\n\r\n\t\tfaces.sort( materialIndexSort );\r\n\r\n\t\t// sort uvs\r\n\r\n\t\tvar uvs1 = this.faceVertexUvs[ 0 ];\r\n\t\tvar uvs2 = this.faceVertexUvs[ 1 ];\r\n\r\n\t\tvar newUvs1, newUvs2;\r\n\r\n\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\r\n\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\r\n\r\n\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\r\n\t\t\tvar id = faces[ i ]._id;\r\n\r\n\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\r\n\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\r\n\r\n\t\t}\r\n\r\n\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\r\n\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar data = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.5,\r\n\t\t\t\ttype: 'Geometry',\r\n\t\t\t\tgenerator: 'Geometry.toJSON'\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// standard Geometry serialization\r\n\r\n\t\tdata.uuid = this.uuid;\r\n\t\tdata.type = this.type;\r\n\t\tif ( this.name !== '' ) data.name = this.name;\r\n\r\n\t\tif ( this.parameters !== undefined ) {\r\n\r\n\t\t\tvar parameters = this.parameters;\r\n\r\n\t\t\tfor ( var key in parameters ) {\r\n\r\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tvar vertices = [];\r\n\r\n\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\r\n\r\n\t\t\tvar vertex = this.vertices[ i ];\r\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t}\r\n\r\n\t\tvar faces = [];\r\n\t\tvar normals = [];\r\n\t\tvar normalsHash = {};\r\n\t\tvar colors = [];\r\n\t\tvar colorsHash = {};\r\n\t\tvar uvs = [];\r\n\t\tvar uvsHash = {};\r\n\r\n\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\r\n\r\n\t\t\tvar face = this.faces[ i ];\r\n\r\n\t\t\tvar hasMaterial = true;\r\n\t\t\tvar hasFaceUv = false; // deprecated\r\n\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\r\n\t\t\tvar hasFaceNormal = face.normal.length() > 0;\r\n\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\r\n\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\r\n\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\r\n\r\n\t\t\tvar faceType = 0;\r\n\r\n\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\r\n\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\r\n\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\r\n\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\r\n\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\r\n\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\r\n\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\r\n\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\r\n\r\n\t\t\tfaces.push( faceType );\r\n\t\t\tfaces.push( face.a, face.b, face.c );\r\n\t\t\tfaces.push( face.materialIndex );\r\n\r\n\t\t\tif ( hasFaceVertexUv ) {\r\n\r\n\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\r\n\r\n\t\t\t\tfaces.push(\r\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\r\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\r\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceNormal ) {\r\n\r\n\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexNormal ) {\r\n\r\n\t\t\t\tvar vertexNormals = face.vertexNormals;\r\n\r\n\t\t\t\tfaces.push(\r\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\r\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\r\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceColor ) {\r\n\r\n\t\t\t\tfaces.push( getColorIndex( face.color ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexColor ) {\r\n\r\n\t\t\t\tvar vertexColors = face.vertexColors;\r\n\r\n\t\t\t\tfaces.push(\r\n\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\r\n\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\r\n\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction setBit( value, position, enabled ) {\r\n\r\n\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\r\n\r\n\t\t}\r\n\r\n\t\tfunction getNormalIndex( normal ) {\r\n\r\n\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\r\n\r\n\t\t\tif ( normalsHash[ hash ] !== undefined ) {\r\n\r\n\t\t\t\treturn normalsHash[ hash ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnormalsHash[ hash ] = normals.length / 3;\r\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\r\n\r\n\t\t\treturn normalsHash[ hash ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction getColorIndex( color ) {\r\n\r\n\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\r\n\r\n\t\t\tif ( colorsHash[ hash ] !== undefined ) {\r\n\r\n\t\t\t\treturn colorsHash[ hash ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcolorsHash[ hash ] = colors.length;\r\n\t\t\tcolors.push( color.getHex() );\r\n\r\n\t\t\treturn colorsHash[ hash ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction getUvIndex( uv ) {\r\n\r\n\t\t\tvar hash = uv.x.toString() + uv.y.toString();\r\n\r\n\t\t\tif ( uvsHash[ hash ] !== undefined ) {\r\n\r\n\t\t\t\treturn uvsHash[ hash ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuvsHash[ hash ] = uvs.length / 2;\r\n\t\t\tuvs.push( uv.x, uv.y );\r\n\r\n\t\t\treturn uvsHash[ hash ];\r\n\r\n\t\t}\r\n\r\n\t\tdata.data = {};\r\n\r\n\t\tdata.data.vertices = vertices;\r\n\t\tdata.data.normals = normals;\r\n\t\tif ( colors.length > 0 ) data.data.colors = colors;\r\n\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\r\n\t\tdata.data.faces = faces;\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\t/*\r\n\t\t // Handle primitives\r\n\r\n\t\t var parameters = this.parameters;\r\n\r\n\t\t if ( parameters !== undefined ) {\r\n\r\n\t\t var values = [];\r\n\r\n\t\t for ( var key in parameters ) {\r\n\r\n\t\t values.push( parameters[ key ] );\r\n\r\n\t\t }\r\n\r\n\t\t var geometry = Object.create( this.constructor.prototype );\r\n\t\t this.constructor.apply( geometry, values );\r\n\t\t return geometry;\r\n\r\n\t\t }\r\n\r\n\t\t return new this.constructor().copy( this );\r\n\t\t */\r\n\r\n\t\treturn new loader_Geometry_Geometry().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tvar i, il, j, jl, k, kl;\r\n\r\n\t\t// reset\r\n\r\n\t\tthis.vertices = [];\r\n\t\tthis.colors = [];\r\n\t\tthis.faces = [];\r\n\t\tthis.faceVertexUvs = [[]];\r\n\t\tthis.morphTargets = [];\r\n\t\tthis.morphNormals = [];\r\n\t\tthis.skinWeights = [];\r\n\t\tthis.skinIndices = [];\r\n\t\tthis.lineDistances = [];\r\n\t\tthis.boundingBox = null;\r\n\t\tthis.boundingSphere = null;\r\n\r\n\t\t// name\r\n\r\n\t\tthis.name = source.name;\r\n\r\n\t\t// vertices\r\n\r\n\t\tvar vertices = source.vertices;\r\n\r\n\t\tfor ( i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.vertices.push( vertices[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\t// colors\r\n\r\n\t\tvar colors = source.colors;\r\n\r\n\t\tfor ( i = 0, il = colors.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.colors.push( colors[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\t// faces\r\n\r\n\t\tvar faces = source.faces;\r\n\r\n\t\tfor ( i = 0, il = faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.faces.push( faces[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\t// face vertex uvs\r\n\r\n\t\tfor ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar faceVertexUvs = source.faceVertexUvs[ i ];\r\n\r\n\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\r\n\r\n\t\t\t\tthis.faceVertexUvs[ i ] = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\r\n\r\n\t\t\t\tfor ( k = 0, kl = uvs.length; k < kl; k ++ ) {\r\n\r\n\t\t\t\t\tvar uv = uvs[ k ];\r\n\r\n\t\t\t\t\tuvsCopy.push( uv.clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// morph targets\r\n\r\n\t\tvar morphTargets = source.morphTargets;\r\n\r\n\t\tfor ( i = 0, il = morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar morphTarget = {};\r\n\t\t\tmorphTarget.name = morphTargets[ i ].name;\r\n\r\n\t\t\t// vertices\r\n\r\n\t\t\tif ( morphTargets[ i ].vertices !== undefined ) {\r\n\r\n\t\t\t\tmorphTarget.vertices = [];\r\n\r\n\t\t\t\tfor ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tmorphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// normals\r\n\r\n\t\t\tif ( morphTargets[ i ].normals !== undefined ) {\r\n\r\n\t\t\t\tmorphTarget.normals = [];\r\n\r\n\t\t\t\tfor ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tmorphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.morphTargets.push( morphTarget );\r\n\r\n\t\t}\r\n\r\n\t\t// morph normals\r\n\r\n\t\tvar morphNormals = source.morphNormals;\r\n\r\n\t\tfor ( i = 0, il = morphNormals.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar morphNormal = {};\r\n\r\n\t\t\t// vertex normals\r\n\r\n\t\t\tif ( morphNormals[ i ].vertexNormals !== undefined ) {\r\n\r\n\t\t\t\tmorphNormal.vertexNormals = [];\r\n\r\n\t\t\t\tfor ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tvar srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];\r\n\t\t\t\t\tvar destVertexNormal = {};\r\n\r\n\t\t\t\t\tdestVertexNormal.a = srcVertexNormal.a.clone();\r\n\t\t\t\t\tdestVertexNormal.b = srcVertexNormal.b.clone();\r\n\t\t\t\t\tdestVertexNormal.c = srcVertexNormal.c.clone();\r\n\r\n\t\t\t\t\tmorphNormal.vertexNormals.push( destVertexNormal );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// face normals\r\n\r\n\t\t\tif ( morphNormals[ i ].faceNormals !== undefined ) {\r\n\r\n\t\t\t\tmorphNormal.faceNormals = [];\r\n\r\n\t\t\t\tfor ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tmorphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.morphNormals.push( morphNormal );\r\n\r\n\t\t}\r\n\r\n\t\t// skin weights\r\n\r\n\t\tvar skinWeights = source.skinWeights;\r\n\r\n\t\tfor ( i = 0, il = skinWeights.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.skinWeights.push( skinWeights[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\t// skin indices\r\n\r\n\t\tvar skinIndices = source.skinIndices;\r\n\r\n\t\tfor ( i = 0, il = skinIndices.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.skinIndices.push( skinIndices[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\t// line distances\r\n\r\n\t\tvar lineDistances = source.lineDistances;\r\n\r\n\t\tfor ( i = 0, il = lineDistances.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.lineDistances.push( lineDistances[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\t// bounding box\r\n\r\n\t\tvar boundingBox = source.boundingBox;\r\n\r\n\t\tif ( boundingBox !== null ) {\r\n\r\n\t\t\tthis.boundingBox = boundingBox.clone();\r\n\r\n\t\t}\r\n\r\n\t\t// bounding sphere\r\n\r\n\t\tvar boundingSphere = source.boundingSphere;\r\n\r\n\t\tif ( boundingSphere !== null ) {\r\n\r\n\t\t\tthis.boundingSphere = boundingSphere.clone();\r\n\r\n\t\t}\r\n\r\n\t\t// update flags\r\n\r\n\t\tthis.elementsNeedUpdate = source.elementsNeedUpdate;\r\n\t\tthis.verticesNeedUpdate = source.verticesNeedUpdate;\r\n\t\tthis.uvsNeedUpdate = source.uvsNeedUpdate;\r\n\t\tthis.normalsNeedUpdate = source.normalsNeedUpdate;\r\n\t\tthis.colorsNeedUpdate = source.colorsNeedUpdate;\r\n\t\tthis.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\r\n\t\tthis.groupsNeedUpdate = source.groupsNeedUpdate;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/loader/BufferAttribute.js\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nfunction BufferAttribute( array, itemSize, normalized ) {\r\n\r\n\tif ( Array.isArray( array ) ) {\r\n\r\n\t\tthrow new TypeError( 'COOL.BufferAttribute: array should be a Typed Array.' );\r\n\r\n\t}\r\n\r\n\tthis.name = '';\r\n\r\n\tthis.array = array;\r\n\tthis.itemSize = itemSize;\r\n\tthis.count = array !== undefined ? array.length / itemSize : 0;\r\n\tthis.normalized = normalized === true;\r\n\r\n\tthis.dynamic = false;\r\n\tthis.updateRange = { offset: 0, count: - 1 };\r\n\r\n\tthis.version = 0;\r\n\r\n}\r\n\r\nObject.defineProperty( BufferAttribute.prototype, 'needsUpdate', {\r\n\r\n\tset: function ( value ) {\r\n\r\n\t\tif ( value === true ) this.version ++;\r\n\r\n\t}\r\n\r\n} );\r\n\r\nObject.assign( BufferAttribute.prototype, {\r\n\r\n\tisBufferAttribute: true,\r\n\r\n\tonUploadCallback: function () {},\r\n\r\n\tsetArray: function ( array ) {\r\n\r\n\t\tif ( Array.isArray( array ) ) {\r\n\r\n\t\t\tthrow new TypeError( 'COOL.BufferAttribute: array should be a Typed Array.' );\r\n\r\n\t\t}\r\n\r\n\t\tthis.count = array !== undefined ? array.length / this.itemSize : 0;\r\n\t\tthis.array = array;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetDynamic: function ( value ) {\r\n\r\n\t\tthis.dynamic = value;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.name = source.name;\r\n\t\tthis.array = new source.array.constructor( source.array );\r\n\t\tthis.itemSize = source.itemSize;\r\n\t\tthis.count = source.count;\r\n\t\tthis.normalized = source.normalized;\r\n\r\n\t\tthis.dynamic = source.dynamic;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyAt: function ( index1, attribute, index2 ) {\r\n\r\n\t\tindex1 *= this.itemSize;\r\n\t\tindex2 *= attribute.itemSize;\r\n\r\n\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\r\n\r\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyArray: function ( array ) {\r\n\r\n\t\tthis.array.set( array );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyColorsArray: function ( colors ) {\r\n\r\n\t\tvar array = this.array, offset = 0;\r\n\r\n\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar color = colors[ i ];\r\n\r\n\t\t\tif ( color === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'COOL.BufferAttribute.copyColorsArray(): color is undefined', i );\r\n\t\t\t\tcolor = new Color();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tarray[ offset ++ ] = color.r;\r\n\t\t\tarray[ offset ++ ] = color.g;\r\n\t\t\tarray[ offset ++ ] = color.b;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyVector2sArray: function ( vectors ) {\r\n\r\n\t\tvar array = this.array, offset = 0;\r\n\r\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar vector = vectors[ i ];\r\n\r\n\t\t\tif ( vector === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'COOL.BufferAttribute.copyVector2sArray(): vector is undefined', i );\r\n\t\t\t\tvector = new Vector2();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tarray[ offset ++ ] = vector.x;\r\n\t\t\tarray[ offset ++ ] = vector.y;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyVector3sArray: function ( vectors ) {\r\n\r\n\t\tvar array = this.array, offset = 0;\r\n\r\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar vector = vectors[ i ];\r\n\r\n\t\t\tif ( vector === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'COOL.BufferAttribute.copyVector3sArray(): vector is undefined', i );\r\n\t\t\t\tvector = new Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tarray[ offset ++ ] = vector.x;\r\n\t\t\tarray[ offset ++ ] = vector.y;\r\n\t\t\tarray[ offset ++ ] = vector.z;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyVector4sArray: function ( vectors ) {\r\n\r\n\t\tvar array = this.array, offset = 0;\r\n\r\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar vector = vectors[ i ];\r\n\r\n\t\t\tif ( vector === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'COOL.BufferAttribute.copyVector4sArray(): vector is undefined', i );\r\n\t\t\t\tvector = new Vector4();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tarray[ offset ++ ] = vector.x;\r\n\t\t\tarray[ offset ++ ] = vector.y;\r\n\t\t\tarray[ offset ++ ] = vector.z;\r\n\t\t\tarray[ offset ++ ] = vector.w;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tset: function ( value, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.array.set( value, offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetX: function ( index ) {\r\n\r\n\t\treturn this.array[ index * this.itemSize ];\r\n\r\n\t},\r\n\r\n\tsetX: function ( index, x ) {\r\n\r\n\t\tthis.array[ index * this.itemSize ] = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetY: function ( index ) {\r\n\r\n\t\treturn this.array[ index * this.itemSize + 1 ];\r\n\r\n\t},\r\n\r\n\tsetY: function ( index, y ) {\r\n\r\n\t\tthis.array[ index * this.itemSize + 1 ] = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetZ: function ( index ) {\r\n\r\n\t\treturn this.array[ index * this.itemSize + 2 ];\r\n\r\n\t},\r\n\r\n\tsetZ: function ( index, z ) {\r\n\r\n\t\tthis.array[ index * this.itemSize + 2 ] = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetW: function ( index ) {\r\n\r\n\t\treturn this.array[ index * this.itemSize + 3 ];\r\n\r\n\t},\r\n\r\n\tsetW: function ( index, w ) {\r\n\r\n\t\tthis.array[ index * this.itemSize + 3 ] = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXY: function ( index, x, y ) {\r\n\r\n\t\tindex *= this.itemSize;\r\n\r\n\t\tthis.array[ index + 0 ] = x;\r\n\t\tthis.array[ index + 1 ] = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXYZ: function ( index, x, y, z ) {\r\n\r\n\t\tindex *= this.itemSize;\r\n\r\n\t\tthis.array[ index + 0 ] = x;\r\n\t\tthis.array[ index + 1 ] = y;\r\n\t\tthis.array[ index + 2 ] = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXYZW: function ( index, x, y, z, w ) {\r\n\r\n\t\tindex *= this.itemSize;\r\n\r\n\t\tthis.array[ index + 0 ] = x;\r\n\t\tthis.array[ index + 1 ] = y;\r\n\t\tthis.array[ index + 2 ] = z;\r\n\t\tthis.array[ index + 3 ] = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tonUpload: function ( callback ) {\r\n\r\n\t\tthis.onUploadCallback = callback;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.array, this.itemSize ).copy( this );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n//\r\n\r\nfunction Int8BufferAttribute( array, itemSize, normalized ) {\r\n\r\n\tBufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );\r\n\r\n}\r\n\r\nInt8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\r\nInt8BufferAttribute.prototype.constructor = Int8BufferAttribute;\r\n\r\n\r\nfunction Uint8BufferAttribute( array, itemSize, normalized ) {\r\n\r\n\tBufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );\r\n\r\n}\r\n\r\nUint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\r\nUint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;\r\n\r\n\r\nfunction Uint8ClampedBufferAttribute( array, itemSize, normalized ) {\r\n\r\n\tBufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );\r\n\r\n}\r\n\r\nUint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );\r\nUint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;\r\n\r\n\r\nfunction Int16BufferAttribute( array, itemSize, normalized ) {\r\n\r\n\tBufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );\r\n\r\n}\r\n\r\nInt16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\r\nInt16BufferAttribute.prototype.constructor = Int16BufferAttribute;\r\n\r\n\r\nfunction Uint16BufferAttribute( array, itemSize, normalized ) {\r\n\r\n\tBufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );\r\n\r\n}\r\n\r\nUint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\r\nUint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;\r\n\r\n\r\nfunction Int32BufferAttribute( array, itemSize, normalized ) {\r\n\r\n\tBufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );\r\n\r\n}\r\n\r\nInt32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\r\nInt32BufferAttribute.prototype.constructor = Int32BufferAttribute;\r\n\r\n\r\nfunction Uint32BufferAttribute( array, itemSize, normalized ) {\r\n\r\n\tBufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );\r\n\r\n}\r\n\r\nUint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\r\nUint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;\r\n\r\n\r\nfunction Float32BufferAttribute( array, itemSize, normalized ) {\r\n\r\n\tBufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );\r\n\r\n}\r\n\r\nFloat32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\r\nFloat32BufferAttribute.prototype.constructor = Float32BufferAttribute;\r\n\r\n\r\nfunction Float64BufferAttribute( array, itemSize, normalized ) {\r\n\r\n\tBufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );\r\n\r\n}\r\n\r\nFloat64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\r\nFloat64BufferAttribute.prototype.constructor = Float64BufferAttribute;\r\n\r\n//\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/loader/DirectGeometry.js\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\n\r\n\r\nfunction DirectGeometry() {\r\n\r\n\tthis.vertices = [];\r\n\tthis.normals = [];\r\n\tthis.colors = [];\r\n\tthis.uvs = [];\r\n\tthis.uvs2 = [];\r\n\r\n\tthis.groups = [];\r\n\r\n\tthis.morphTargets = {};\r\n\r\n\tthis.skinWeights = [];\r\n\tthis.skinIndices = [];\r\n\r\n\t// this.lineDistances = [];\r\n\r\n\tthis.boundingBox = null;\r\n\tthis.boundingSphere = null;\r\n\r\n\t// update flags\r\n\r\n\tthis.verticesNeedUpdate = false;\r\n\tthis.normalsNeedUpdate = false;\r\n\tthis.colorsNeedUpdate = false;\r\n\tthis.uvsNeedUpdate = false;\r\n\tthis.groupsNeedUpdate = false;\r\n\r\n}\r\n\r\nObject.assign( DirectGeometry.prototype, {\r\n\r\n\tcomputeGroups: function ( geometry ) {\r\n\r\n\t\tvar group;\r\n\t\tvar groups = [];\r\n\t\tvar materialIndex = undefined;\r\n\r\n\t\tvar faces = geometry.faces;\r\n\r\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\t// materials\r\n\r\n\t\t\tif ( face.materialIndex !== materialIndex ) {\r\n\r\n\t\t\t\tmaterialIndex = face.materialIndex;\r\n\r\n\t\t\t\tif ( group !== undefined ) {\r\n\r\n\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\r\n\t\t\t\t\tgroups.push( group );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgroup = {\r\n\t\t\t\t\tstart: i * 3,\r\n\t\t\t\t\tmaterialIndex: materialIndex\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( group !== undefined ) {\r\n\r\n\t\t\tgroup.count = ( i * 3 ) - group.start;\r\n\t\t\tgroups.push( group );\r\n\r\n\t\t}\r\n\r\n\t\tthis.groups = groups;\r\n\r\n\t},\r\n\r\n\tfromGeometry: function ( geometry ) {\r\n\r\n\t\tvar faces = geometry.faces;\r\n\t\tvar vertices = geometry.vertices;\r\n\t\tvar faceVertexUvs = geometry.faceVertexUvs;\r\n\r\n\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\r\n\t\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\r\n\r\n\t\t// morphs\r\n\r\n\t\tvar morphTargets = geometry.morphTargets;\r\n\t\tvar morphTargetsLength = morphTargets.length;\r\n\r\n\t\tvar morphTargetsPosition;\r\n\r\n\t\tif ( morphTargetsLength > 0 ) {\r\n\r\n\t\t\tmorphTargetsPosition = [];\r\n\r\n\t\t\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\r\n\r\n\t\t\t\tmorphTargetsPosition[ i ] = {\r\n\t\t\t\t\tname: morphTargets[ i ].name,\r\n\t\t\t\t \tdata: []\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.morphTargets.position = morphTargetsPosition;\r\n\r\n\t\t}\r\n\r\n\t\tvar morphNormals = geometry.morphNormals;\r\n\t\tvar morphNormalsLength = morphNormals.length;\r\n\r\n\t\tvar morphTargetsNormal;\r\n\r\n\t\tif ( morphNormalsLength > 0 ) {\r\n\r\n\t\t\tmorphTargetsNormal = [];\r\n\r\n\t\t\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\r\n\r\n\t\t\t\tmorphTargetsNormal[ i ] = {\r\n\t\t\t\t\tname: morphNormals[ i ].name,\r\n\t\t\t\t \tdata: []\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.morphTargets.normal = morphTargetsNormal;\r\n\r\n\t\t}\r\n\r\n\t\t// skins\r\n\r\n\t\tvar skinIndices = geometry.skinIndices;\r\n\t\tvar skinWeights = geometry.skinWeights;\r\n\r\n\t\tvar hasSkinIndices = skinIndices.length === vertices.length;\r\n\t\tvar hasSkinWeights = skinWeights.length === vertices.length;\r\n\r\n\t\t//\r\n\r\n\t\tif ( vertices.length > 0 && faces.length === 0 ) {\r\n\r\n\t\t\tconsole.error( 'COOL.DirectGeometry: Faceless geometries are not supported.' );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\r\n\r\n\t\t\tvar vertexNormals = face.vertexNormals;\r\n\r\n\t\t\tif ( vertexNormals.length === 3 ) {\r\n\r\n\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar normal = face.normal;\r\n\r\n\t\t\t\tthis.normals.push( normal, normal, normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar vertexColors = face.vertexColors;\r\n\r\n\t\t\tif ( vertexColors.length === 3 ) {\r\n\r\n\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar color = face.color;\r\n\r\n\t\t\t\tthis.colors.push( color, color, color );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexUv === true ) {\r\n\r\n\t\t\t\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\r\n\r\n\t\t\t\tif ( vertexUvs !== undefined ) {\r\n\r\n\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.warn( 'COOL.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\r\n\r\n\t\t\t\t\tthis.uvs.push( new Vector2(), new Vector2(), new Vector2() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexUv2 === true ) {\r\n\r\n\t\t\t\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\r\n\r\n\t\t\t\tif ( vertexUvs !== undefined ) {\r\n\r\n\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.warn( 'COOL.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\r\n\r\n\t\t\t\t\tthis.uvs2.push( new Vector2(), new Vector2(), new Vector2() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// morphs\r\n\r\n\t\t\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\r\n\r\n\t\t\t\tvar morphTarget = morphTargets[ j ].vertices;\r\n\r\n\t\t\t\tmorphTargetsPosition[ j ].data.push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\r\n\r\n\t\t\t\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\r\n\r\n\t\t\t\tmorphTargetsNormal[ j ].data.push( morphNormal.a, morphNormal.b, morphNormal.c );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// skins\r\n\r\n\t\t\tif ( hasSkinIndices ) {\r\n\r\n\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasSkinWeights ) {\r\n\r\n\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.computeGroups( geometry );\r\n\r\n\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\r\n\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\r\n\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\r\n\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\r\n\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/loader/utils.js\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nfunction arrayMin( array ) {\r\n\r\n\tif ( array.length === 0 ) return Infinity;\r\n\r\n\tvar min = array[ 0 ];\r\n\r\n\tfor ( var i = 1, l = array.length; i < l; ++ i ) {\r\n\r\n\t\tif ( array[ i ] < min ) min = array[ i ];\r\n\r\n\t}\r\n\r\n\treturn min;\r\n\r\n}\r\n\r\nfunction arrayMax( array ) {\r\n\r\n\tif ( array.length === 0 ) return - Infinity;\r\n\r\n\tvar max = array[ 0 ];\r\n\r\n\tfor ( var i = 1, l = array.length; i < l; ++ i ) {\r\n\r\n\t\tif ( array[ i ] > max ) max = array[ i ];\r\n\r\n\t}\r\n\r\n\treturn max;\r\n\r\n}\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/loader/BufferGeometry.js\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nvar bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id\r\n\r\nfunction BufferGeometry() {\r\n\r\n\tObject.defineProperty( this, 'id', { value: bufferGeometryId += 2 } );\r\n\r\n\tthis.uuid = _Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'BufferGeometry';\r\n\r\n\tthis.index = null;\r\n\tthis.attributes = {};\r\n\r\n\tthis.morphAttributes = {};\r\n\r\n\tthis.groups = [];\r\n\r\n\tthis.boundingBox = null;\r\n\tthis.boundingSphere = null;\r\n\r\n\tthis.drawRange = { start: 0, count: Infinity };\r\n\r\n\tthis.userData = {};\r\n\r\n}\r\n\r\nBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\r\n\r\n\tconstructor: BufferGeometry,\r\n\r\n\tisBufferGeometry: true,\r\n\r\n\tgetIndex: function () {\r\n\r\n\t\treturn this.index;\r\n\r\n\t},\r\n\r\n\tsetIndex: function ( index ) {\r\n\r\n\t\tif ( Array.isArray( index ) ) {\r\n\r\n\t\t\tthis.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.index = index;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\taddAttribute: function ( name, attribute ) {\r\n\r\n\t\tif ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\r\n\r\n\t\t\treturn this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( name === 'index' ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\r\n\t\t\tthis.setIndex( attribute );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tthis.attributes[ name ] = attribute;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetAttribute: function ( name ) {\r\n\r\n\t\treturn this.attributes[ name ];\r\n\r\n\t},\r\n\r\n\tremoveAttribute: function ( name ) {\r\n\r\n\t\tdelete this.attributes[ name ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddGroup: function ( start, count, materialIndex ) {\r\n\r\n\t\tthis.groups.push( {\r\n\r\n\t\t\tstart: start,\r\n\t\t\tcount: count,\r\n\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\r\n\r\n\t\t} );\r\n\r\n\t},\r\n\r\n\tclearGroups: function () {\r\n\r\n\t\tthis.groups = [];\r\n\r\n\t},\r\n\r\n\tsetDrawRange: function ( start, count ) {\r\n\r\n\t\tthis.drawRange.start = start;\r\n\t\tthis.drawRange.count = count;\r\n\r\n\t},\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tvar position = this.attributes.position;\r\n\r\n\t\tif ( position !== undefined ) {\r\n\r\n\t\t\tmatrix.applyToBufferAttribute( position );\r\n\t\t\tposition.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tvar normal = this.attributes.normal;\r\n\r\n\t\tif ( normal !== undefined ) {\r\n\r\n\t\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\r\n\r\n\t\t\tnormalMatrix.applyToBufferAttribute( normal );\r\n\t\t\tnormal.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingBox !== null ) {\r\n\r\n\t\t\tthis.computeBoundingBox();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.computeBoundingSphere();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trotateX: function () {\r\n\r\n\t\t// rotate geometry around world x-axis\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function rotateX( angle ) {\r\n\r\n\t\t\tm1.makeRotationX( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateY: function () {\r\n\r\n\t\t// rotate geometry around world y-axis\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function rotateY( angle ) {\r\n\r\n\t\t\tm1.makeRotationY( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateZ: function () {\r\n\r\n\t\t// rotate geometry around world z-axis\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function rotateZ( angle ) {\r\n\r\n\t\t\tm1.makeRotationZ( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function () {\r\n\r\n\t\t// translate geometry\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function translate( x, y, z ) {\r\n\r\n\t\t\tm1.makeTranslation( x, y, z );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tscale: function () {\r\n\r\n\t\t// scale geometry\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function scale( x, y, z ) {\r\n\r\n\t\t\tm1.makeScale( x, y, z );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlookAt: function () {\r\n\r\n\t\tvar obj = new Object3D();\r\n\r\n\t\treturn function lookAt( vector ) {\r\n\r\n\t\t\tobj.lookAt( vector );\r\n\r\n\t\t\tobj.updateMatrix();\r\n\r\n\t\t\tthis.applyMatrix( obj.matrix );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcenter: function () {\r\n\r\n\t\tvar offset = new Vector3();\r\n\r\n\t\treturn function center() {\r\n\r\n\t\t\tthis.computeBoundingBox();\r\n\r\n\t\t\tthis.boundingBox.getCenter( offset ).negate();\r\n\r\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetFromObject: function ( object ) {\r\n\r\n\t\t// console.log( 'COOL.BufferGeometry.setFromObject(). Converting', object, this );\r\n\r\n\t\tvar geometry = object.geometry;\r\n\r\n\t\tif ( object.isPoints || object.isLine ) {\r\n\r\n\t\t\tvar positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );\r\n\t\t\tvar colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );\r\n\r\n\t\t\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\r\n\t\t\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\r\n\r\n\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\r\n\r\n\t\t\t\tvar lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );\r\n\r\n\t\t\t\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( geometry.boundingSphere !== null ) {\r\n\r\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( geometry.boundingBox !== null ) {\r\n\r\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( object.isMesh ) {\r\n\r\n\t\t\tif ( geometry && geometry.isGeometry ) {\r\n\r\n\t\t\t\tthis.fromGeometry( geometry );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function ( points ) {\r\n\r\n\t\tvar position = [];\r\n\r\n\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar point = points[ i ];\r\n\t\t\tposition.push( point.x, point.y, point.z || 0 );\r\n\r\n\t\t}\r\n\r\n\t\tthis.addAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tupdateFromObject: function ( object ) {\r\n\r\n\t\tvar geometry = object.geometry;\r\n\r\n\t\tif ( object.isMesh ) {\r\n\r\n\t\t\tvar direct = geometry.__directGeometry;\r\n\r\n\t\t\tif ( geometry.elementsNeedUpdate === true ) {\r\n\r\n\t\t\t\tdirect = undefined;\r\n\t\t\t\tgeometry.elementsNeedUpdate = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( direct === undefined ) {\r\n\r\n\t\t\t\treturn this.fromGeometry( geometry );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\r\n\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\r\n\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\r\n\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\r\n\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\r\n\r\n\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\tgeometry.normalsNeedUpdate = false;\r\n\t\t\tgeometry.colorsNeedUpdate = false;\r\n\t\t\tgeometry.uvsNeedUpdate = false;\r\n\t\t\tgeometry.groupsNeedUpdate = false;\r\n\r\n\t\t\tgeometry = direct;\r\n\r\n\t\t}\r\n\r\n\t\tvar attribute;\r\n\r\n\t\tif ( geometry.verticesNeedUpdate === true ) {\r\n\r\n\t\t\tattribute = this.attributes.position;\r\n\r\n\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\r\n\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.verticesNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.normalsNeedUpdate === true ) {\r\n\r\n\t\t\tattribute = this.attributes.normal;\r\n\r\n\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\tattribute.copyVector3sArray( geometry.normals );\r\n\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.normalsNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.colorsNeedUpdate === true ) {\r\n\r\n\t\t\tattribute = this.attributes.color;\r\n\r\n\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\tattribute.copyColorsArray( geometry.colors );\r\n\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.colorsNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.uvsNeedUpdate ) {\r\n\r\n\t\t\tattribute = this.attributes.uv;\r\n\r\n\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\r\n\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.uvsNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.lineDistancesNeedUpdate ) {\r\n\r\n\t\t\tattribute = this.attributes.lineDistance;\r\n\r\n\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\tattribute.copyArray( geometry.lineDistances );\r\n\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.lineDistancesNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.groupsNeedUpdate ) {\r\n\r\n\t\t\tgeometry.computeGroups( object.geometry );\r\n\t\t\tthis.groups = geometry.groups;\r\n\r\n\t\t\tgeometry.groupsNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tfromGeometry: function ( geometry ) {\r\n\r\n\t\tgeometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );\r\n\r\n\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\r\n\r\n\t},\r\n\r\n\tfromDirectGeometry: function ( geometry ) {\r\n\r\n\t\tvar positions = new Float32Array( geometry.vertices.length * 3 );\r\n\t\tthis.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\r\n\r\n\t\tif ( geometry.normals.length > 0 ) {\r\n\r\n\t\t\tvar normals = new Float32Array( geometry.normals.length * 3 );\r\n\t\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.colors.length > 0 ) {\r\n\r\n\t\t\tvar colors = new Float32Array( geometry.colors.length * 3 );\r\n\t\t\tthis.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.uvs.length > 0 ) {\r\n\r\n\t\t\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\r\n\t\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.uvs2.length > 0 ) {\r\n\r\n\t\t\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\r\n\t\t\tthis.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\r\n\r\n\t\t}\r\n\r\n\t\t// groups\r\n\r\n\t\tthis.groups = geometry.groups;\r\n\r\n\t\t// morphs\r\n\r\n\t\tfor ( var name in geometry.morphTargets ) {\r\n\r\n\t\t\tvar array = [];\r\n\t\t\tvar morphTargets = geometry.morphTargets[ name ];\r\n\r\n\t\t\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar morphTarget = morphTargets[ i ];\r\n\r\n\t\t\t\tvar attribute = new Float32BufferAttribute( morphTarget.data.length * 3, 3 );\r\n\t\t\t\tattribute.name = morphTarget.name;\r\n\r\n\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget.data ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.morphAttributes[ name ] = array;\r\n\r\n\t\t}\r\n\r\n\t\t// skinning\r\n\r\n\t\tif ( geometry.skinIndices.length > 0 ) {\r\n\r\n\t\t\tvar skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );\r\n\t\t\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.skinWeights.length > 0 ) {\r\n\r\n\t\t\tvar skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );\r\n\t\t\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( geometry.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.boundingBox !== null ) {\r\n\r\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcomputeBoundingBox: function () {\r\n\r\n\t\tif ( this.boundingBox === null ) {\r\n\r\n\t\t\tthis.boundingBox = new Box3();\r\n\r\n\t\t}\r\n\r\n\t\tvar position = this.attributes.position;\r\n\r\n\t\tif ( position !== undefined ) {\r\n\r\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.boundingBox.makeEmpty();\r\n\r\n\t\t}\r\n\r\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\r\n\r\n\t\t\tconsole.error( 'COOL.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeBoundingSphere: function () {\r\n\r\n\t\tvar box = new Box3();\r\n\t\tvar vector = new Vector3();\r\n\r\n\t\treturn function computeBoundingSphere() {\r\n\r\n\t\t\tif ( this.boundingSphere === null ) {\r\n\r\n\t\t\t\tthis.boundingSphere = new Sphere();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar position = this.attributes.position;\r\n\r\n\t\t\tif ( position ) {\r\n\r\n\t\t\t\tvar center = this.boundingSphere.center;\r\n\r\n\t\t\t\tbox.setFromBufferAttribute( position );\r\n\t\t\t\tbox.getCenter( center );\r\n\r\n\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\r\n\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\r\n\r\n\t\t\t\tvar maxRadiusSq = 0;\r\n\r\n\t\t\t\tfor ( var i = 0, il = position.count; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvector.x = position.getX( i );\r\n\t\t\t\t\tvector.y = position.getY( i );\r\n\t\t\t\t\tvector.z = position.getZ( i );\r\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\r\n\r\n\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\r\n\r\n\t\t\t\t\tconsole.error( 'COOL.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcomputeFaceNormals: function () {\r\n\r\n\t\t// backwards compatibility\r\n\r\n\t},\r\n\r\n\tcomputeVertexNormals: function () {\r\n\r\n\t\tvar index = this.index;\r\n\t\tvar attributes = this.attributes;\r\n\r\n\t\tif ( attributes.position ) {\r\n\r\n\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\tif ( attributes.normal === undefined ) {\r\n\r\n\t\t\t\tthis.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// reset existing normals to zero\r\n\r\n\t\t\t\tvar array = attributes.normal.array;\r\n\r\n\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tarray[ i ] = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar normals = attributes.normal.array;\r\n\r\n\t\t\tvar vA, vB, vC;\r\n\t\t\tvar pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\r\n\t\t\tvar cb = new Vector3(), ab = new Vector3();\r\n\r\n\t\t\t// indexed elements\r\n\r\n\t\t\tif ( index ) {\r\n\r\n\t\t\t\tvar indices = index.array;\r\n\r\n\t\t\t\tfor ( var i = 0, il = index.count; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\tvA = indices[ i + 0 ] * 3;\r\n\t\t\t\t\tvB = indices[ i + 1 ] * 3;\r\n\t\t\t\t\tvC = indices[ i + 2 ] * 3;\r\n\r\n\t\t\t\t\tpA.fromArray( positions, vA );\r\n\t\t\t\t\tpB.fromArray( positions, vB );\r\n\t\t\t\t\tpC.fromArray( positions, vC );\r\n\r\n\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\t\tnormals[ vA ] += cb.x;\r\n\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\r\n\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\r\n\r\n\t\t\t\t\tnormals[ vB ] += cb.x;\r\n\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\r\n\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\r\n\r\n\t\t\t\t\tnormals[ vC ] += cb.x;\r\n\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\r\n\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\r\n\r\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\r\n\r\n\t\t\t\t\tpA.fromArray( positions, i );\r\n\t\t\t\t\tpB.fromArray( positions, i + 3 );\r\n\t\t\t\t\tpC.fromArray( positions, i + 6 );\r\n\r\n\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\t\tnormals[ i ] = cb.x;\r\n\t\t\t\t\tnormals[ i + 1 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 2 ] = cb.z;\r\n\r\n\t\t\t\t\tnormals[ i + 3 ] = cb.x;\r\n\t\t\t\t\tnormals[ i + 4 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 5 ] = cb.z;\r\n\r\n\t\t\t\t\tnormals[ i + 6 ] = cb.x;\r\n\t\t\t\t\tnormals[ i + 7 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 8 ] = cb.z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.normalizeNormals();\r\n\r\n\t\t\tattributes.normal.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tmerge: function ( geometry, offset ) {\r\n\r\n\t\tif ( ! ( geometry && geometry.isBufferGeometry ) ) {\r\n\r\n\t\t\tconsole.error( 'COOL.BufferGeometry.merge(): geometry not an instance of COOL.BufferGeometry.', geometry );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( offset === undefined ) {\r\n\r\n\t\t\toffset = 0;\r\n\r\n\t\t\tconsole.warn(\r\n\t\t\t\t'COOL.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '\r\n\t\t\t\t+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\tvar attributes = this.attributes;\r\n\r\n\t\tfor ( var key in attributes ) {\r\n\r\n\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\r\n\r\n\t\t\tvar attribute1 = attributes[ key ];\r\n\t\t\tvar attributeArray1 = attribute1.array;\r\n\r\n\t\t\tvar attribute2 = geometry.attributes[ key ];\r\n\t\t\tvar attributeArray2 = attribute2.array;\r\n\r\n\t\t\tvar attributeSize = attribute2.itemSize;\r\n\r\n\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\r\n\r\n\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnormalizeNormals: function () {\r\n\r\n\t\tvar vector = new Vector3();\r\n\r\n\t\treturn function normalizeNormals() {\r\n\r\n\t\t\tvar normals = this.attributes.normal;\r\n\r\n\t\t\tfor ( var i = 0, il = normals.count; i < il; i ++ ) {\r\n\r\n\t\t\t\tvector.x = normals.getX( i );\r\n\t\t\t\tvector.y = normals.getY( i );\r\n\t\t\t\tvector.z = normals.getZ( i );\r\n\r\n\t\t\t\tvector.normalize();\r\n\r\n\t\t\t\tnormals.setXYZ( i, vector.x, vector.y, vector.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttoNonIndexed: function () {\r\n\r\n\t\tif ( this.index === null ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tvar geometry2 = new BufferGeometry();\r\n\r\n\t\tvar indices = this.index.array;\r\n\t\tvar attributes = this.attributes;\r\n\r\n\t\tfor ( var name in attributes ) {\r\n\r\n\t\t\tvar attribute = attributes[ name ];\r\n\r\n\t\t\tvar array = attribute.array;\r\n\t\t\tvar itemSize = attribute.itemSize;\r\n\r\n\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\r\n\r\n\t\t\tvar index = 0, index2 = 0;\r\n\r\n\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tindex = indices[ i ] * itemSize;\r\n\r\n\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\r\n\r\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar groups = this.groups;\r\n\r\n\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar group = groups[ i ];\r\n\t\t\tgeometry2.addGroup( group.start, group.count, group.materialIndex );\r\n\r\n\t\t}\r\n\r\n\t\treturn geometry2;\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar data = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.5,\r\n\t\t\t\ttype: 'BufferGeometry',\r\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// standard BufferGeometry serialization\r\n\r\n\t\tdata.uuid = this.uuid;\r\n\t\tdata.type = this.type;\r\n\t\tif ( this.name !== '' ) data.name = this.name;\r\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\r\n\r\n\t\tif ( this.parameters !== undefined ) {\r\n\r\n\t\t\tvar parameters = this.parameters;\r\n\r\n\t\t\tfor ( var key in parameters ) {\r\n\r\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tdata.data = { attributes: {} };\r\n\r\n\t\tvar index = this.index;\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\tvar array = Array.prototype.slice.call( index.array );\r\n\r\n\t\t\tdata.data.index = {\r\n\t\t\t\ttype: index.array.constructor.name,\r\n\t\t\t\tarray: array\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tvar attributes = this.attributes;\r\n\r\n\t\tfor ( var key in attributes ) {\r\n\r\n\t\t\tvar attribute = attributes[ key ];\r\n\r\n\t\t\tvar array = Array.prototype.slice.call( attribute.array );\r\n\r\n\t\t\tdata.data.attributes[ key ] = {\r\n\t\t\t\titemSize: attribute.itemSize,\r\n\t\t\t\ttype: attribute.array.constructor.name,\r\n\t\t\t\tarray: array,\r\n\t\t\t\tnormalized: attribute.normalized\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tvar groups = this.groups;\r\n\r\n\t\tif ( groups.length > 0 ) {\r\n\r\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar boundingSphere = this.boundingSphere;\r\n\r\n\t\tif ( boundingSphere !== null ) {\r\n\r\n\t\t\tdata.data.boundingSphere = {\r\n\t\t\t\tcenter: boundingSphere.center.toArray(),\r\n\t\t\t\tradius: boundingSphere.radius\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\t/*\r\n\t\t // Handle primitives\r\n\r\n\t\t var parameters = this.parameters;\r\n\r\n\t\t if ( parameters !== undefined ) {\r\n\r\n\t\t var values = [];\r\n\r\n\t\t for ( var key in parameters ) {\r\n\r\n\t\t values.push( parameters[ key ] );\r\n\r\n\t\t }\r\n\r\n\t\t var geometry = Object.create( this.constructor.prototype );\r\n\t\t this.constructor.apply( geometry, values );\r\n\t\t return geometry;\r\n\r\n\t\t }\r\n\r\n\t\t return new this.constructor().copy( this );\r\n\t\t */\r\n\r\n\t\treturn new BufferGeometry().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tvar name, i, l;\r\n\r\n\t\t// reset\r\n\r\n\t\tthis.index = null;\r\n\t\tthis.attributes = {};\r\n\t\tthis.morphAttributes = {};\r\n\t\tthis.groups = [];\r\n\t\tthis.boundingBox = null;\r\n\t\tthis.boundingSphere = null;\r\n\r\n\t\t// name\r\n\r\n\t\tthis.name = source.name;\r\n\r\n\t\t// index\r\n\r\n\t\tvar index = source.index;\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\tthis.setIndex( index.clone() );\r\n\r\n\t\t}\r\n\r\n\t\t// attributes\r\n\r\n\t\tvar attributes = source.attributes;\r\n\r\n\t\tfor ( name in attributes ) {\r\n\r\n\t\t\tvar attribute = attributes[ name ];\r\n\t\t\tthis.addAttribute( name, attribute.clone() );\r\n\r\n\t\t}\r\n\r\n\t\t// morph attributes\r\n\r\n\t\tvar morphAttributes = source.morphAttributes;\r\n\r\n\t\tfor ( name in morphAttributes ) {\r\n\r\n\t\t\tvar array = [];\r\n\t\t\tvar morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\r\n\r\n\t\t\tfor ( i = 0, l = morphAttribute.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tarray.push( morphAttribute[ i ].clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.morphAttributes[ name ] = array;\r\n\r\n\t\t}\r\n\r\n\t\t// groups\r\n\r\n\t\tvar groups = source.groups;\r\n\r\n\t\tfor ( i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar group = groups[ i ];\r\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\r\n\r\n\t\t}\r\n\r\n\t\t// bounding box\r\n\r\n\t\tvar boundingBox = source.boundingBox;\r\n\r\n\t\tif ( boundingBox !== null ) {\r\n\r\n\t\t\tthis.boundingBox = boundingBox.clone();\r\n\r\n\t\t}\r\n\r\n\t\t// bounding sphere\r\n\r\n\t\tvar boundingSphere = source.boundingSphere;\r\n\r\n\t\tif ( boundingSphere !== null ) {\r\n\r\n\t\t\tthis.boundingSphere = boundingSphere.clone();\r\n\r\n\t\t}\r\n\r\n\t\t// draw range\r\n\r\n\t\tthis.drawRange.start = source.drawRange.start;\r\n\t\tthis.drawRange.count = source.drawRange.count;\r\n\r\n\t\t// user data\r\n\r\n\t\tthis.userData = source.userData;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/Earcut.js\n/**\r\n * @author Mugen87 / https://github.com/Mugen87\r\n * Port from https://github.com/mapbox/earcut (v2.1.2)\r\n */\r\n\r\nvar Earcut = {\r\n\r\n\ttriangulate: function ( data, holeIndices, dim ) {\r\n\r\n\t\tdim = dim || 2;\r\n\r\n\t\tvar hasHoles = holeIndices && holeIndices.length,\r\n\t\t\touterLen = hasHoles ? holeIndices[ 0 ] * dim : data.length,\r\n\t\t\touterNode = linkedList( data, 0, outerLen, dim, true ),\r\n\t\t\ttriangles = [];\r\n\r\n\t\tif ( ! outerNode ) return triangles;\r\n\r\n\t\tvar minX, minY, maxX, maxY, x, y, invSize;\r\n\r\n\t\tif ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );\r\n\r\n\t\t// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\r\n\r\n\t\tif ( data.length > 80 * dim ) {\r\n\r\n\t\t\tminX = maxX = data[ 0 ];\r\n\t\t\tminY = maxY = data[ 1 ];\r\n\r\n\t\t\tfor ( var i = dim; i < outerLen; i += dim ) {\r\n\r\n\t\t\t\tx = data[ i ];\r\n\t\t\t\ty = data[ i + 1 ];\r\n\t\t\t\tif ( x < minX ) minX = x;\r\n\t\t\t\tif ( y < minY ) minY = y;\r\n\t\t\t\tif ( x > maxX ) maxX = x;\r\n\t\t\t\tif ( y > maxY ) maxY = y;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// minX, minY and invSize are later used to transform coords into integers for z-order calculation\r\n\r\n\t\t\tinvSize = Math.max( maxX - minX, maxY - minY );\r\n\t\t\tinvSize = invSize !== 0 ? 1 / invSize : 0;\r\n\r\n\t\t}\r\n\r\n\t\tearcutLinked( outerNode, triangles, dim, minX, minY, invSize );\r\n\r\n\t\treturn triangles;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// create a circular doubly linked list from polygon points in the specified winding order\r\n\r\nfunction linkedList( data, start, end, dim, clockwise ) {\r\n\r\n\tvar i, last;\r\n\r\n\tif ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {\r\n\r\n\t\tfor ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\r\n\r\n\t} else {\r\n\r\n\t\tfor ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\r\n\r\n\t}\r\n\r\n\tif ( last && equals( last, last.next ) ) {\r\n\r\n\t\tremoveNode( last );\r\n\t\tlast = last.next;\r\n\r\n\t}\r\n\r\n\treturn last;\r\n\r\n}\r\n\r\n// eliminate colinear or duplicate points\r\n\r\nfunction filterPoints( start, end ) {\r\n\r\n\tif ( ! start ) return start;\r\n\tif ( ! end ) end = start;\r\n\r\n\tvar p = start, again;\r\n\r\n\tdo {\r\n\r\n\t\tagain = false;\r\n\r\n\t\tif ( ! p.steiner && ( equals( p, p.next ) || Earcut_area( p.prev, p, p.next ) === 0 ) ) {\r\n\r\n\t\t\tremoveNode( p );\r\n\t\t\tp = end = p.prev;\r\n\t\t\tif ( p === p.next ) break;\r\n\t\t\tagain = true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tp = p.next;\r\n\r\n\t\t}\r\n\r\n\t} while ( again || p !== end );\r\n\r\n\treturn end;\r\n\r\n}\r\n\r\n// main ear slicing loop which triangulates a polygon (given as a linked list)\r\n\r\nfunction earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {\r\n\r\n\tif ( ! ear ) return;\r\n\r\n\t// interlink polygon nodes in z-order\r\n\r\n\tif ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );\r\n\r\n\tvar stop = ear, prev, next;\r\n\r\n\t// iterate through ears, slicing them one by one\r\n\r\n\twhile ( ear.prev !== ear.next ) {\r\n\r\n\t\tprev = ear.prev;\r\n\t\tnext = ear.next;\r\n\r\n\t\tif ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {\r\n\r\n\t\t\t// cut off the triangle\r\n\t\t\ttriangles.push( prev.i / dim );\r\n\t\t\ttriangles.push( ear.i / dim );\r\n\t\t\ttriangles.push( next.i / dim );\r\n\r\n\t\t\tremoveNode( ear );\r\n\r\n\t\t\t// skipping the next vertice leads to less sliver triangles\r\n\t\t\tear = next.next;\r\n\t\t\tstop = next.next;\r\n\r\n\t\t\tcontinue;\r\n\r\n\t\t}\r\n\r\n\t\tear = next;\r\n\r\n\t\t// if we looped through the whole remaining polygon and can't find any more ears\r\n\r\n\t\tif ( ear === stop ) {\r\n\r\n\t\t\t// try filtering points and slicing again\r\n\r\n\t\t\tif ( ! pass ) {\r\n\r\n\t\t\t\tearcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );\r\n\r\n\t\t\t\t// if this didn't work, try curing all small self-intersections locally\r\n\r\n\t\t\t} else if ( pass === 1 ) {\r\n\r\n\t\t\t\tear = cureLocalIntersections( ear, triangles, dim );\r\n\t\t\t\tearcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );\r\n\r\n\t\t\t\t// as a last resort, try splitting the remaining polygon into two\r\n\r\n\t\t\t} else if ( pass === 2 ) {\r\n\r\n\t\t\t\tsplitEarcut( ear, triangles, dim, minX, minY, invSize );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n// check whether a polygon node forms a valid ear with adjacent nodes\r\n\r\nfunction isEar( ear ) {\r\n\r\n\tvar a = ear.prev,\r\n\t\tb = ear,\r\n\t\tc = ear.next;\r\n\r\n\tif ( Earcut_area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\r\n\r\n\t// now make sure we don't have other points inside the potential ear\r\n\tvar p = ear.next.next;\r\n\r\n\twhile ( p !== ear.prev ) {\r\n\r\n\t\tif ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) && Earcut_area( p.prev, p, p.next ) >= 0 ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\tp = p.next;\r\n\r\n\t}\r\n\r\n\treturn true;\r\n\r\n}\r\n\r\nfunction isEarHashed( ear, minX, minY, invSize ) {\r\n\r\n\tvar a = ear.prev,\r\n\t\tb = ear,\r\n\t\tc = ear.next;\r\n\r\n\tif ( Earcut_area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\r\n\r\n\t// triangle bbox; min & max are calculated like this for speed\r\n\r\n\tvar minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),\r\n\t\tminTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),\r\n\t\tmaxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),\r\n\t\tmaxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );\r\n\r\n\t// z-order range for the current triangle bbox;\r\n\r\n\tvar minZ = zOrder( minTX, minTY, minX, minY, invSize ),\r\n\t\tmaxZ = zOrder( maxTX, maxTY, minX, minY, invSize );\r\n\r\n\t// first look for points inside the triangle in increasing z-order\r\n\r\n\tvar p = ear.nextZ;\r\n\r\n\twhile ( p && p.z <= maxZ ) {\r\n\r\n\t\tif ( p !== ear.prev && p !== ear.next &&\r\n\t\t\t\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\r\n\t\t\t\tEarcut_area( p.prev, p, p.next ) >= 0 ) return false;\r\n\t\tp = p.nextZ;\r\n\r\n\t}\r\n\r\n\t// then look for points in decreasing z-order\r\n\r\n\tp = ear.prevZ;\r\n\r\n\twhile ( p && p.z >= minZ ) {\r\n\r\n\t\tif ( p !== ear.prev && p !== ear.next &&\r\n\t\t\t\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\r\n\t\t\t\tEarcut_area( p.prev, p, p.next ) >= 0 ) return false;\r\n\r\n\t\tp = p.prevZ;\r\n\r\n\t}\r\n\r\n\treturn true;\r\n\r\n}\r\n\r\n// go through all polygon nodes and cure small local self-intersections\r\n\r\nfunction cureLocalIntersections( start, triangles, dim ) {\r\n\r\n\tvar p = start;\r\n\r\n\tdo {\r\n\r\n\t\tvar a = p.prev, b = p.next.next;\r\n\r\n\t\tif ( ! equals( a, b ) && Earcut_intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {\r\n\r\n\t\t\ttriangles.push( a.i / dim );\r\n\t\t\ttriangles.push( p.i / dim );\r\n\t\t\ttriangles.push( b.i / dim );\r\n\r\n\t\t\t// remove two nodes involved\r\n\r\n\t\t\tremoveNode( p );\r\n\t\t\tremoveNode( p.next );\r\n\r\n\t\t\tp = start = b;\r\n\r\n\t\t}\r\n\r\n\t\tp = p.next;\r\n\r\n\t} while ( p !== start );\r\n\r\n\treturn p;\r\n\r\n}\r\n\r\n// try splitting polygon into two and triangulate them independently\r\n\r\nfunction splitEarcut( start, triangles, dim, minX, minY, invSize ) {\r\n\r\n\t// look for a valid diagonal that divides the polygon into two\r\n\r\n\tvar a = start;\r\n\r\n\tdo {\r\n\r\n\t\tvar b = a.next.next;\r\n\r\n\t\twhile ( b !== a.prev ) {\r\n\r\n\t\t\tif ( a.i !== b.i && isValidDiagonal( a, b ) ) {\r\n\r\n\t\t\t\t// split the polygon in two by the diagonal\r\n\r\n\t\t\t\tvar c = splitPolygon( a, b );\r\n\r\n\t\t\t\t// filter colinear points around the cuts\r\n\r\n\t\t\t\ta = filterPoints( a, a.next );\r\n\t\t\t\tc = filterPoints( c, c.next );\r\n\r\n\t\t\t\t// run earcut on each half\r\n\r\n\t\t\t\tearcutLinked( a, triangles, dim, minX, minY, invSize );\r\n\t\t\t\tearcutLinked( c, triangles, dim, minX, minY, invSize );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tb = b.next;\r\n\r\n\t\t}\r\n\r\n\t\ta = a.next;\r\n\r\n\t} while ( a !== start );\r\n\r\n}\r\n\r\n// link every hole into the outer loop, producing a single-ring polygon without holes\r\n\r\nfunction eliminateHoles( data, holeIndices, outerNode, dim ) {\r\n\r\n\tvar queue = [], i, len, start, end, list;\r\n\r\n\tfor ( i = 0, len = holeIndices.length; i < len; i ++ ) {\r\n\r\n\t\tstart = holeIndices[ i ] * dim;\r\n\t\tend = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;\r\n\t\tlist = linkedList( data, start, end, dim, false );\r\n\t\tif ( list === list.next ) list.steiner = true;\r\n\t\tqueue.push( getLeftmost( list ) );\r\n\r\n\t}\r\n\r\n\tqueue.sort( compareX );\r\n\r\n\t// process holes from left to right\r\n\r\n\tfor ( i = 0; i < queue.length; i ++ ) {\r\n\r\n\t\teliminateHole( queue[ i ], outerNode );\r\n\t\touterNode = filterPoints( outerNode, outerNode.next );\r\n\r\n\t}\r\n\r\n\treturn outerNode;\r\n\r\n}\r\n\r\nfunction compareX( a, b ) {\r\n\r\n\treturn a.x - b.x;\r\n\r\n}\r\n\r\n// find a bridge between vertices that connects hole with an outer ring and and link it\r\n\r\nfunction eliminateHole( hole, outerNode ) {\r\n\r\n\touterNode = findHoleBridge( hole, outerNode );\r\n\r\n\tif ( outerNode ) {\r\n\r\n\t\tvar b = splitPolygon( outerNode, hole );\r\n\r\n\t\tfilterPoints( b, b.next );\r\n\r\n\t}\r\n\r\n}\r\n\r\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\r\n\r\nfunction findHoleBridge( hole, outerNode ) {\r\n\r\n\tvar p = outerNode,\r\n\t\thx = hole.x,\r\n\t\thy = hole.y,\r\n\t\tqx = - Infinity,\r\n\t\tm;\r\n\r\n\t// find a segment intersected by a ray from the hole's leftmost point to the left;\r\n\t// segment's endpoint with lesser x will be potential connection point\r\n\r\n\tdo {\r\n\r\n\t\tif ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {\r\n\r\n\t\t\tvar x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );\r\n\r\n\t\t\tif ( x <= hx && x > qx ) {\r\n\r\n\t\t\t\tqx = x;\r\n\r\n\t\t\t\tif ( x === hx ) {\r\n\r\n\t\t\t\t\tif ( hy === p.y ) return p;\r\n\t\t\t\t\tif ( hy === p.next.y ) return p.next;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tm = p.x < p.next.x ? p : p.next;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tp = p.next;\r\n\r\n\t} while ( p !== outerNode );\r\n\r\n\tif ( ! m ) return null;\r\n\r\n\tif ( hx === qx ) return m.prev; // hole touches outer segment; pick lower endpoint\r\n\r\n\t// look for points inside the triangle of hole point, segment intersection and endpoint;\r\n\t// if there are no points found, we have a valid connection;\r\n\t// otherwise choose the point of the minimum angle with the ray as connection point\r\n\r\n\tvar stop = m,\r\n\t\tmx = m.x,\r\n\t\tmy = m.y,\r\n\t\ttanMin = Infinity,\r\n\t\ttan;\r\n\r\n\tp = m.next;\r\n\r\n\twhile ( p !== stop ) {\r\n\r\n\t\tif ( hx >= p.x && p.x >= mx && hx !== p.x &&\r\n\t\t\t\t\t\tpointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {\r\n\r\n\t\t\ttan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential\r\n\r\n\t\t\tif ( ( tan < tanMin || ( tan === tanMin && p.x > m.x ) ) && locallyInside( p, hole ) ) {\r\n\r\n\t\t\t\tm = p;\r\n\t\t\t\ttanMin = tan;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tp = p.next;\r\n\r\n\t}\r\n\r\n\treturn m;\r\n\r\n}\r\n\r\n// interlink polygon nodes in z-order\r\n\r\nfunction indexCurve( start, minX, minY, invSize ) {\r\n\r\n\tvar p = start;\r\n\r\n\tdo {\r\n\r\n\t\tif ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );\r\n\t\tp.prevZ = p.prev;\r\n\t\tp.nextZ = p.next;\r\n\t\tp = p.next;\r\n\r\n\t} while ( p !== start );\r\n\r\n\tp.prevZ.nextZ = null;\r\n\tp.prevZ = null;\r\n\r\n\tsortLinked( p );\r\n\r\n}\r\n\r\n// Simon Tatham's linked list merge sort algorithm\r\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\r\n\r\nfunction sortLinked( list ) {\r\n\r\n\tvar i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;\r\n\r\n\tdo {\r\n\r\n\t\tp = list;\r\n\t\tlist = null;\r\n\t\ttail = null;\r\n\t\tnumMerges = 0;\r\n\r\n\t\twhile ( p ) {\r\n\r\n\t\t\tnumMerges ++;\r\n\t\t\tq = p;\r\n\t\t\tpSize = 0;\r\n\r\n\t\t\tfor ( i = 0; i < inSize; i ++ ) {\r\n\r\n\t\t\t\tpSize ++;\r\n\t\t\t\tq = q.nextZ;\r\n\t\t\t\tif ( ! q ) break;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tqSize = inSize;\r\n\r\n\t\t\twhile ( pSize > 0 || ( qSize > 0 && q ) ) {\r\n\r\n\t\t\t\tif ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {\r\n\r\n\t\t\t\t\te = p;\r\n\t\t\t\t\tp = p.nextZ;\r\n\t\t\t\t\tpSize --;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\te = q;\r\n\t\t\t\t\tq = q.nextZ;\r\n\t\t\t\t\tqSize --;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( tail ) tail.nextZ = e;\r\n\t\t\t\telse list = e;\r\n\r\n\t\t\t\te.prevZ = tail;\r\n\t\t\t\ttail = e;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tp = q;\r\n\r\n\t\t}\r\n\r\n\t\ttail.nextZ = null;\r\n\t\tinSize *= 2;\r\n\r\n\t} while ( numMerges > 1 );\r\n\r\n\treturn list;\r\n\r\n}\r\n\r\n// z-order of a point given coords and inverse of the longer side of data bbox\r\n\r\nfunction zOrder( x, y, minX, minY, invSize ) {\r\n\r\n\t// coords are transformed into non-negative 15-bit integer range\r\n\r\n\tx = 32767 * ( x - minX ) * invSize;\r\n\ty = 32767 * ( y - minY ) * invSize;\r\n\r\n\tx = ( x | ( x << 8 ) ) & 0x00FF00FF;\r\n\tx = ( x | ( x << 4 ) ) & 0x0F0F0F0F;\r\n\tx = ( x | ( x << 2 ) ) & 0x33333333;\r\n\tx = ( x | ( x << 1 ) ) & 0x55555555;\r\n\r\n\ty = ( y | ( y << 8 ) ) & 0x00FF00FF;\r\n\ty = ( y | ( y << 4 ) ) & 0x0F0F0F0F;\r\n\ty = ( y | ( y << 2 ) ) & 0x33333333;\r\n\ty = ( y | ( y << 1 ) ) & 0x55555555;\r\n\r\n\treturn x | ( y << 1 );\r\n\r\n}\r\n\r\n// find the leftmost node of a polygon ring\r\n\r\nfunction getLeftmost( start ) {\r\n\r\n\tvar p = start, leftmost = start;\r\n\r\n\tdo {\r\n\r\n\t\tif ( p.x < leftmost.x ) leftmost = p;\r\n\t\tp = p.next;\r\n\r\n\t} while ( p !== start );\r\n\r\n\treturn leftmost;\r\n\r\n}\r\n\r\n// check if a point lies within a convex triangle\r\n\r\nfunction pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {\r\n\r\n\treturn ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&\r\n\t ( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&\r\n\t ( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;\r\n\r\n}\r\n\r\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\r\n\r\nfunction isValidDiagonal( a, b ) {\r\n\r\n\treturn a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) &&\r\n\t\tlocallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b );\r\n\r\n}\r\n\r\n// signed area of a triangle\r\n\r\nfunction Earcut_area( p, q, r ) {\r\n\r\n\treturn ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );\r\n\r\n}\r\n\r\n// check if two points are equal\r\n\r\nfunction equals( p1, p2 ) {\r\n\r\n\treturn p1.x === p2.x && p1.y === p2.y;\r\n\r\n}\r\n\r\n// check if two segments intersect\r\n\r\nfunction Earcut_intersects( p1, q1, p2, q2 ) {\r\n\r\n\tif ( ( equals( p1, q1 ) && equals( p2, q2 ) ) ||\r\n\t\t\t( equals( p1, q2 ) && equals( p2, q1 ) ) ) return true;\r\n\r\n\treturn Earcut_area( p1, q1, p2 ) > 0 !== Earcut_area( p1, q1, q2 ) > 0 &&\r\n\t\t\t\t Earcut_area( p2, q2, p1 ) > 0 !== Earcut_area( p2, q2, q1 ) > 0;\r\n\r\n}\r\n\r\n// check if a polygon diagonal intersects any polygon segments\r\n\r\nfunction intersectsPolygon( a, b ) {\r\n\r\n\tvar p = a;\r\n\r\n\tdo {\r\n\r\n\t\tif ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\r\n\t\t\t\t\t\tEarcut_intersects( p, p.next, a, b ) ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\tp = p.next;\r\n\r\n\t} while ( p !== a );\r\n\r\n\treturn false;\r\n\r\n}\r\n\r\n// check if a polygon diagonal is locally inside the polygon\r\n\r\nfunction locallyInside( a, b ) {\r\n\r\n\treturn Earcut_area( a.prev, a, a.next ) < 0 ?\r\n\t\tEarcut_area( a, b, a.next ) >= 0 && Earcut_area( a, a.prev, b ) >= 0 :\r\n\t\tEarcut_area( a, b, a.prev ) < 0 || Earcut_area( a, a.next, b ) < 0;\r\n\r\n}\r\n\r\n// check if the middle point of a polygon diagonal is inside the polygon\r\n\r\nfunction middleInside( a, b ) {\r\n\r\n\tvar p = a,\r\n\t\tinside = false,\r\n\t\tpx = ( a.x + b.x ) / 2,\r\n\t\tpy = ( a.y + b.y ) / 2;\r\n\r\n\tdo {\r\n\r\n\t\tif ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&\r\n\t\t\t\t\t\t( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) ) {\r\n\r\n\t\t\tinside = ! inside;\r\n\r\n\t\t}\r\n\r\n\t\tp = p.next;\r\n\r\n\t} while ( p !== a );\r\n\r\n\treturn inside;\r\n\r\n}\r\n\r\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\r\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\r\n\r\nfunction splitPolygon( a, b ) {\r\n\r\n\tvar a2 = new Node( a.i, a.x, a.y ),\r\n\t\tb2 = new Node( b.i, b.x, b.y ),\r\n\t\tan = a.next,\r\n\t\tbp = b.prev;\r\n\r\n\ta.next = b;\r\n\tb.prev = a;\r\n\r\n\ta2.next = an;\r\n\tan.prev = a2;\r\n\r\n\tb2.next = a2;\r\n\ta2.prev = b2;\r\n\r\n\tbp.next = b2;\r\n\tb2.prev = bp;\r\n\r\n\treturn b2;\r\n\r\n}\r\n\r\n// create a node and optionally link it with previous one (in a circular doubly linked list)\r\n\r\nfunction insertNode( i, x, y, last ) {\r\n\r\n\tvar p = new Node( i, x, y );\r\n\r\n\tif ( ! last ) {\r\n\r\n\t\tp.prev = p;\r\n\t\tp.next = p;\r\n\r\n\t} else {\r\n\r\n\t\tp.next = last.next;\r\n\t\tp.prev = last;\r\n\t\tlast.next.prev = p;\r\n\t\tlast.next = p;\r\n\r\n\t}\r\n\r\n\treturn p;\r\n\r\n}\r\n\r\nfunction removeNode( p ) {\r\n\r\n\tp.next.prev = p.prev;\r\n\tp.prev.next = p.next;\r\n\r\n\tif ( p.prevZ ) p.prevZ.nextZ = p.nextZ;\r\n\tif ( p.nextZ ) p.nextZ.prevZ = p.prevZ;\r\n\r\n}\r\n\r\nfunction Node( i, x, y ) {\r\n\r\n\t// vertice index in coordinates array\r\n\tthis.i = i;\r\n\r\n\t// vertex coordinates\r\n\tthis.x = x;\r\n\tthis.y = y;\r\n\r\n\t// previous and next vertice nodes in a polygon ring\r\n\tthis.prev = null;\r\n\tthis.next = null;\r\n\r\n\t// z-order curve value\r\n\tthis.z = null;\r\n\r\n\t// previous and next nodes in z-order\r\n\tthis.prevZ = null;\r\n\tthis.nextZ = null;\r\n\r\n\t// indicates whether this is a steiner point\r\n\tthis.steiner = false;\r\n\r\n}\r\n\r\nfunction signedArea( data, start, end, dim ) {\r\n\r\n\tvar sum = 0;\r\n\r\n\tfor ( var i = start, j = end - dim; i < end; i += dim ) {\r\n\r\n\t\tsum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );\r\n\t\tj = i;\r\n\r\n\t}\r\n\r\n\treturn sum;\r\n\r\n}\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/ShapeUtils.js\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\n\r\n\r\nvar ShapeUtils = {\r\n\r\n\t// calculate area of the contour polygon\r\n\r\n\tarea: function ( contour ) {\r\n\r\n\t\tvar n = contour.length;\r\n\t\tvar a = 0.0;\r\n\r\n\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\r\n\r\n\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\r\n\r\n\t\t}\r\n\r\n\t\treturn a * 0.5;\r\n\r\n\t},\r\n\r\n\tisClockWise: function ( pts ) {\r\n\r\n\t\treturn ShapeUtils.area( pts ) < 0;\r\n\r\n\t},\r\n\r\n\ttriangulateShape: function ( contour, holes ) {\r\n\r\n\t\tvar vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]\r\n\t\tvar holeIndices = []; // array of hole indices\r\n\t\tvar faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]\r\n\r\n\t\tremoveDupEndPts( contour );\r\n\t\taddContour( vertices, contour );\r\n\r\n\t\t//\r\n\r\n\t\tvar holeIndex = contour.length;\r\n\r\n\t\tholes.forEach( removeDupEndPts );\r\n\r\n\t\tfor ( var i = 0; i < holes.length; i ++ ) {\r\n\r\n\t\t\tholeIndices.push( holeIndex );\r\n\t\t\tholeIndex += holes[ i ].length;\r\n\t\t\taddContour( vertices, holes[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tvar triangles = Earcut.triangulate( vertices, holeIndices );\r\n\r\n\t\t//\r\n\r\n\t\tfor ( var i = 0; i < triangles.length; i += 3 ) {\r\n\r\n\t\t\tfaces.push( triangles.slice( i, i + 3 ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn faces;\r\n\r\n\t}\r\n\r\n};\r\n\r\nfunction removeDupEndPts( points ) {\r\n\r\n\tvar l = points.length;\r\n\r\n\tif ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {\r\n\r\n\t\tpoints.pop();\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction addContour( vertices, contour ) {\r\n\r\n\tfor ( var i = 0; i < contour.length; i ++ ) {\r\n\r\n\t\tvertices.push( contour[ i ].x );\r\n\t\tvertices.push( contour[ i ].y );\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/loader/ExtrudeGeometry.js\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n * Creates extruded geometry from a path shape.\r\n *\r\n * parameters = {\r\n *\r\n *  curveSegments: <int>, // number of points on the curves\r\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\r\n *  depth: <float>, // Depth to extrude the shape\r\n *\r\n *  bevelEnabled: <bool>, // turn on bevel\r\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\r\n *  bevelSize: <float>, // how far from shape outline is bevel\r\n *  bevelSegments: <int>, // number of bevel layers\r\n *\r\n *  extrudePath: <COOL.Curve> // curve to extrude shape along\r\n *\r\n *  UVGenerator: <Object> // object that provides UV generator functions\r\n *\r\n * }\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// ExtrudeGeometry\r\n\r\nfunction ExtrudeGeometry( shapes, options ) {\r\n\r\n\tloader_Geometry_Geometry.call( this );\r\n\r\n\tthis.type = 'ExtrudeGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tshapes: shapes,\r\n\t\toptions: options\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );\r\n\tthis.mergeVertices();\r\n\r\n}\r\n\r\nExtrudeGeometry.prototype = Object.create( loader_Geometry_Geometry.prototype );\r\nExtrudeGeometry.prototype.constructor = ExtrudeGeometry;\r\n\r\nExtrudeGeometry.prototype.toJSON = function () {\r\n\r\n\tvar data = loader_Geometry_Geometry.prototype.toJSON.call( this );\r\n\r\n\tvar shapes = this.parameters.shapes;\r\n\tvar options = this.parameters.options;\r\n\r\n\treturn toJSON( shapes, options, data );\r\n\r\n};\r\n\r\n// ExtrudeBufferGeometry\r\n\r\nfunction ExtrudeBufferGeometry( shapes, options ) {\r\n\r\n\tBufferGeometry.call( this );\r\n\r\n\tthis.type = 'ExtrudeBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tshapes: shapes,\r\n\t\toptions: options\r\n\t};\r\n\r\n\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\r\n\r\n\tvar scope = this;\r\n\r\n\tvar verticesArray = [];\r\n\tvar uvArray = [];\r\n\r\n\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\r\n\r\n\t\tvar shape = shapes[ i ];\r\n\t\taddShape( shape );\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\r\n\tthis.addAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );\r\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );\r\n\r\n\tthis.computeVertexNormals();\r\n\r\n\t// functions\r\n\r\n\tfunction addShape( shape ) {\r\n\r\n\t\tvar placeholder = [];\r\n\r\n\t\t// options\r\n\r\n\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\t\tvar steps = options.steps !== undefined ? options.steps : 1;\r\n\t\tvar depth = options.depth !== undefined ? options.depth : 100;\r\n\r\n\t\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\r\n\t\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;\r\n\t\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;\r\n\t\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\r\n\r\n\t\tvar extrudePath = options.extrudePath;\r\n\r\n\t\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;\r\n\r\n\t\t// deprecated options\r\n\r\n\t\tif ( options.amount !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'COOL.ExtrudeBufferGeometry: amount has been renamed to depth.' );\r\n\t\t\tdepth = options.amount;\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tvar extrudePts, extrudeByPath = false;\r\n\t\tvar splineTube, binormal, normal, position2;\r\n\r\n\t\tif ( extrudePath ) {\r\n\r\n\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\r\n\r\n\t\t\textrudeByPath = true;\r\n\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\r\n\r\n\t\t\t// SETUP TNB variables\r\n\r\n\t\t\t// TODO1 - have a .isClosed in spline?\r\n\r\n\t\t\tsplineTube = extrudePath.computeFrenetFrames( steps, false );\r\n\r\n\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\r\n\r\n\t\t\tbinormal = new Vector3();\r\n\t\t\tnormal = new Vector3();\r\n\t\t\tposition2 = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\t// Safeguards if bevels are not enabled\r\n\r\n\t\tif ( ! bevelEnabled ) {\r\n\r\n\t\t\tbevelSegments = 0;\r\n\t\t\tbevelThickness = 0;\r\n\t\t\tbevelSize = 0;\r\n\r\n\t\t}\r\n\r\n\t\t// Variables initialization\r\n\r\n\t\tvar ahole, h, hl; // looping of holes\r\n\r\n\t\tvar shapePoints = shape.extractPoints( curveSegments );\r\n\r\n\t\tvar vertices = shapePoints.shape;\r\n\t\tvar holes = shapePoints.holes;\r\n\r\n\t\tvar reverse = ! ShapeUtils.isClockWise( vertices );\r\n\r\n\t\tif ( reverse ) {\r\n\r\n\t\t\tvertices = vertices.reverse();\r\n\r\n\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\r\n\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\t\tahole = holes[ h ];\r\n\r\n\t\t\t\tif ( ShapeUtils.isClockWise( ahole ) ) {\r\n\r\n\t\t\t\t\tholes[ h ] = ahole.reverse();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\tvar faces = ShapeUtils.triangulateShape( vertices, holes );\r\n\r\n\t\t/* Vertices */\r\n\r\n\t\tvar contour = vertices; // vertices has all points but contour has only points of circumference\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\r\n\t\t\tvertices = vertices.concat( ahole );\r\n\r\n\t\t}\r\n\r\n\r\n\t\tfunction scalePt2( pt, vec, size ) {\r\n\r\n\t\t\tif ( ! vec ) console.error( \"COOL.ExtrudeGeometry: vec does not exist\" );\r\n\r\n\t\t\treturn vec.clone().multiplyScalar( size ).add( pt );\r\n\r\n\t\t}\r\n\r\n\t\tvar b, bs, t, z,\r\n\t\t\tvert, vlen = vertices.length,\r\n\t\t\tface, flen = faces.length;\r\n\r\n\r\n\t\t// Find directions for point movement\r\n\r\n\r\n\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\r\n\r\n\t\t\t// computes for inPt the corresponding point inPt' on a new contour\r\n\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\r\n\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\r\n\t\t\t//\r\n\t\t\t// inPt' is the intersection of the two lines parallel to the two\r\n\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\r\n\r\n\t\t\tvar v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\r\n\r\n\t\t\t// good reading for geometry algorithms (here: line-line intersection)\r\n\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\r\n\r\n\t\t\tvar v_prev_x = inPt.x - inPrev.x,\r\n\t\t\t\tv_prev_y = inPt.y - inPrev.y;\r\n\t\t\tvar v_next_x = inNext.x - inPt.x,\r\n\t\t\t\tv_next_y = inNext.y - inPt.y;\r\n\r\n\t\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\r\n\r\n\t\t\t// check for collinear edges\r\n\t\t\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\r\n\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\r\n\r\n\t\t\t\t// not collinear\r\n\r\n\t\t\t\t// length of vectors for normalizing\r\n\r\n\t\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\r\n\t\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\r\n\r\n\t\t\t\t// shift adjacent points by unit vectors to the left\r\n\r\n\t\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\r\n\t\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\r\n\r\n\t\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\r\n\t\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\r\n\r\n\t\t\t\t// scaling factor for v_prev to intersection point\r\n\r\n\t\t\t\tvar sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\r\n\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /\r\n\t\t\t\t\t( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\r\n\t\t\t\t// vector from inPt to intersection point\r\n\r\n\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\r\n\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\r\n\r\n\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\r\n\t\t\t\t//  but prevent crazy spikes\r\n\t\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\r\n\t\t\t\tif ( v_trans_lensq <= 2 ) {\r\n\r\n\t\t\t\t\treturn new Vector2( v_trans_x, v_trans_y );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// handle special case of collinear edges\r\n\r\n\t\t\t\tvar direction_eq = false; // assumes: opposite\r\n\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\r\n\r\n\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\r\n\r\n\t\t\t\t\t\tdirection_eq = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\r\n\r\n\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\r\n\r\n\t\t\t\t\t\t\tdirection_eq = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\r\n\r\n\t\t\t\t\t\t\tdirection_eq = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( direction_eq ) {\r\n\r\n\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\r\n\t\t\t\t\tv_trans_x = - v_prev_y;\r\n\t\t\t\t\tv_trans_y = v_prev_x;\r\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\r\n\t\t\t\t\tv_trans_x = v_prev_x;\r\n\t\t\t\t\tv_trans_y = v_prev_y;\r\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\r\n\r\n\t\t}\r\n\r\n\r\n\t\tvar contourMovements = [];\r\n\r\n\t\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\r\n\t\t\tif ( j === il ) j = 0;\r\n\t\t\tif ( k === il ) k = 0;\r\n\r\n\t\t\t//  (j)---(i)---(k)\r\n\t\t\t// console.log('i,j,k', i, j , k)\r\n\r\n\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\r\n\r\n\t\t}\r\n\r\n\t\tvar holesMovements = [],\r\n\t\t\toneHoleMovements, verticesMovements = contourMovements.concat();\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\r\n\t\t\toneHoleMovements = [];\r\n\r\n\t\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\r\n\t\t\t\tif ( j === il ) j = 0;\r\n\t\t\t\tif ( k === il ) k = 0;\r\n\r\n\t\t\t\t//  (j)---(i)---(k)\r\n\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tholesMovements.push( oneHoleMovements );\r\n\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\r\n\r\n\t\t}\r\n\r\n\r\n\t\t// Loop bevelSegments, 1 for the front, 1 for the back\r\n\r\n\t\tfor ( b = 0; b < bevelSegments; b ++ ) {\r\n\r\n\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\r\n\r\n\t\t\tt = b / bevelSegments;\r\n\t\t\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\r\n\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\r\n\r\n\t\t\t// contract shape\r\n\r\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\r\n\t\t\t\tv( vert.x, vert.y, - z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// expand holes\r\n\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\t\tahole = holes[ h ];\r\n\t\t\t\toneHoleMovements = holesMovements[ h ];\r\n\r\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\r\n\t\t\t\t\tv( vert.x, vert.y, - z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tbs = bevelSize;\r\n\r\n\t\t// Back facing vertices\r\n\r\n\t\tfor ( i = 0; i < vlen; i ++ ) {\r\n\r\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\r\n\t\t\tif ( ! extrudeByPath ) {\r\n\r\n\t\t\t\tv( vert.x, vert.y, 0 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\r\n\r\n\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\r\n\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\r\n\r\n\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\r\n\r\n\t\t\t\tv( position2.x, position2.y, position2.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Add stepped vertices...\r\n\t\t// Including front facing vertices\r\n\r\n\t\tvar s;\r\n\r\n\t\tfor ( s = 1; s <= steps; s ++ ) {\r\n\r\n\t\t\tfor ( i = 0; i < vlen; i ++ ) {\r\n\r\n\t\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\r\n\t\t\t\tif ( ! extrudeByPath ) {\r\n\r\n\t\t\t\t\tv( vert.x, vert.y, depth / steps * s );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\r\n\r\n\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\r\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\r\n\r\n\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\r\n\r\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\t// Add bevel segments planes\r\n\r\n\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\r\n\t\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\r\n\r\n\t\t\tt = b / bevelSegments;\r\n\t\t\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\r\n\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\r\n\r\n\t\t\t// contract shape\r\n\r\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\t\t\t\tv( vert.x, vert.y, depth + z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// expand holes\r\n\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\t\tahole = holes[ h ];\r\n\t\t\t\toneHoleMovements = holesMovements[ h ];\r\n\r\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\r\n\t\t\t\t\tif ( ! extrudeByPath ) {\r\n\r\n\t\t\t\t\t\tv( vert.x, vert.y, depth + z );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t/* Faces */\r\n\r\n\t\t// Top and bottom faces\r\n\r\n\t\tbuildLidFaces();\r\n\r\n\t\t// Sides faces\r\n\r\n\t\tbuildSideFaces();\r\n\r\n\r\n\t\t/////  Internal functions\r\n\r\n\t\tfunction buildLidFaces() {\r\n\r\n\t\t\tvar start = verticesArray.length / 3;\r\n\r\n\t\t\tif ( bevelEnabled ) {\r\n\r\n\t\t\t\tvar layer = 0; // steps + 1\r\n\t\t\t\tvar offset = vlen * layer;\r\n\r\n\t\t\t\t// Bottom faces\r\n\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlayer = steps + bevelSegments * 2;\r\n\t\t\t\toffset = vlen * layer;\r\n\r\n\t\t\t\t// Top faces\r\n\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Bottom faces\r\n\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Top faces\r\n\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 0 );\r\n\r\n\t\t}\r\n\r\n\t\t// Create faces for the z-sides of the shape\r\n\r\n\t\tfunction buildSideFaces() {\r\n\r\n\t\t\tvar start = verticesArray.length / 3;\r\n\t\t\tvar layeroffset = 0;\r\n\t\t\tsidewalls( contour, layeroffset );\r\n\t\t\tlayeroffset += contour.length;\r\n\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\t\tahole = holes[ h ];\r\n\t\t\t\tsidewalls( ahole, layeroffset );\r\n\r\n\t\t\t\t//, true\r\n\t\t\t\tlayeroffset += ahole.length;\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 1 );\r\n\r\n\r\n\t\t}\r\n\r\n\t\tfunction sidewalls( contour, layeroffset ) {\r\n\r\n\t\t\tvar j, k;\r\n\t\t\ti = contour.length;\r\n\r\n\t\t\twhile ( -- i >= 0 ) {\r\n\r\n\t\t\t\tj = i;\r\n\t\t\t\tk = i - 1;\r\n\t\t\t\tif ( k < 0 ) k = contour.length - 1;\r\n\r\n\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\r\n\r\n\t\t\t\tvar s = 0,\r\n\t\t\t\t\tsl = steps + bevelSegments * 2;\r\n\r\n\t\t\t\tfor ( s = 0; s < sl; s ++ ) {\r\n\r\n\t\t\t\t\tvar slen1 = vlen * s;\r\n\t\t\t\t\tvar slen2 = vlen * ( s + 1 );\r\n\r\n\t\t\t\t\tvar a = layeroffset + j + slen1,\r\n\t\t\t\t\t\tb = layeroffset + k + slen1,\r\n\t\t\t\t\t\tc = layeroffset + k + slen2,\r\n\t\t\t\t\t\td = layeroffset + j + slen2;\r\n\r\n\t\t\t\t\tf4( a, b, c, d );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction v( x, y, z ) {\r\n\r\n\t\t\tplaceholder.push( x );\r\n\t\t\tplaceholder.push( y );\r\n\t\t\tplaceholder.push( z );\r\n\r\n\t\t}\r\n\r\n\r\n\t\tfunction f3( a, b, c ) {\r\n\r\n\t\t\taddVertex( a );\r\n\t\t\taddVertex( b );\r\n\t\t\taddVertex( c );\r\n\r\n\t\t\tvar nextIndex = verticesArray.length / 3;\r\n\t\t\tvar uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\r\n\r\n\t\t\taddUV( uvs[ 0 ] );\r\n\t\t\taddUV( uvs[ 1 ] );\r\n\t\t\taddUV( uvs[ 2 ] );\r\n\r\n\t\t}\r\n\r\n\t\tfunction f4( a, b, c, d ) {\r\n\r\n\t\t\taddVertex( a );\r\n\t\t\taddVertex( b );\r\n\t\t\taddVertex( d );\r\n\r\n\t\t\taddVertex( b );\r\n\t\t\taddVertex( c );\r\n\t\t\taddVertex( d );\r\n\r\n\r\n\t\t\tvar nextIndex = verticesArray.length / 3;\r\n\t\t\tvar uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\r\n\r\n\t\t\taddUV( uvs[ 0 ] );\r\n\t\t\taddUV( uvs[ 1 ] );\r\n\t\t\taddUV( uvs[ 3 ] );\r\n\r\n\t\t\taddUV( uvs[ 1 ] );\r\n\t\t\taddUV( uvs[ 2 ] );\r\n\t\t\taddUV( uvs[ 3 ] );\r\n\r\n\t\t}\r\n\r\n\t\tfunction addVertex( index ) {\r\n\r\n\t\t\tverticesArray.push( placeholder[ index * 3 + 0 ] );\r\n\t\t\tverticesArray.push( placeholder[ index * 3 + 1 ] );\r\n\t\t\tverticesArray.push( placeholder[ index * 3 + 2 ] );\r\n\r\n\t\t}\r\n\r\n\r\n\t\tfunction addUV( vector2 ) {\r\n\r\n\t\t\tuvArray.push( vector2.x );\r\n\t\t\tuvArray.push( vector2.y );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\r\nExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;\r\n\r\nExtrudeBufferGeometry.prototype.toJSON = function () {\r\n\r\n\tvar data = BufferGeometry.prototype.toJSON.call( this );\r\n\r\n\tvar shapes = this.parameters.shapes;\r\n\tvar options = this.parameters.options;\r\n\r\n\treturn toJSON( shapes, options, data );\r\n\r\n};\r\n\r\n//\r\n\r\nvar WorldUVGenerator = {\r\n\r\n\tgenerateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {\r\n\r\n\t\tvar a_x = vertices[ indexA * 3 ];\r\n\t\tvar a_y = vertices[ indexA * 3 + 1 ];\r\n\t\tvar b_x = vertices[ indexB * 3 ];\r\n\t\tvar b_y = vertices[ indexB * 3 + 1 ];\r\n\t\tvar c_x = vertices[ indexC * 3 ];\r\n\t\tvar c_y = vertices[ indexC * 3 + 1 ];\r\n\r\n\t\treturn [\r\n\t\t\tnew Vector2( a_x, a_y ),\r\n\t\t\tnew Vector2( b_x, b_y ),\r\n\t\t\tnew Vector2( c_x, c_y )\r\n\t\t];\r\n\r\n\t},\r\n\r\n\tgenerateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {\r\n\r\n\t\tvar a_x = vertices[ indexA * 3 ];\r\n\t\tvar a_y = vertices[ indexA * 3 + 1 ];\r\n\t\tvar a_z = vertices[ indexA * 3 + 2 ];\r\n\t\tvar b_x = vertices[ indexB * 3 ];\r\n\t\tvar b_y = vertices[ indexB * 3 + 1 ];\r\n\t\tvar b_z = vertices[ indexB * 3 + 2 ];\r\n\t\tvar c_x = vertices[ indexC * 3 ];\r\n\t\tvar c_y = vertices[ indexC * 3 + 1 ];\r\n\t\tvar c_z = vertices[ indexC * 3 + 2 ];\r\n\t\tvar d_x = vertices[ indexD * 3 ];\r\n\t\tvar d_y = vertices[ indexD * 3 + 1 ];\r\n\t\tvar d_z = vertices[ indexD * 3 + 2 ];\r\n\r\n\t\tif ( Math.abs( a_y - b_y ) < 0.01 ) {\r\n\r\n\t\t\treturn [\r\n\t\t\t\tnew Vector2( a_x, 1 - a_z ),\r\n\t\t\t\tnew Vector2( b_x, 1 - b_z ),\r\n\t\t\t\tnew Vector2( c_x, 1 - c_z ),\r\n\t\t\t\tnew Vector2( d_x, 1 - d_z )\r\n\t\t\t];\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn [\r\n\t\t\t\tnew Vector2( a_y, 1 - a_z ),\r\n\t\t\t\tnew Vector2( b_y, 1 - b_z ),\r\n\t\t\t\tnew Vector2( c_y, 1 - c_z ),\r\n\t\t\t\tnew Vector2( d_y, 1 - d_z )\r\n\t\t\t];\r\n\r\n\t\t}\r\n\r\n\t}\r\n};\r\n\r\nfunction toJSON( shapes, options, data ) {\r\n\r\n\t//\r\n\r\n\tdata.shapes = [];\r\n\r\n\tif ( Array.isArray( shapes ) ) {\r\n\r\n\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar shape = shapes[ i ];\r\n\r\n\t\t\tdata.shapes.push( shape.uuid );\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tdata.shapes.push( shapes.uuid );\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tif ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();\r\n\r\n\treturn data;\r\n\r\n}\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/core/Curve.js\n\r\n\r\n\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Extensible curve object\r\n *\r\n * Some common of curve methods:\r\n * .getPoint( t, optionalTarget ), .getTangent( t )\r\n * .getPointAt( u, optionalTarget ), .getTangentAt( u )\r\n * .getPoints(), .getSpacedPoints()\r\n * .getLength()\r\n * .updateArcLengths()\r\n *\r\n * This following curves inherit from COOL.Curve:\r\n *\r\n * -- 2D curves --\r\n * COOL.ArcCurve\r\n * COOL.CubicBezierCurve\r\n * COOL.EllipseCurve\r\n * COOL.LineCurve\r\n * COOL.QuadraticBezierCurve\r\n * COOL.SplineCurve\r\n *\r\n * -- 3D curves --\r\n * COOL.CatmullRomCurve3\r\n * COOL.CubicBezierCurve3\r\n * COOL.LineCurve3\r\n * COOL.QuadraticBezierCurve3\r\n *\r\n * A series of curves can be represented as a COOL.CurvePath.\r\n *\r\n **/\r\n\r\n/**************************************************************\r\n *\tAbstract Curve base class\r\n **************************************************************/\r\n\r\nfunction Curve() {\r\n\r\n\tthis.type = 'Curve';\r\n\r\n\tthis.arcLengthDivisions = 200;\r\n\r\n}\r\n\r\nObject.assign( Curve.prototype, {\r\n\r\n\t// Virtual base class method to overwrite and implement in subclasses\r\n\t//\t- t [0 .. 1]\r\n\r\n\tgetPoint: function ( /* t, optionalTarget */ ) {\r\n\r\n\t\tconsole.warn( 'COOL.Curve: .getPoint() not implemented.' );\r\n\t\treturn null;\r\n\r\n\t},\r\n\r\n\t// Get point at relative position in curve according to arc length\r\n\t// - u [0 .. 1]\r\n\r\n\tgetPointAt: function ( u, optionalTarget ) {\r\n\r\n\t\tvar t = this.getUtoTmapping( u );\r\n\t\treturn this.getPoint( t, optionalTarget );\r\n\r\n\t},\r\n\r\n\t// Get sequence of points using getPoint( t )\r\n\r\n\tgetPoints: function ( divisions ) {\r\n\r\n\t\tif ( divisions === undefined ) divisions = 5;\r\n\r\n\t\tvar points = [];\r\n\r\n\t\tfor ( var d = 0; d <= divisions; d ++ ) {\r\n\r\n\t\t\tpoints.push( this.getPoint( d / divisions ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn points;\r\n\r\n\t},\r\n\r\n\t// Get sequence of points using getPointAt( u )\r\n\r\n\tgetSpacedPoints: function ( divisions ) {\r\n\r\n\t\tif ( divisions === undefined ) divisions = 5;\r\n\r\n\t\tvar points = [];\r\n\r\n\t\tfor ( var d = 0; d <= divisions; d ++ ) {\r\n\r\n\t\t\tpoints.push( this.getPointAt( d / divisions ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn points;\r\n\r\n\t},\r\n\r\n\t// Get total curve arc length\r\n\r\n\tgetLength: function () {\r\n\r\n\t\tvar lengths = this.getLengths();\r\n\t\treturn lengths[ lengths.length - 1 ];\r\n\r\n\t},\r\n\r\n\t// Get list of cumulative segment lengths\r\n\r\n\tgetLengths: function ( divisions ) {\r\n\r\n\t\tif ( divisions === undefined ) divisions = this.arcLengthDivisions;\r\n\r\n\t\tif ( this.cacheArcLengths &&\r\n\t\t\t( this.cacheArcLengths.length === divisions + 1 ) &&\r\n\t\t\t! this.needsUpdate ) {\r\n\r\n\t\t\treturn this.cacheArcLengths;\r\n\r\n\t\t}\r\n\r\n\t\tthis.needsUpdate = false;\r\n\r\n\t\tvar cache = [];\r\n\t\tvar current, last = this.getPoint( 0 );\r\n\t\tvar p, sum = 0;\r\n\r\n\t\tcache.push( 0 );\r\n\r\n\t\tfor ( p = 1; p <= divisions; p ++ ) {\r\n\r\n\t\t\tcurrent = this.getPoint( p / divisions );\r\n\t\t\tsum += current.distanceTo( last );\r\n\t\t\tcache.push( sum );\r\n\t\t\tlast = current;\r\n\r\n\t\t}\r\n\r\n\t\tthis.cacheArcLengths = cache;\r\n\r\n\t\treturn cache; // { sums: cache, sum: sum }; Sum is in the last element.\r\n\r\n\t},\r\n\r\n\tupdateArcLengths: function () {\r\n\r\n\t\tthis.needsUpdate = true;\r\n\t\tthis.getLengths();\r\n\r\n\t},\r\n\r\n\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\r\n\r\n\tgetUtoTmapping: function ( u, distance ) {\r\n\r\n\t\tvar arcLengths = this.getLengths();\r\n\r\n\t\tvar i = 0, il = arcLengths.length;\r\n\r\n\t\tvar targetArcLength; // The targeted u distance value to get\r\n\r\n\t\tif ( distance ) {\r\n\r\n\t\t\ttargetArcLength = distance;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\r\n\r\n\t\t}\r\n\r\n\t\t// binary search for the index with largest value smaller than target u distance\r\n\r\n\t\tvar low = 0, high = il - 1, comparison;\r\n\r\n\t\twhile ( low <= high ) {\r\n\r\n\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\r\n\r\n\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\r\n\r\n\t\t\tif ( comparison < 0 ) {\r\n\r\n\t\t\t\tlow = i + 1;\r\n\r\n\t\t\t} else if ( comparison > 0 ) {\r\n\r\n\t\t\t\thigh = i - 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\thigh = i;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t\t// DONE\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\ti = high;\r\n\r\n\t\tif ( arcLengths[ i ] === targetArcLength ) {\r\n\r\n\t\t\treturn i / ( il - 1 );\r\n\r\n\t\t}\r\n\r\n\t\t// we could get finer grain at lengths, or use simple interpolation between two points\r\n\r\n\t\tvar lengthBefore = arcLengths[ i ];\r\n\t\tvar lengthAfter = arcLengths[ i + 1 ];\r\n\r\n\t\tvar segmentLength = lengthAfter - lengthBefore;\r\n\r\n\t\t// determine where we are between the 'before' and 'after' points\r\n\r\n\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\r\n\r\n\t\t// add that fractional amount to t\r\n\r\n\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\r\n\r\n\t\treturn t;\r\n\r\n\t},\r\n\r\n\t// Returns a unit vector tangent at t\r\n\t// In case any sub curve does not implement its tangent derivation,\r\n\t// 2 points a small delta apart will be used to find its gradient\r\n\t// which seems to give a reasonable approximation\r\n\r\n\tgetTangent: function ( t ) {\r\n\r\n\t\tvar delta = 0.0001;\r\n\t\tvar t1 = t - delta;\r\n\t\tvar t2 = t + delta;\r\n\r\n\t\t// Capping in case of danger\r\n\r\n\t\tif ( t1 < 0 ) t1 = 0;\r\n\t\tif ( t2 > 1 ) t2 = 1;\r\n\r\n\t\tvar pt1 = this.getPoint( t1 );\r\n\t\tvar pt2 = this.getPoint( t2 );\r\n\r\n\t\tvar vec = pt2.clone().sub( pt1 );\r\n\t\treturn vec.normalize();\r\n\r\n\t},\r\n\r\n\tgetTangentAt: function ( u ) {\r\n\r\n\t\tvar t = this.getUtoTmapping( u );\r\n\t\treturn this.getTangent( t );\r\n\r\n\t},\r\n\r\n\tcomputeFrenetFrames: function ( segments, closed ) {\r\n\r\n\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\r\n\r\n\t\tvar normal = new Vector3();\r\n\r\n\t\tvar tangents = [];\r\n\t\tvar normals = [];\r\n\t\tvar binormals = [];\r\n\r\n\t\tvar vec = new Vector3();\r\n\t\tvar mat = new Matrix4();\r\n\r\n\t\tvar i, u, theta;\r\n\r\n\t\t// compute the tangent vectors for each segment on the curve\r\n\r\n\t\tfor ( i = 0; i <= segments; i ++ ) {\r\n\r\n\t\t\tu = i / segments;\r\n\r\n\t\t\ttangents[ i ] = this.getTangentAt( u );\r\n\t\t\ttangents[ i ].normalize();\r\n\r\n\t\t}\r\n\r\n\t\t// select an initial normal vector perpendicular to the first tangent vector,\r\n\t\t// and in the direction of the minimum tangent xyz component\r\n\r\n\t\tnormals[ 0 ] = new Vector3();\r\n\t\tbinormals[ 0 ] = new Vector3();\r\n\t\tvar min = Number.MAX_VALUE;\r\n\t\tvar tx = Math.abs( tangents[ 0 ].x );\r\n\t\tvar ty = Math.abs( tangents[ 0 ].y );\r\n\t\tvar tz = Math.abs( tangents[ 0 ].z );\r\n\r\n\t\tif ( tx <= min ) {\r\n\r\n\t\t\tmin = tx;\r\n\t\t\tnormal.set( 1, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( ty <= min ) {\r\n\r\n\t\t\tmin = ty;\r\n\t\t\tnormal.set( 0, 1, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( tz <= min ) {\r\n\r\n\t\t\tnormal.set( 0, 0, 1 );\r\n\r\n\t\t}\r\n\r\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\r\n\r\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\r\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\r\n\r\n\t\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\r\n\r\n\t\tfor ( i = 1; i <= segments; i ++ ) {\r\n\r\n\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\r\n\r\n\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\r\n\r\n\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\r\n\r\n\t\t\tif ( vec.length() > Number.EPSILON ) {\r\n\r\n\t\t\t\tvec.normalize();\r\n\r\n\t\t\t\ttheta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\r\n\r\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\r\n\r\n\t\tif ( closed === true ) {\r\n\r\n\t\t\ttheta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\r\n\t\t\ttheta /= segments;\r\n\r\n\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\r\n\r\n\t\t\t\ttheta = - theta;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( i = 1; i <= segments; i ++ ) {\r\n\r\n\t\t\t\t// twist a little...\r\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\r\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\ttangents: tangents,\r\n\t\t\tnormals: normals,\r\n\t\t\tbinormals: binormals\r\n\t\t};\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.arcLengthDivisions = source.arcLengthDivisions;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar data = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.5,\r\n\t\t\t\ttype: 'Curve',\r\n\t\t\t\tgenerator: 'Curve.toJSON'\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tdata.arcLengthDivisions = this.arcLengthDivisions;\r\n\t\tdata.type = this.type;\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tfromJSON: function ( json ) {\r\n\r\n\t\tthis.arcLengthDivisions = json.arcLengthDivisions;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/curves/EllipseCurve.js\n\r\n\r\n\r\n\r\nfunction EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\r\n\tCurve.call( this );\r\n\r\n\tthis.type = 'EllipseCurve';\r\n\r\n\tthis.aX = aX || 0;\r\n\tthis.aY = aY || 0;\r\n\r\n\tthis.xRadius = xRadius || 1;\r\n\tthis.yRadius = yRadius || 1;\r\n\r\n\tthis.aStartAngle = aStartAngle || 0;\r\n\tthis.aEndAngle = aEndAngle || 2 * Math.PI;\r\n\r\n\tthis.aClockwise = aClockwise || false;\r\n\r\n\tthis.aRotation = aRotation || 0;\r\n\r\n}\r\n\r\nEllipseCurve.prototype = Object.create( Curve.prototype );\r\nEllipseCurve.prototype.constructor = EllipseCurve;\r\n\r\nEllipseCurve.prototype.isEllipseCurve = true;\r\n\r\nEllipseCurve.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\tvar point = optionalTarget || new Vector2();\r\n\r\n\tvar twoPi = Math.PI * 2;\r\n\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\r\n\tvar samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\r\n\r\n\t// ensures that deltaAngle is 0 .. 2 PI\r\n\twhile ( deltaAngle < 0 ) deltaAngle += twoPi;\r\n\twhile ( deltaAngle > twoPi ) deltaAngle -= twoPi;\r\n\r\n\tif ( deltaAngle < Number.EPSILON ) {\r\n\r\n\t\tif ( samePoints ) {\r\n\r\n\t\t\tdeltaAngle = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tdeltaAngle = twoPi;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif ( this.aClockwise === true && ! samePoints ) {\r\n\r\n\t\tif ( deltaAngle === twoPi ) {\r\n\r\n\t\t\tdeltaAngle = - twoPi;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tdeltaAngle = deltaAngle - twoPi;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvar angle = this.aStartAngle + t * deltaAngle;\r\n\tvar x = this.aX + this.xRadius * Math.cos( angle );\r\n\tvar y = this.aY + this.yRadius * Math.sin( angle );\r\n\r\n\tif ( this.aRotation !== 0 ) {\r\n\r\n\t\tvar cos = Math.cos( this.aRotation );\r\n\t\tvar sin = Math.sin( this.aRotation );\r\n\r\n\t\tvar tx = x - this.aX;\r\n\t\tvar ty = y - this.aY;\r\n\r\n\t\t// Rotate the point about the center of the ellipse.\r\n\t\tx = tx * cos - ty * sin + this.aX;\r\n\t\ty = tx * sin + ty * cos + this.aY;\r\n\r\n\t}\r\n\r\n\treturn point.set( x, y );\r\n\r\n};\r\n\r\nEllipseCurve.prototype.copy = function ( source ) {\r\n\r\n\tCurve.prototype.copy.call( this, source );\r\n\r\n\tthis.aX = source.aX;\r\n\tthis.aY = source.aY;\r\n\r\n\tthis.xRadius = source.xRadius;\r\n\tthis.yRadius = source.yRadius;\r\n\r\n\tthis.aStartAngle = source.aStartAngle;\r\n\tthis.aEndAngle = source.aEndAngle;\r\n\r\n\tthis.aClockwise = source.aClockwise;\r\n\r\n\tthis.aRotation = source.aRotation;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n\r\nEllipseCurve.prototype.toJSON = function () {\r\n\r\n\tvar data = Curve.prototype.toJSON.call( this );\r\n\r\n\tdata.aX = this.aX;\r\n\tdata.aY = this.aY;\r\n\r\n\tdata.xRadius = this.xRadius;\r\n\tdata.yRadius = this.yRadius;\r\n\r\n\tdata.aStartAngle = this.aStartAngle;\r\n\tdata.aEndAngle = this.aEndAngle;\r\n\r\n\tdata.aClockwise = this.aClockwise;\r\n\r\n\tdata.aRotation = this.aRotation;\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nEllipseCurve.prototype.fromJSON = function ( json ) {\r\n\r\n\tCurve.prototype.fromJSON.call( this, json );\r\n\r\n\tthis.aX = json.aX;\r\n\tthis.aY = json.aY;\r\n\r\n\tthis.xRadius = json.xRadius;\r\n\tthis.yRadius = json.yRadius;\r\n\r\n\tthis.aStartAngle = json.aStartAngle;\r\n\tthis.aEndAngle = json.aEndAngle;\r\n\r\n\tthis.aClockwise = json.aClockwise;\r\n\r\n\tthis.aRotation = json.aRotation;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/curves/ArcCurve.js\n\r\n\r\n\r\nfunction ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tEllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\r\n\r\n\tthis.type = 'ArcCurve';\r\n\r\n}\r\n\r\nArcCurve.prototype = Object.create( EllipseCurve.prototype );\r\nArcCurve.prototype.constructor = ArcCurve;\r\n\r\nArcCurve.prototype.isArcCurve = true;\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/curves/CatmullRomCurve3.js\n\r\n\r\n\r\n/**\r\n * @author zz85 https://github.com/zz85\r\n *\r\n * Centripetal CatmullRom Curve - which is useful for avoiding\r\n * cusps and self-intersections in non-uniform catmull rom curves.\r\n * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\r\n *\r\n * curve.type accepts centripetal(default), chordal and catmullrom\r\n * curve.tension is used for catmullrom which defaults to 0.5\r\n */\r\n\r\n\r\n/*\r\nBased on an optimized c++ solution in\r\n - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\r\n - http://ideone.com/NoEbVM\r\n\r\nThis CubicPoly class could be used for reusing some variables and calculations,\r\nbut for COOL.js curve use, it could be possible inlined and flatten into a single function call\r\nwhich can be placed in CurveUtils.\r\n*/\r\n\r\nfunction CubicPoly() {\r\n\r\n\tvar c0 = 0, c1 = 0, c2 = 0, c3 = 0;\r\n\r\n\t/*\r\n\t * Compute coefficients for a cubic polynomial\r\n\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\r\n\t * such that\r\n\t *   p(0) = x0, p(1) = x1\r\n\t *  and\r\n\t *   p'(0) = t0, p'(1) = t1.\r\n\t */\r\n\tfunction init( x0, x1, t0, t1 ) {\r\n\r\n\t\tc0 = x0;\r\n\t\tc1 = t0;\r\n\t\tc2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\r\n\t\tc3 = 2 * x0 - 2 * x1 + t0 + t1;\r\n\r\n\t}\r\n\r\n\treturn {\r\n\r\n\t\tinitCatmullRom: function ( x0, x1, x2, x3, tension ) {\r\n\r\n\t\t\tinit( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\r\n\r\n\t\t},\r\n\r\n\t\tinitNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {\r\n\r\n\t\t\t// compute tangents when parameterized in [t1,t2]\r\n\t\t\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\r\n\t\t\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\r\n\r\n\t\t\t// rescale tangents for parametrization in [0,1]\r\n\t\t\tt1 *= dt1;\r\n\t\t\tt2 *= dt1;\r\n\r\n\t\t\tinit( x1, x2, t1, t2 );\r\n\r\n\t\t},\r\n\r\n\t\tcalc: function ( t ) {\r\n\r\n\t\t\tvar t2 = t * t;\r\n\t\t\tvar t3 = t2 * t;\r\n\t\t\treturn c0 + c1 * t + c2 * t2 + c3 * t3;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}\r\n\r\n//\r\n\r\nvar tmp = new Vector3();\r\nvar px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();\r\n\r\nfunction CatmullRomCurve3( points, closed, curveType, tension ) {\r\n\r\n\tCurve.call( this );\r\n\r\n\tthis.type = 'CatmullRomCurve3';\r\n\r\n\tthis.points = points || [];\r\n\tthis.closed = closed || false;\r\n\tthis.curveType = curveType || 'centripetal';\r\n\tthis.tension = tension || 0.5;\r\n\r\n}\r\n\r\nCatmullRomCurve3.prototype = Object.create( Curve.prototype );\r\nCatmullRomCurve3.prototype.constructor = CatmullRomCurve3;\r\n\r\nCatmullRomCurve3.prototype.isCatmullRomCurve3 = true;\r\n\r\nCatmullRomCurve3.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\tvar point = optionalTarget || new Vector3();\r\n\r\n\tvar points = this.points;\r\n\tvar l = points.length;\r\n\r\n\tvar p = ( l - ( this.closed ? 0 : 1 ) ) * t;\r\n\tvar intPoint = Math.floor( p );\r\n\tvar weight = p - intPoint;\r\n\r\n\tif ( this.closed ) {\r\n\r\n\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;\r\n\r\n\t} else if ( weight === 0 && intPoint === l - 1 ) {\r\n\r\n\t\tintPoint = l - 2;\r\n\t\tweight = 1;\r\n\r\n\t}\r\n\r\n\tvar p0, p1, p2, p3; // 4 points\r\n\r\n\tif ( this.closed || intPoint > 0 ) {\r\n\r\n\t\tp0 = points[ ( intPoint - 1 ) % l ];\r\n\r\n\t} else {\r\n\r\n\t\t// extrapolate first point\r\n\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\r\n\t\tp0 = tmp;\r\n\r\n\t}\r\n\r\n\tp1 = points[ intPoint % l ];\r\n\tp2 = points[ ( intPoint + 1 ) % l ];\r\n\r\n\tif ( this.closed || intPoint + 2 < l ) {\r\n\r\n\t\tp3 = points[ ( intPoint + 2 ) % l ];\r\n\r\n\t} else {\r\n\r\n\t\t// extrapolate last point\r\n\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\r\n\t\tp3 = tmp;\r\n\r\n\t}\r\n\r\n\tif ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {\r\n\r\n\t\t// init Centripetal / Chordal Catmull-Rom\r\n\t\tvar pow = this.curveType === 'chordal' ? 0.5 : 0.25;\r\n\t\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\r\n\t\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\r\n\t\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\r\n\r\n\t\t// safety check for repeated points\r\n\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\r\n\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\r\n\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\r\n\r\n\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\r\n\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\r\n\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\r\n\r\n\t} else if ( this.curveType === 'catmullrom' ) {\r\n\r\n\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );\r\n\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );\r\n\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );\r\n\r\n\t}\r\n\r\n\tpoint.set(\r\n\t\tpx.calc( weight ),\r\n\t\tpy.calc( weight ),\r\n\t\tpz.calc( weight )\r\n\t);\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\nCatmullRomCurve3.prototype.copy = function ( source ) {\r\n\r\n\tCurve.prototype.copy.call( this, source );\r\n\r\n\tthis.points = [];\r\n\r\n\tfor ( var i = 0, l = source.points.length; i < l; i ++ ) {\r\n\r\n\t\tvar point = source.points[ i ];\r\n\r\n\t\tthis.points.push( point.clone() );\r\n\r\n\t}\r\n\r\n\tthis.closed = source.closed;\r\n\tthis.curveType = source.curveType;\r\n\tthis.tension = source.tension;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nCatmullRomCurve3.prototype.toJSON = function () {\r\n\r\n\tvar data = Curve.prototype.toJSON.call( this );\r\n\r\n\tdata.points = [];\r\n\r\n\tfor ( var i = 0, l = this.points.length; i < l; i ++ ) {\r\n\r\n\t\tvar point = this.points[ i ];\r\n\t\tdata.points.push( point.toArray() );\r\n\r\n\t}\r\n\r\n\tdata.closed = this.closed;\r\n\tdata.curveType = this.curveType;\r\n\tdata.tension = this.tension;\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nCatmullRomCurve3.prototype.fromJSON = function ( json ) {\r\n\r\n\tCurve.prototype.fromJSON.call( this, json );\r\n\r\n\tthis.points = [];\r\n\r\n\tfor ( var i = 0, l = json.points.length; i < l; i ++ ) {\r\n\r\n\t\tvar point = json.points[ i ];\r\n\t\tthis.points.push( new Vector3().fromArray( point ) );\r\n\r\n\t}\r\n\r\n\tthis.closed = json.closed;\r\n\tthis.curveType = json.curveType;\r\n\tthis.tension = json.tension;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/core/Interpolations.js\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n * Bezier Curves formulas obtained from\r\n * http://en.wikipedia.org/wiki/Bézier_curve\r\n */\r\n\r\nfunction CatmullRom( t, p0, p1, p2, p3 ) {\r\n\r\n\tvar v0 = ( p2 - p0 ) * 0.5;\r\n\tvar v1 = ( p3 - p1 ) * 0.5;\r\n\tvar t2 = t * t;\r\n\tvar t3 = t * t2;\r\n\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\r\n}\r\n\r\n//\r\n\r\nfunction QuadraticBezierP0( t, p ) {\r\n\r\n\tvar k = 1 - t;\r\n\treturn k * k * p;\r\n\r\n}\r\n\r\nfunction QuadraticBezierP1( t, p ) {\r\n\r\n\treturn 2 * ( 1 - t ) * t * p;\r\n\r\n}\r\n\r\nfunction QuadraticBezierP2( t, p ) {\r\n\r\n\treturn t * t * p;\r\n\r\n}\r\n\r\nfunction QuadraticBezier( t, p0, p1, p2 ) {\r\n\r\n\treturn QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +\r\n\t\tQuadraticBezierP2( t, p2 );\r\n\r\n}\r\n\r\n//\r\n\r\nfunction CubicBezierP0( t, p ) {\r\n\r\n\tvar k = 1 - t;\r\n\treturn k * k * k * p;\r\n\r\n}\r\n\r\nfunction CubicBezierP1( t, p ) {\r\n\r\n\tvar k = 1 - t;\r\n\treturn 3 * k * k * t * p;\r\n\r\n}\r\n\r\nfunction CubicBezierP2( t, p ) {\r\n\r\n\treturn 3 * ( 1 - t ) * t * t * p;\r\n\r\n}\r\n\r\nfunction CubicBezierP3( t, p ) {\r\n\r\n\treturn t * t * t * p;\r\n\r\n}\r\n\r\nfunction CubicBezier( t, p0, p1, p2, p3 ) {\r\n\r\n\treturn CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +\r\n\t\tCubicBezierP3( t, p3 );\r\n\r\n}\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/curves/CubicBezierCurve.js\n\r\n\r\n\r\n\r\n\r\nfunction CubicBezierCurve( v0, v1, v2, v3 ) {\r\n\r\n\tCurve.call( this );\r\n\r\n\tthis.type = 'CubicBezierCurve';\r\n\r\n\tthis.v0 = v0 || new Vector2();\r\n\tthis.v1 = v1 || new Vector2();\r\n\tthis.v2 = v2 || new Vector2();\r\n\tthis.v3 = v3 || new Vector2();\r\n\r\n}\r\n\r\nCubicBezierCurve.prototype = Object.create( Curve.prototype );\r\nCubicBezierCurve.prototype.constructor = CubicBezierCurve;\r\n\r\nCubicBezierCurve.prototype.isCubicBezierCurve = true;\r\n\r\nCubicBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\tvar point = optionalTarget || new Vector2();\r\n\r\n\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\r\n\r\n\tpoint.set(\r\n\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\r\n\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y )\r\n\t);\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\nCubicBezierCurve.prototype.copy = function ( source ) {\r\n\r\n\tCurve.prototype.copy.call( this, source );\r\n\r\n\tthis.v0.copy( source.v0 );\r\n\tthis.v1.copy( source.v1 );\r\n\tthis.v2.copy( source.v2 );\r\n\tthis.v3.copy( source.v3 );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nCubicBezierCurve.prototype.toJSON = function () {\r\n\r\n\tvar data = Curve.prototype.toJSON.call( this );\r\n\r\n\tdata.v0 = this.v0.toArray();\r\n\tdata.v1 = this.v1.toArray();\r\n\tdata.v2 = this.v2.toArray();\r\n\tdata.v3 = this.v3.toArray();\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nCubicBezierCurve.prototype.fromJSON = function ( json ) {\r\n\r\n\tCurve.prototype.fromJSON.call( this, json );\r\n\r\n\tthis.v0.fromArray( json.v0 );\r\n\tthis.v1.fromArray( json.v1 );\r\n\tthis.v2.fromArray( json.v2 );\r\n\tthis.v3.fromArray( json.v3 );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/curves/CubicBezierCurve3.js\n\r\n\r\n\r\n\r\n\r\nfunction CubicBezierCurve3( v0, v1, v2, v3 ) {\r\n\r\n\tCurve.call( this );\r\n\r\n\tthis.type = 'CubicBezierCurve3';\r\n\r\n\tthis.v0 = v0 || new Vector3();\r\n\tthis.v1 = v1 || new Vector3();\r\n\tthis.v2 = v2 || new Vector3();\r\n\tthis.v3 = v3 || new Vector3();\r\n\r\n}\r\n\r\nCubicBezierCurve3.prototype = Object.create( Curve.prototype );\r\nCubicBezierCurve3.prototype.constructor = CubicBezierCurve3;\r\n\r\nCubicBezierCurve3.prototype.isCubicBezierCurve3 = true;\r\n\r\nCubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\tvar point = optionalTarget || new Vector3();\r\n\r\n\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\r\n\r\n\tpoint.set(\r\n\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\r\n\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y ),\r\n\t\tCubicBezier( t, v0.z, v1.z, v2.z, v3.z )\r\n\t);\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\nCubicBezierCurve3.prototype.copy = function ( source ) {\r\n\r\n\tCurve.prototype.copy.call( this, source );\r\n\r\n\tthis.v0.copy( source.v0 );\r\n\tthis.v1.copy( source.v1 );\r\n\tthis.v2.copy( source.v2 );\r\n\tthis.v3.copy( source.v3 );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nCubicBezierCurve3.prototype.toJSON = function () {\r\n\r\n\tvar data = Curve.prototype.toJSON.call( this );\r\n\r\n\tdata.v0 = this.v0.toArray();\r\n\tdata.v1 = this.v1.toArray();\r\n\tdata.v2 = this.v2.toArray();\r\n\tdata.v3 = this.v3.toArray();\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nCubicBezierCurve3.prototype.fromJSON = function ( json ) {\r\n\r\n\tCurve.prototype.fromJSON.call( this, json );\r\n\r\n\tthis.v0.fromArray( json.v0 );\r\n\tthis.v1.fromArray( json.v1 );\r\n\tthis.v2.fromArray( json.v2 );\r\n\tthis.v3.fromArray( json.v3 );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/curves/LineCurve.js\n\r\n\r\n\r\n\r\nfunction LineCurve( v1, v2 ) {\r\n\r\n\tCurve.call( this );\r\n\r\n\tthis.type = 'LineCurve';\r\n\r\n\tthis.v1 = v1 || new Vector2();\r\n\tthis.v2 = v2 || new Vector2();\r\n\r\n}\r\n\r\nLineCurve.prototype = Object.create( Curve.prototype );\r\nLineCurve.prototype.constructor = LineCurve;\r\n\r\nLineCurve.prototype.isLineCurve = true;\r\n\r\nLineCurve.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\tvar point = optionalTarget || new Vector2();\r\n\r\n\tif ( t === 1 ) {\r\n\r\n\t\tpoint.copy( this.v2 );\r\n\r\n\t} else {\r\n\r\n\t\tpoint.copy( this.v2 ).sub( this.v1 );\r\n\t\tpoint.multiplyScalar( t ).add( this.v1 );\r\n\r\n\t}\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\n// Line curve is linear, so we can overwrite default getPointAt\r\n\r\nLineCurve.prototype.getPointAt = function ( u, optionalTarget ) {\r\n\r\n\treturn this.getPoint( u, optionalTarget );\r\n\r\n};\r\n\r\nLineCurve.prototype.getTangent = function ( /* t */ ) {\r\n\r\n\tvar tangent = this.v2.clone().sub( this.v1 );\r\n\r\n\treturn tangent.normalize();\r\n\r\n};\r\n\r\nLineCurve.prototype.copy = function ( source ) {\r\n\r\n\tCurve.prototype.copy.call( this, source );\r\n\r\n\tthis.v1.copy( source.v1 );\r\n\tthis.v2.copy( source.v2 );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nLineCurve.prototype.toJSON = function () {\r\n\r\n\tvar data = Curve.prototype.toJSON.call( this );\r\n\r\n\tdata.v1 = this.v1.toArray();\r\n\tdata.v2 = this.v2.toArray();\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nLineCurve.prototype.fromJSON = function ( json ) {\r\n\r\n\tCurve.prototype.fromJSON.call( this, json );\r\n\r\n\tthis.v1.fromArray( json.v1 );\r\n\tthis.v2.fromArray( json.v2 );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/curves/LineCurve3.js\n\r\n\r\n\r\n\r\nfunction LineCurve3( v1, v2 ) {\r\n\r\n\tCurve.call( this );\r\n\r\n\tthis.type = 'LineCurve3';\r\n\r\n\tthis.v1 = v1 || new Vector3();\r\n\tthis.v2 = v2 || new Vector3();\r\n\r\n}\r\n\r\nLineCurve3.prototype = Object.create( Curve.prototype );\r\nLineCurve3.prototype.constructor = LineCurve3;\r\n\r\nLineCurve3.prototype.isLineCurve3 = true;\r\n\r\nLineCurve3.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\tvar point = optionalTarget || new Vector3();\r\n\r\n\tif ( t === 1 ) {\r\n\r\n\t\tpoint.copy( this.v2 );\r\n\r\n\t} else {\r\n\r\n\t\tpoint.copy( this.v2 ).sub( this.v1 );\r\n\t\tpoint.multiplyScalar( t ).add( this.v1 );\r\n\r\n\t}\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\n// Line curve is linear, so we can overwrite default getPointAt\r\n\r\nLineCurve3.prototype.getPointAt = function ( u, optionalTarget ) {\r\n\r\n\treturn this.getPoint( u, optionalTarget );\r\n\r\n};\r\n\r\nLineCurve3.prototype.copy = function ( source ) {\r\n\r\n\tCurve.prototype.copy.call( this, source );\r\n\r\n\tthis.v1.copy( source.v1 );\r\n\tthis.v2.copy( source.v2 );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nLineCurve3.prototype.toJSON = function () {\r\n\r\n\tvar data = Curve.prototype.toJSON.call( this );\r\n\r\n\tdata.v1 = this.v1.toArray();\r\n\tdata.v2 = this.v2.toArray();\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nLineCurve3.prototype.fromJSON = function ( json ) {\r\n\r\n\tCurve.prototype.fromJSON.call( this, json );\r\n\r\n\tthis.v1.fromArray( json.v1 );\r\n\tthis.v2.fromArray( json.v2 );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/curves/QuadraticBezierCurve.js\n\r\n\r\n\r\n\r\n\r\nfunction QuadraticBezierCurve( v0, v1, v2 ) {\r\n\r\n\tCurve.call( this );\r\n\r\n\tthis.type = 'QuadraticBezierCurve';\r\n\r\n\tthis.v0 = v0 || new Vector2();\r\n\tthis.v1 = v1 || new Vector2();\r\n\tthis.v2 = v2 || new Vector2();\r\n\r\n}\r\n\r\nQuadraticBezierCurve.prototype = Object.create( Curve.prototype );\r\nQuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;\r\n\r\nQuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;\r\n\r\nQuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\tvar point = optionalTarget || new Vector2();\r\n\r\n\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2;\r\n\r\n\tpoint.set(\r\n\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\r\n\t\tQuadraticBezier( t, v0.y, v1.y, v2.y )\r\n\t);\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\nQuadraticBezierCurve.prototype.copy = function ( source ) {\r\n\r\n\tCurve.prototype.copy.call( this, source );\r\n\r\n\tthis.v0.copy( source.v0 );\r\n\tthis.v1.copy( source.v1 );\r\n\tthis.v2.copy( source.v2 );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nQuadraticBezierCurve.prototype.toJSON = function () {\r\n\r\n\tvar data = Curve.prototype.toJSON.call( this );\r\n\r\n\tdata.v0 = this.v0.toArray();\r\n\tdata.v1 = this.v1.toArray();\r\n\tdata.v2 = this.v2.toArray();\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nQuadraticBezierCurve.prototype.fromJSON = function ( json ) {\r\n\r\n\tCurve.prototype.fromJSON.call( this, json );\r\n\r\n\tthis.v0.fromArray( json.v0 );\r\n\tthis.v1.fromArray( json.v1 );\r\n\tthis.v2.fromArray( json.v2 );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/curves/QuadraticBezierCurve3.js\n\r\n\r\n\r\n\r\n\r\nfunction QuadraticBezierCurve3( v0, v1, v2 ) {\r\n\r\n\tCurve.call( this );\r\n\r\n\tthis.type = 'QuadraticBezierCurve3';\r\n\r\n\tthis.v0 = v0 || new Vector3();\r\n\tthis.v1 = v1 || new Vector3();\r\n\tthis.v2 = v2 || new Vector3();\r\n\r\n}\r\n\r\nQuadraticBezierCurve3.prototype = Object.create( Curve.prototype );\r\nQuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;\r\n\r\nQuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;\r\n\r\nQuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\tvar point = optionalTarget || new Vector3();\r\n\r\n\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2;\r\n\r\n\tpoint.set(\r\n\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\r\n\t\tQuadraticBezier( t, v0.y, v1.y, v2.y ),\r\n\t\tQuadraticBezier( t, v0.z, v1.z, v2.z )\r\n\t);\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\nQuadraticBezierCurve3.prototype.copy = function ( source ) {\r\n\r\n\tCurve.prototype.copy.call( this, source );\r\n\r\n\tthis.v0.copy( source.v0 );\r\n\tthis.v1.copy( source.v1 );\r\n\tthis.v2.copy( source.v2 );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nQuadraticBezierCurve3.prototype.toJSON = function () {\r\n\r\n\tvar data = Curve.prototype.toJSON.call( this );\r\n\r\n\tdata.v0 = this.v0.toArray();\r\n\tdata.v1 = this.v1.toArray();\r\n\tdata.v2 = this.v2.toArray();\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nQuadraticBezierCurve3.prototype.fromJSON = function ( json ) {\r\n\r\n\tCurve.prototype.fromJSON.call( this, json );\r\n\r\n\tthis.v0.fromArray( json.v0 );\r\n\tthis.v1.fromArray( json.v1 );\r\n\tthis.v2.fromArray( json.v2 );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/curves/SplineCurve.js\n\r\n\r\n\r\n\r\n\r\nfunction SplineCurve( points /* array of Vector2 */ ) {\r\n\r\n\tCurve.call( this );\r\n\r\n\tthis.type = 'SplineCurve';\r\n\r\n\tthis.points = points || [];\r\n\r\n}\r\n\r\nSplineCurve.prototype = Object.create( Curve.prototype );\r\nSplineCurve.prototype.constructor = SplineCurve;\r\n\r\nSplineCurve.prototype.isSplineCurve = true;\r\n\r\nSplineCurve.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\tvar point = optionalTarget || new Vector2();\r\n\r\n\tvar points = this.points;\r\n\tvar p = ( points.length - 1 ) * t;\r\n\r\n\tvar intPoint = Math.floor( p );\r\n\tvar weight = p - intPoint;\r\n\r\n\tvar p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\r\n\tvar p1 = points[ intPoint ];\r\n\tvar p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\r\n\tvar p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\r\n\r\n\tpoint.set(\r\n\t\tCatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),\r\n\t\tCatmullRom( weight, p0.y, p1.y, p2.y, p3.y )\r\n\t);\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\nSplineCurve.prototype.copy = function ( source ) {\r\n\r\n\tCurve.prototype.copy.call( this, source );\r\n\r\n\tthis.points = [];\r\n\r\n\tfor ( var i = 0, l = source.points.length; i < l; i ++ ) {\r\n\r\n\t\tvar point = source.points[ i ];\r\n\r\n\t\tthis.points.push( point.clone() );\r\n\r\n\t}\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nSplineCurve.prototype.toJSON = function () {\r\n\r\n\tvar data = Curve.prototype.toJSON.call( this );\r\n\r\n\tdata.points = [];\r\n\r\n\tfor ( var i = 0, l = this.points.length; i < l; i ++ ) {\r\n\r\n\t\tvar point = this.points[ i ];\r\n\t\tdata.points.push( point.toArray() );\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nSplineCurve.prototype.fromJSON = function ( json ) {\r\n\r\n\tCurve.prototype.fromJSON.call( this, json );\r\n\r\n\tthis.points = [];\r\n\r\n\tfor ( var i = 0, l = json.points.length; i < l; i ++ ) {\r\n\r\n\t\tvar point = json.points[ i ];\r\n\t\tthis.points.push( new Vector2().fromArray( point ) );\r\n\r\n\t}\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/curves/Curves.js\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/core/CurvePath.js\n\r\n\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n **/\r\n\r\n/**************************************************************\r\n *\tCurved Path - a curve path is simply a array of connected\r\n *  curves, but retains the api of a curve\r\n **************************************************************/\r\n\r\nfunction CurvePath() {\r\n\r\n\tCurve.call( this );\r\n\r\n\tthis.type = 'CurvePath';\r\n\r\n\tthis.curves = [];\r\n\tthis.autoClose = false; // Automatically closes the path\r\n\r\n}\r\n\r\nCurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {\r\n\r\n\tconstructor: CurvePath,\r\n\r\n\tadd: function ( curve ) {\r\n\r\n\t\tthis.curves.push( curve );\r\n\r\n\t},\r\n\r\n\tclosePath: function () {\r\n\r\n\t\t// Add a line curve if start and end of lines are not connected\r\n\t\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\r\n\t\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\r\n\r\n\t\tif ( ! startPoint.equals( endPoint ) ) {\r\n\r\n\t\t\tthis.curves.push( new LineCurve( endPoint, startPoint ) );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t// To get accurate point with reference to\r\n\t// entire path distance at time t,\r\n\t// following has to be done:\r\n\r\n\t// 1. Length of each sub path have to be known\r\n\t// 2. Locate and identify type of curve\r\n\t// 3. Get t for the curve\r\n\t// 4. Return curve.getPointAt(t')\r\n\r\n\tgetPoint: function ( t ) {\r\n\r\n\t\tvar d = t * this.getLength();\r\n\t\tvar curveLengths = this.getCurveLengths();\r\n\t\tvar i = 0;\r\n\r\n\t\t// To think about boundaries points.\r\n\r\n\t\twhile ( i < curveLengths.length ) {\r\n\r\n\t\t\tif ( curveLengths[ i ] >= d ) {\r\n\r\n\t\t\t\tvar diff = curveLengths[ i ] - d;\r\n\t\t\t\tvar curve = this.curves[ i ];\r\n\r\n\t\t\t\tvar segmentLength = curve.getLength();\r\n\t\t\t\tvar u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\r\n\r\n\t\t\t\treturn curve.getPointAt( u );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ti ++;\r\n\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t\t// loop where sum != 0, sum > d , sum+1 <d\r\n\r\n\t},\r\n\r\n\t// We cannot use the default COOL.Curve getPoint() with getLength() because in\r\n\t// COOL.Curve, getLength() depends on getPoint() but in COOL.CurvePath\r\n\t// getPoint() depends on getLength\r\n\r\n\tgetLength: function () {\r\n\r\n\t\tvar lens = this.getCurveLengths();\r\n\t\treturn lens[ lens.length - 1 ];\r\n\r\n\t},\r\n\r\n\t// cacheLengths must be recalculated.\r\n\tupdateArcLengths: function () {\r\n\r\n\t\tthis.needsUpdate = true;\r\n\t\tthis.cacheLengths = null;\r\n\t\tthis.getCurveLengths();\r\n\r\n\t},\r\n\r\n\t// Compute lengths and cache them\r\n\t// We cannot overwrite getLengths() because UtoT mapping uses it.\r\n\r\n\tgetCurveLengths: function () {\r\n\r\n\t\t// We use cache values if curves and cache array are same length\r\n\r\n\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\r\n\r\n\t\t\treturn this.cacheLengths;\r\n\r\n\t\t}\r\n\r\n\t\t// Get length of sub-curve\r\n\t\t// Push sums into cached array\r\n\r\n\t\tvar lengths = [], sums = 0;\r\n\r\n\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\r\n\r\n\t\t\tsums += this.curves[ i ].getLength();\r\n\t\t\tlengths.push( sums );\r\n\r\n\t\t}\r\n\r\n\t\tthis.cacheLengths = lengths;\r\n\r\n\t\treturn lengths;\r\n\r\n\t},\r\n\r\n\tgetSpacedPoints: function ( divisions ) {\r\n\r\n\t\tif ( divisions === undefined ) divisions = 40;\r\n\r\n\t\tvar points = [];\r\n\r\n\t\tfor ( var i = 0; i <= divisions; i ++ ) {\r\n\r\n\t\t\tpoints.push( this.getPoint( i / divisions ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.autoClose ) {\r\n\r\n\t\t\tpoints.push( points[ 0 ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn points;\r\n\r\n\t},\r\n\r\n\tgetPoints: function ( divisions ) {\r\n\r\n\t\tdivisions = divisions || 12;\r\n\r\n\t\tvar points = [], last;\r\n\r\n\t\tfor ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {\r\n\r\n\t\t\tvar curve = curves[ i ];\r\n\t\t\tvar resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2\r\n\t\t\t\t: ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1\r\n\t\t\t\t\t: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length\r\n\t\t\t\t\t\t: divisions;\r\n\r\n\t\t\tvar pts = curve.getPoints( resolution );\r\n\r\n\t\t\tfor ( var j = 0; j < pts.length; j ++ ) {\r\n\r\n\t\t\t\tvar point = pts[ j ];\r\n\r\n\t\t\t\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\r\n\r\n\t\t\t\tpoints.push( point );\r\n\t\t\t\tlast = point;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {\r\n\r\n\t\t\tpoints.push( points[ 0 ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn points;\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tCurve.prototype.copy.call( this, source );\r\n\r\n\t\tthis.curves = [];\r\n\r\n\t\tfor ( var i = 0, l = source.curves.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar curve = source.curves[ i ];\r\n\r\n\t\t\tthis.curves.push( curve.clone() );\r\n\r\n\t\t}\r\n\r\n\t\tthis.autoClose = source.autoClose;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar data = Curve.prototype.toJSON.call( this );\r\n\r\n\t\tdata.autoClose = this.autoClose;\r\n\t\tdata.curves = [];\r\n\r\n\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar curve = this.curves[ i ];\r\n\t\t\tdata.curves.push( curve.toJSON() );\r\n\r\n\t\t}\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tfromJSON: function ( json ) {\r\n\r\n\t\tCurve.prototype.fromJSON.call( this, json );\r\n\r\n\t\tthis.autoClose = json.autoClose;\r\n\t\tthis.curves = [];\r\n\r\n\t\tfor ( var i = 0, l = json.curves.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar curve = json.curves[ i ];\r\n\t\t\tthis.curves.push( new Curves_namespaceObject[ curve.type ]().fromJSON( curve ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/core/Path.js\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Creates free form 2d path using series of points, lines or curves.\r\n **/\r\n\r\nfunction Path( points ) {\r\n\r\n\tCurvePath.call( this );\r\n\r\n\tthis.type = 'Path';\r\n\r\n\tthis.currentPoint = new Vector2();\r\n\r\n\tif ( points ) {\r\n\r\n\t\tthis.setFromPoints( points );\r\n\r\n\t}\r\n\r\n}\r\n\r\nPath.prototype = Object.assign( Object.create( CurvePath.prototype ), {\r\n\r\n\tconstructor: Path,\r\n\r\n\tsetFromPoints: function ( points ) {\r\n\r\n\t\tthis.moveTo( points[ 0 ].x, points[ 0 ].y );\r\n\r\n\t\tfor ( var i = 1, l = points.length; i < l; i ++ ) {\r\n\r\n\t\t\tthis.lineTo( points[ i ].x, points[ i ].y );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tmoveTo: function ( x, y ) {\r\n\r\n\t\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\r\n\r\n\t},\r\n\r\n\tlineTo: function ( x, y ) {\r\n\r\n\t\tvar curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\r\n\t\tthis.curves.push( curve );\r\n\r\n\t\tthis.currentPoint.set( x, y );\r\n\r\n\t},\r\n\r\n\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\r\n\r\n\t\tvar curve = new QuadraticBezierCurve(\r\n\t\t\tthis.currentPoint.clone(),\r\n\t\t\tnew Vector2( aCPx, aCPy ),\r\n\t\t\tnew Vector2( aX, aY )\r\n\t\t);\r\n\r\n\t\tthis.curves.push( curve );\r\n\r\n\t\tthis.currentPoint.set( aX, aY );\r\n\r\n\t},\r\n\r\n\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\r\n\r\n\t\tvar curve = new CubicBezierCurve(\r\n\t\t\tthis.currentPoint.clone(),\r\n\t\t\tnew Vector2( aCP1x, aCP1y ),\r\n\t\t\tnew Vector2( aCP2x, aCP2y ),\r\n\t\t\tnew Vector2( aX, aY )\r\n\t\t);\r\n\r\n\t\tthis.curves.push( curve );\r\n\r\n\t\tthis.currentPoint.set( aX, aY );\r\n\r\n\t},\r\n\r\n\tsplineThru: function ( pts /*Array of Vector*/ ) {\r\n\r\n\t\tvar npts = [ this.currentPoint.clone() ].concat( pts );\r\n\r\n\t\tvar curve = new SplineCurve( npts );\r\n\t\tthis.curves.push( curve );\r\n\r\n\t\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\r\n\r\n\t},\r\n\r\n\tarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\t\tvar x0 = this.currentPoint.x;\r\n\t\tvar y0 = this.currentPoint.y;\r\n\r\n\t\tthis.absarc( aX + x0, aY + y0, aRadius,\r\n\t\t\taStartAngle, aEndAngle, aClockwise );\r\n\r\n\t},\r\n\r\n\tabsarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\r\n\r\n\t},\r\n\r\n\tellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\r\n\t\tvar x0 = this.currentPoint.x;\r\n\t\tvar y0 = this.currentPoint.y;\r\n\r\n\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\r\n\r\n\t},\r\n\r\n\tabsellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\r\n\t\tvar curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\r\n\r\n\t\tif ( this.curves.length > 0 ) {\r\n\r\n\t\t\t// if a previous curve is present, attempt to join\r\n\t\t\tvar firstPoint = curve.getPoint( 0 );\r\n\r\n\t\t\tif ( ! firstPoint.equals( this.currentPoint ) ) {\r\n\r\n\t\t\t\tthis.lineTo( firstPoint.x, firstPoint.y );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.curves.push( curve );\r\n\r\n\t\tvar lastPoint = curve.getPoint( 1 );\r\n\t\tthis.currentPoint.copy( lastPoint );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tCurvePath.prototype.copy.call( this, source );\r\n\r\n\t\tthis.currentPoint.copy( source.currentPoint );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar data = CurvePath.prototype.toJSON.call( this );\r\n\r\n\t\tdata.currentPoint = this.currentPoint.toArray();\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tfromJSON: function ( json ) {\r\n\r\n\t\tCurvePath.prototype.fromJSON.call( this, json );\r\n\r\n\t\tthis.currentPoint.fromArray( json.currentPoint );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/extras/core/Shape.js\n\r\n\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Defines a 2d shape plane using paths.\r\n **/\r\n\r\n// STEP 1 Create a path.\r\n// STEP 2 Turn path into shape.\r\n// STEP 3 ExtrudeGeometry takes in Shape/Shapes\r\n// STEP 3a - Extract points from each shape, turn to vertices\r\n// STEP 3b - Triangulate each shape, add faces.\r\n\r\nfunction Shape( points ) {\r\n\r\n\tPath.call( this, points );\r\n\r\n\tthis.uuid = _Math.generateUUID();\r\n\r\n\tthis.type = 'Shape';\r\n\r\n\tthis.holes = [];\r\n\r\n}\r\n\r\nShape.prototype = Object.assign( Object.create( Path.prototype ), {\r\n\r\n\tconstructor: Shape,\r\n\r\n\tgetPointsHoles: function ( divisions ) {\r\n\r\n\t\tvar holesPts = [];\r\n\r\n\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\r\n\r\n\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\r\n\r\n\t\t}\r\n\r\n\t\treturn holesPts;\r\n\r\n\t},\r\n\r\n\t// get points of shape and holes (keypoints based on segments parameter)\r\n\r\n\textractPoints: function ( divisions ) {\r\n\r\n\t\treturn {\r\n\r\n\t\t\tshape: this.getPoints( divisions ),\r\n\t\t\tholes: this.getPointsHoles( divisions )\r\n\r\n\t\t};\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tPath.prototype.copy.call( this, source );\r\n\r\n\t\tthis.holes = [];\r\n\r\n\t\tfor ( var i = 0, l = source.holes.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar hole = source.holes[ i ];\r\n\r\n\t\t\tthis.holes.push( hole.clone() );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar data = Path.prototype.toJSON.call( this );\r\n\r\n\t\tdata.uuid = this.uuid;\r\n\t\tdata.holes = [];\r\n\r\n\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar hole = this.holes[ i ];\r\n\t\t\tdata.holes.push( hole.toJSON() );\r\n\r\n\t\t}\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tfromJSON: function ( json ) {\r\n\r\n\t\tPath.prototype.fromJSON.call( this, json );\r\n\r\n\t\tthis.uuid = json.uuid;\r\n\t\tthis.holes = [];\r\n\r\n\t\tfor ( var i = 0, l = json.holes.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar hole = json.holes[ i ];\r\n\t\t\tthis.holes.push( new Path().fromJSON( hole ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n\r\n\n// CONCATENATED MODULE: ./src/core/TextGeometry.js\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass TextGeometry_TextGeometry {\r\n    constructor(param) {\r\n        param = param || {};\r\n\r\n        this.text = param.text == undefined ? '0' : param.text;\r\n\r\n        if(this.text == '2'){\r\n\r\n            var pts = [];\r\n\r\n            pts.push( new Vector2( 0, 10 ) );\r\n            pts.push( new Vector2( 5, 10 ) );\r\n            pts.push( new Vector2( 5, 4.5 ) );\r\n            pts.push( new Vector2( 1, 4.5 ) );\r\n            pts.push( new Vector2( 1, 1 ) );\r\n            pts.push( new Vector2( 5, 1 ) );\r\n            pts.push( new Vector2( 5, 0 ) );\r\n            pts.push( new Vector2( 0, 0 ) );\r\n            pts.push( new Vector2( 0, 5.5 ) );\r\n            pts.push( new Vector2( 4, 5.5 ) );\r\n            pts.push( new Vector2( 4, 9 ) );\r\n            pts.push( new Vector2( 0, 9 ) );\r\n\r\n            var shape = new Shape( pts );\r\n            var extrudeSettings = {\r\n                depth: 3,\r\n                steps: 1,\r\n                bevelEnabled: false,\r\n                bevelThickness: 2,\r\n                bevelSize: 4,\r\n                bevelSegments: 1\r\n            };\r\n            var extrudeGeometry = new ExtrudeBufferGeometry( shape, extrudeSettings );\r\n\r\n            var indices = [];\r\n            for(var i=0; i<extrudeGeometry.attributes.position.array.length/3; i++){\r\n                indices.push(i);\r\n            }\r\n\r\n            param.vertices = extrudeGeometry.attributes.position.array;\r\n            param.normal = extrudeGeometry.attributes.normal.array;\r\n            param.uv = extrudeGeometry.attributes.uv.array;\r\n            param.indices = indices;\r\n\r\n\r\n        }else if(this.text == '1'){\r\n\r\n            var pts = [];\r\n\r\n            pts.push( new Vector2( 4.5, 0 ) );\r\n            pts.push( new Vector2( 4.5, 10 ) );\r\n            pts.push( new Vector2( 5.5, 10 ) );\r\n            pts.push( new Vector2( 5.5, 0 ) );\r\n\r\n\r\n            var shape = new Shape( pts );\r\n            var extrudeSettings = {\r\n                depth: 3,\r\n                steps: 1,\r\n                bevelEnabled: false,\r\n                bevelThickness: 2,\r\n                bevelSize: 4,\r\n                bevelSegments: 1\r\n            };\r\n            var extrudeGeometry = new ExtrudeBufferGeometry( shape, extrudeSettings );\r\n\r\n            var indices = [];\r\n            for(var i=0; i<extrudeGeometry.attributes.position.array.length/3; i++){\r\n                indices.push(i);\r\n            }\r\n\r\n            param.vertices = extrudeGeometry.attributes.position.array;\r\n            param.normal = extrudeGeometry.attributes.normal.array;\r\n            param.uv = extrudeGeometry.attributes.uv.array;\r\n            param.indices = indices;\r\n\r\n\r\n        }else if(this.text == '3'){\r\n\r\n            var pts = [];\r\n\r\n            pts.push( new Vector2( 0, 0 ) );\r\n            pts.push( new Vector2( 0, 1 ) );\r\n            pts.push( new Vector2( 4, 1 ) );\r\n            pts.push( new Vector2( 4, 4.5 ) );\r\n            pts.push( new Vector2( 0, 4.5 ) );\r\n            pts.push( new Vector2( 0, 5.5 ) );\r\n            pts.push( new Vector2( 4, 5.5 ) );\r\n            pts.push( new Vector2( 4, 9 ) );\r\n            pts.push( new Vector2( 0, 9 ) );\r\n            pts.push( new Vector2( 0, 10 ) );\r\n            pts.push( new Vector2( 5, 10 ) );\r\n            pts.push( new Vector2( 5, 0 ) );\r\n            pts.push( new Vector2( 5, 0 ) );\r\n\r\n\r\n\r\n            var shape = new Shape( pts );\r\n            var extrudeSettings = {\r\n                depth: 3,\r\n                steps: 1,\r\n                bevelEnabled: false,\r\n                bevelThickness: 2,\r\n                bevelSize: 4,\r\n                bevelSegments: 1\r\n            };\r\n            var extrudeGeometry = new ExtrudeBufferGeometry( shape, extrudeSettings );\r\n\r\n            var indices = [];\r\n            for(var i=0; i<extrudeGeometry.attributes.position.array.length/3; i++){\r\n                indices.push(i);\r\n            }\r\n\r\n            param.vertices = extrudeGeometry.attributes.position.array;\r\n            param.normal = extrudeGeometry.attributes.normal.array;\r\n            param.uv = extrudeGeometry.attributes.uv.array;\r\n            param.indices = indices;\r\n\r\n\r\n        }else if(this.text == '4'){\r\n\r\n            var pts = [];\r\n\r\n            pts.push( new Vector2( 0, 10 ) );\r\n            pts.push( new Vector2( 1, 10 ) );\r\n            pts.push( new Vector2( 1, 5.5 ) );\r\n            pts.push( new Vector2( 4, 5.5 ) );\r\n            pts.push( new Vector2( 4, 10 ) );\r\n            pts.push( new Vector2( 5, 10 ) );\r\n            pts.push( new Vector2( 5, 0 ) );\r\n            pts.push( new Vector2( 4, 0 ) );\r\n            pts.push( new Vector2( 4, 4.5 ) );\r\n            pts.push( new Vector2( 0, 4.5 ) );\r\n\r\n\r\n            var shape = new Shape( pts );\r\n            var extrudeSettings = {\r\n                depth: 3,\r\n                steps: 1,\r\n                bevelEnabled: false,\r\n                bevelThickness: 2,\r\n                bevelSize: 4,\r\n                bevelSegments: 1\r\n            };\r\n            var extrudeGeometry = new ExtrudeBufferGeometry( shape, extrudeSettings );\r\n\r\n            var indices = [];\r\n            for(var i=0; i<extrudeGeometry.attributes.position.array.length/3; i++){\r\n                indices.push(i);\r\n            }\r\n\r\n            param.vertices = extrudeGeometry.attributes.position.array;\r\n            param.normal = extrudeGeometry.attributes.normal.array;\r\n            param.uv = extrudeGeometry.attributes.uv.array;\r\n            param.indices = indices;\r\n\r\n\r\n        }else if(this.text == '5'){\r\n\r\n            var pts = [];\r\n\r\n            pts.push( new Vector2( 0, 0 ) );\r\n            pts.push( new Vector2( 0, 1 ) );\r\n            pts.push( new Vector2( 4, 1 ) );\r\n            pts.push( new Vector2( 4, 4.5 ) );\r\n            pts.push( new Vector2( 0, 4.5 ) );\r\n            pts.push( new Vector2( 0, 10 ) );\r\n            pts.push( new Vector2( 5, 10 ) );\r\n            pts.push( new Vector2( 5, 9 ) );\r\n            pts.push( new Vector2( 1, 9 ) );\r\n            pts.push( new Vector2( 1, 5.5 ) );\r\n            pts.push( new Vector2( 5, 5.5 ) );\r\n            pts.push( new Vector2( 5, 0 ) );\r\n\r\n\r\n            var shape = new Shape( pts );\r\n            var extrudeSettings = {\r\n                depth: 3,\r\n                steps: 1,\r\n                bevelEnabled: false,\r\n                bevelThickness: 2,\r\n                bevelSize: 4,\r\n                bevelSegments: 1\r\n            };\r\n            var extrudeGeometry = new ExtrudeBufferGeometry( shape, extrudeSettings );\r\n\r\n            var indices = [];\r\n            for(var i=0; i<extrudeGeometry.attributes.position.array.length/3; i++){\r\n                indices.push(i);\r\n            }\r\n\r\n            param.vertices = extrudeGeometry.attributes.position.array;\r\n            param.normal = extrudeGeometry.attributes.normal.array;\r\n            param.uv = extrudeGeometry.attributes.uv.array;\r\n            param.indices = indices;\r\n        }else if(this.text == '6'){\r\n\r\n            var pts = [];\r\n\r\n            pts.push( new Vector2( 5, 10 ) );\r\n            pts.push( new Vector2( 0, 10 ) );\r\n            pts.push( new Vector2( 0, 0 ) );\r\n            pts.push( new Vector2( 5, 0 ) );\r\n            pts.push( new Vector2( 5, 5.5 ) );\r\n            pts.push( new Vector2( 1, 5.5 ) );\r\n            pts.push( new Vector2( 1, 4.5 ) );\r\n            pts.push( new Vector2( 4, 4.5 ) );\r\n            pts.push( new Vector2( 4, 1 ) );\r\n            pts.push( new Vector2( 1, 1 ) );\r\n            pts.push( new Vector2( 1, 9 ) );\r\n            pts.push( new Vector2( 5, 9 ) );\r\n\r\n\r\n\r\n            var shape = new Shape( pts );\r\n            var extrudeSettings = {\r\n                depth: 3,\r\n                steps: 1,\r\n                bevelEnabled: false,\r\n                bevelThickness: 2,\r\n                bevelSize: 4,\r\n                bevelSegments: 1\r\n            };\r\n            var extrudeGeometry = new ExtrudeBufferGeometry( shape, extrudeSettings );\r\n\r\n            var indices = [];\r\n            for(var i=0; i<extrudeGeometry.attributes.position.array.length/3; i++){\r\n                indices.push(i);\r\n            }\r\n\r\n            param.vertices = extrudeGeometry.attributes.position.array;\r\n            param.normal = extrudeGeometry.attributes.normal.array;\r\n            param.uv = extrudeGeometry.attributes.uv.array;\r\n            param.indices = indices;\r\n        }else if(this.text == '7'){\r\n\r\n            var pts = [];\r\n\r\n            pts.push( new Vector2( 0, 10 ) );\r\n            pts.push( new Vector2( 5, 10 ) );\r\n            pts.push( new Vector2( 5, 0 ) );\r\n            pts.push( new Vector2( 4, 0 ) );\r\n            pts.push( new Vector2( 4, 9 ) );\r\n            pts.push( new Vector2( 0, 9 ) );\r\n\r\n\r\n            var shape = new Shape( pts );\r\n            var extrudeSettings = {\r\n                depth: 3,\r\n                steps: 1,\r\n                bevelEnabled: false,\r\n                bevelThickness: 2,\r\n                bevelSize: 4,\r\n                bevelSegments: 1\r\n            };\r\n            var extrudeGeometry = new ExtrudeBufferGeometry( shape, extrudeSettings );\r\n\r\n            var indices = [];\r\n            for(var i=0; i<extrudeGeometry.attributes.position.array.length/3; i++){\r\n                indices.push(i);\r\n            }\r\n\r\n            param.vertices = extrudeGeometry.attributes.position.array;\r\n            param.normal = extrudeGeometry.attributes.normal.array;\r\n            param.uv = extrudeGeometry.attributes.uv.array;\r\n            param.indices = indices;\r\n        }else if(this.text == '8'){\r\n\r\n            var pts = [];\r\n\r\n            pts.push( new Vector2( 5, 10 ) );\r\n            pts.push( new Vector2( 0, 10 ) );\r\n            pts.push( new Vector2( 0, 0 ) );\r\n            pts.push( new Vector2( 5, 0 ) );\r\n\r\n            pts.push( new Vector2( 5, 9 ) );\r\n            pts.push( new Vector2( 4, 9 ) );\r\n            pts.push( new Vector2( 4, 5.5 ) );\r\n            pts.push( new Vector2( 1, 5.5 ) );\r\n\r\n            pts.push( new Vector2( 1, 4.5 ) );\r\n            pts.push( new Vector2( 4, 4.5 ) );\r\n            pts.push( new Vector2( 4, 1 ) );\r\n            pts.push( new Vector2( 1, 1 ) );\r\n            pts.push( new Vector2( 1, 9 ) );\r\n            pts.push( new Vector2( 5, 9 ) );\r\n\r\n\r\n            var shape = new Shape( pts );\r\n            var extrudeSettings = {\r\n                depth: 3,\r\n                steps: 1,\r\n                bevelEnabled: false,\r\n                bevelThickness: 2,\r\n                bevelSize: 4,\r\n                bevelSegments: 1\r\n            };\r\n            var extrudeGeometry = new ExtrudeBufferGeometry( shape, extrudeSettings );\r\n\r\n            var indices = [];\r\n            for(var i=0; i<extrudeGeometry.attributes.position.array.length/3; i++){\r\n                indices.push(i);\r\n            }\r\n\r\n            param.vertices = extrudeGeometry.attributes.position.array;\r\n            param.normal = extrudeGeometry.attributes.normal.array;\r\n            param.uv = extrudeGeometry.attributes.uv.array;\r\n            param.indices = indices;\r\n        }else if(this.text == '9'){\r\n\r\n            var pts = [];\r\n\r\n            pts.push( new Vector2( 0, 10 ) );\r\n            pts.push( new Vector2( 1, 10 ) );\r\n            pts.push( new Vector2( 1, 5.5 ) );\r\n            pts.push( new Vector2( 4, 5.5 ) );\r\n\r\n            pts.push( new Vector2( 4, 9 ) );\r\n            pts.push( new Vector2( 1, 9 ) );\r\n            pts.push( new Vector2( 1, 10 ) );\r\n            pts.push( new Vector2( 5, 10 ) );\r\n\r\n            pts.push( new Vector2( 5, 0 ) );\r\n            pts.push( new Vector2( 4, 0 ) );\r\n            pts.push( new Vector2( 4, 4.5 ) );\r\n            pts.push( new Vector2( 0, 4.5 ) );\r\n\r\n\r\n            var shape = new Shape( pts );\r\n            var extrudeSettings = {\r\n                depth: 3,\r\n                steps: 1,\r\n                bevelEnabled: false,\r\n                bevelThickness: 2,\r\n                bevelSize: 4,\r\n                bevelSegments: 1\r\n            };\r\n            var extrudeGeometry = new ExtrudeBufferGeometry( shape, extrudeSettings );\r\n\r\n            var indices = [];\r\n            for(var i=0; i<extrudeGeometry.attributes.position.array.length/3; i++){\r\n                indices.push(i);\r\n            }\r\n\r\n            param.vertices = extrudeGeometry.attributes.position.array;\r\n            param.normal = extrudeGeometry.attributes.normal.array;\r\n            param.uv = extrudeGeometry.attributes.uv.array;\r\n            param.indices = indices;\r\n        }else if(this.text == '0'){\r\n\r\n            var pts = [];\r\n\r\n            pts.push( new Vector2( 5, 10 ) );\r\n            pts.push( new Vector2( 0, 10 ) );\r\n            pts.push( new Vector2( 0, 0 ) );\r\n            pts.push( new Vector2( 5, 0 ) );\r\n\r\n            pts.push( new Vector2( 5, 9 ) );\r\n            pts.push( new Vector2( 4, 9 ) );\r\n            pts.push( new Vector2( 4, 1 ) );\r\n            pts.push( new Vector2( 1, 1 ) );\r\n\r\n            pts.push( new Vector2( 1, 9 ) );\r\n            pts.push( new Vector2( 5, 9 ) );\r\n\r\n\r\n            var shape = new Shape( pts );\r\n            var extrudeSettings = {\r\n                depth: 3,\r\n                steps: 1,\r\n                bevelEnabled: false,\r\n                bevelThickness: 2,\r\n                bevelSize: 4,\r\n                bevelSegments: 1\r\n            };\r\n            var extrudeGeometry = new ExtrudeBufferGeometry( shape, extrudeSettings );\r\n\r\n            var indices = [];\r\n            for(var i=0; i<extrudeGeometry.attributes.position.array.length/3; i++){\r\n                indices.push(i);\r\n            }\r\n\r\n            param.vertices = extrudeGeometry.attributes.position.array;\r\n            param.normal = extrudeGeometry.attributes.normal.array;\r\n            param.uv = extrudeGeometry.attributes.uv.array;\r\n            param.indices = indices;\r\n        }\r\n\r\n        this.uv = param.uv || new Float32Array([   // Vertex coordinates\r\n\r\n            1,1, 0,1, 0,0, 1,0,  // v0-v1-v2-v3 front\r\n            0,1, 0,0, 1,0, 1,1,  // v0-v3-v4-v5 right\r\n            1,0, 1,1, 0,1, 0,0,  // v0-v5-v6-v1 up\r\n            1,1, 0,1, 0,0, 1,0,  // v1-v6-v7-v2 left\r\n            0,1, 1,1, 1,0, 0,0,  // v7-v4-v3-v2 down\r\n            1,0, 0,0, 0,1, 1,1   // v4-v7-v6-v5 back\r\n\r\n        ]);\r\n\r\n        this.vertices = param.vertices || new Float32Array([   // Vertex coordinates\r\n            0.5, 0.5, 0.5,  -0.5, 0.5, 0.5,  -0.5,-0.5, 0.5,   0.5,-0.5, 0.5,  // v0-v1-v2-v3 front\r\n            0.5, 0.5, 0.5,   0.5,-0.5, 0.5,   0.5,-0.5,-0.5,   0.5, 0.5,-0.5,  // v0-v3-v4-v5 right\r\n            0.5, 0.5, 0.5,   0.5, 0.5,-0.5,  -0.5, 0.5,-0.5,  -0.5, 0.5, 0.5,  // v0-v5-v6-v1 up\r\n            -0.5, 0.5, 0.5,  -0.5, 0.5,-0.5,  -0.5,-0.5,-0.5,  -0.5,-0.5, 0.5,  // v1-v6-v7-v2 left\r\n            -0.5,-0.5,-0.5,   0.5,-0.5,-0.5,   0.5,-0.5, 0.5,  -0.5,-0.5, 0.5,  // v7-v4-v3-v2 down\r\n            0.5,-0.5,-0.5,  -0.5,-0.5,-0.5,  -0.5, 0.5,-0.5,   0.5, 0.5,-0.5   // v4-v7-v6-v5 back\r\n        ]);\r\n\r\n        this.normal = param.normal || this.vertices;\r\n\r\n        this.indices = new Uint16Array(param.indices);\r\n\r\n        this.morphAttributes = param.morphAttributes;\r\n\r\n        this.boundingSphere = new Sphere();\r\n        this.boundingBox = new Box3();\r\n        this.computeBoundingBox();\r\n\r\n        // this.updateNormal();\r\n\r\n        this.updataBuffer();\r\n\r\n    }\r\n\r\n    updataBuffer(){\r\n        var buffer = [];\r\n        var uv = this.uv;\r\n        var vertices = this.vertices;\r\n        var normal = this.normal;\r\n        for(var i=0; i<vertices.length; i+=3){\r\n            buffer.push(vertices[i+0]);\r\n            buffer.push(vertices[i+1]);\r\n            buffer.push(vertices[i+2]);\r\n\r\n            buffer.push(normal[i+0]);\r\n            buffer.push(normal[i+1]);\r\n            buffer.push(normal[i+2]);\r\n\r\n            buffer.push(uv[i/3*2+0]);\r\n            buffer.push(uv[i/3*2+1]);\r\n        }\r\n\r\n        this.buffer = new Float32Array(buffer);\r\n    }\r\n\r\n    updateNormal(){\r\n        var normal = [];\r\n        var vertices = this.vertices;\r\n        for(var i=0; i<vertices.length; i+=3*4){\r\n            var line1 = new Vector3().subVectors(\r\n                new Vector3(vertices[i+0], vertices[i+1], vertices[i+2]),\r\n                new Vector3(vertices[i+3], vertices[i+4], vertices[i+5])\r\n            );\r\n            var line2 = new Vector3().subVectors(\r\n                new Vector3(vertices[i+3], vertices[i+4], vertices[i+5]),\r\n                new Vector3(vertices[i+6], vertices[i+7], vertices[i+8]),\r\n            );\r\n            var cur_normal = new Vector3().crossVectors(\r\n                line1,\r\n                line2\r\n            ).toArray();\r\n            for(var j=0 ;j<4; j++){\r\n                normal.push(cur_normal[0], cur_normal[1], cur_normal[2]);\r\n            }\r\n        }\r\n        this.normal = new Float32Array(normal);\r\n\r\n    }\r\n\r\n    computeBoundingBox () {\r\n        var verticesV3 = [];\r\n        for(var i=0; i<this.vertices.length; i+=3){\r\n            verticesV3.push(new Vector3(this.vertices[i], this.vertices[i+1], this.vertices[i+2]))\r\n        }\r\n        this.boundingBox.setFromPoints(verticesV3);\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ var core_TextGeometry = (TextGeometry_TextGeometry);\r\n\n// CONCATENATED MODULE: ./src/material/CubeTexture.js\n\r\n\r\nclass CubeTexture_CubeTexture extends material_Texture{\r\n    constructor(param) {\r\n        super(param);\r\n\r\n        param = param || {};\r\n        this.urls = param.urls;\r\n\r\n        this.images = [];\r\n        this.imgLoadCount = 0;\r\n        this.imgReady = false;\r\n\r\n        var that = this;\r\n        var urls = this.urls;\r\n        for(var i in urls){\r\n            var image = new Image();\r\n            that.images.push(image);\r\n            image.addEventListener('load', function() {\r\n                that.imgLoadCount ++;\r\n                if(that.imgLoadCount == 6){\r\n                    that.imgReady = true;\r\n                }\r\n            });\r\n            image.src = urls[i];\r\n        }\r\n\r\n    }\r\n\r\n    clone(){\r\n\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ var material_CubeTexture = (CubeTexture_CubeTexture);\r\n\n// CONCATENATED MODULE: ./src/main.js\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// import _GLTFLoader from \"./core/GLTFLoader\";\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar main_COOL = window.COOL = {};\r\n\r\nmain_COOL.LINEAR = 9729;\r\nmain_COOL.NEAREST = 9728;\r\n\r\nmain_COOL.CLAMP_TO_EDGE = 33071;\r\nmain_COOL.REPEAT = 10497;\r\nmain_COOL.MIRRORED_REPEAT = 33648;\r\n\r\nmain_COOL.Renderer = core_Renderer;\r\nmain_COOL.Mesh = core_Mesh;\r\nmain_COOL.Camera = camera_Camera;\r\nmain_COOL.OrthoCamera = camera_OrthoCamera;\r\nmain_COOL.CameraController = camera_CameraController;\r\nmain_COOL.Scene = core_Scene;\r\nmain_COOL.Material = material_Material;\r\nmain_COOL.MeshBasicMaterial = material_MeshBasicMaterial;\r\nmain_COOL.MeshLambertMaterial = material_MeshLambertMaterial;\r\nmain_COOL.MeshStandardMaterial = material_MeshStandardMaterial;\r\n\r\nmain_COOL.Texture = material_Texture;\r\nmain_COOL.CubeTexture = material_CubeTexture;\r\n\r\nmain_COOL.AmbientLight = light_AmbientLight;\r\nmain_COOL.DirectionalLight = light_DirectionalLight;\r\n\r\nmain_COOL.Geometry = core_Geometry;\r\nmain_COOL.BoxGeometry = core_BoxGeometry;\r\nmain_COOL.SphereGeometry = core_SphereGeometry;\r\n\r\n// COOL.GLTFLoader = _GLTFLoader;\r\nmain_COOL.GLTFLoader2 = GLTFLoader2;\r\n\r\nmain_COOL.Animation = animation_Animation;\r\n\r\nmain_COOL.Raycaster = Raycaster;\r\n\r\nmain_COOL.Vector2 = Vector2;\r\nmain_COOL.Vector3 = Vector3;\r\n\r\nmain_COOL.ExtrudeGeometry = ExtrudeGeometry;\r\nmain_COOL.ExtrudeBufferGeometry = ExtrudeBufferGeometry;\r\nmain_COOL.TextGeometry = core_TextGeometry;\r\nmain_COOL.Shape = Shape;\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tYXRoL01hdGguanM/NWRiMCIsIndlYnBhY2s6Ly8vLi9zcmMvbWF0aC9WZWN0b3I0LmpzP2RiYTkiLCJ3ZWJwYWNrOi8vLy4vc3JjL21hdGgvTWF0cml4NC5qcz80N2ViIiwid2VicGFjazovLy8uL3NyYy9tYXRoL1F1YXRlcm5pb24uanM/ZDhlZSIsIndlYnBhY2s6Ly8vLi9zcmMvbWF0aC9WZWN0b3IzLmpzPzFiMjgiLCJ3ZWJwYWNrOi8vLy4vc3JjL21hdGgvQm94My5qcz82MWQxIiwid2VicGFjazovLy8uL3NyYy9tYXRoL1NwaGVyZS5qcz9lZmI5Iiwid2VicGFjazovLy8uL3NyYy9jb3JlL0JveEdlb21ldHJ5LmpzP2E3Y2YiLCJ3ZWJwYWNrOi8vLy4vc3JjL21hdGVyaWFsL01hdGVyaWFsLmpzPzcxNzAiLCJ3ZWJwYWNrOi8vLy4vc3JjL21hdGgvRXVsZXIuanM/ZTgwYiIsIndlYnBhY2s6Ly8vLi9zcmMvbWF0aC9WZWN0b3IyLmpzPzAyMGQiLCJ3ZWJwYWNrOi8vLy4vc3JjL21hdGgvUmF5LmpzPzdjZDMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21hdGgvVHJpYW5nbGUuanM/NzFjOCIsIndlYnBhY2s6Ly8vLi9zcmMvbWF0aC9Db2xvci5qcz8wZDdkIiwid2VicGFjazovLy8uL3NyYy9jb3JlL0ZhY2UzLmpzPzVlZTUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvTWVzaC5qcz8yYTJmIiwid2VicGFjazovLy8uL3NyYy91dGlsL3dlYmdsLXV0aWxzLmpzPzRhMzEiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvd2ViZ2wtZGVidWcuanM/YzJhMyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC9VdGlsLmpzPzQyZGIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpZ2h0L0xpZ2h0LmpzP2ViMjMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpZ2h0L0FtYmllbnRMaWdodC5qcz9jZDIwIiwid2VicGFjazovLy8uL3NyYy9saWdodC9EaXJlY3Rpb25hbExpZ2h0LmpzPzA0OTUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvUmVuZGVyZXIuanM/OGIxNSIsIndlYnBhY2s6Ly8vLi9zcmMvY2FtZXJhL0NhbWVyYS5qcz9lMjFkIiwid2VicGFjazovLy8uL3NyYy9jYW1lcmEvQ2FtZXJhQ29udHJvbGxlci5qcz9lMDY4Iiwid2VicGFjazovLy8uL3NyYy9jb3JlL1NjZW5lLmpzPzg1Y2EiLCJ3ZWJwYWNrOi8vLy4vc3JjL21hdGVyaWFsL1RleHR1cmUuanM/NGMwZiIsIndlYnBhY2s6Ly8vLi9zcmMvbWF0ZXJpYWwvTWVzaEJhc2ljTWF0ZXJpYWwuanM/YmZlNCIsIndlYnBhY2s6Ly8vLi9zcmMvbWF0ZXJpYWwvTWVzaExhbWJlcnRNYXRlcmlhbC5qcz80MzZkIiwid2VicGFjazovLy8uL3NyYy9tYXRlcmlhbC9NZXNoU3RhbmRhcmRNYXRlcmlhbC5qcz8yN2IxIiwid2VicGFjazovLy8uL3NyYy9jb3JlL0dlb21ldHJ5LmpzP2ZhZGUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvU3BoZXJlR2VvbWV0cnkuanM/MzVhYyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9HTFRGTG9hZGVyMi5qcz83NjI3Iiwid2VicGFjazovLy8uL3NyYy9jYW1lcmEvT3J0aG9DYW1lcmEuanM/M2E1NiIsIndlYnBhY2s6Ly8vLi9zcmMvYW5pbWF0aW9uL0FuaW1hdGlvbi5qcz9lYjg2Iiwid2VicGFjazovLy8uL3NyYy9jb3JlL1JheWNhc3Rlci5qcz9iZmIyIiwid2VicGFjazovLy8uL3NyYy9sb2FkZXIvRXZlbnREaXNwYXRjaGVyLmpzPzRhMDIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xvYWRlci9GYWNlMy5qcz8wMzczIiwid2VicGFjazovLy8uL3NyYy9tYXRoL01hdHJpeDMuanM/NGVjZCIsIndlYnBhY2s6Ly8vLi9zcmMvbG9hZGVyL0xheWVycy5qcz8wOWQxIiwid2VicGFjazovLy8uL3NyYy9sb2FkZXIvT2JqZWN0M0QuanM/MmE1MCIsIndlYnBhY2s6Ly8vLi9zcmMvbG9hZGVyL0dlb21ldHJ5LmpzPzFhZjAiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xvYWRlci9CdWZmZXJBdHRyaWJ1dGUuanM/NjNlYSIsIndlYnBhY2s6Ly8vLi9zcmMvbG9hZGVyL0RpcmVjdEdlb21ldHJ5LmpzP2NlNWIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xvYWRlci91dGlscy5qcz9hYmQ4Iiwid2VicGFjazovLy8uL3NyYy9sb2FkZXIvQnVmZmVyR2VvbWV0cnkuanM/MzI0NSIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0cmFzL0VhcmN1dC5qcz84NTI4Iiwid2VicGFjazovLy8uL3NyYy9leHRyYXMvU2hhcGVVdGlscy5qcz84N2UyIiwid2VicGFjazovLy8uL3NyYy9sb2FkZXIvRXh0cnVkZUdlb21ldHJ5LmpzP2JjMjYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dHJhcy9jb3JlL0N1cnZlLmpzP2JjYjUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dHJhcy9jdXJ2ZXMvRWxsaXBzZUN1cnZlLmpzPzc5ZTciLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dHJhcy9jdXJ2ZXMvQXJjQ3VydmUuanM/MTJiZiIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0cmFzL2N1cnZlcy9DYXRtdWxsUm9tQ3VydmUzLmpzPzYyMGQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dHJhcy9jb3JlL0ludGVycG9sYXRpb25zLmpzP2NhYWEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dHJhcy9jdXJ2ZXMvQ3ViaWNCZXppZXJDdXJ2ZS5qcz9iMmE4Iiwid2VicGFjazovLy8uL3NyYy9leHRyYXMvY3VydmVzL0N1YmljQmV6aWVyQ3VydmUzLmpzPzhjYzkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dHJhcy9jdXJ2ZXMvTGluZUN1cnZlLmpzPzM3Y2YiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dHJhcy9jdXJ2ZXMvTGluZUN1cnZlMy5qcz8xMWE1Iiwid2VicGFjazovLy8uL3NyYy9leHRyYXMvY3VydmVzL1F1YWRyYXRpY0JlemllckN1cnZlLmpzPzM2MGYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dHJhcy9jdXJ2ZXMvUXVhZHJhdGljQmV6aWVyQ3VydmUzLmpzP2E0N2EiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dHJhcy9jdXJ2ZXMvU3BsaW5lQ3VydmUuanM/ZDE1YyIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0cmFzL2N1cnZlcy9DdXJ2ZXMuanM/ZmYyOSIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0cmFzL2NvcmUvQ3VydmVQYXRoLmpzP2NmOTIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dHJhcy9jb3JlL1BhdGguanM/MGYyOSIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0cmFzL2NvcmUvU2hhcGUuanM/NmJhZiIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9UZXh0R2VvbWV0cnkuanM/YmNiMyIsIndlYnBhY2s6Ly8vLi9zcmMvbWF0ZXJpYWwvQ3ViZVRleHR1cmUuanM/ZjM5NiIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcz81NmQ3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcbnZhciBfTWF0aCA9IHtcclxuXHJcblx0REVHMlJBRDogTWF0aC5QSSAvIDE4MCxcclxuXHRSQUQyREVHOiAxODAgLyBNYXRoLlBJLFxyXG5cclxuXHRnZW5lcmF0ZVVVSUQ6ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA1MDM0L2hvdy10by1jcmVhdGUtYS1ndWlkLXV1aWQtaW4tamF2YXNjcmlwdC8yMTk2MzEzNiMyMTk2MzEzNlxyXG5cclxuXHRcdHZhciBsdXQgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCAyNTY7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRsdXRbIGkgXSA9ICggaSA8IDE2ID8gJzAnIDogJycgKSArICggaSApLnRvU3RyaW5nKCAxNiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKCkge1xyXG5cclxuXHRcdFx0dmFyIGQwID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xyXG5cdFx0XHR2YXIgZDEgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XHJcblx0XHRcdHZhciBkMiA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcclxuXHRcdFx0dmFyIGQzID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xyXG5cdFx0XHR2YXIgdXVpZCA9IGx1dFsgZDAgJiAweGZmIF0gKyBsdXRbIGQwID4+IDggJiAweGZmIF0gKyBsdXRbIGQwID4+IDE2ICYgMHhmZiBdICsgbHV0WyBkMCA+PiAyNCAmIDB4ZmYgXSArICctJyArXHJcblx0XHRcdFx0bHV0WyBkMSAmIDB4ZmYgXSArIGx1dFsgZDEgPj4gOCAmIDB4ZmYgXSArICctJyArIGx1dFsgZDEgPj4gMTYgJiAweDBmIHwgMHg0MCBdICsgbHV0WyBkMSA+PiAyNCAmIDB4ZmYgXSArICctJyArXHJcblx0XHRcdFx0bHV0WyBkMiAmIDB4M2YgfCAweDgwIF0gKyBsdXRbIGQyID4+IDggJiAweGZmIF0gKyAnLScgKyBsdXRbIGQyID4+IDE2ICYgMHhmZiBdICsgbHV0WyBkMiA+PiAyNCAmIDB4ZmYgXSArXHJcblx0XHRcdFx0bHV0WyBkMyAmIDB4ZmYgXSArIGx1dFsgZDMgPj4gOCAmIDB4ZmYgXSArIGx1dFsgZDMgPj4gMTYgJiAweGZmIF0gKyBsdXRbIGQzID4+IDI0ICYgMHhmZiBdO1xyXG5cclxuXHRcdFx0Ly8gLnRvVXBwZXJDYXNlKCkgaGVyZSBmbGF0dGVucyBjb25jYXRlbmF0ZWQgc3RyaW5ncyB0byBzYXZlIGhlYXAgbWVtb3J5IHNwYWNlLlxyXG5cdFx0XHRyZXR1cm4gdXVpZC50b1VwcGVyQ2FzZSgpO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0gKSgpLFxyXG5cclxuXHRjbGFtcDogZnVuY3Rpb24gKCB2YWx1ZSwgbWluLCBtYXggKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIHZhbHVlICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gY29tcHV0ZSBldWNsaWRpYW4gbW9kdWxvIG9mIG0gJSBuXHJcblx0Ly8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9kdWxvX29wZXJhdGlvblxyXG5cclxuXHRldWNsaWRlYW5Nb2R1bG86IGZ1bmN0aW9uICggbiwgbSApIHtcclxuXHJcblx0XHRyZXR1cm4gKCAoIG4gJSBtICkgKyBtICkgJSBtO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBMaW5lYXIgbWFwcGluZyBmcm9tIHJhbmdlIDxhMSwgYTI+IHRvIHJhbmdlIDxiMSwgYjI+XHJcblxyXG5cdG1hcExpbmVhcjogZnVuY3Rpb24gKCB4LCBhMSwgYTIsIGIxLCBiMiApIHtcclxuXHJcblx0XHRyZXR1cm4gYjEgKyAoIHggLSBhMSApICogKCBiMiAtIGIxICkgLyAoIGEyIC0gYTEgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZWFyX2ludGVycG9sYXRpb25cclxuXHJcblx0bGVycDogZnVuY3Rpb24gKCB4LCB5LCB0ICkge1xyXG5cclxuXHRcdHJldHVybiAoIDEgLSB0ICkgKiB4ICsgdCAqIHk7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU21vb3Roc3RlcFxyXG5cclxuXHRzbW9vdGhzdGVwOiBmdW5jdGlvbiAoIHgsIG1pbiwgbWF4ICkge1xyXG5cclxuXHRcdGlmICggeCA8PSBtaW4gKSByZXR1cm4gMDtcclxuXHRcdGlmICggeCA+PSBtYXggKSByZXR1cm4gMTtcclxuXHJcblx0XHR4ID0gKCB4IC0gbWluICkgLyAoIG1heCAtIG1pbiApO1xyXG5cclxuXHRcdHJldHVybiB4ICogeCAqICggMyAtIDIgKiB4ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNtb290aGVyc3RlcDogZnVuY3Rpb24gKCB4LCBtaW4sIG1heCApIHtcclxuXHJcblx0XHRpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XHJcblx0XHRpZiAoIHggPj0gbWF4ICkgcmV0dXJuIDE7XHJcblxyXG5cdFx0eCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcclxuXHJcblx0XHRyZXR1cm4geCAqIHggKiB4ICogKCB4ICogKCB4ICogNiAtIDE1ICkgKyAxMCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBSYW5kb20gaW50ZWdlciBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXHJcblxyXG5cdHJhbmRJbnQ6IGZ1bmN0aW9uICggbG93LCBoaWdoICkge1xyXG5cclxuXHRcdHJldHVybiBsb3cgKyBNYXRoLmZsb29yKCBNYXRoLnJhbmRvbSgpICogKCBoaWdoIC0gbG93ICsgMSApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIFJhbmRvbSBmbG9hdCBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXHJcblxyXG5cdHJhbmRGbG9hdDogZnVuY3Rpb24gKCBsb3csIGhpZ2ggKSB7XHJcblxyXG5cdFx0cmV0dXJuIGxvdyArIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gUmFuZG9tIGZsb2F0IGZyb20gPC1yYW5nZS8yLCByYW5nZS8yPiBpbnRlcnZhbFxyXG5cclxuXHRyYW5kRmxvYXRTcHJlYWQ6IGZ1bmN0aW9uICggcmFuZ2UgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHJhbmdlICogKCAwLjUgLSBNYXRoLnJhbmRvbSgpICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRlZ1RvUmFkOiBmdW5jdGlvbiAoIGRlZ3JlZXMgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGRlZ3JlZXMgKiBfTWF0aC5ERUcyUkFEO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyYWRUb0RlZzogZnVuY3Rpb24gKCByYWRpYW5zICkge1xyXG5cclxuXHRcdHJldHVybiByYWRpYW5zICogX01hdGguUkFEMkRFRztcclxuXHJcblx0fSxcclxuXHJcblx0aXNQb3dlck9mVHdvOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHJldHVybiAoIHZhbHVlICYgKCB2YWx1ZSAtIDEgKSApID09PSAwICYmIHZhbHVlICE9PSAwO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjZWlsUG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5wb3coIDIsIE1hdGguY2VpbCggTWF0aC5sb2coIHZhbHVlICkgLyBNYXRoLkxOMiApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZsb29yUG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5wb3coIDIsIE1hdGguZmxvb3IoIE1hdGgubG9nKCB2YWx1ZSApIC8gTWF0aC5MTjIgKSApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuXHJcbmV4cG9ydCB7IF9NYXRoIH07XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xyXG4gKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGVncmFldGhlciAvIGh0dHA6Ly9lZ3JhZXRoZXIuY29tL1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICovXHJcblxyXG5mdW5jdGlvbiBWZWN0b3I0KCB4LCB5LCB6LCB3ICkge1xyXG5cclxuXHR0aGlzLnggPSB4IHx8IDA7XHJcblx0dGhpcy55ID0geSB8fCAwO1xyXG5cdHRoaXMueiA9IHogfHwgMDtcclxuXHR0aGlzLncgPSAoIHcgIT09IHVuZGVmaW5lZCApID8gdyA6IDE7XHJcblxyXG5cdHRoaXMuZWxlbWVudHMgPSBbdGhpcy54LHRoaXMueSx0aGlzLnosdGhpcy53XTtcclxufVxyXG5cclxuT2JqZWN0LmFzc2lnbiggVmVjdG9yNC5wcm90b3R5cGUsIHtcclxuXHJcblx0aXNWZWN0b3I0OiB0cnVlLFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcclxuXHJcblx0XHR0aGlzLnggPSB4O1xyXG5cdFx0dGhpcy55ID0geTtcclxuXHRcdHRoaXMueiA9IHo7XHJcblx0XHR0aGlzLncgPSB3O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHNjYWxhcjtcclxuXHRcdHRoaXMueSA9IHNjYWxhcjtcclxuXHRcdHRoaXMueiA9IHNjYWxhcjtcclxuXHRcdHRoaXMudyA9IHNjYWxhcjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WDogZnVuY3Rpb24gKCB4ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHg7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFk6IGZ1bmN0aW9uICggeSApIHtcclxuXHJcblx0XHR0aGlzLnkgPSB5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRaOiBmdW5jdGlvbiAoIHogKSB7XHJcblxyXG5cdFx0dGhpcy56ID0gejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0VzogZnVuY3Rpb24gKCB3ICkge1xyXG5cclxuXHRcdHRoaXMudyA9IHc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCwgdmFsdWUgKSB7XHJcblxyXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgMjogdGhpcy56ID0gdmFsdWU7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIDM6IHRoaXMudyA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcclxuXHJcblx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcclxuXHRcdFx0Y2FzZSAxOiByZXR1cm4gdGhpcy55O1xyXG5cdFx0XHRjYXNlIDI6IHJldHVybiB0aGlzLno7XHJcblx0XHRcdGNhc2UgMzogcmV0dXJuIHRoaXMudztcclxuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLncgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHYueDtcclxuXHRcdHRoaXMueSA9IHYueTtcclxuXHRcdHRoaXMueiA9IHYuejtcclxuXHRcdHRoaXMudyA9ICggdi53ICE9PSB1bmRlZmluZWQgKSA/IHYudyA6IDE7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZDogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5WZWN0b3I0OiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCB2LCB3ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMueCArPSB2Lng7XHJcblx0XHR0aGlzLnkgKz0gdi55O1xyXG5cdFx0dGhpcy56ICs9IHYuejtcclxuXHRcdHRoaXMudyArPSB2Lnc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMueCArPSBzO1xyXG5cdFx0dGhpcy55ICs9IHM7XHJcblx0XHR0aGlzLnogKz0gcztcclxuXHRcdHRoaXMudyArPSBzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGRWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gYS54ICsgYi54O1xyXG5cdFx0dGhpcy55ID0gYS55ICsgYi55O1xyXG5cdFx0dGhpcy56ID0gYS56ICsgYi56O1xyXG5cdFx0dGhpcy53ID0gYS53ICsgYi53O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGRTY2FsZWRWZWN0b3I6IGZ1bmN0aW9uICggdiwgcyApIHtcclxuXHJcblx0XHR0aGlzLnggKz0gdi54ICogcztcclxuXHRcdHRoaXMueSArPSB2LnkgKiBzO1xyXG5cdFx0dGhpcy56ICs9IHYueiAqIHM7XHJcblx0XHR0aGlzLncgKz0gdi53ICogcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c3ViOiBmdW5jdGlvbiAoIHYsIHcgKSB7XHJcblxyXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdDT09MLlZlY3RvcjQ6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYsIHcgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy54IC09IHYueDtcclxuXHRcdHRoaXMueSAtPSB2Lnk7XHJcblx0XHR0aGlzLnogLT0gdi56O1xyXG5cdFx0dGhpcy53IC09IHYudztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c3ViU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0dGhpcy54IC09IHM7XHJcblx0XHR0aGlzLnkgLT0gcztcclxuXHRcdHRoaXMueiAtPSBzO1xyXG5cdFx0dGhpcy53IC09IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHN1YlZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBhLnggLSBiLng7XHJcblx0XHR0aGlzLnkgPSBhLnkgLSBiLnk7XHJcblx0XHR0aGlzLnogPSBhLnogLSBiLno7XHJcblx0XHR0aGlzLncgPSBhLncgLSBiLnc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcclxuXHJcblx0XHR0aGlzLnggKj0gc2NhbGFyO1xyXG5cdFx0dGhpcy55ICo9IHNjYWxhcjtcclxuXHRcdHRoaXMueiAqPSBzY2FsYXI7XHJcblx0XHR0aGlzLncgKj0gc2NhbGFyO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMueiwgdyA9IHRoaXMudztcclxuXHRcdHZhciBlID0gbS5lbGVtZW50cztcclxuXHJcblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAqIHogKyBlWyAxMiBdICogdztcclxuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICogeiArIGVbIDEzIF0gKiB3O1xyXG5cdFx0dGhpcy56ID0gZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF0gKiB3O1xyXG5cdFx0dGhpcy53ID0gZVsgMyBdICogeCArIGVbIDcgXSAqIHkgKyBlWyAxMSBdICogeiArIGVbIDE1IF0gKiB3O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gc2NhbGFyICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEF4aXNBbmdsZUZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XHJcblxyXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL3F1YXRlcm5pb25Ub0FuZ2xlL2luZGV4Lmh0bVxyXG5cclxuXHRcdC8vIHEgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXHJcblxyXG5cdFx0dGhpcy53ID0gMiAqIE1hdGguYWNvcyggcS53ICk7XHJcblxyXG5cdFx0dmFyIHMgPSBNYXRoLnNxcnQoIDEgLSBxLncgKiBxLncgKTtcclxuXHJcblx0XHRpZiAoIHMgPCAwLjAwMDEgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSAxO1xyXG5cdFx0XHR0aGlzLnkgPSAwO1xyXG5cdFx0XHR0aGlzLnogPSAwO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSBxLnggLyBzO1xyXG5cdFx0XHR0aGlzLnkgPSBxLnkgLyBzO1xyXG5cdFx0XHR0aGlzLnogPSBxLnogLyBzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0QXhpc0FuZ2xlRnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvQW5nbGUvaW5kZXguaHRtXHJcblxyXG5cdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcclxuXHJcblx0XHR2YXIgYW5nbGUsIHgsIHksIHosXHRcdC8vIHZhcmlhYmxlcyBmb3IgcmVzdWx0XHJcblx0XHRcdGVwc2lsb24gPSAwLjAxLFx0XHQvLyBtYXJnaW4gdG8gYWxsb3cgZm9yIHJvdW5kaW5nIGVycm9yc1xyXG5cdFx0XHRlcHNpbG9uMiA9IDAuMSxcdFx0Ly8gbWFyZ2luIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gMCBhbmQgMTgwIGRlZ3JlZXNcclxuXHJcblx0XHRcdHRlID0gbS5lbGVtZW50cyxcclxuXHJcblx0XHRcdG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF0sXHJcblx0XHRcdG0yMSA9IHRlWyAxIF0sIG0yMiA9IHRlWyA1IF0sIG0yMyA9IHRlWyA5IF0sXHJcblx0XHRcdG0zMSA9IHRlWyAyIF0sIG0zMiA9IHRlWyA2IF0sIG0zMyA9IHRlWyAxMCBdO1xyXG5cclxuXHRcdGlmICggKCBNYXRoLmFicyggbTEyIC0gbTIxICkgPCBlcHNpbG9uICkgJiZcclxuXHRcdCAgICAgKCBNYXRoLmFicyggbTEzIC0gbTMxICkgPCBlcHNpbG9uICkgJiZcclxuXHRcdCAgICAgKCBNYXRoLmFicyggbTIzIC0gbTMyICkgPCBlcHNpbG9uICkgKSB7XHJcblxyXG5cdFx0XHQvLyBzaW5ndWxhcml0eSBmb3VuZFxyXG5cdFx0XHQvLyBmaXJzdCBjaGVjayBmb3IgaWRlbnRpdHkgbWF0cml4IHdoaWNoIG11c3QgaGF2ZSArMSBmb3IgYWxsIHRlcm1zXHJcblx0XHRcdC8vIGluIGxlYWRpbmcgZGlhZ29uYWwgYW5kIHplcm8gaW4gb3RoZXIgdGVybXNcclxuXHJcblx0XHRcdGlmICggKCBNYXRoLmFicyggbTEyICsgbTIxICkgPCBlcHNpbG9uMiApICYmXHJcblx0XHRcdCAgICAgKCBNYXRoLmFicyggbTEzICsgbTMxICkgPCBlcHNpbG9uMiApICYmXHJcblx0XHRcdCAgICAgKCBNYXRoLmFicyggbTIzICsgbTMyICkgPCBlcHNpbG9uMiApICYmXHJcblx0XHRcdCAgICAgKCBNYXRoLmFicyggbTExICsgbTIyICsgbTMzIC0gMyApIDwgZXBzaWxvbjIgKSApIHtcclxuXHJcblx0XHRcdFx0Ly8gdGhpcyBzaW5ndWxhcml0eSBpcyBpZGVudGl0eSBtYXRyaXggc28gYW5nbGUgPSAwXHJcblxyXG5cdFx0XHRcdHRoaXMuc2V0KCAxLCAwLCAwLCAwICk7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzOyAvLyB6ZXJvIGFuZ2xlLCBhcmJpdHJhcnkgYXhpc1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gb3RoZXJ3aXNlIHRoaXMgc2luZ3VsYXJpdHkgaXMgYW5nbGUgPSAxODBcclxuXHJcblx0XHRcdGFuZ2xlID0gTWF0aC5QSTtcclxuXHJcblx0XHRcdHZhciB4eCA9ICggbTExICsgMSApIC8gMjtcclxuXHRcdFx0dmFyIHl5ID0gKCBtMjIgKyAxICkgLyAyO1xyXG5cdFx0XHR2YXIgenogPSAoIG0zMyArIDEgKSAvIDI7XHJcblx0XHRcdHZhciB4eSA9ICggbTEyICsgbTIxICkgLyA0O1xyXG5cdFx0XHR2YXIgeHogPSAoIG0xMyArIG0zMSApIC8gNDtcclxuXHRcdFx0dmFyIHl6ID0gKCBtMjMgKyBtMzIgKSAvIDQ7XHJcblxyXG5cdFx0XHRpZiAoICggeHggPiB5eSApICYmICggeHggPiB6eiApICkge1xyXG5cclxuXHRcdFx0XHQvLyBtMTEgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybVxyXG5cclxuXHRcdFx0XHRpZiAoIHh4IDwgZXBzaWxvbiApIHtcclxuXHJcblx0XHRcdFx0XHR4ID0gMDtcclxuXHRcdFx0XHRcdHkgPSAwLjcwNzEwNjc4MTtcclxuXHRcdFx0XHRcdHogPSAwLjcwNzEwNjc4MTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR4ID0gTWF0aC5zcXJ0KCB4eCApO1xyXG5cdFx0XHRcdFx0eSA9IHh5IC8geDtcclxuXHRcdFx0XHRcdHogPSB4eiAvIHg7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHl5ID4genogKSB7XHJcblxyXG5cdFx0XHRcdC8vIG0yMiBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtXHJcblxyXG5cdFx0XHRcdGlmICggeXkgPCBlcHNpbG9uICkge1xyXG5cclxuXHRcdFx0XHRcdHggPSAwLjcwNzEwNjc4MTtcclxuXHRcdFx0XHRcdHkgPSAwO1xyXG5cdFx0XHRcdFx0eiA9IDAuNzA3MTA2NzgxO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHkgPSBNYXRoLnNxcnQoIHl5ICk7XHJcblx0XHRcdFx0XHR4ID0geHkgLyB5O1xyXG5cdFx0XHRcdFx0eiA9IHl6IC8geTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gbTMzIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm0gc28gYmFzZSByZXN1bHQgb24gdGhpc1xyXG5cclxuXHRcdFx0XHRpZiAoIHp6IDwgZXBzaWxvbiApIHtcclxuXHJcblx0XHRcdFx0XHR4ID0gMC43MDcxMDY3ODE7XHJcblx0XHRcdFx0XHR5ID0gMC43MDcxMDY3ODE7XHJcblx0XHRcdFx0XHR6ID0gMDtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR6ID0gTWF0aC5zcXJ0KCB6eiApO1xyXG5cdFx0XHRcdFx0eCA9IHh6IC8gejtcclxuXHRcdFx0XHRcdHkgPSB5eiAvIHo7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuc2V0KCB4LCB5LCB6LCBhbmdsZSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7IC8vIHJldHVybiAxODAgZGVnIHJvdGF0aW9uXHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGFzIHdlIGhhdmUgcmVhY2hlZCBoZXJlIHRoZXJlIGFyZSBubyBzaW5ndWxhcml0aWVzIHNvIHdlIGNhbiBoYW5kbGUgbm9ybWFsbHlcclxuXHJcblx0XHR2YXIgcyA9IE1hdGguc3FydCggKCBtMzIgLSBtMjMgKSAqICggbTMyIC0gbTIzICkgK1xyXG5cdFx0ICAgICAgICAgICAgICAgICAgICggbTEzIC0gbTMxICkgKiAoIG0xMyAtIG0zMSApICtcclxuXHRcdCAgICAgICAgICAgICAgICAgICAoIG0yMSAtIG0xMiApICogKCBtMjEgLSBtMTIgKSApOyAvLyB1c2VkIHRvIG5vcm1hbGl6ZVxyXG5cclxuXHRcdGlmICggTWF0aC5hYnMoIHMgKSA8IDAuMDAxICkgcyA9IDE7XHJcblxyXG5cdFx0Ly8gcHJldmVudCBkaXZpZGUgYnkgemVybywgc2hvdWxkIG5vdCBoYXBwZW4gaWYgbWF0cml4IGlzIG9ydGhvZ29uYWwgYW5kIHNob3VsZCBiZVxyXG5cdFx0Ly8gY2F1Z2h0IGJ5IHNpbmd1bGFyaXR5IHRlc3QgYWJvdmUsIGJ1dCBJJ3ZlIGxlZnQgaXQgaW4ganVzdCBpbiBjYXNlXHJcblxyXG5cdFx0dGhpcy54ID0gKCBtMzIgLSBtMjMgKSAvIHM7XHJcblx0XHR0aGlzLnkgPSAoIG0xMyAtIG0zMSApIC8gcztcclxuXHRcdHRoaXMueiA9ICggbTIxIC0gbTEyICkgLyBzO1xyXG5cdFx0dGhpcy53ID0gTWF0aC5hY29zKCAoIG0xMSArIG0yMiArIG0zMyAtIDEgKSAvIDIgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWluOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5taW4oIHRoaXMueCwgdi54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLm1pbiggdGhpcy55LCB2LnkgKTtcclxuXHRcdHRoaXMueiA9IE1hdGgubWluKCB0aGlzLnosIHYueiApO1xyXG5cdFx0dGhpcy53ID0gTWF0aC5taW4oIHRoaXMudywgdi53ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1heDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCB0aGlzLngsIHYueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIHRoaXMueSwgdi55ICk7XHJcblx0XHR0aGlzLnogPSBNYXRoLm1heCggdGhpcy56LCB2LnogKTtcclxuXHRcdHRoaXMudyA9IE1hdGgubWF4KCB0aGlzLncsIHYudyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbGFtcDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcclxuXHJcblx0XHQvLyBhc3N1bWVzIG1pbiA8IG1heCwgY29tcG9uZW50d2lzZVxyXG5cclxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCBtaW4ueCwgTWF0aC5taW4oIG1heC54LCB0aGlzLnggKSApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIG1pbi55LCBNYXRoLm1pbiggbWF4LnksIHRoaXMueSApICk7XHJcblx0XHR0aGlzLnogPSBNYXRoLm1heCggbWluLnosIE1hdGgubWluKCBtYXgueiwgdGhpcy56ICkgKTtcclxuXHRcdHRoaXMudyA9IE1hdGgubWF4KCBtaW4udywgTWF0aC5taW4oIG1heC53LCB0aGlzLncgKSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbGFtcFNjYWxhcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBtaW4sIG1heDtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gY2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xyXG5cclxuXHRcdFx0aWYgKCBtaW4gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0bWluID0gbmV3IFZlY3RvcjQoKTtcclxuXHRcdFx0XHRtYXggPSBuZXcgVmVjdG9yNCgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bWluLnNldCggbWluVmFsLCBtaW5WYWwsIG1pblZhbCwgbWluVmFsICk7XHJcblx0XHRcdG1heC5zZXQoIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwsIG1heFZhbCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuY2xhbXAoIG1pbiwgbWF4ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRjbGFtcExlbmd0aDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcclxuXHJcblx0XHR2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIGxlbmd0aCB8fCAxICkubXVsdGlwbHlTY2FsYXIoIE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIGxlbmd0aCApICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5mbG9vciggdGhpcy56ICk7XHJcblx0XHR0aGlzLncgPSBNYXRoLmZsb29yKCB0aGlzLncgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2VpbDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcclxuXHRcdHRoaXMudyA9IE1hdGguY2VpbCggdGhpcy53ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdW5kOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcclxuXHRcdHRoaXMueiA9IE1hdGgucm91bmQoIHRoaXMueiApO1xyXG5cdFx0dGhpcy53ID0gTWF0aC5yb3VuZCggdGhpcy53ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcclxuXHRcdHRoaXMueiA9ICggdGhpcy56IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnogKSA6IE1hdGguZmxvb3IoIHRoaXMueiApO1xyXG5cdFx0dGhpcy53ID0gKCB0aGlzLncgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMudyApIDogTWF0aC5mbG9vciggdGhpcy53ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IC0gdGhpcy54O1xyXG5cdFx0dGhpcy55ID0gLSB0aGlzLnk7XHJcblx0XHR0aGlzLnogPSAtIHRoaXMuejtcclxuXHRcdHRoaXMudyA9IC0gdGhpcy53O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56ICsgdGhpcy53ICogdi53O1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLnc7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlbmd0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYW5oYXR0YW5MZW5ndGg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApICsgTWF0aC5hYnMoIHRoaXMueiApICsgTWF0aC5hYnMoIHRoaXMudyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgfHwgMSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRMZW5ndGg6IGZ1bmN0aW9uICggbGVuZ3RoICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCBsZW5ndGggKTtcclxuXHJcblx0fSxcclxuXHJcblx0bGVycDogZnVuY3Rpb24gKCB2LCBhbHBoYSApIHtcclxuXHJcblx0XHR0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xyXG5cdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcclxuXHRcdHRoaXMueiArPSAoIHYueiAtIHRoaXMueiApICogYWxwaGE7XHJcblx0XHR0aGlzLncgKz0gKCB2LncgLSB0aGlzLncgKSAqIGFscGhhO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZXJwVmVjdG9yczogZnVuY3Rpb24gKCB2MSwgdjIsIGFscGhhICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYyLCB2MSApLm11bHRpcGx5U2NhbGFyKCBhbHBoYSApLmFkZCggdjEgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSAmJiAoIHYueiA9PT0gdGhpcy56ICkgJiYgKCB2LncgPT09IHRoaXMudyApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcclxuXHRcdHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XHJcblx0XHR0aGlzLnogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xyXG5cdFx0dGhpcy53ID0gYXJyYXlbIG9mZnNldCArIDMgXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XHJcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLng7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy55O1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuejtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLnc7XHJcblxyXG5cdFx0cmV0dXJuIGFycmF5O1xyXG5cclxuXHR9LFxyXG5cclxuXHRmcm9tQnVmZmVyQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIG9mZnNldCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5WZWN0b3I0OiBvZmZzZXQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIC5mcm9tQnVmZmVyQXR0cmlidXRlKCkuJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnggPSBhdHRyaWJ1dGUuZ2V0WCggaW5kZXggKTtcclxuXHRcdHRoaXMueSA9IGF0dHJpYnV0ZS5nZXRZKCBpbmRleCApO1xyXG5cdFx0dGhpcy56ID0gYXR0cmlidXRlLmdldFooIGluZGV4ICk7XHJcblx0XHR0aGlzLncgPSBhdHRyaWJ1dGUuZ2V0VyggaW5kZXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxufSApO1xyXG5cclxuXHJcbmV4cG9ydCB7IFZlY3RvcjQgfTtcclxuIiwiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4vVmVjdG9yMy5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjQgfSBmcm9tICcuL1ZlY3RvcjQuanMnO1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3Igc3VwZXJlZ2diZXJ0IC8gaHR0cDovL3d3dy5wYXVsYnJ1bnQuY28udWsvXHJcbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXHJcbiAqIEBhdXRob3Igam9yZGlfcm9zIC8gaHR0cDovL3BsYXR0c29mdC5jb21cclxuICogQGF1dGhvciBEMXBsbzFkIC8gaHR0cDovL2dpdGh1Yi5jb20vRDFwbG8xZFxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIHRpbWtuaXAgLyBodHRwOi8vd3d3LmZsb29ycGxhbm5lci5jb20vXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gTWF0cml4NCgpIHtcclxuXHJcblx0dGhpcy5lbGVtZW50cyA9IFtcclxuXHJcblx0XHQxLCAwLCAwLCAwLFxyXG5cdFx0MCwgMSwgMCwgMCxcclxuXHRcdDAsIDAsIDEsIDAsXHJcblx0XHQwLCAwLCAwLCAxXHJcblxyXG5cdF07XHJcblxyXG5cdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0Y29uc29sZS5lcnJvciggJ0NPT0wuTWF0cml4NDogdGhlIGNvbnN0cnVjdG9yIG5vIGxvbmdlciByZWFkcyBhcmd1bWVudHMuIHVzZSAuc2V0KCkgaW5zdGVhZC4nICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbk9iamVjdC5hc3NpZ24oIE1hdHJpeDQucHJvdG90eXBlLCB7XHJcblxyXG5cdGlzTWF0cml4NDogdHJ1ZSxcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIG4xMSwgbjEyLCBuMTMsIG4xNCwgbjIxLCBuMjIsIG4yMywgbjI0LCBuMzEsIG4zMiwgbjMzLCBuMzQsIG40MSwgbjQyLCBuNDMsIG40NCApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRlWyAwIF0gPSBuMTE7IHRlWyA0IF0gPSBuMTI7IHRlWyA4IF0gPSBuMTM7IHRlWyAxMiBdID0gbjE0O1xyXG5cdFx0dGVbIDEgXSA9IG4yMTsgdGVbIDUgXSA9IG4yMjsgdGVbIDkgXSA9IG4yMzsgdGVbIDEzIF0gPSBuMjQ7XHJcblx0XHR0ZVsgMiBdID0gbjMxOyB0ZVsgNiBdID0gbjMyOyB0ZVsgMTAgXSA9IG4zMzsgdGVbIDE0IF0gPSBuMzQ7XHJcblx0XHR0ZVsgMyBdID0gbjQxOyB0ZVsgNyBdID0gbjQyOyB0ZVsgMTEgXSA9IG40MzsgdGVbIDE1IF0gPSBuNDQ7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG4gICAgc2V0SWRlbnRpdHkgOmZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBlID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICBlWzBdID0gMTsgICBlWzRdID0gMDsgICBlWzhdICA9IDA7ICAgZVsxMl0gPSAwO1xyXG4gICAgICAgIGVbMV0gPSAwOyAgIGVbNV0gPSAxOyAgIGVbOV0gID0gMDsgICBlWzEzXSA9IDA7XHJcbiAgICAgICAgZVsyXSA9IDA7ICAgZVs2XSA9IDA7ICAgZVsxMF0gPSAxOyAgIGVbMTRdID0gMDtcclxuICAgICAgICBlWzNdID0gMDsgICBlWzddID0gMDsgICBlWzExXSA9IDA7ICAgZVsxNV0gPSAxO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBtdWx0aXBseVZlY3RvcjMgOmZ1bmN0aW9uKHBvcykge1xyXG4gICAgICAgIHZhciBlID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICB2YXIgcCA9IHBvcy5lbGVtZW50cztcclxuICAgICAgICB2YXIgdiA9IG5ldyBWZWN0b3IzKCk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHYuZWxlbWVudHM7XHJcblxyXG4gICAgICAgIHJlc3VsdFswXSA9IHBbMF0gKiBlWzBdICsgcFsxXSAqIGVbNF0gKyBwWzJdICogZVsgOF0gKyBlWzExXTtcclxuICAgICAgICByZXN1bHRbMV0gPSBwWzBdICogZVsxXSArIHBbMV0gKiBlWzVdICsgcFsyXSAqIGVbIDldICsgZVsxMl07XHJcbiAgICAgICAgcmVzdWx0WzJdID0gcFswXSAqIGVbMl0gKyBwWzFdICogZVs2XSArIHBbMl0gKiBlWzEwXSArIGVbMTNdO1xyXG5cclxuICAgICAgICByZXR1cm4gdjtcclxuICAgIH0sXHJcblxyXG4gICAgbXVsdGlwbHlWZWN0b3I0IDpmdW5jdGlvbihwb3MpIHtcclxuICAgICAgICB2YXIgZSA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICAgICAgdmFyIHAgPSBwb3MuZWxlbWVudHM7XHJcbiAgICAgICAgdmFyIHYgPSBuZXcgVmVjdG9yNCgpO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB2LmVsZW1lbnRzO1xyXG5cclxuICAgICAgICByZXN1bHRbMF0gPSBwWzBdICogZVswXSArIHBbMV0gKiBlWzRdICsgcFsyXSAqIGVbIDhdICsgcFszXSAqIGVbMTJdO1xyXG4gICAgICAgIHJlc3VsdFsxXSA9IHBbMF0gKiBlWzFdICsgcFsxXSAqIGVbNV0gKyBwWzJdICogZVsgOV0gKyBwWzNdICogZVsxM107XHJcbiAgICAgICAgcmVzdWx0WzJdID0gcFswXSAqIGVbMl0gKyBwWzFdICogZVs2XSArIHBbMl0gKiBlWzEwXSArIHBbM10gKiBlWzE0XTtcclxuICAgICAgICByZXN1bHRbM10gPSBwWzBdICogZVszXSArIHBbMV0gKiBlWzddICsgcFsyXSAqIGVbMTFdICsgcFszXSAqIGVbMTVdO1xyXG5cclxuICAgICAgICB2ID0gbmV3IFZlY3RvcjQocmVzdWx0WzBdLHJlc3VsdFsxXSxyZXN1bHRbMl0scmVzdWx0WzNdKTtcclxuICAgICAgICByZXR1cm4gdjtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0SW52ZXJzZU9mIDpmdW5jdGlvbihvdGhlcikge1xyXG4gICAgICAgIHZhciBpLCBzLCBkLCBpbnYsIGRldDtcclxuXHJcbiAgICAgICAgcyA9IG90aGVyLmVsZW1lbnRzO1xyXG4gICAgICAgIGQgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgICAgIGludiA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xyXG5cclxuICAgICAgICBpbnZbMF0gID0gICBzWzVdKnNbMTBdKnNbMTVdIC0gc1s1XSAqc1sxMV0qc1sxNF0gLSBzWzldICpzWzZdKnNbMTVdXHJcbiAgICAgICAgICAgICsgc1s5XSpzWzddICpzWzE0XSArIHNbMTNdKnNbNl0gKnNbMTFdIC0gc1sxM10qc1s3XSpzWzEwXTtcclxuICAgICAgICBpbnZbNF0gID0gLSBzWzRdKnNbMTBdKnNbMTVdICsgc1s0XSAqc1sxMV0qc1sxNF0gKyBzWzhdICpzWzZdKnNbMTVdXHJcbiAgICAgICAgICAgIC0gc1s4XSpzWzddICpzWzE0XSAtIHNbMTJdKnNbNl0gKnNbMTFdICsgc1sxMl0qc1s3XSpzWzEwXTtcclxuICAgICAgICBpbnZbOF0gID0gICBzWzRdKnNbOV0gKnNbMTVdIC0gc1s0XSAqc1sxMV0qc1sxM10gLSBzWzhdICpzWzVdKnNbMTVdXHJcbiAgICAgICAgICAgICsgc1s4XSpzWzddICpzWzEzXSArIHNbMTJdKnNbNV0gKnNbMTFdIC0gc1sxMl0qc1s3XSpzWzldO1xyXG4gICAgICAgIGludlsxMl0gPSAtIHNbNF0qc1s5XSAqc1sxNF0gKyBzWzRdICpzWzEwXSpzWzEzXSArIHNbOF0gKnNbNV0qc1sxNF1cclxuICAgICAgICAgICAgLSBzWzhdKnNbNl0gKnNbMTNdIC0gc1sxMl0qc1s1XSAqc1sxMF0gKyBzWzEyXSpzWzZdKnNbOV07XHJcblxyXG4gICAgICAgIGludlsxXSAgPSAtIHNbMV0qc1sxMF0qc1sxNV0gKyBzWzFdICpzWzExXSpzWzE0XSArIHNbOV0gKnNbMl0qc1sxNV1cclxuICAgICAgICAgICAgLSBzWzldKnNbM10gKnNbMTRdIC0gc1sxM10qc1syXSAqc1sxMV0gKyBzWzEzXSpzWzNdKnNbMTBdO1xyXG4gICAgICAgIGludls1XSAgPSAgIHNbMF0qc1sxMF0qc1sxNV0gLSBzWzBdICpzWzExXSpzWzE0XSAtIHNbOF0gKnNbMl0qc1sxNV1cclxuICAgICAgICAgICAgKyBzWzhdKnNbM10gKnNbMTRdICsgc1sxMl0qc1syXSAqc1sxMV0gLSBzWzEyXSpzWzNdKnNbMTBdO1xyXG4gICAgICAgIGludls5XSAgPSAtIHNbMF0qc1s5XSAqc1sxNV0gKyBzWzBdICpzWzExXSpzWzEzXSArIHNbOF0gKnNbMV0qc1sxNV1cclxuICAgICAgICAgICAgLSBzWzhdKnNbM10gKnNbMTNdIC0gc1sxMl0qc1sxXSAqc1sxMV0gKyBzWzEyXSpzWzNdKnNbOV07XHJcbiAgICAgICAgaW52WzEzXSA9ICAgc1swXSpzWzldICpzWzE0XSAtIHNbMF0gKnNbMTBdKnNbMTNdIC0gc1s4XSAqc1sxXSpzWzE0XVxyXG4gICAgICAgICAgICArIHNbOF0qc1syXSAqc1sxM10gKyBzWzEyXSpzWzFdICpzWzEwXSAtIHNbMTJdKnNbMl0qc1s5XTtcclxuXHJcbiAgICAgICAgaW52WzJdICA9ICAgc1sxXSpzWzZdKnNbMTVdIC0gc1sxXSAqc1s3XSpzWzE0XSAtIHNbNV0gKnNbMl0qc1sxNV1cclxuICAgICAgICAgICAgKyBzWzVdKnNbM10qc1sxNF0gKyBzWzEzXSpzWzJdKnNbN10gIC0gc1sxM10qc1szXSpzWzZdO1xyXG4gICAgICAgIGludls2XSAgPSAtIHNbMF0qc1s2XSpzWzE1XSArIHNbMF0gKnNbN10qc1sxNF0gKyBzWzRdICpzWzJdKnNbMTVdXHJcbiAgICAgICAgICAgIC0gc1s0XSpzWzNdKnNbMTRdIC0gc1sxMl0qc1syXSpzWzddICArIHNbMTJdKnNbM10qc1s2XTtcclxuICAgICAgICBpbnZbMTBdID0gICBzWzBdKnNbNV0qc1sxNV0gLSBzWzBdICpzWzddKnNbMTNdIC0gc1s0XSAqc1sxXSpzWzE1XVxyXG4gICAgICAgICAgICArIHNbNF0qc1szXSpzWzEzXSArIHNbMTJdKnNbMV0qc1s3XSAgLSBzWzEyXSpzWzNdKnNbNV07XHJcbiAgICAgICAgaW52WzE0XSA9IC0gc1swXSpzWzVdKnNbMTRdICsgc1swXSAqc1s2XSpzWzEzXSArIHNbNF0gKnNbMV0qc1sxNF1cclxuICAgICAgICAgICAgLSBzWzRdKnNbMl0qc1sxM10gLSBzWzEyXSpzWzFdKnNbNl0gICsgc1sxMl0qc1syXSpzWzVdO1xyXG5cclxuICAgICAgICBpbnZbM10gID0gLSBzWzFdKnNbNl0qc1sxMV0gKyBzWzFdKnNbN10qc1sxMF0gKyBzWzVdKnNbMl0qc1sxMV1cclxuICAgICAgICAgICAgLSBzWzVdKnNbM10qc1sxMF0gLSBzWzldKnNbMl0qc1s3XSAgKyBzWzldKnNbM10qc1s2XTtcclxuICAgICAgICBpbnZbN10gID0gICBzWzBdKnNbNl0qc1sxMV0gLSBzWzBdKnNbN10qc1sxMF0gLSBzWzRdKnNbMl0qc1sxMV1cclxuICAgICAgICAgICAgKyBzWzRdKnNbM10qc1sxMF0gKyBzWzhdKnNbMl0qc1s3XSAgLSBzWzhdKnNbM10qc1s2XTtcclxuICAgICAgICBpbnZbMTFdID0gLSBzWzBdKnNbNV0qc1sxMV0gKyBzWzBdKnNbN10qc1s5XSAgKyBzWzRdKnNbMV0qc1sxMV1cclxuICAgICAgICAgICAgLSBzWzRdKnNbM10qc1s5XSAgLSBzWzhdKnNbMV0qc1s3XSAgKyBzWzhdKnNbM10qc1s1XTtcclxuICAgICAgICBpbnZbMTVdID0gICBzWzBdKnNbNV0qc1sxMF0gLSBzWzBdKnNbNl0qc1s5XSAgLSBzWzRdKnNbMV0qc1sxMF1cclxuICAgICAgICAgICAgKyBzWzRdKnNbMl0qc1s5XSAgKyBzWzhdKnNbMV0qc1s2XSAgLSBzWzhdKnNbMl0qc1s1XTtcclxuXHJcbiAgICAgICAgZGV0ID0gc1swXSppbnZbMF0gKyBzWzFdKmludls0XSArIHNbMl0qaW52WzhdICsgc1szXSppbnZbMTJdO1xyXG4gICAgICAgIGlmIChkZXQgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkZXQgPSAxIC8gZGV0O1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRbaV0gPSBpbnZbaV0gKiBkZXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgaW52ZXJ0IDpmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZXRJbnZlcnNlT2YodGhpcyk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9ydGhvIDpmdW5jdGlvbihsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbmNhdChuZXcgTWF0cml4NCgpLnNldE9ydGhvKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEZydXN0dW0gOmZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XHJcbiAgICAgICAgdmFyIGUsIHJ3LCByaCwgcmQ7XHJcblxyXG4gICAgICAgIGlmIChsZWZ0ID09PSByaWdodCB8fCB0b3AgPT09IGJvdHRvbSB8fCBuZWFyID09PSBmYXIpIHtcclxuICAgICAgICAgICAgdGhyb3cgJ251bGwgZnJ1c3R1bSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuZWFyIDw9IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgJ25lYXIgPD0gMCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmYXIgPD0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyAnZmFyIDw9IDAnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcncgPSAxIC8gKHJpZ2h0IC0gbGVmdCk7XHJcbiAgICAgICAgcmggPSAxIC8gKHRvcCAtIGJvdHRvbSk7XHJcbiAgICAgICAgcmQgPSAxIC8gKGZhciAtIG5lYXIpO1xyXG5cclxuICAgICAgICBlID0gdGhpcy5lbGVtZW50cztcclxuXHJcbiAgICAgICAgZVsgMF0gPSAyICogbmVhciAqIHJ3O1xyXG4gICAgICAgIGVbIDFdID0gMDtcclxuICAgICAgICBlWyAyXSA9IDA7XHJcbiAgICAgICAgZVsgM10gPSAwO1xyXG5cclxuICAgICAgICBlWyA0XSA9IDA7XHJcbiAgICAgICAgZVsgNV0gPSAyICogbmVhciAqIHJoO1xyXG4gICAgICAgIGVbIDZdID0gMDtcclxuICAgICAgICBlWyA3XSA9IDA7XHJcblxyXG4gICAgICAgIGVbIDhdID0gKHJpZ2h0ICsgbGVmdCkgKiBydztcclxuICAgICAgICBlWyA5XSA9ICh0b3AgKyBib3R0b20pICogcmg7XHJcbiAgICAgICAgZVsxMF0gPSAtKGZhciArIG5lYXIpICogcmQ7XHJcbiAgICAgICAgZVsxMV0gPSAtMTtcclxuXHJcbiAgICAgICAgZVsxMl0gPSAwO1xyXG4gICAgICAgIGVbMTNdID0gMDtcclxuICAgICAgICBlWzE0XSA9IC0yICogbmVhciAqIGZhciAqIHJkO1xyXG4gICAgICAgIGVbMTVdID0gMDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldE9ydGhvIDpmdW5jdGlvbihsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xyXG4gICAgICAgIHZhciBlLCBydywgcmgsIHJkO1xyXG5cclxuICAgICAgICBpZiAobGVmdCA9PT0gcmlnaHQgfHwgYm90dG9tID09PSB0b3AgfHwgbmVhciA9PT0gZmFyKSB7XHJcbiAgICAgICAgICAgIHRocm93ICdudWxsIGZydXN0dW0nO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcncgPSAxIC8gKHJpZ2h0IC0gbGVmdCk7XHJcbiAgICAgICAgcmggPSAxIC8gKHRvcCAtIGJvdHRvbSk7XHJcbiAgICAgICAgcmQgPSAxIC8gKGZhciAtIG5lYXIpO1xyXG5cclxuICAgICAgICBlID0gdGhpcy5lbGVtZW50cztcclxuXHJcbiAgICAgICAgZVswXSAgPSAyICogcnc7XHJcbiAgICAgICAgZVsxXSAgPSAwO1xyXG4gICAgICAgIGVbMl0gID0gMDtcclxuICAgICAgICBlWzNdICA9IDA7XHJcblxyXG4gICAgICAgIGVbNF0gID0gMDtcclxuICAgICAgICBlWzVdICA9IDIgKiByaDtcclxuICAgICAgICBlWzZdICA9IDA7XHJcbiAgICAgICAgZVs3XSAgPSAwO1xyXG5cclxuICAgICAgICBlWzhdICA9IDA7XHJcbiAgICAgICAgZVs5XSAgPSAwO1xyXG4gICAgICAgIGVbMTBdID0gLTIgKiByZDtcclxuICAgICAgICBlWzExXSA9IDA7XHJcblxyXG4gICAgICAgIGVbMTJdID0gLShyaWdodCArIGxlZnQpICogcnc7XHJcbiAgICAgICAgZVsxM10gPSAtKHRvcCArIGJvdHRvbSkgKiByaDtcclxuICAgICAgICBlWzE0XSA9IC0oZmFyICsgbmVhcikgKiByZDtcclxuICAgICAgICBlWzE1XSA9IDE7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBjb25jYXQgOmZ1bmN0aW9uKG90aGVyKSB7XHJcbiAgICAgICAgdmFyIGksIGUsIGEsIGIsIGFpMCwgYWkxLCBhaTIsIGFpMztcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGUgPSBhICogYlxyXG4gICAgICAgIGUgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgICAgIGEgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgICAgIGIgPSBvdGhlci5lbGVtZW50cztcclxuXHJcbiAgICAgICAgLy8gSWYgZSBlcXVhbHMgYiwgY29weSBiIHRvIHRlbXBvcmFyeSBtYXRyaXguXHJcbiAgICAgICAgaWYgKGUgPT09IGIpIHtcclxuICAgICAgICAgICAgYiA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTY7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgYltpXSA9IGVbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpKyspIHtcclxuICAgICAgICAgICAgYWkwPWFbaV07ICBhaTE9YVtpKzRdOyAgYWkyPWFbaSs4XTsgIGFpMz1hW2krMTJdO1xyXG4gICAgICAgICAgICBlW2ldICAgID0gYWkwICogYlswXSAgKyBhaTEgKiBiWzFdICArIGFpMiAqIGJbMl0gICsgYWkzICogYlszXTtcclxuICAgICAgICAgICAgZVtpKzRdICA9IGFpMCAqIGJbNF0gICsgYWkxICogYls1XSAgKyBhaTIgKiBiWzZdICArIGFpMyAqIGJbN107XHJcbiAgICAgICAgICAgIGVbaSs4XSAgPSBhaTAgKiBiWzhdICArIGFpMSAqIGJbOV0gICsgYWkyICogYlsxMF0gKyBhaTMgKiBiWzExXTtcclxuICAgICAgICAgICAgZVtpKzEyXSA9IGFpMCAqIGJbMTJdICsgYWkxICogYlsxM10gKyBhaTIgKiBiWzE0XSArIGFpMyAqIGJbMTVdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGZydXN0dW0gOmZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uY2F0KG5ldyBNYXRyaXg0KCkuc2V0RnJ1c3R1bShsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRQZXJzcGVjdGl2ZSA6ZnVuY3Rpb24oZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpIHtcclxuICAgICAgICB2YXIgZSwgcmQsIHMsIGN0O1xyXG5cclxuICAgICAgICBpZiAobmVhciA9PT0gZmFyIHx8IGFzcGVjdCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyAnbnVsbCBmcnVzdHVtJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5lYXIgPD0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyAnbmVhciA8PSAwJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZhciA8PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93ICdmYXIgPD0gMCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3Z5ID0gTWF0aC5QSSAqIGZvdnkgLyAxODAgLyAyO1xyXG4gICAgICAgIHMgPSBNYXRoLnNpbihmb3Z5KTtcclxuICAgICAgICBpZiAocyA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyAnbnVsbCBmcnVzdHVtJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJkID0gMSAvIChmYXIgLSBuZWFyKTtcclxuICAgICAgICBjdCA9IE1hdGguY29zKGZvdnkpIC8gcztcclxuXHJcbiAgICAgICAgZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG4gICAgICAgIGVbMF0gID0gY3QgLyBhc3BlY3Q7XHJcbiAgICAgICAgZVsxXSAgPSAwO1xyXG4gICAgICAgIGVbMl0gID0gMDtcclxuICAgICAgICBlWzNdICA9IDA7XHJcblxyXG4gICAgICAgIGVbNF0gID0gMDtcclxuICAgICAgICBlWzVdICA9IGN0O1xyXG4gICAgICAgIGVbNl0gID0gMDtcclxuICAgICAgICBlWzddICA9IDA7XHJcblxyXG4gICAgICAgIGVbOF0gID0gMDtcclxuICAgICAgICBlWzldICA9IDA7XHJcbiAgICAgICAgZVsxMF0gPSAtKGZhciArIG5lYXIpICogcmQ7XHJcbiAgICAgICAgZVsxMV0gPSAtMTtcclxuXHJcbiAgICAgICAgZVsxMl0gPSAwO1xyXG4gICAgICAgIGVbMTNdID0gMDtcclxuICAgICAgICBlWzE0XSA9IC0yICogbmVhciAqIGZhciAqIHJkO1xyXG4gICAgICAgIGVbMTVdID0gMDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHBlcnNwZWN0aXZlIDpmdW5jdGlvbihmb3Z5LCBhc3BlY3QsIG5lYXIsIGZhcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbmNhdChuZXcgTWF0cml4NCgpLnNldFBlcnNwZWN0aXZlKGZvdnksIGFzcGVjdCwgbmVhciwgZmFyKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNjYWxlIDpmdW5jdGlvbih4LCB5LCB6KSB7XHJcbiAgICAgICAgdmFyIGUgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgICAgIGVbMF0gPSB4OyAgZVs0XSA9IDA7ICBlWzhdICA9IDA7ICBlWzEyXSA9IDA7XHJcbiAgICAgICAgZVsxXSA9IDA7ICBlWzVdID0geTsgIGVbOV0gID0gMDsgIGVbMTNdID0gMDtcclxuICAgICAgICBlWzJdID0gMDsgIGVbNl0gPSAwOyAgZVsxMF0gPSB6OyAgZVsxNF0gPSAwO1xyXG4gICAgICAgIGVbM10gPSAwOyAgZVs3XSA9IDA7ICBlWzExXSA9IDA7ICBlWzE1XSA9IDE7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNjYWxlIDpmdW5jdGlvbih4LCB5LCB6KSB7XHJcbiAgICAgICAgdmFyIGUgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgICAgIGVbMF0gKj0geDsgIGVbNF0gKj0geTsgIGVbOF0gICo9IHo7XHJcbiAgICAgICAgZVsxXSAqPSB4OyAgZVs1XSAqPSB5OyAgZVs5XSAgKj0gejtcclxuICAgICAgICBlWzJdICo9IHg7ICBlWzZdICo9IHk7ICBlWzEwXSAqPSB6O1xyXG4gICAgICAgIGVbM10gKj0geDsgIGVbN10gKj0geTsgIGVbMTFdICo9IHo7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuXHRpZGVudGl0eTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0MSwgMCwgMCwgMCxcclxuXHRcdFx0MCwgMSwgMCwgMCxcclxuXHRcdFx0MCwgMCwgMSwgMCxcclxuXHRcdFx0MCwgMCwgMCwgMVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBNYXRyaXg0KCkuZnJvbUFycmF5KCB0aGlzLmVsZW1lbnRzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0dmFyIG1lID0gbS5lbGVtZW50cztcclxuXHJcblx0XHR0ZVsgMCBdID0gbWVbIDAgXTsgdGVbIDEgXSA9IG1lWyAxIF07IHRlWyAyIF0gPSBtZVsgMiBdOyB0ZVsgMyBdID0gbWVbIDMgXTtcclxuXHRcdHRlWyA0IF0gPSBtZVsgNCBdOyB0ZVsgNSBdID0gbWVbIDUgXTsgdGVbIDYgXSA9IG1lWyA2IF07IHRlWyA3IF0gPSBtZVsgNyBdO1xyXG5cdFx0dGVbIDggXSA9IG1lWyA4IF07IHRlWyA5IF0gPSBtZVsgOSBdOyB0ZVsgMTAgXSA9IG1lWyAxMCBdOyB0ZVsgMTEgXSA9IG1lWyAxMSBdO1xyXG5cdFx0dGVbIDEyIF0gPSBtZVsgMTIgXTsgdGVbIDEzIF0gPSBtZVsgMTMgXTsgdGVbIDE0IF0gPSBtZVsgMTQgXTsgdGVbIDE1IF0gPSBtZVsgMTUgXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weVBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cywgbWUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRlWyAxMiBdID0gbWVbIDEyIF07XHJcblx0XHR0ZVsgMTMgXSA9IG1lWyAxMyBdO1xyXG5cdFx0dGVbIDE0IF0gPSBtZVsgMTQgXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXh0cmFjdEJhc2lzOiBmdW5jdGlvbiAoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XHJcblxyXG5cdFx0eEF4aXMuc2V0RnJvbU1hdHJpeENvbHVtbiggdGhpcywgMCApO1xyXG5cdFx0eUF4aXMuc2V0RnJvbU1hdHJpeENvbHVtbiggdGhpcywgMSApO1xyXG5cdFx0ekF4aXMuc2V0RnJvbU1hdHJpeENvbHVtbiggdGhpcywgMiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlQmFzaXM6IGZ1bmN0aW9uICggeEF4aXMsIHlBeGlzLCB6QXhpcyApIHtcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHRcdFx0eEF4aXMueCwgeUF4aXMueCwgekF4aXMueCwgMCxcclxuXHRcdFx0eEF4aXMueSwgeUF4aXMueSwgekF4aXMueSwgMCxcclxuXHRcdFx0eEF4aXMueiwgeUF4aXMueiwgekF4aXMueiwgMCxcclxuXHRcdFx0MCwgMCwgMCwgMVxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXh0cmFjdFJvdGF0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gZXh0cmFjdFJvdGF0aW9uKCBtICkge1xyXG5cclxuXHRcdFx0Ly8gdGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCByZWZsZWN0aW9uIG1hdHJpY2VzXHJcblxyXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0XHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdFx0dmFyIHNjYWxlWCA9IDEgLyB2MS5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAwICkubGVuZ3RoKCk7XHJcblx0XHRcdHZhciBzY2FsZVkgPSAxIC8gdjEuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMSApLmxlbmd0aCgpO1xyXG5cdFx0XHR2YXIgc2NhbGVaID0gMSAvIHYxLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDIgKS5sZW5ndGgoKTtcclxuXHJcblx0XHRcdHRlWyAwIF0gPSBtZVsgMCBdICogc2NhbGVYO1xyXG5cdFx0XHR0ZVsgMSBdID0gbWVbIDEgXSAqIHNjYWxlWDtcclxuXHRcdFx0dGVbIDIgXSA9IG1lWyAyIF0gKiBzY2FsZVg7XHJcblx0XHRcdHRlWyAzIF0gPSAwO1xyXG5cclxuXHRcdFx0dGVbIDQgXSA9IG1lWyA0IF0gKiBzY2FsZVk7XHJcblx0XHRcdHRlWyA1IF0gPSBtZVsgNSBdICogc2NhbGVZO1xyXG5cdFx0XHR0ZVsgNiBdID0gbWVbIDYgXSAqIHNjYWxlWTtcclxuXHRcdFx0dGVbIDcgXSA9IDA7XHJcblxyXG5cdFx0XHR0ZVsgOCBdID0gbWVbIDggXSAqIHNjYWxlWjtcclxuXHRcdFx0dGVbIDkgXSA9IG1lWyA5IF0gKiBzY2FsZVo7XHJcblx0XHRcdHRlWyAxMCBdID0gbWVbIDEwIF0gKiBzY2FsZVo7XHJcblx0XHRcdHRlWyAxMSBdID0gMDtcclxuXHJcblx0XHRcdHRlWyAxMiBdID0gMDtcclxuXHRcdFx0dGVbIDEzIF0gPSAwO1xyXG5cdFx0XHR0ZVsgMTQgXSA9IDA7XHJcblx0XHRcdHRlWyAxNSBdID0gMTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0bWFrZVJvdGF0aW9uRnJvbUV1bGVyOiBmdW5jdGlvbiAoIGV1bGVyICkge1xyXG5cclxuXHRcdGlmICggISAoIGV1bGVyICYmIGV1bGVyLmlzRXVsZXIgKSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdDT09MLk1hdHJpeDQ6IC5tYWtlUm90YXRpb25Gcm9tRXVsZXIoKSBub3cgZXhwZWN0cyBhIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHZhciB4ID0gZXVsZXIueCwgeSA9IGV1bGVyLnksIHogPSBldWxlci56O1xyXG5cdFx0dmFyIGEgPSBNYXRoLmNvcyggeCApLCBiID0gTWF0aC5zaW4oIHggKTtcclxuXHRcdHZhciBjID0gTWF0aC5jb3MoIHkgKSwgZCA9IE1hdGguc2luKCB5ICk7XHJcblx0XHR2YXIgZSA9IE1hdGguY29zKCB6ICksIGYgPSBNYXRoLnNpbiggeiApO1xyXG5cclxuXHRcdGlmICggZXVsZXIub3JkZXIgPT09ICdYWVonICkge1xyXG5cclxuXHRcdFx0dmFyIGFlID0gYSAqIGUsIGFmID0gYSAqIGYsIGJlID0gYiAqIGUsIGJmID0gYiAqIGY7XHJcblxyXG5cdFx0XHR0ZVsgMCBdID0gYyAqIGU7XHJcblx0XHRcdHRlWyA0IF0gPSAtIGMgKiBmO1xyXG5cdFx0XHR0ZVsgOCBdID0gZDtcclxuXHJcblx0XHRcdHRlWyAxIF0gPSBhZiArIGJlICogZDtcclxuXHRcdFx0dGVbIDUgXSA9IGFlIC0gYmYgKiBkO1xyXG5cdFx0XHR0ZVsgOSBdID0gLSBiICogYztcclxuXHJcblx0XHRcdHRlWyAyIF0gPSBiZiAtIGFlICogZDtcclxuXHRcdFx0dGVbIDYgXSA9IGJlICsgYWYgKiBkO1xyXG5cdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWVhaJyApIHtcclxuXHJcblx0XHRcdHZhciBjZSA9IGMgKiBlLCBjZiA9IGMgKiBmLCBkZSA9IGQgKiBlLCBkZiA9IGQgKiBmO1xyXG5cclxuXHRcdFx0dGVbIDAgXSA9IGNlICsgZGYgKiBiO1xyXG5cdFx0XHR0ZVsgNCBdID0gZGUgKiBiIC0gY2Y7XHJcblx0XHRcdHRlWyA4IF0gPSBhICogZDtcclxuXHJcblx0XHRcdHRlWyAxIF0gPSBhICogZjtcclxuXHRcdFx0dGVbIDUgXSA9IGEgKiBlO1xyXG5cdFx0XHR0ZVsgOSBdID0gLSBiO1xyXG5cclxuXHRcdFx0dGVbIDIgXSA9IGNmICogYiAtIGRlO1xyXG5cdFx0XHR0ZVsgNiBdID0gZGYgKyBjZSAqIGI7XHJcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWFknICkge1xyXG5cclxuXHRcdFx0dmFyIGNlID0gYyAqIGUsIGNmID0gYyAqIGYsIGRlID0gZCAqIGUsIGRmID0gZCAqIGY7XHJcblxyXG5cdFx0XHR0ZVsgMCBdID0gY2UgLSBkZiAqIGI7XHJcblx0XHRcdHRlWyA0IF0gPSAtIGEgKiBmO1xyXG5cdFx0XHR0ZVsgOCBdID0gZGUgKyBjZiAqIGI7XHJcblxyXG5cdFx0XHR0ZVsgMSBdID0gY2YgKyBkZSAqIGI7XHJcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcclxuXHRcdFx0dGVbIDkgXSA9IGRmIC0gY2UgKiBiO1xyXG5cclxuXHRcdFx0dGVbIDIgXSA9IC0gYSAqIGQ7XHJcblx0XHRcdHRlWyA2IF0gPSBiO1xyXG5cdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWllYJyApIHtcclxuXHJcblx0XHRcdHZhciBhZSA9IGEgKiBlLCBhZiA9IGEgKiBmLCBiZSA9IGIgKiBlLCBiZiA9IGIgKiBmO1xyXG5cclxuXHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xyXG5cdFx0XHR0ZVsgNCBdID0gYmUgKiBkIC0gYWY7XHJcblx0XHRcdHRlWyA4IF0gPSBhZSAqIGQgKyBiZjtcclxuXHJcblx0XHRcdHRlWyAxIF0gPSBjICogZjtcclxuXHRcdFx0dGVbIDUgXSA9IGJmICogZCArIGFlO1xyXG5cdFx0XHR0ZVsgOSBdID0gYWYgKiBkIC0gYmU7XHJcblxyXG5cdFx0XHR0ZVsgMiBdID0gLSBkO1xyXG5cdFx0XHR0ZVsgNiBdID0gYiAqIGM7XHJcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWlgnICkge1xyXG5cclxuXHRcdFx0dmFyIGFjID0gYSAqIGMsIGFkID0gYSAqIGQsIGJjID0gYiAqIGMsIGJkID0gYiAqIGQ7XHJcblxyXG5cdFx0XHR0ZVsgMCBdID0gYyAqIGU7XHJcblx0XHRcdHRlWyA0IF0gPSBiZCAtIGFjICogZjtcclxuXHRcdFx0dGVbIDggXSA9IGJjICogZiArIGFkO1xyXG5cclxuXHRcdFx0dGVbIDEgXSA9IGY7XHJcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcclxuXHRcdFx0dGVbIDkgXSA9IC0gYiAqIGU7XHJcblxyXG5cdFx0XHR0ZVsgMiBdID0gLSBkICogZTtcclxuXHRcdFx0dGVbIDYgXSA9IGFkICogZiArIGJjO1xyXG5cdFx0XHR0ZVsgMTAgXSA9IGFjIC0gYmQgKiBmO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWFpZJyApIHtcclxuXHJcblx0XHRcdHZhciBhYyA9IGEgKiBjLCBhZCA9IGEgKiBkLCBiYyA9IGIgKiBjLCBiZCA9IGIgKiBkO1xyXG5cclxuXHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xyXG5cdFx0XHR0ZVsgNCBdID0gLSBmO1xyXG5cdFx0XHR0ZVsgOCBdID0gZCAqIGU7XHJcblxyXG5cdFx0XHR0ZVsgMSBdID0gYWMgKiBmICsgYmQ7XHJcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcclxuXHRcdFx0dGVbIDkgXSA9IGFkICogZiAtIGJjO1xyXG5cclxuXHRcdFx0dGVbIDIgXSA9IGJjICogZiAtIGFkO1xyXG5cdFx0XHR0ZVsgNiBdID0gYiAqIGU7XHJcblx0XHRcdHRlWyAxMCBdID0gYmQgKiBmICsgYWM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGJvdHRvbSByb3dcclxuXHRcdHRlWyAzIF0gPSAwO1xyXG5cdFx0dGVbIDcgXSA9IDA7XHJcblx0XHR0ZVsgMTEgXSA9IDA7XHJcblxyXG5cdFx0Ly8gbGFzdCBjb2x1bW5cclxuXHRcdHRlWyAxMiBdID0gMDtcclxuXHRcdHRlWyAxMyBdID0gMDtcclxuXHRcdHRlWyAxNCBdID0gMDtcclxuXHRcdHRlWyAxNSBdID0gMTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgemVybyA9IG5ldyBWZWN0b3IzKCAwLCAwLCAwICk7XHJcblx0XHR2YXIgb25lID0gbmV3IFZlY3RvcjMoIDEsIDEsIDEgKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gbWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5jb21wb3NlKCB6ZXJvLCBxLCBvbmUgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGxvb2tBdDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB4ID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHZhciB5ID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHZhciB6ID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gbG9va0F0KCBleWUsIHRhcmdldCwgdXAgKSB7XHJcblxyXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdFx0ei5zdWJWZWN0b3JzKCBleWUsIHRhcmdldCApO1xyXG5cclxuXHRcdFx0aWYgKCB6Lmxlbmd0aFNxKCkgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGV5ZSBhbmQgdGFyZ2V0IGFyZSBpbiB0aGUgc2FtZSBwb3NpdGlvblxyXG5cclxuXHRcdFx0XHR6LnogPSAxO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ei5ub3JtYWxpemUoKTtcclxuXHRcdFx0eC5jcm9zc1ZlY3RvcnMoIHVwLCB6ICk7XHJcblxyXG5cdFx0XHRpZiAoIHgubGVuZ3RoU3EoKSA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0Ly8gdXAgYW5kIHogYXJlIHBhcmFsbGVsXHJcblxyXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIHVwLnogKSA9PT0gMSApIHtcclxuXHJcblx0XHRcdFx0XHR6LnggKz0gMC4wMDAxO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHoueiArPSAwLjAwMDE7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0ei5ub3JtYWxpemUoKTtcclxuXHRcdFx0XHR4LmNyb3NzVmVjdG9ycyggdXAsIHogKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHgubm9ybWFsaXplKCk7XHJcblx0XHRcdHkuY3Jvc3NWZWN0b3JzKCB6LCB4ICk7XHJcblxyXG5cdFx0XHR0ZVsgMCBdID0geC54OyB0ZVsgNCBdID0geS54OyB0ZVsgOCBdID0gei54O1xyXG5cdFx0XHR0ZVsgMSBdID0geC55OyB0ZVsgNSBdID0geS55OyB0ZVsgOSBdID0gei55O1xyXG5cdFx0XHR0ZVsgMiBdID0geC56OyB0ZVsgNiBdID0geS56OyB0ZVsgMTAgXSA9IHouejtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggbSwgbiApIHtcclxuXHJcblx0XHRpZiAoIG4gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ0NPT0wuTWF0cml4NDogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlNYXRyaWNlcyggYSwgYiApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCBtLCBuICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIHRoaXMsIG0gKTtcclxuXHJcblx0fSxcclxuXHJcblx0cHJlbXVsdGlwbHk6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCBtLCB0aGlzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5TWF0cmljZXM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHR2YXIgYWUgPSBhLmVsZW1lbnRzO1xyXG5cdFx0dmFyIGJlID0gYi5lbGVtZW50cztcclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dmFyIGExMSA9IGFlWyAwIF0sIGExMiA9IGFlWyA0IF0sIGExMyA9IGFlWyA4IF0sIGExNCA9IGFlWyAxMiBdO1xyXG5cdFx0dmFyIGEyMSA9IGFlWyAxIF0sIGEyMiA9IGFlWyA1IF0sIGEyMyA9IGFlWyA5IF0sIGEyNCA9IGFlWyAxMyBdO1xyXG5cdFx0dmFyIGEzMSA9IGFlWyAyIF0sIGEzMiA9IGFlWyA2IF0sIGEzMyA9IGFlWyAxMCBdLCBhMzQgPSBhZVsgMTQgXTtcclxuXHRcdHZhciBhNDEgPSBhZVsgMyBdLCBhNDIgPSBhZVsgNyBdLCBhNDMgPSBhZVsgMTEgXSwgYTQ0ID0gYWVbIDE1IF07XHJcblxyXG5cdFx0dmFyIGIxMSA9IGJlWyAwIF0sIGIxMiA9IGJlWyA0IF0sIGIxMyA9IGJlWyA4IF0sIGIxNCA9IGJlWyAxMiBdO1xyXG5cdFx0dmFyIGIyMSA9IGJlWyAxIF0sIGIyMiA9IGJlWyA1IF0sIGIyMyA9IGJlWyA5IF0sIGIyNCA9IGJlWyAxMyBdO1xyXG5cdFx0dmFyIGIzMSA9IGJlWyAyIF0sIGIzMiA9IGJlWyA2IF0sIGIzMyA9IGJlWyAxMCBdLCBiMzQgPSBiZVsgMTQgXTtcclxuXHRcdHZhciBiNDEgPSBiZVsgMyBdLCBiNDIgPSBiZVsgNyBdLCBiNDMgPSBiZVsgMTEgXSwgYjQ0ID0gYmVbIDE1IF07XHJcblxyXG5cdFx0dGVbIDAgXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMSArIGExNCAqIGI0MTtcclxuXHRcdHRlWyA0IF0gPSBhMTEgKiBiMTIgKyBhMTIgKiBiMjIgKyBhMTMgKiBiMzIgKyBhMTQgKiBiNDI7XHJcblx0XHR0ZVsgOCBdID0gYTExICogYjEzICsgYTEyICogYjIzICsgYTEzICogYjMzICsgYTE0ICogYjQzO1xyXG5cdFx0dGVbIDEyIF0gPSBhMTEgKiBiMTQgKyBhMTIgKiBiMjQgKyBhMTMgKiBiMzQgKyBhMTQgKiBiNDQ7XHJcblxyXG5cdFx0dGVbIDEgXSA9IGEyMSAqIGIxMSArIGEyMiAqIGIyMSArIGEyMyAqIGIzMSArIGEyNCAqIGI0MTtcclxuXHRcdHRlWyA1IF0gPSBhMjEgKiBiMTIgKyBhMjIgKiBiMjIgKyBhMjMgKiBiMzIgKyBhMjQgKiBiNDI7XHJcblx0XHR0ZVsgOSBdID0gYTIxICogYjEzICsgYTIyICogYjIzICsgYTIzICogYjMzICsgYTI0ICogYjQzO1xyXG5cdFx0dGVbIDEzIF0gPSBhMjEgKiBiMTQgKyBhMjIgKiBiMjQgKyBhMjMgKiBiMzQgKyBhMjQgKiBiNDQ7XHJcblxyXG5cdFx0dGVbIDIgXSA9IGEzMSAqIGIxMSArIGEzMiAqIGIyMSArIGEzMyAqIGIzMSArIGEzNCAqIGI0MTtcclxuXHRcdHRlWyA2IF0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzIgKyBhMzQgKiBiNDI7XHJcblx0XHR0ZVsgMTAgXSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMyArIGEzNCAqIGI0MztcclxuXHRcdHRlWyAxNCBdID0gYTMxICogYjE0ICsgYTMyICogYjI0ICsgYTMzICogYjM0ICsgYTM0ICogYjQ0O1xyXG5cclxuXHRcdHRlWyAzIF0gPSBhNDEgKiBiMTEgKyBhNDIgKiBiMjEgKyBhNDMgKiBiMzEgKyBhNDQgKiBiNDE7XHJcblx0XHR0ZVsgNyBdID0gYTQxICogYjEyICsgYTQyICogYjIyICsgYTQzICogYjMyICsgYTQ0ICogYjQyO1xyXG5cdFx0dGVbIDExIF0gPSBhNDEgKiBiMTMgKyBhNDIgKiBiMjMgKyBhNDMgKiBiMzMgKyBhNDQgKiBiNDM7XHJcblx0XHR0ZVsgMTUgXSA9IGE0MSAqIGIxNCArIGE0MiAqIGIyNCArIGE0MyAqIGIzNCArIGE0NCAqIGI0NDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRlWyAwIF0gKj0gczsgdGVbIDQgXSAqPSBzOyB0ZVsgOCBdICo9IHM7IHRlWyAxMiBdICo9IHM7XHJcblx0XHR0ZVsgMSBdICo9IHM7IHRlWyA1IF0gKj0gczsgdGVbIDkgXSAqPSBzOyB0ZVsgMTMgXSAqPSBzO1xyXG5cdFx0dGVbIDIgXSAqPSBzOyB0ZVsgNiBdICo9IHM7IHRlWyAxMCBdICo9IHM7IHRlWyAxNCBdICo9IHM7XHJcblx0XHR0ZVsgMyBdICo9IHM7IHRlWyA3IF0gKj0gczsgdGVbIDExIF0gKj0gczsgdGVbIDE1IF0gKj0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlUb0J1ZmZlckF0dHJpYnV0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGFwcGx5VG9CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGF0dHJpYnV0ZS5jb3VudDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHYxLnggPSBhdHRyaWJ1dGUuZ2V0WCggaSApO1xyXG5cdFx0XHRcdHYxLnkgPSBhdHRyaWJ1dGUuZ2V0WSggaSApO1xyXG5cdFx0XHRcdHYxLnogPSBhdHRyaWJ1dGUuZ2V0WiggaSApO1xyXG5cclxuXHRcdFx0XHR2MS5hcHBseU1hdHJpeDQoIHRoaXMgKTtcclxuXHJcblx0XHRcdFx0YXR0cmlidXRlLnNldFhZWiggaSwgdjEueCwgdjEueSwgdjEueiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGF0dHJpYnV0ZTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGRldGVybWluYW50OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR2YXIgbjExID0gdGVbIDAgXSwgbjEyID0gdGVbIDQgXSwgbjEzID0gdGVbIDggXSwgbjE0ID0gdGVbIDEyIF07XHJcblx0XHR2YXIgbjIxID0gdGVbIDEgXSwgbjIyID0gdGVbIDUgXSwgbjIzID0gdGVbIDkgXSwgbjI0ID0gdGVbIDEzIF07XHJcblx0XHR2YXIgbjMxID0gdGVbIDIgXSwgbjMyID0gdGVbIDYgXSwgbjMzID0gdGVbIDEwIF0sIG4zNCA9IHRlWyAxNCBdO1xyXG5cdFx0dmFyIG40MSA9IHRlWyAzIF0sIG40MiA9IHRlWyA3IF0sIG40MyA9IHRlWyAxMSBdLCBuNDQgPSB0ZVsgMTUgXTtcclxuXHJcblx0XHQvL1RPRE86IG1ha2UgdGhpcyBtb3JlIGVmZmljaWVudFxyXG5cdFx0Ly8oIGJhc2VkIG9uIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bSApXHJcblxyXG5cdFx0cmV0dXJuIChcclxuXHRcdFx0bjQxICogKFxyXG5cdFx0XHRcdCsgbjE0ICogbjIzICogbjMyXHJcblx0XHRcdFx0IC0gbjEzICogbjI0ICogbjMyXHJcblx0XHRcdFx0IC0gbjE0ICogbjIyICogbjMzXHJcblx0XHRcdFx0ICsgbjEyICogbjI0ICogbjMzXHJcblx0XHRcdFx0ICsgbjEzICogbjIyICogbjM0XHJcblx0XHRcdFx0IC0gbjEyICogbjIzICogbjM0XHJcblx0XHRcdCkgK1xyXG5cdFx0XHRuNDIgKiAoXHJcblx0XHRcdFx0KyBuMTEgKiBuMjMgKiBuMzRcclxuXHRcdFx0XHQgLSBuMTEgKiBuMjQgKiBuMzNcclxuXHRcdFx0XHQgKyBuMTQgKiBuMjEgKiBuMzNcclxuXHRcdFx0XHQgLSBuMTMgKiBuMjEgKiBuMzRcclxuXHRcdFx0XHQgKyBuMTMgKiBuMjQgKiBuMzFcclxuXHRcdFx0XHQgLSBuMTQgKiBuMjMgKiBuMzFcclxuXHRcdFx0KSArXHJcblx0XHRcdG40MyAqIChcclxuXHRcdFx0XHQrIG4xMSAqIG4yNCAqIG4zMlxyXG5cdFx0XHRcdCAtIG4xMSAqIG4yMiAqIG4zNFxyXG5cdFx0XHRcdCAtIG4xNCAqIG4yMSAqIG4zMlxyXG5cdFx0XHRcdCArIG4xMiAqIG4yMSAqIG4zNFxyXG5cdFx0XHRcdCArIG4xNCAqIG4yMiAqIG4zMVxyXG5cdFx0XHRcdCAtIG4xMiAqIG4yNCAqIG4zMVxyXG5cdFx0XHQpICtcclxuXHRcdFx0bjQ0ICogKFxyXG5cdFx0XHRcdC0gbjEzICogbjIyICogbjMxXHJcblx0XHRcdFx0IC0gbjExICogbjIzICogbjMyXHJcblx0XHRcdFx0ICsgbjExICogbjIyICogbjMzXHJcblx0XHRcdFx0ICsgbjEzICogbjIxICogbjMyXHJcblx0XHRcdFx0IC0gbjEyICogbjIxICogbjMzXHJcblx0XHRcdFx0ICsgbjEyICogbjIzICogbjMxXHJcblx0XHRcdClcclxuXHJcblx0XHQpO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0cmFuc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0dmFyIHRtcDtcclxuXHJcblx0XHR0bXAgPSB0ZVsgMSBdOyB0ZVsgMSBdID0gdGVbIDQgXTsgdGVbIDQgXSA9IHRtcDtcclxuXHRcdHRtcCA9IHRlWyAyIF07IHRlWyAyIF0gPSB0ZVsgOCBdOyB0ZVsgOCBdID0gdG1wO1xyXG5cdFx0dG1wID0gdGVbIDYgXTsgdGVbIDYgXSA9IHRlWyA5IF07IHRlWyA5IF0gPSB0bXA7XHJcblxyXG5cdFx0dG1wID0gdGVbIDMgXTsgdGVbIDMgXSA9IHRlWyAxMiBdOyB0ZVsgMTIgXSA9IHRtcDtcclxuXHRcdHRtcCA9IHRlWyA3IF07IHRlWyA3IF0gPSB0ZVsgMTMgXTsgdGVbIDEzIF0gPSB0bXA7XHJcblx0XHR0bXAgPSB0ZVsgMTEgXTsgdGVbIDExIF0gPSB0ZVsgMTQgXTsgdGVbIDE0IF0gPSB0bXA7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFBvc2l0aW9uOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR0ZVsgMTIgXSA9IHYueDtcclxuXHRcdHRlWyAxMyBdID0gdi55O1xyXG5cdFx0dGVbIDE0IF0gPSB2Lno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEludmVyc2U6IGZ1bmN0aW9uICggbSwgdGhyb3dPbkRlZ2VuZXJhdGUgKSB7XHJcblxyXG5cdFx0Ly8gYmFzZWQgb24gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzLFxyXG5cdFx0XHRtZSA9IG0uZWxlbWVudHMsXHJcblxyXG5cdFx0XHRuMTEgPSBtZVsgMCBdLCBuMjEgPSBtZVsgMSBdLCBuMzEgPSBtZVsgMiBdLCBuNDEgPSBtZVsgMyBdLFxyXG5cdFx0XHRuMTIgPSBtZVsgNCBdLCBuMjIgPSBtZVsgNSBdLCBuMzIgPSBtZVsgNiBdLCBuNDIgPSBtZVsgNyBdLFxyXG5cdFx0XHRuMTMgPSBtZVsgOCBdLCBuMjMgPSBtZVsgOSBdLCBuMzMgPSBtZVsgMTAgXSwgbjQzID0gbWVbIDExIF0sXHJcblx0XHRcdG4xNCA9IG1lWyAxMiBdLCBuMjQgPSBtZVsgMTMgXSwgbjM0ID0gbWVbIDE0IF0sIG40NCA9IG1lWyAxNSBdLFxyXG5cclxuXHRcdFx0dDExID0gbjIzICogbjM0ICogbjQyIC0gbjI0ICogbjMzICogbjQyICsgbjI0ICogbjMyICogbjQzIC0gbjIyICogbjM0ICogbjQzIC0gbjIzICogbjMyICogbjQ0ICsgbjIyICogbjMzICogbjQ0LFxyXG5cdFx0XHR0MTIgPSBuMTQgKiBuMzMgKiBuNDIgLSBuMTMgKiBuMzQgKiBuNDIgLSBuMTQgKiBuMzIgKiBuNDMgKyBuMTIgKiBuMzQgKiBuNDMgKyBuMTMgKiBuMzIgKiBuNDQgLSBuMTIgKiBuMzMgKiBuNDQsXHJcblx0XHRcdHQxMyA9IG4xMyAqIG4yNCAqIG40MiAtIG4xNCAqIG4yMyAqIG40MiArIG4xNCAqIG4yMiAqIG40MyAtIG4xMiAqIG4yNCAqIG40MyAtIG4xMyAqIG4yMiAqIG40NCArIG4xMiAqIG4yMyAqIG40NCxcclxuXHRcdFx0dDE0ID0gbjE0ICogbjIzICogbjMyIC0gbjEzICogbjI0ICogbjMyIC0gbjE0ICogbjIyICogbjMzICsgbjEyICogbjI0ICogbjMzICsgbjEzICogbjIyICogbjM0IC0gbjEyICogbjIzICogbjM0O1xyXG5cclxuXHRcdHZhciBkZXQgPSBuMTEgKiB0MTEgKyBuMjEgKiB0MTIgKyBuMzEgKiB0MTMgKyBuNDEgKiB0MTQ7XHJcblxyXG5cdFx0aWYgKCBkZXQgPT09IDAgKSB7XHJcblxyXG5cdFx0XHR2YXIgbXNnID0gXCJDT09MLk1hdHJpeDQ6IC5nZXRJbnZlcnNlKCkgY2FuJ3QgaW52ZXJ0IG1hdHJpeCwgZGV0ZXJtaW5hbnQgaXMgMFwiO1xyXG5cclxuXHRcdFx0aWYgKCB0aHJvd09uRGVnZW5lcmF0ZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggbXNnICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5pZGVudGl0eSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZGV0SW52ID0gMSAvIGRldDtcclxuXHJcblx0XHR0ZVsgMCBdID0gdDExICogZGV0SW52O1xyXG5cdFx0dGVbIDEgXSA9ICggbjI0ICogbjMzICogbjQxIC0gbjIzICogbjM0ICogbjQxIC0gbjI0ICogbjMxICogbjQzICsgbjIxICogbjM0ICogbjQzICsgbjIzICogbjMxICogbjQ0IC0gbjIxICogbjMzICogbjQ0ICkgKiBkZXRJbnY7XHJcblx0XHR0ZVsgMiBdID0gKCBuMjIgKiBuMzQgKiBuNDEgLSBuMjQgKiBuMzIgKiBuNDEgKyBuMjQgKiBuMzEgKiBuNDIgLSBuMjEgKiBuMzQgKiBuNDIgLSBuMjIgKiBuMzEgKiBuNDQgKyBuMjEgKiBuMzIgKiBuNDQgKSAqIGRldEludjtcclxuXHRcdHRlWyAzIF0gPSAoIG4yMyAqIG4zMiAqIG40MSAtIG4yMiAqIG4zMyAqIG40MSAtIG4yMyAqIG4zMSAqIG40MiArIG4yMSAqIG4zMyAqIG40MiArIG4yMiAqIG4zMSAqIG40MyAtIG4yMSAqIG4zMiAqIG40MyApICogZGV0SW52O1xyXG5cclxuXHRcdHRlWyA0IF0gPSB0MTIgKiBkZXRJbnY7XHJcblx0XHR0ZVsgNSBdID0gKCBuMTMgKiBuMzQgKiBuNDEgLSBuMTQgKiBuMzMgKiBuNDEgKyBuMTQgKiBuMzEgKiBuNDMgLSBuMTEgKiBuMzQgKiBuNDMgLSBuMTMgKiBuMzEgKiBuNDQgKyBuMTEgKiBuMzMgKiBuNDQgKSAqIGRldEludjtcclxuXHRcdHRlWyA2IF0gPSAoIG4xNCAqIG4zMiAqIG40MSAtIG4xMiAqIG4zNCAqIG40MSAtIG4xNCAqIG4zMSAqIG40MiArIG4xMSAqIG4zNCAqIG40MiArIG4xMiAqIG4zMSAqIG40NCAtIG4xMSAqIG4zMiAqIG40NCApICogZGV0SW52O1xyXG5cdFx0dGVbIDcgXSA9ICggbjEyICogbjMzICogbjQxIC0gbjEzICogbjMyICogbjQxICsgbjEzICogbjMxICogbjQyIC0gbjExICogbjMzICogbjQyIC0gbjEyICogbjMxICogbjQzICsgbjExICogbjMyICogbjQzICkgKiBkZXRJbnY7XHJcblxyXG5cdFx0dGVbIDggXSA9IHQxMyAqIGRldEludjtcclxuXHRcdHRlWyA5IF0gPSAoIG4xNCAqIG4yMyAqIG40MSAtIG4xMyAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMSAqIG40MyArIG4xMSAqIG4yNCAqIG40MyArIG4xMyAqIG4yMSAqIG40NCAtIG4xMSAqIG4yMyAqIG40NCApICogZGV0SW52O1xyXG5cdFx0dGVbIDEwIF0gPSAoIG4xMiAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMiAqIG40MSArIG4xNCAqIG4yMSAqIG40MiAtIG4xMSAqIG4yNCAqIG40MiAtIG4xMiAqIG4yMSAqIG40NCArIG4xMSAqIG4yMiAqIG40NCApICogZGV0SW52O1xyXG5cdFx0dGVbIDExIF0gPSAoIG4xMyAqIG4yMiAqIG40MSAtIG4xMiAqIG4yMyAqIG40MSAtIG4xMyAqIG4yMSAqIG40MiArIG4xMSAqIG4yMyAqIG40MiArIG4xMiAqIG4yMSAqIG40MyAtIG4xMSAqIG4yMiAqIG40MyApICogZGV0SW52O1xyXG5cclxuXHRcdHRlWyAxMiBdID0gdDE0ICogZGV0SW52O1xyXG5cdFx0dGVbIDEzIF0gPSAoIG4xMyAqIG4yNCAqIG4zMSAtIG4xNCAqIG4yMyAqIG4zMSArIG4xNCAqIG4yMSAqIG4zMyAtIG4xMSAqIG4yNCAqIG4zMyAtIG4xMyAqIG4yMSAqIG4zNCArIG4xMSAqIG4yMyAqIG4zNCApICogZGV0SW52O1xyXG5cdFx0dGVbIDE0IF0gPSAoIG4xNCAqIG4yMiAqIG4zMSAtIG4xMiAqIG4yNCAqIG4zMSAtIG4xNCAqIG4yMSAqIG4zMiArIG4xMSAqIG4yNCAqIG4zMiArIG4xMiAqIG4yMSAqIG4zNCAtIG4xMSAqIG4yMiAqIG4zNCApICogZGV0SW52O1xyXG5cdFx0dGVbIDE1IF0gPSAoIG4xMiAqIG4yMyAqIG4zMSAtIG4xMyAqIG4yMiAqIG4zMSArIG4xMyAqIG4yMSAqIG4zMiAtIG4xMSAqIG4yMyAqIG4zMiAtIG4xMiAqIG4yMSAqIG4zMyArIG4xMSAqIG4yMiAqIG4zMyApICogZGV0SW52O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzY2FsZTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHR2YXIgeCA9IHYueCwgeSA9IHYueSwgeiA9IHYuejtcclxuXHJcblx0XHR0ZVsgMCBdICo9IHg7IHRlWyA0IF0gKj0geTsgdGVbIDggXSAqPSB6O1xyXG5cdFx0dGVbIDEgXSAqPSB4OyB0ZVsgNSBdICo9IHk7IHRlWyA5IF0gKj0gejtcclxuXHRcdHRlWyAyIF0gKj0geDsgdGVbIDYgXSAqPSB5OyB0ZVsgMTAgXSAqPSB6O1xyXG5cdFx0dGVbIDMgXSAqPSB4OyB0ZVsgNyBdICo9IHk7IHRlWyAxMSBdICo9IHo7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG4gICAgc2V0VHJhbnNsYXRlIDpmdW5jdGlvbih4LCB5LCB6KSB7XHJcbiAgICAgICAgdmFyIGUgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgICAgIGVbMF0gPSAxOyAgZVs0XSA9IDA7ICBlWzhdICA9IDA7ICBlWzEyXSA9IHg7XHJcbiAgICAgICAgZVsxXSA9IDA7ICBlWzVdID0gMTsgIGVbOV0gID0gMDsgIGVbMTNdID0geTtcclxuICAgICAgICBlWzJdID0gMDsgIGVbNl0gPSAwOyAgZVsxMF0gPSAxOyAgZVsxNF0gPSB6O1xyXG4gICAgICAgIGVbM10gPSAwOyAgZVs3XSA9IDA7ICBlWzExXSA9IDA7ICBlWzE1XSA9IDE7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHRyYW5zbGF0ZSA6ZnVuY3Rpb24oeCwgeSwgeikge1xyXG4gICAgICAgIHZhciBlID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICBlWzEyXSArPSBlWzBdICogeCArIGVbNF0gKiB5ICsgZVs4XSAgKiB6O1xyXG4gICAgICAgIGVbMTNdICs9IGVbMV0gKiB4ICsgZVs1XSAqIHkgKyBlWzldICAqIHo7XHJcbiAgICAgICAgZVsxNF0gKz0gZVsyXSAqIHggKyBlWzZdICogeSArIGVbMTBdICogejtcclxuICAgICAgICBlWzE1XSArPSBlWzNdICogeCArIGVbN10gKiB5ICsgZVsxMV0gKiB6O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRSb3RhdGUgOmZ1bmN0aW9uKGFuZ2xlLCB4LCB5LCB6KSB7XHJcbiAgICAgICAgdmFyIGUsIHMsIGMsIGxlbiwgcmxlbiwgbmMsIHh5LCB5eiwgengsIHhzLCB5cywgenM7XHJcblxyXG4gICAgICAgIGFuZ2xlID0gTWF0aC5QSSAqIGFuZ2xlIC8gMTgwO1xyXG4gICAgICAgIGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuICAgICAgICBzID0gTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgICAgIGMgPSBNYXRoLmNvcyhhbmdsZSk7XHJcblxyXG4gICAgICAgIGlmICgwICE9PSB4ICYmIDAgPT09IHkgJiYgMCA9PT0geikge1xyXG4gICAgICAgICAgICAvLyBSb3RhdGlvbiBhcm91bmQgWCBheGlzXHJcbiAgICAgICAgICAgIGlmICh4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgcyA9IC1zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVbMF0gPSAxOyAgZVs0XSA9IDA7ICBlWyA4XSA9IDA7ICBlWzEyXSA9IDA7XHJcbiAgICAgICAgICAgIGVbMV0gPSAwOyAgZVs1XSA9IGM7ICBlWyA5XSA9LXM7ICBlWzEzXSA9IDA7XHJcbiAgICAgICAgICAgIGVbMl0gPSAwOyAgZVs2XSA9IHM7ICBlWzEwXSA9IGM7ICBlWzE0XSA9IDA7XHJcbiAgICAgICAgICAgIGVbM10gPSAwOyAgZVs3XSA9IDA7ICBlWzExXSA9IDA7ICBlWzE1XSA9IDE7XHJcbiAgICAgICAgfSBlbHNlIGlmICgwID09PSB4ICYmIDAgIT09IHkgJiYgMCA9PT0geikge1xyXG4gICAgICAgICAgICAvLyBSb3RhdGlvbiBhcm91bmQgWSBheGlzXHJcbiAgICAgICAgICAgIGlmICh5IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgcyA9IC1zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVbMF0gPSBjOyAgZVs0XSA9IDA7ICBlWyA4XSA9IHM7ICBlWzEyXSA9IDA7XHJcbiAgICAgICAgICAgIGVbMV0gPSAwOyAgZVs1XSA9IDE7ICBlWyA5XSA9IDA7ICBlWzEzXSA9IDA7XHJcbiAgICAgICAgICAgIGVbMl0gPS1zOyAgZVs2XSA9IDA7ICBlWzEwXSA9IGM7ICBlWzE0XSA9IDA7XHJcbiAgICAgICAgICAgIGVbM10gPSAwOyAgZVs3XSA9IDA7ICBlWzExXSA9IDA7ICBlWzE1XSA9IDE7XHJcbiAgICAgICAgfSBlbHNlIGlmICgwID09PSB4ICYmIDAgPT09IHkgJiYgMCAhPT0geikge1xyXG4gICAgICAgICAgICAvLyBSb3RhdGlvbiBhcm91bmQgWiBheGlzXHJcbiAgICAgICAgICAgIGlmICh6IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgcyA9IC1zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVbMF0gPSBjOyAgZVs0XSA9LXM7ICBlWyA4XSA9IDA7ICBlWzEyXSA9IDA7XHJcbiAgICAgICAgICAgIGVbMV0gPSBzOyAgZVs1XSA9IGM7ICBlWyA5XSA9IDA7ICBlWzEzXSA9IDA7XHJcbiAgICAgICAgICAgIGVbMl0gPSAwOyAgZVs2XSA9IDA7ICBlWzEwXSA9IDE7ICBlWzE0XSA9IDA7XHJcbiAgICAgICAgICAgIGVbM10gPSAwOyAgZVs3XSA9IDA7ICBlWzExXSA9IDA7ICBlWzE1XSA9IDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gUm90YXRpb24gYXJvdW5kIGFub3RoZXIgYXhpc1xyXG4gICAgICAgICAgICBsZW4gPSBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KTtcclxuICAgICAgICAgICAgaWYgKGxlbiAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmxlbiA9IDEgLyBsZW47XHJcbiAgICAgICAgICAgICAgICB4ICo9IHJsZW47XHJcbiAgICAgICAgICAgICAgICB5ICo9IHJsZW47XHJcbiAgICAgICAgICAgICAgICB6ICo9IHJsZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbmMgPSAxIC0gYztcclxuICAgICAgICAgICAgeHkgPSB4ICogeTtcclxuICAgICAgICAgICAgeXogPSB5ICogejtcclxuICAgICAgICAgICAgenggPSB6ICogeDtcclxuICAgICAgICAgICAgeHMgPSB4ICogcztcclxuICAgICAgICAgICAgeXMgPSB5ICogcztcclxuICAgICAgICAgICAgenMgPSB6ICogcztcclxuXHJcbiAgICAgICAgICAgIGVbIDBdID0geCp4Km5jICsgIGM7XHJcbiAgICAgICAgICAgIGVbIDFdID0geHkgKm5jICsgenM7XHJcbiAgICAgICAgICAgIGVbIDJdID0genggKm5jIC0geXM7XHJcbiAgICAgICAgICAgIGVbIDNdID0gMDtcclxuXHJcbiAgICAgICAgICAgIGVbIDRdID0geHkgKm5jIC0genM7XHJcbiAgICAgICAgICAgIGVbIDVdID0geSp5Km5jICsgIGM7XHJcbiAgICAgICAgICAgIGVbIDZdID0geXogKm5jICsgeHM7XHJcbiAgICAgICAgICAgIGVbIDddID0gMDtcclxuXHJcbiAgICAgICAgICAgIGVbIDhdID0genggKm5jICsgeXM7XHJcbiAgICAgICAgICAgIGVbIDldID0geXogKm5jIC0geHM7XHJcbiAgICAgICAgICAgIGVbMTBdID0geip6Km5jICsgIGM7XHJcbiAgICAgICAgICAgIGVbMTFdID0gMDtcclxuXHJcbiAgICAgICAgICAgIGVbMTJdID0gMDtcclxuICAgICAgICAgICAgZVsxM10gPSAwO1xyXG4gICAgICAgICAgICBlWzE0XSA9IDA7XHJcbiAgICAgICAgICAgIGVbMTVdID0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICByb3RhdGUgOmZ1bmN0aW9uKGFuZ2xlLCB4LCB5LCB6KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uY2F0KG5ldyBNYXRyaXg0KCkuc2V0Um90YXRlKGFuZ2xlLCB4LCB5LCB6KSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldExvb2tBdCA6ZnVuY3Rpb24oZXllWCwgZXllWSwgZXllWiwgY2VudGVyWCwgY2VudGVyWSwgY2VudGVyWiwgdXBYLCB1cFksIHVwWikge1xyXG4gICAgICAgIHZhciBlLCBmeCwgZnksIGZ6LCBybGYsIHN4LCBzeSwgc3osIHJscywgdXgsIHV5LCB1ejtcclxuXHJcbiAgICAgICAgZnggPSBjZW50ZXJYIC0gZXllWDtcclxuICAgICAgICBmeSA9IGNlbnRlclkgLSBleWVZO1xyXG4gICAgICAgIGZ6ID0gY2VudGVyWiAtIGV5ZVo7XHJcblxyXG4gICAgICAgIC8vIE5vcm1hbGl6ZSBmLlxyXG4gICAgICAgIHJsZiA9IDEgLyBNYXRoLnNxcnQoZngqZnggKyBmeSpmeSArIGZ6KmZ6KTtcclxuICAgICAgICBmeCAqPSBybGY7XHJcbiAgICAgICAgZnkgKj0gcmxmO1xyXG4gICAgICAgIGZ6ICo9IHJsZjtcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGNyb3NzIHByb2R1Y3Qgb2YgZiBhbmQgdXAuXHJcbiAgICAgICAgc3ggPSBmeSAqIHVwWiAtIGZ6ICogdXBZO1xyXG4gICAgICAgIHN5ID0gZnogKiB1cFggLSBmeCAqIHVwWjtcclxuICAgICAgICBzeiA9IGZ4ICogdXBZIC0gZnkgKiB1cFg7XHJcblxyXG4gICAgICAgIC8vIE5vcm1hbGl6ZSBzLlxyXG4gICAgICAgIHJscyA9IDEgLyBNYXRoLnNxcnQoc3gqc3ggKyBzeSpzeSArIHN6KnN6KTtcclxuICAgICAgICBzeCAqPSBybHM7XHJcbiAgICAgICAgc3kgKj0gcmxzO1xyXG4gICAgICAgIHN6ICo9IHJscztcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGNyb3NzIHByb2R1Y3Qgb2YgcyBhbmQgZi5cclxuICAgICAgICB1eCA9IHN5ICogZnogLSBzeiAqIGZ5O1xyXG4gICAgICAgIHV5ID0gc3ogKiBmeCAtIHN4ICogZno7XHJcbiAgICAgICAgdXogPSBzeCAqIGZ5IC0gc3kgKiBmeDtcclxuXHJcbiAgICAgICAgLy8gU2V0IHRvIHRoaXMuXHJcbiAgICAgICAgZSA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICAgICAgZVswXSA9IHN4O1xyXG4gICAgICAgIGVbMV0gPSB1eDtcclxuICAgICAgICBlWzJdID0gLWZ4O1xyXG4gICAgICAgIGVbM10gPSAwO1xyXG5cclxuICAgICAgICBlWzRdID0gc3k7XHJcbiAgICAgICAgZVs1XSA9IHV5O1xyXG4gICAgICAgIGVbNl0gPSAtZnk7XHJcbiAgICAgICAgZVs3XSA9IDA7XHJcblxyXG4gICAgICAgIGVbOF0gPSBzejtcclxuICAgICAgICBlWzldID0gdXo7XHJcbiAgICAgICAgZVsxMF0gPSAtZno7XHJcbiAgICAgICAgZVsxMV0gPSAwO1xyXG5cclxuICAgICAgICBlWzEyXSA9IDA7XHJcbiAgICAgICAgZVsxM10gPSAwO1xyXG4gICAgICAgIGVbMTRdID0gMDtcclxuICAgICAgICBlWzE1XSA9IDE7XHJcblxyXG4gICAgICAgIC8vIFRyYW5zbGF0ZS5cclxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGUoLWV5ZVgsIC1leWVZLCAtZXllWik7XHJcbiAgICB9LFxyXG5cclxuICAgIGxvb2tBdDIgOmZ1bmN0aW9uKGV5ZVgsIGV5ZVksIGV5ZVosIGNlbnRlclgsIGNlbnRlclksIGNlbnRlclosIHVwWCwgdXBZLCB1cFopIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb25jYXQobmV3IE1hdHJpeDQoKS5zZXRMb29rQXQoZXllWCwgZXllWSwgZXllWiwgY2VudGVyWCwgY2VudGVyWSwgY2VudGVyWiwgdXBYLCB1cFksIHVwWikpO1xyXG4gICAgfSxcclxuXHJcblx0Z2V0TWF4U2NhbGVPbkF4aXM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHZhciBzY2FsZVhTcSA9IHRlWyAwIF0gKiB0ZVsgMCBdICsgdGVbIDEgXSAqIHRlWyAxIF0gKyB0ZVsgMiBdICogdGVbIDIgXTtcclxuXHRcdHZhciBzY2FsZVlTcSA9IHRlWyA0IF0gKiB0ZVsgNCBdICsgdGVbIDUgXSAqIHRlWyA1IF0gKyB0ZVsgNiBdICogdGVbIDYgXTtcclxuXHRcdHZhciBzY2FsZVpTcSA9IHRlWyA4IF0gKiB0ZVsgOCBdICsgdGVbIDkgXSAqIHRlWyA5IF0gKyB0ZVsgMTAgXSAqIHRlWyAxMCBdO1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIE1hdGgubWF4KCBzY2FsZVhTcSwgc2NhbGVZU3EsIHNjYWxlWlNxICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bWFrZVRyYW5zbGF0aW9uOiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHQxLCAwLCAwLCB4LFxyXG5cdFx0XHQwLCAxLCAwLCB5LFxyXG5cdFx0XHQwLCAwLCAxLCB6LFxyXG5cdFx0XHQwLCAwLCAwLCAxXHJcblxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWFrZVJvdGF0aW9uWDogZnVuY3Rpb24gKCB0aGV0YSApIHtcclxuXHJcblx0XHR2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XHJcblxyXG5cdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHQxLCAwLCAwLCAwLFxyXG5cdFx0XHQwLCBjLCAtIHMsIDAsXHJcblx0XHRcdDAsIHMsIGMsIDAsXHJcblx0XHRcdDAsIDAsIDAsIDFcclxuXHJcblx0XHQpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlUm90YXRpb25ZOiBmdW5jdGlvbiAoIHRoZXRhICkge1xyXG5cclxuXHRcdHZhciBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHJcblx0XHRcdCBjLCAwLCBzLCAwLFxyXG5cdFx0XHQgMCwgMSwgMCwgMCxcclxuXHRcdFx0LSBzLCAwLCBjLCAwLFxyXG5cdFx0XHQgMCwgMCwgMCwgMVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1ha2VSb3RhdGlvblo6IGZ1bmN0aW9uICggdGhldGEgKSB7XHJcblxyXG5cdFx0dmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0YywgLSBzLCAwLCAwLFxyXG5cdFx0XHRzLCBjLCAwLCAwLFxyXG5cdFx0XHQwLCAwLCAxLCAwLFxyXG5cdFx0XHQwLCAwLCAwLCAxXHJcblxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWFrZVJvdGF0aW9uQXhpczogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcclxuXHJcblx0XHQvLyBCYXNlZCBvbiBodHRwOi8vd3d3LmdhbWVkZXYubmV0L3JlZmVyZW5jZS9hcnRpY2xlcy9hcnRpY2xlMTE5OS5hc3BcclxuXHJcblx0XHR2YXIgYyA9IE1hdGguY29zKCBhbmdsZSApO1xyXG5cdFx0dmFyIHMgPSBNYXRoLnNpbiggYW5nbGUgKTtcclxuXHRcdHZhciB0ID0gMSAtIGM7XHJcblx0XHR2YXIgeCA9IGF4aXMueCwgeSA9IGF4aXMueSwgeiA9IGF4aXMuejtcclxuXHRcdHZhciB0eCA9IHQgKiB4LCB0eSA9IHQgKiB5O1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0dHggKiB4ICsgYywgdHggKiB5IC0gcyAqIHosIHR4ICogeiArIHMgKiB5LCAwLFxyXG5cdFx0XHR0eCAqIHkgKyBzICogeiwgdHkgKiB5ICsgYywgdHkgKiB6IC0gcyAqIHgsIDAsXHJcblx0XHRcdHR4ICogeiAtIHMgKiB5LCB0eSAqIHogKyBzICogeCwgdCAqIHogKiB6ICsgYywgMCxcclxuXHRcdFx0MCwgMCwgMCwgMVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0IHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlU2NhbGU6IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHJcblx0XHRcdHgsIDAsIDAsIDAsXHJcblx0XHRcdDAsIHksIDAsIDAsXHJcblx0XHRcdDAsIDAsIHosIDAsXHJcblx0XHRcdDAsIDAsIDAsIDFcclxuXHJcblx0XHQpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlU2hlYXI6IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHJcblx0XHRcdDEsIHksIHosIDAsXHJcblx0XHRcdHgsIDEsIHosIDAsXHJcblx0XHRcdHgsIHksIDEsIDAsXHJcblx0XHRcdDAsIDAsIDAsIDFcclxuXHJcblx0XHQpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wb3NlOiBmdW5jdGlvbiAoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHZhciB4ID0gcXVhdGVybmlvbi5feCwgeSA9IHF1YXRlcm5pb24uX3ksIHogPSBxdWF0ZXJuaW9uLl96LCB3ID0gcXVhdGVybmlvbi5fdztcclxuXHRcdHZhciB4MiA9IHggKyB4LFx0eTIgPSB5ICsgeSwgejIgPSB6ICsgejtcclxuXHRcdHZhciB4eCA9IHggKiB4MiwgeHkgPSB4ICogeTIsIHh6ID0geCAqIHoyO1xyXG5cdFx0dmFyIHl5ID0geSAqIHkyLCB5eiA9IHkgKiB6MiwgenogPSB6ICogejI7XHJcblx0XHR2YXIgd3ggPSB3ICogeDIsIHd5ID0gdyAqIHkyLCB3eiA9IHcgKiB6MjtcclxuXHJcblx0XHR2YXIgc3ggPSBzY2FsZS54LCBzeSA9IHNjYWxlLnksIHN6ID0gc2NhbGUuejtcclxuXHJcblx0ICAgICAgICB0ZVsgMCBdID0gKCAxIC0gKCB5eSArIHp6ICkgKSAqIHN4O1xyXG5cdCAgICAgICAgdGVbIDEgXSA9ICggeHkgKyB3eiApICogc3g7XHJcblx0ICAgICAgICB0ZVsgMiBdID0gKCB4eiAtIHd5ICkgKiBzeDtcclxuXHQgICAgICAgIHRlWyAzIF0gPSAwO1xyXG5cclxuXHQgICAgICAgIHRlWyA0IF0gPSAoIHh5IC0gd3ogKSAqIHN5O1xyXG5cdCAgICAgICAgdGVbIDUgXSA9ICggMSAtICggeHggKyB6eiApICkgKiBzeTtcclxuXHQgICAgICAgIHRlWyA2IF0gPSAoIHl6ICsgd3ggKSAqIHN5O1xyXG5cdCAgICAgICAgdGVbIDcgXSA9IDA7XHJcblxyXG5cdCAgICAgICAgdGVbIDggXSA9ICggeHogKyB3eSApICogc3o7XHJcblx0ICAgICAgICB0ZVsgOSBdID0gKCB5eiAtIHd4ICkgKiBzejtcclxuXHQgICAgICAgIHRlWyAxMCBdID0gKCAxIC0gKCB4eCArIHl5ICkgKSAqIHN6O1xyXG5cdCAgICAgICAgdGVbIDExIF0gPSAwO1xyXG5cclxuXHQgICAgICAgIHRlWyAxMiBdID0gcG9zaXRpb24ueDtcclxuXHQgICAgICAgIHRlWyAxMyBdID0gcG9zaXRpb24ueTtcclxuXHQgICAgICAgIHRlWyAxNCBdID0gcG9zaXRpb24uejtcclxuXHQgICAgICAgIHRlWyAxNSBdID0gMTtcclxuXHJcblx0ICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZGVjb21wb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHR2YXIgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKSB7XHJcblxyXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdFx0dmFyIHN4ID0gdmVjdG9yLnNldCggdGVbIDAgXSwgdGVbIDEgXSwgdGVbIDIgXSApLmxlbmd0aCgpO1xyXG5cdFx0XHR2YXIgc3kgPSB2ZWN0b3Iuc2V0KCB0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdICkubGVuZ3RoKCk7XHJcblx0XHRcdHZhciBzeiA9IHZlY3Rvci5zZXQoIHRlWyA4IF0sIHRlWyA5IF0sIHRlWyAxMCBdICkubGVuZ3RoKCk7XHJcblxyXG5cdFx0XHQvLyBpZiBkZXRlcm1pbmUgaXMgbmVnYXRpdmUsIHdlIG5lZWQgdG8gaW52ZXJ0IG9uZSBzY2FsZVxyXG5cdFx0XHR2YXIgZGV0ID0gdGhpcy5kZXRlcm1pbmFudCgpO1xyXG5cdFx0XHRpZiAoIGRldCA8IDAgKSBzeCA9IC0gc3g7XHJcblxyXG5cdFx0XHRwb3NpdGlvbi54ID0gdGVbIDEyIF07XHJcblx0XHRcdHBvc2l0aW9uLnkgPSB0ZVsgMTMgXTtcclxuXHRcdFx0cG9zaXRpb24ueiA9IHRlWyAxNCBdO1xyXG5cclxuXHRcdFx0Ly8gc2NhbGUgdGhlIHJvdGF0aW9uIHBhcnRcclxuXHRcdFx0bWF0cml4LmNvcHkoIHRoaXMgKTtcclxuXHJcblx0XHRcdHZhciBpbnZTWCA9IDEgLyBzeDtcclxuXHRcdFx0dmFyIGludlNZID0gMSAvIHN5O1xyXG5cdFx0XHR2YXIgaW52U1ogPSAxIC8gc3o7XHJcblxyXG5cdFx0XHRtYXRyaXguZWxlbWVudHNbIDAgXSAqPSBpbnZTWDtcclxuXHRcdFx0bWF0cml4LmVsZW1lbnRzWyAxIF0gKj0gaW52U1g7XHJcblx0XHRcdG1hdHJpeC5lbGVtZW50c1sgMiBdICo9IGludlNYO1xyXG5cclxuXHRcdFx0bWF0cml4LmVsZW1lbnRzWyA0IF0gKj0gaW52U1k7XHJcblx0XHRcdG1hdHJpeC5lbGVtZW50c1sgNSBdICo9IGludlNZO1xyXG5cdFx0XHRtYXRyaXguZWxlbWVudHNbIDYgXSAqPSBpbnZTWTtcclxuXHJcblx0XHRcdG1hdHJpeC5lbGVtZW50c1sgOCBdICo9IGludlNaO1xyXG5cdFx0XHRtYXRyaXguZWxlbWVudHNbIDkgXSAqPSBpbnZTWjtcclxuXHRcdFx0bWF0cml4LmVsZW1lbnRzWyAxMCBdICo9IGludlNaO1xyXG5cclxuXHRcdFx0cXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG1hdHJpeCApO1xyXG5cclxuXHRcdFx0c2NhbGUueCA9IHN4O1xyXG5cdFx0XHRzY2FsZS55ID0gc3k7XHJcblx0XHRcdHNjYWxlLnogPSBzejtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0bWFrZVBlcnNwZWN0aXZlOiBmdW5jdGlvbiAoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICkge1xyXG5cclxuXHRcdGlmICggZmFyID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdDT09MLk1hdHJpeDQ6IC5tYWtlUGVyc3BlY3RpdmUoKSBoYXMgYmVlbiByZWRlZmluZWQgYW5kIGhhcyBhIG5ldyBzaWduYXR1cmUuIFBsZWFzZSBjaGVjayB0aGUgZG9jcy4nICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHR2YXIgeCA9IDIgKiBuZWFyIC8gKCByaWdodCAtIGxlZnQgKTtcclxuXHRcdHZhciB5ID0gMiAqIG5lYXIgLyAoIHRvcCAtIGJvdHRvbSApO1xyXG5cclxuXHRcdHZhciBhID0gKCByaWdodCArIGxlZnQgKSAvICggcmlnaHQgLSBsZWZ0ICk7XHJcblx0XHR2YXIgYiA9ICggdG9wICsgYm90dG9tICkgLyAoIHRvcCAtIGJvdHRvbSApO1xyXG5cdFx0dmFyIGMgPSAtICggZmFyICsgbmVhciApIC8gKCBmYXIgLSBuZWFyICk7XHJcblx0XHR2YXIgZCA9IC0gMiAqIGZhciAqIG5lYXIgLyAoIGZhciAtIG5lYXIgKTtcclxuXHJcblx0XHR0ZVsgMCBdID0geDtcdHRlWyA0IF0gPSAwO1x0dGVbIDggXSA9IGE7XHR0ZVsgMTIgXSA9IDA7XHJcblx0XHR0ZVsgMSBdID0gMDtcdHRlWyA1IF0gPSB5O1x0dGVbIDkgXSA9IGI7XHR0ZVsgMTMgXSA9IDA7XHJcblx0XHR0ZVsgMiBdID0gMDtcdHRlWyA2IF0gPSAwO1x0dGVbIDEwIF0gPSBjO1x0dGVbIDE0IF0gPSBkO1xyXG5cdFx0dGVbIDMgXSA9IDA7XHR0ZVsgNyBdID0gMDtcdHRlWyAxMSBdID0gLSAxO1x0dGVbIDE1IF0gPSAwO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlT3J0aG9ncmFwaGljOiBmdW5jdGlvbiAoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHR2YXIgdyA9IDEuMCAvICggcmlnaHQgLSBsZWZ0ICk7XHJcblx0XHR2YXIgaCA9IDEuMCAvICggdG9wIC0gYm90dG9tICk7XHJcblx0XHR2YXIgcCA9IDEuMCAvICggZmFyIC0gbmVhciApO1xyXG5cclxuXHRcdHZhciB4ID0gKCByaWdodCArIGxlZnQgKSAqIHc7XHJcblx0XHR2YXIgeSA9ICggdG9wICsgYm90dG9tICkgKiBoO1xyXG5cdFx0dmFyIHogPSAoIGZhciArIG5lYXIgKSAqIHA7XHJcblxyXG5cdFx0dGVbIDAgXSA9IDIgKiB3O1x0dGVbIDQgXSA9IDA7XHR0ZVsgOCBdID0gMDtcdHRlWyAxMiBdID0gLSB4O1xyXG5cdFx0dGVbIDEgXSA9IDA7XHR0ZVsgNSBdID0gMiAqIGg7XHR0ZVsgOSBdID0gMDtcdHRlWyAxMyBdID0gLSB5O1xyXG5cdFx0dGVbIDIgXSA9IDA7XHR0ZVsgNiBdID0gMDtcdHRlWyAxMCBdID0gLSAyICogcDtcdHRlWyAxNCBdID0gLSB6O1xyXG5cdFx0dGVbIDMgXSA9IDA7XHR0ZVsgNyBdID0gMDtcdHRlWyAxMSBdID0gMDtcdHRlWyAxNSBdID0gMTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0dmFyIG1lID0gbWF0cml4LmVsZW1lbnRzO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDE2OyBpICsrICkge1xyXG5cclxuXHRcdFx0aWYgKCB0ZVsgaSBdICE9PSBtZVsgaSBdICkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgMTY7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmVsZW1lbnRzWyBpIF0gPSBhcnJheVsgaSArIG9mZnNldCBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XHJcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRlWyAwIF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGVbIDEgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0ZVsgMiBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRlWyAzIF07XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgNSBdID0gdGVbIDUgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyA2IF0gPSB0ZVsgNiBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDcgXSA9IHRlWyA3IF07XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCArIDggXSA9IHRlWyA4IF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgOSBdID0gdGVbIDkgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxMCBdID0gdGVbIDEwIF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTEgXSA9IHRlWyAxMSBdO1xyXG5cclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxMiBdID0gdGVbIDEyIF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTMgXSA9IHRlWyAxMyBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDE0IF0gPSB0ZVsgMTQgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxNSBdID0gdGVbIDE1IF07XHJcblxyXG5cdFx0cmV0dXJuIGFycmF5O1xyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcblxyXG5cclxuZXhwb3J0IHsgTWF0cml4NCB9O1xyXG4iLCIvKipcclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICovXHJcblxyXG5pbXBvcnQgIHtfTWF0aH0gZnJvbSAnLi8vTWF0aC5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuL1ZlY3RvcjMuanMnO1xyXG5cclxuZnVuY3Rpb24gUXVhdGVybmlvbiggeCwgeSwgeiwgdyApIHtcclxuXHJcblx0dGhpcy5feCA9IHggfHwgMDtcclxuXHR0aGlzLl95ID0geSB8fCAwO1xyXG5cdHRoaXMuX3ogPSB6IHx8IDA7XHJcblx0dGhpcy5fdyA9ICggdyAhPT0gdW5kZWZpbmVkICkgPyB3IDogMTtcclxuXHJcbn1cclxuXHJcbk9iamVjdC5hc3NpZ24oIFF1YXRlcm5pb24sIHtcclxuXHJcblx0c2xlcnA6IGZ1bmN0aW9uICggcWEsIHFiLCBxbSwgdCApIHtcclxuXHJcblx0XHRyZXR1cm4gcW0uY29weSggcWEgKS5zbGVycCggcWIsIHQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2xlcnBGbGF0OiBmdW5jdGlvbiAoIGRzdCwgZHN0T2Zmc2V0LCBzcmMwLCBzcmNPZmZzZXQwLCBzcmMxLCBzcmNPZmZzZXQxLCB0ICkge1xyXG5cclxuXHRcdC8vIGZ1enotZnJlZSwgYXJyYXktYmFzZWQgUXVhdGVybmlvbiBTTEVSUCBvcGVyYXRpb25cclxuXHJcblx0XHR2YXIgeDAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMCBdLFxyXG5cdFx0XHR5MCA9IHNyYzBbIHNyY09mZnNldDAgKyAxIF0sXHJcblx0XHRcdHowID0gc3JjMFsgc3JjT2Zmc2V0MCArIDIgXSxcclxuXHRcdFx0dzAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMyBdLFxyXG5cclxuXHRcdFx0eDEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMCBdLFxyXG5cdFx0XHR5MSA9IHNyYzFbIHNyY09mZnNldDEgKyAxIF0sXHJcblx0XHRcdHoxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDIgXSxcclxuXHRcdFx0dzEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMyBdO1xyXG5cclxuXHRcdGlmICggdzAgIT09IHcxIHx8IHgwICE9PSB4MSB8fCB5MCAhPT0geTEgfHwgejAgIT09IHoxICkge1xyXG5cclxuXHRcdFx0dmFyIHMgPSAxIC0gdCxcclxuXHJcblx0XHRcdFx0Y29zID0geDAgKiB4MSArIHkwICogeTEgKyB6MCAqIHoxICsgdzAgKiB3MSxcclxuXHJcblx0XHRcdFx0ZGlyID0gKCBjb3MgPj0gMCA/IDEgOiAtIDEgKSxcclxuXHRcdFx0XHRzcXJTaW4gPSAxIC0gY29zICogY29zO1xyXG5cclxuXHRcdFx0Ly8gU2tpcCB0aGUgU2xlcnAgZm9yIHRpbnkgc3RlcHMgdG8gYXZvaWQgbnVtZXJpYyBwcm9ibGVtczpcclxuXHRcdFx0aWYgKCBzcXJTaW4gPiBOdW1iZXIuRVBTSUxPTiApIHtcclxuXHJcblx0XHRcdFx0dmFyIHNpbiA9IE1hdGguc3FydCggc3FyU2luICksXHJcblx0XHRcdFx0XHRsZW4gPSBNYXRoLmF0YW4yKCBzaW4sIGNvcyAqIGRpciApO1xyXG5cclxuXHRcdFx0XHRzID0gTWF0aC5zaW4oIHMgKiBsZW4gKSAvIHNpbjtcclxuXHRcdFx0XHR0ID0gTWF0aC5zaW4oIHQgKiBsZW4gKSAvIHNpbjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciB0RGlyID0gdCAqIGRpcjtcclxuXHJcblx0XHRcdHgwID0geDAgKiBzICsgeDEgKiB0RGlyO1xyXG5cdFx0XHR5MCA9IHkwICogcyArIHkxICogdERpcjtcclxuXHRcdFx0ejAgPSB6MCAqIHMgKyB6MSAqIHREaXI7XHJcblx0XHRcdHcwID0gdzAgKiBzICsgdzEgKiB0RGlyO1xyXG5cclxuXHRcdFx0Ly8gTm9ybWFsaXplIGluIGNhc2Ugd2UganVzdCBkaWQgYSBsZXJwOlxyXG5cdFx0XHRpZiAoIHMgPT09IDEgLSB0ICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZiA9IDEgLyBNYXRoLnNxcnQoIHgwICogeDAgKyB5MCAqIHkwICsgejAgKiB6MCArIHcwICogdzAgKTtcclxuXHJcblx0XHRcdFx0eDAgKj0gZjtcclxuXHRcdFx0XHR5MCAqPSBmO1xyXG5cdFx0XHRcdHowICo9IGY7XHJcblx0XHRcdFx0dzAgKj0gZjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZHN0WyBkc3RPZmZzZXQgXSA9IHgwO1xyXG5cdFx0ZHN0WyBkc3RPZmZzZXQgKyAxIF0gPSB5MDtcclxuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMiBdID0gejA7XHJcblx0XHRkc3RbIGRzdE9mZnNldCArIDMgXSA9IHcwO1xyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggUXVhdGVybmlvbi5wcm90b3R5cGUsIHtcclxuXHJcblx0eDoge1xyXG5cclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuX3g7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl94ID0gdmFsdWU7XHJcblx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0eToge1xyXG5cclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuX3k7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl95ID0gdmFsdWU7XHJcblx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0ejoge1xyXG5cclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuX3o7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl96ID0gdmFsdWU7XHJcblx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0dzoge1xyXG5cclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuX3c7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl93ID0gdmFsdWU7XHJcblx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufSApO1xyXG5cclxuT2JqZWN0LmFzc2lnbiggUXVhdGVybmlvbi5wcm90b3R5cGUsIHtcclxuXHJcblx0aXNRdWF0ZXJuaW9uOiB0cnVlLFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcclxuXHJcblx0XHR0aGlzLl94ID0geDtcclxuXHRcdHRoaXMuX3kgPSB5O1xyXG5cdFx0dGhpcy5feiA9IHo7XHJcblx0XHR0aGlzLl93ID0gdztcclxuXHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX3cgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBxdWF0ZXJuaW9uICkge1xyXG5cclxuXHRcdHRoaXMuX3ggPSBxdWF0ZXJuaW9uLng7XHJcblx0XHR0aGlzLl95ID0gcXVhdGVybmlvbi55O1xyXG5cdFx0dGhpcy5feiA9IHF1YXRlcm5pb24uejtcclxuXHRcdHRoaXMuX3cgPSBxdWF0ZXJuaW9uLnc7XHJcblxyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21FdWxlcjogZnVuY3Rpb24gKCBldWxlciwgdXBkYXRlICkge1xyXG5cclxuXHRcdGlmICggISAoIGV1bGVyICYmIGV1bGVyLmlzRXVsZXIgKSApIHtcclxuXHJcblx0XHRcdHRocm93IG5ldyBFcnJvciggJ0NPT0wuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIG5vdyBleHBlY3RzIGFuIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgeCA9IGV1bGVyLl94LCB5ID0gZXVsZXIuX3ksIHogPSBldWxlci5feiwgb3JkZXIgPSBldWxlci5vcmRlcjtcclxuXHJcblx0XHQvLyBodHRwOi8vd3d3Lm1hdGh3b3Jrcy5jb20vbWF0bGFiY2VudHJhbC9maWxlZXhjaGFuZ2UvXHJcblx0XHQvLyBcdDIwNjk2LWZ1bmN0aW9uLXRvLWNvbnZlcnQtYmV0d2Vlbi1kY20tZXVsZXItYW5nbGVzLXF1YXRlcm5pb25zLWFuZC1ldWxlci12ZWN0b3JzL1xyXG5cdFx0Ly9cdGNvbnRlbnQvU3BpbkNhbGMubVxyXG5cclxuXHRcdHZhciBjb3MgPSBNYXRoLmNvcztcclxuXHRcdHZhciBzaW4gPSBNYXRoLnNpbjtcclxuXHJcblx0XHR2YXIgYzEgPSBjb3MoIHggLyAyICk7XHJcblx0XHR2YXIgYzIgPSBjb3MoIHkgLyAyICk7XHJcblx0XHR2YXIgYzMgPSBjb3MoIHogLyAyICk7XHJcblxyXG5cdFx0dmFyIHMxID0gc2luKCB4IC8gMiApO1xyXG5cdFx0dmFyIHMyID0gc2luKCB5IC8gMiApO1xyXG5cdFx0dmFyIHMzID0gc2luKCB6IC8gMiApO1xyXG5cclxuXHRcdGlmICggb3JkZXIgPT09ICdYWVonICkge1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcclxuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcclxuXHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcclxuXHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1lYWicgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xyXG5cdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xyXG5cdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xyXG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWlhZJyApIHtcclxuXHJcblx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XHJcblx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XHJcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XHJcblx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWVgnICkge1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcclxuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcclxuXHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcclxuXHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1laWCcgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xyXG5cdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xyXG5cdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xyXG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWFpZJyApIHtcclxuXHJcblx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XHJcblx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XHJcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XHJcblx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdXBkYXRlICE9PSBmYWxzZSApIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tQXhpc0FuZ2xlOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xyXG5cclxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9hbmdsZVRvUXVhdGVybmlvbi9pbmRleC5odG1cclxuXHJcblx0XHQvLyBhc3N1bWVzIGF4aXMgaXMgbm9ybWFsaXplZFxyXG5cclxuXHRcdHZhciBoYWxmQW5nbGUgPSBhbmdsZSAvIDIsIHMgPSBNYXRoLnNpbiggaGFsZkFuZ2xlICk7XHJcblxyXG5cdFx0dGhpcy5feCA9IGF4aXMueCAqIHM7XHJcblx0XHR0aGlzLl95ID0gYXhpcy55ICogcztcclxuXHRcdHRoaXMuX3ogPSBheGlzLnogKiBzO1xyXG5cdFx0dGhpcy5fdyA9IE1hdGguY29zKCBoYWxmQW5nbGUgKTtcclxuXHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvUXVhdGVybmlvbi9pbmRleC5odG1cclxuXHJcblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxyXG5cclxuXHRcdHZhciB0ZSA9IG0uZWxlbWVudHMsXHJcblxyXG5cdFx0XHRtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdLFxyXG5cdFx0XHRtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdLFxyXG5cdFx0XHRtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXSxcclxuXHJcblx0XHRcdHRyYWNlID0gbTExICsgbTIyICsgbTMzLFxyXG5cdFx0XHRzO1xyXG5cclxuXHRcdGlmICggdHJhY2UgPiAwICkge1xyXG5cclxuXHRcdFx0cyA9IDAuNSAvIE1hdGguc3FydCggdHJhY2UgKyAxLjAgKTtcclxuXHJcblx0XHRcdHRoaXMuX3cgPSAwLjI1IC8gcztcclxuXHRcdFx0dGhpcy5feCA9ICggbTMyIC0gbTIzICkgKiBzO1xyXG5cdFx0XHR0aGlzLl95ID0gKCBtMTMgLSBtMzEgKSAqIHM7XHJcblx0XHRcdHRoaXMuX3ogPSAoIG0yMSAtIG0xMiApICogcztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtMTEgPiBtMjIgJiYgbTExID4gbTMzICkge1xyXG5cclxuXHRcdFx0cyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTExIC0gbTIyIC0gbTMzICk7XHJcblxyXG5cdFx0XHR0aGlzLl93ID0gKCBtMzIgLSBtMjMgKSAvIHM7XHJcblx0XHRcdHRoaXMuX3ggPSAwLjI1ICogcztcclxuXHRcdFx0dGhpcy5feSA9ICggbTEyICsgbTIxICkgLyBzO1xyXG5cdFx0XHR0aGlzLl96ID0gKCBtMTMgKyBtMzEgKSAvIHM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbTIyID4gbTMzICkge1xyXG5cclxuXHRcdFx0cyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTIyIC0gbTExIC0gbTMzICk7XHJcblxyXG5cdFx0XHR0aGlzLl93ID0gKCBtMTMgLSBtMzEgKSAvIHM7XHJcblx0XHRcdHRoaXMuX3ggPSAoIG0xMiArIG0yMSApIC8gcztcclxuXHRcdFx0dGhpcy5feSA9IDAuMjUgKiBzO1xyXG5cdFx0XHR0aGlzLl96ID0gKCBtMjMgKyBtMzIgKSAvIHM7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0zMyAtIG0xMSAtIG0yMiApO1xyXG5cclxuXHRcdFx0dGhpcy5fdyA9ICggbTIxIC0gbTEyICkgLyBzO1xyXG5cdFx0XHR0aGlzLl94ID0gKCBtMTMgKyBtMzEgKSAvIHM7XHJcblx0XHRcdHRoaXMuX3kgPSAoIG0yMyArIG0zMiApIC8gcztcclxuXHRcdFx0dGhpcy5feiA9IDAuMjUgKiBzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbVVuaXRWZWN0b3JzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gYXNzdW1lcyBkaXJlY3Rpb24gdmVjdG9ycyB2RnJvbSBhbmQgdlRvIGFyZSBub3JtYWxpemVkXHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHZhciByO1xyXG5cclxuXHRcdHZhciBFUFMgPSAwLjAwMDAwMTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gc2V0RnJvbVVuaXRWZWN0b3JzKCB2RnJvbSwgdlRvICkge1xyXG5cclxuXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0ciA9IHZGcm9tLmRvdCggdlRvICkgKyAxO1xyXG5cclxuXHRcdFx0aWYgKCByIDwgRVBTICkge1xyXG5cclxuXHRcdFx0XHRyID0gMDtcclxuXHJcblx0XHRcdFx0aWYgKCBNYXRoLmFicyggdkZyb20ueCApID4gTWF0aC5hYnMoIHZGcm9tLnogKSApIHtcclxuXHJcblx0XHRcdFx0XHR2MS5zZXQoIC0gdkZyb20ueSwgdkZyb20ueCwgMCApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHYxLnNldCggMCwgLSB2RnJvbS56LCB2RnJvbS55ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHYxLmNyb3NzVmVjdG9ycyggdkZyb20sIHZUbyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5feCA9IHYxLng7XHJcblx0XHRcdHRoaXMuX3kgPSB2MS55O1xyXG5cdFx0XHR0aGlzLl96ID0gdjEuejtcclxuXHRcdFx0dGhpcy5fdyA9IHI7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGFuZ2xlVG86IGZ1bmN0aW9uICggcSApIHtcclxuXHJcblx0XHRyZXR1cm4gMiAqIE1hdGguYWNvcyggTWF0aC5hYnMoIF9NYXRoLmNsYW1wKCB0aGlzLmRvdCggcSApLCAtIDEsIDEgKSApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdGF0ZVRvd2FyZHM6IGZ1bmN0aW9uICggcSwgc3RlcCApIHtcclxuXHJcblx0XHR2YXIgYW5nbGUgPSB0aGlzLmFuZ2xlVG8oIHEgKTtcclxuXHJcblx0XHRpZiAoIGFuZ2xlID09PSAwICkgcmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0dmFyIHQgPSBNYXRoLm1pbiggMSwgc3RlcCAvIGFuZ2xlICk7XHJcblxyXG5cdFx0dGhpcy5zbGVycCggcSwgdCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbnZlcnNlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gcXVhdGVybmlvbiBpcyBhc3N1bWVkIHRvIGhhdmUgdW5pdCBsZW5ndGhcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5jb25qdWdhdGUoKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29uanVnYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5feCAqPSAtIDE7XHJcblx0XHR0aGlzLl95ICo9IC0gMTtcclxuXHRcdHRoaXMuX3ogKj0gLSAxO1xyXG5cclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5feCAqIHYuX3ggKyB0aGlzLl95ICogdi5feSArIHRoaXMuX3ogKiB2Ll96ICsgdGhpcy5fdyAqIHYuX3c7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93O1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgbCA9IHRoaXMubGVuZ3RoKCk7XHJcblxyXG5cdFx0aWYgKCBsID09PSAwICkge1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IDA7XHJcblx0XHRcdHRoaXMuX3kgPSAwO1xyXG5cdFx0XHR0aGlzLl96ID0gMDtcclxuXHRcdFx0dGhpcy5fdyA9IDE7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGwgPSAxIC8gbDtcclxuXHJcblx0XHRcdHRoaXMuX3ggPSB0aGlzLl94ICogbDtcclxuXHRcdFx0dGhpcy5feSA9IHRoaXMuX3kgKiBsO1xyXG5cdFx0XHR0aGlzLl96ID0gdGhpcy5feiAqIGw7XHJcblx0XHRcdHRoaXMuX3cgPSB0aGlzLl93ICogbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5OiBmdW5jdGlvbiAoIHEsIHAgKSB7XHJcblxyXG5cdFx0aWYgKCBwICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdDT09MLlF1YXRlcm5pb246IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5UXVhdGVybmlvbnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggcSwgcCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCB0aGlzLCBxICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHByZW11bHRpcGx5OiBmdW5jdGlvbiAoIHEgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggcSwgdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseVF1YXRlcm5pb25zOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0Ly8gZnJvbSBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL2NvZGUvaW5kZXguaHRtXHJcblxyXG5cdFx0dmFyIHFheCA9IGEuX3gsIHFheSA9IGEuX3ksIHFheiA9IGEuX3osIHFhdyA9IGEuX3c7XHJcblx0XHR2YXIgcWJ4ID0gYi5feCwgcWJ5ID0gYi5feSwgcWJ6ID0gYi5feiwgcWJ3ID0gYi5fdztcclxuXHJcblx0XHR0aGlzLl94ID0gcWF4ICogcWJ3ICsgcWF3ICogcWJ4ICsgcWF5ICogcWJ6IC0gcWF6ICogcWJ5O1xyXG5cdFx0dGhpcy5feSA9IHFheSAqIHFidyArIHFhdyAqIHFieSArIHFheiAqIHFieCAtIHFheCAqIHFiejtcclxuXHRcdHRoaXMuX3ogPSBxYXogKiBxYncgKyBxYXcgKiBxYnogKyBxYXggKiBxYnkgLSBxYXkgKiBxYng7XHJcblx0XHR0aGlzLl93ID0gcWF3ICogcWJ3IC0gcWF4ICogcWJ4IC0gcWF5ICogcWJ5IC0gcWF6ICogcWJ6O1xyXG5cclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzbGVycDogZnVuY3Rpb24gKCBxYiwgdCApIHtcclxuXHJcblx0XHRpZiAoIHQgPT09IDAgKSByZXR1cm4gdGhpcztcclxuXHRcdGlmICggdCA9PT0gMSApIHJldHVybiB0aGlzLmNvcHkoIHFiICk7XHJcblxyXG5cdFx0dmFyIHggPSB0aGlzLl94LCB5ID0gdGhpcy5feSwgeiA9IHRoaXMuX3osIHcgPSB0aGlzLl93O1xyXG5cclxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvc2xlcnAvXHJcblxyXG5cdFx0dmFyIGNvc0hhbGZUaGV0YSA9IHcgKiBxYi5fdyArIHggKiBxYi5feCArIHkgKiBxYi5feSArIHogKiBxYi5fejtcclxuXHJcblx0XHRpZiAoIGNvc0hhbGZUaGV0YSA8IDAgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl93ID0gLSBxYi5fdztcclxuXHRcdFx0dGhpcy5feCA9IC0gcWIuX3g7XHJcblx0XHRcdHRoaXMuX3kgPSAtIHFiLl95O1xyXG5cdFx0XHR0aGlzLl96ID0gLSBxYi5fejtcclxuXHJcblx0XHRcdGNvc0hhbGZUaGV0YSA9IC0gY29zSGFsZlRoZXRhO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLmNvcHkoIHFiICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggY29zSGFsZlRoZXRhID49IDEuMCApIHtcclxuXHJcblx0XHRcdHRoaXMuX3cgPSB3O1xyXG5cdFx0XHR0aGlzLl94ID0geDtcclxuXHRcdFx0dGhpcy5feSA9IHk7XHJcblx0XHRcdHRoaXMuX3ogPSB6O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzcXJTaW5IYWxmVGhldGEgPSAxLjAgLSBjb3NIYWxmVGhldGEgKiBjb3NIYWxmVGhldGE7XHJcblxyXG5cdFx0aWYgKCBzcXJTaW5IYWxmVGhldGEgPD0gTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG5cdFx0XHR2YXIgcyA9IDEgLSB0O1xyXG5cdFx0XHR0aGlzLl93ID0gcyAqIHcgKyB0ICogdGhpcy5fdztcclxuXHRcdFx0dGhpcy5feCA9IHMgKiB4ICsgdCAqIHRoaXMuX3g7XHJcblx0XHRcdHRoaXMuX3kgPSBzICogeSArIHQgKiB0aGlzLl95O1xyXG5cdFx0XHR0aGlzLl96ID0gcyAqIHogKyB0ICogdGhpcy5fejtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc2luSGFsZlRoZXRhID0gTWF0aC5zcXJ0KCBzcXJTaW5IYWxmVGhldGEgKTtcclxuXHRcdHZhciBoYWxmVGhldGEgPSBNYXRoLmF0YW4yKCBzaW5IYWxmVGhldGEsIGNvc0hhbGZUaGV0YSApO1xyXG5cdFx0dmFyIHJhdGlvQSA9IE1hdGguc2luKCAoIDEgLSB0ICkgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YSxcclxuXHRcdFx0cmF0aW9CID0gTWF0aC5zaW4oIHQgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YTtcclxuXHJcblx0XHR0aGlzLl93ID0gKCB3ICogcmF0aW9BICsgdGhpcy5fdyAqIHJhdGlvQiApO1xyXG5cdFx0dGhpcy5feCA9ICggeCAqIHJhdGlvQSArIHRoaXMuX3ggKiByYXRpb0IgKTtcclxuXHRcdHRoaXMuX3kgPSAoIHkgKiByYXRpb0EgKyB0aGlzLl95ICogcmF0aW9CICk7XHJcblx0XHR0aGlzLl96ID0gKCB6ICogcmF0aW9BICsgdGhpcy5feiAqIHJhdGlvQiApO1xyXG5cclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggcXVhdGVybmlvbiApIHtcclxuXHJcblx0XHRyZXR1cm4gKCBxdWF0ZXJuaW9uLl94ID09PSB0aGlzLl94ICkgJiYgKCBxdWF0ZXJuaW9uLl95ID09PSB0aGlzLl95ICkgJiYgKCBxdWF0ZXJuaW9uLl96ID09PSB0aGlzLl96ICkgJiYgKCBxdWF0ZXJuaW9uLl93ID09PSB0aGlzLl93ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdHRoaXMuX3ggPSBhcnJheVsgb2Zmc2V0IF07XHJcblx0XHR0aGlzLl95ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcclxuXHRcdHRoaXMuX3ogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xyXG5cdFx0dGhpcy5fdyA9IGFycmF5WyBvZmZzZXQgKyAzIF07XHJcblxyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xyXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5feDtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLl95O1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuX3o7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy5fdztcclxuXHJcblx0XHRyZXR1cm4gYXJyYXk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG9uQ2hhbmdlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xyXG5cclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRvbkNoYW5nZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7fVxyXG5cclxufSApO1xyXG5cclxuXHJcbmV4cG9ydCB7IFF1YXRlcm5pb24gfTtcclxuIiwiaW1wb3J0IHtfTWF0aH0gZnJvbSAnLi8vTWF0aC5qcyc7XHJcbmltcG9ydCB7IE1hdHJpeDR9IGZyb20gJy4vTWF0cml4NC5qcyc7XHJcbmltcG9ydCB7UXVhdGVybmlvbn0gZnJvbSAnLi9RdWF0ZXJuaW9uLmpzJztcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGtpbGUgLyBodHRwOi8va2lsZS5zdHJhdmFnYW56YS5vcmcvXHJcbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIFZlY3RvcjMoIHgsIHksIHogKSB7XHJcblxyXG5cdHRoaXMueCA9IHggfHwgMDtcclxuXHR0aGlzLnkgPSB5IHx8IDA7XHJcblx0dGhpcy56ID0geiB8fCAwO1xyXG5cclxufVxyXG5cclxuT2JqZWN0LmFzc2lnbiggVmVjdG9yMy5wcm90b3R5cGUsIHtcclxuXHJcblx0aXNWZWN0b3IzOiB0cnVlLFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcclxuXHJcblx0XHR0aGlzLnggPSB4O1xyXG5cdFx0dGhpcy55ID0geTtcclxuXHRcdHRoaXMueiA9IHo7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gc2NhbGFyO1xyXG5cdFx0dGhpcy55ID0gc2NhbGFyO1xyXG5cdFx0dGhpcy56ID0gc2NhbGFyO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRYOiBmdW5jdGlvbiAoIHggKSB7XHJcblxyXG5cdFx0dGhpcy54ID0geDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WTogZnVuY3Rpb24gKCB5ICkge1xyXG5cclxuXHRcdHRoaXMueSA9IHk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFo6IGZ1bmN0aW9uICggeiApIHtcclxuXHJcblx0XHR0aGlzLnogPSB6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXgsIHZhbHVlICkge1xyXG5cclxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0Y2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIDI6IHRoaXMueiA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcclxuXHJcblx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcclxuXHRcdFx0Y2FzZSAxOiByZXR1cm4gdGhpcy55O1xyXG5cdFx0XHRjYXNlIDI6IHJldHVybiB0aGlzLno7XHJcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnksIHRoaXMueiApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gdi54O1xyXG5cdFx0dGhpcy55ID0gdi55O1xyXG5cdFx0dGhpcy56ID0gdi56O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGQ6IGZ1bmN0aW9uICggdiwgdyApIHtcclxuXHJcblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ0NPT0wuVmVjdG9yMzogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnggKz0gdi54O1xyXG5cdFx0dGhpcy55ICs9IHYueTtcclxuXHRcdHRoaXMueiArPSB2Lno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMueCArPSBzO1xyXG5cdFx0dGhpcy55ICs9IHM7XHJcblx0XHR0aGlzLnogKz0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHRoaXMueCA9IGEueCArIGIueDtcclxuXHRcdHRoaXMueSA9IGEueSArIGIueTtcclxuXHRcdHRoaXMueiA9IGEueiArIGIuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkU2NhbGVkVmVjdG9yOiBmdW5jdGlvbiAoIHYsIHMgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9IHYueCAqIHM7XHJcblx0XHR0aGlzLnkgKz0gdi55ICogcztcclxuXHRcdHRoaXMueiArPSB2LnogKiBzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzdWI6IGZ1bmN0aW9uICggdiwgdyApIHtcclxuXHJcblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ0NPT0wuVmVjdG9yMzogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnggLT0gdi54O1xyXG5cdFx0dGhpcy55IC09IHYueTtcclxuXHRcdHRoaXMueiAtPSB2Lno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHN1YlNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMueCAtPSBzO1xyXG5cdFx0dGhpcy55IC09IHM7XHJcblx0XHR0aGlzLnogLT0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcbiAgICBzY2FsZVZlY3RvcnMgOmZ1bmN0aW9uKHYxLHNjYWxlKXtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjModjEueCpzY2FsZSwgdjEueSpzY2FsZSwgdjEueipzY2FsZSApO1xyXG4gICAgfSxcclxuXHJcblx0c3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHRoaXMueCA9IGEueCAtIGIueDtcclxuXHRcdHRoaXMueSA9IGEueSAtIGIueTtcclxuXHRcdHRoaXMueiA9IGEueiAtIGIuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggdiwgdyApIHtcclxuXHJcblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ0NPT0wuVmVjdG9yMzogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5VmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnggKj0gdi54O1xyXG5cdFx0dGhpcy55ICo9IHYueTtcclxuXHRcdHRoaXMueiAqPSB2Lno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcclxuXHJcblx0XHR0aGlzLnggKj0gc2NhbGFyO1xyXG5cdFx0dGhpcy55ICo9IHNjYWxhcjtcclxuXHRcdHRoaXMueiAqPSBzY2FsYXI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5VmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHRoaXMueCA9IGEueCAqIGIueDtcclxuXHRcdHRoaXMueSA9IGEueSAqIGIueTtcclxuXHRcdHRoaXMueiA9IGEueiAqIGIuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlFdWxlcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gYXBwbHlFdWxlciggZXVsZXIgKSB7XHJcblxyXG5cdFx0XHRpZiAoICEgKCBldWxlciAmJiBldWxlci5pc0V1bGVyICkgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdDT09MLlZlY3RvcjM6IC5hcHBseUV1bGVyKCkgbm93IGV4cGVjdHMgYW4gRXVsZXIgcm90YXRpb24gcmF0aGVyIHRoYW4gYSBWZWN0b3IzIGFuZCBvcmRlci4nICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciApICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRhcHBseUF4aXNBbmdsZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gYXBwbHlBeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGFwcGx5TWF0cml4MzogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xyXG5cdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyAzIF0gKiB5ICsgZVsgNiBdICogejtcclxuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgNyBdICogejtcclxuXHRcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOCBdICogejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XHJcblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XHJcblxyXG5cdFx0dmFyIHcgPSAxIC8gKCBlWyAzIF0gKiB4ICsgZVsgNyBdICogeSArIGVbIDExIF0gKiB6ICsgZVsgMTUgXSApO1xyXG5cclxuXHRcdHRoaXMueCA9ICggZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gKiB6ICsgZVsgMTIgXSApICogdztcclxuXHRcdHRoaXMueSA9ICggZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gKiB6ICsgZVsgMTMgXSApICogdztcclxuXHRcdHRoaXMueiA9ICggZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF0gKSAqIHc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5UXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xyXG5cclxuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xyXG5cdFx0dmFyIHF4ID0gcS54LCBxeSA9IHEueSwgcXogPSBxLnosIHF3ID0gcS53O1xyXG5cclxuXHRcdC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjdG9yXHJcblxyXG5cdFx0dmFyIGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5O1xyXG5cdFx0dmFyIGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6O1xyXG5cdFx0dmFyIGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xyXG5cdFx0dmFyIGl3ID0gLSBxeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XHJcblxyXG5cdFx0Ly8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxyXG5cclxuXHRcdHRoaXMueCA9IGl4ICogcXcgKyBpdyAqIC0gcXggKyBpeSAqIC0gcXogLSBpeiAqIC0gcXk7XHJcblx0XHR0aGlzLnkgPSBpeSAqIHF3ICsgaXcgKiAtIHF5ICsgaXogKiAtIHF4IC0gaXggKiAtIHF6O1xyXG5cdFx0dGhpcy56ID0gaXogKiBxdyArIGl3ICogLSBxeiArIGl4ICogLSBxeSAtIGl5ICogLSBxeDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICkuYXBwbHlNYXRyaXg0KCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gdW5wcm9qZWN0KCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQoIG1hdHJpeC5nZXRJbnZlcnNlKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApICkuYXBwbHlNYXRyaXg0KCBjYW1lcmEubWF0cml4V29ybGQgKTtcclxuICAgICAgICAgICAgLy8gcmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KCBtYXRyaXguZ2V0SW52ZXJzZSggY2FtZXJhLlZQbWF0cml4ICkgKTsg562J5Lu3XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHR0cmFuc2Zvcm1EaXJlY3Rpb246IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHQvLyBpbnB1dDogQ09PTC5NYXRyaXg0IGFmZmluZSBtYXRyaXhcclxuXHRcdC8vIHZlY3RvciBpbnRlcnByZXRlZCBhcyBhIGRpcmVjdGlvblxyXG5cclxuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xyXG5cdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICogejtcclxuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICogejtcclxuXHRcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHo7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpdmlkZTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCAvPSB2Lng7XHJcblx0XHR0aGlzLnkgLz0gdi55O1xyXG5cdFx0dGhpcy56IC89IHYuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggMSAvIHNjYWxhciApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtaW46IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLm1pbiggdGhpcy54LCB2LnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGgubWluKCB0aGlzLnksIHYueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5taW4oIHRoaXMueiwgdi56ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1heDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCB0aGlzLngsIHYueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIHRoaXMueSwgdi55ICk7XHJcblx0XHR0aGlzLnogPSBNYXRoLm1heCggdGhpcy56LCB2LnogKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG5cdFx0Ly8gYXNzdW1lcyBtaW4gPCBtYXgsIGNvbXBvbmVudHdpc2VcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLm1heCggbWluLngsIE1hdGgubWluKCBtYXgueCwgdGhpcy54ICkgKTtcclxuXHRcdHRoaXMueSA9IE1hdGgubWF4KCBtaW4ueSwgTWF0aC5taW4oIG1heC55LCB0aGlzLnkgKSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5tYXgoIG1pbi56LCBNYXRoLm1pbiggbWF4LnosIHRoaXMueiApICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsYW1wU2NhbGFyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG1pbiA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHR2YXIgbWF4ID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gY2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xyXG5cclxuXHRcdFx0bWluLnNldCggbWluVmFsLCBtaW5WYWwsIG1pblZhbCApO1xyXG5cdFx0XHRtYXguc2V0KCBtYXhWYWwsIG1heFZhbCwgbWF4VmFsICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5jbGFtcCggbWluLCBtYXggKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGNsYW1wTGVuZ3RoOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xyXG5cclxuXHRcdHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggbGVuZ3RoIHx8IDEgKS5tdWx0aXBseVNjYWxhciggTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgbGVuZ3RoICkgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmbG9vcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XHJcblx0XHR0aGlzLnogPSBNYXRoLmZsb29yKCB0aGlzLnogKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2VpbDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKCB0aGlzLnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5yb3VuZCggdGhpcy56ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcclxuXHRcdHRoaXMueiA9ICggdGhpcy56IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnogKSA6IE1hdGguZmxvb3IoIHRoaXMueiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnggPSAtIHRoaXMueDtcclxuXHRcdHRoaXMueSA9IC0gdGhpcy55O1xyXG5cdFx0dGhpcy56ID0gLSB0aGlzLno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRvdDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2Lno7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIFRPRE8gbGVuZ3RoU3F1YXJlZD9cclxuXHJcblx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56O1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKTtcclxuXHJcblx0fSxcclxuXHJcblx0bWFuaGF0dGFuTGVuZ3RoOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKSArIE1hdGguYWJzKCB0aGlzLnogKTtcclxuXHJcblx0fSxcclxuXHJcblx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpIHx8IDEgKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0TGVuZ3RoOiBmdW5jdGlvbiAoIGxlbmd0aCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggbGVuZ3RoICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlcnA6IGZ1bmN0aW9uICggdiwgYWxwaGEgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcclxuXHRcdHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XHJcblx0XHR0aGlzLnogKz0gKCB2LnogLSB0aGlzLnogKSAqIGFscGhhO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZXJwVmVjdG9yczogZnVuY3Rpb24gKCB2MSwgdjIsIGFscGhhICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYyLCB2MSApLm11bHRpcGx5U2NhbGFyKCBhbHBoYSApLmFkZCggdjEgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y3Jvc3M6IGZ1bmN0aW9uICggdiwgdyApIHtcclxuXHJcblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ0NPT0wuVmVjdG9yMzogLmNyb3NzKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuY3Jvc3NWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmNyb3NzVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5jcm9zc1ZlY3RvcnMoIHRoaXMsIHYgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y3Jvc3NWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0dmFyIGF4ID0gYS54LCBheSA9IGEueSwgYXogPSBhLno7XHJcblx0XHR2YXIgYnggPSBiLngsIGJ5ID0gYi55LCBieiA9IGIuejtcclxuXHJcblx0XHR0aGlzLnggPSBheSAqIGJ6IC0gYXogKiBieTtcclxuXHRcdHRoaXMueSA9IGF6ICogYnggLSBheCAqIGJ6O1xyXG5cdFx0dGhpcy56ID0gYXggKiBieSAtIGF5ICogYng7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHByb2plY3RPblZlY3RvcjogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0dmFyIHNjYWxhciA9IHZlY3Rvci5kb3QoIHRoaXMgKSAvIHZlY3Rvci5sZW5ndGhTcSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmNvcHkoIHZlY3RvciApLm11bHRpcGx5U2NhbGFyKCBzY2FsYXIgKTtcclxuXHJcblx0fSxcclxuXHJcblx0cHJvamVjdE9uUGxhbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBwcm9qZWN0T25QbGFuZSggcGxhbmVOb3JtYWwgKSB7XHJcblxyXG5cdFx0XHR2MS5jb3B5KCB0aGlzICkucHJvamVjdE9uVmVjdG9yKCBwbGFuZU5vcm1hbCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuc3ViKCB2MSApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0cmVmbGVjdDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHJlZmxlY3QgaW5jaWRlbnQgdmVjdG9yIG9mZiBwbGFuZSBvcnRob2dvbmFsIHRvIG5vcm1hbFxyXG5cdFx0Ly8gbm9ybWFsIGlzIGFzc3VtZWQgdG8gaGF2ZSB1bml0IGxlbmd0aFxyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJlZmxlY3QoIG5vcm1hbCApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLnN1YiggdjEuY29weSggbm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIDIgKiB0aGlzLmRvdCggbm9ybWFsICkgKSApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0YW5nbGVUbzogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHZhciB0aGV0YSA9IHRoaXMuZG90KCB2ICkgLyAoIE1hdGguc3FydCggdGhpcy5sZW5ndGhTcSgpICogdi5sZW5ndGhTcSgpICkgKTtcclxuXHJcblx0XHQvLyBjbGFtcCwgdG8gaGFuZGxlIG51bWVyaWNhbCBwcm9ibGVtc1xyXG5cclxuXHRcdHJldHVybiBNYXRoLmFjb3MoIF9NYXRoLmNsYW1wKCB0aGV0YSwgLSAxLCAxICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVRvU3F1YXJlZDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHZhciBkeCA9IHRoaXMueCAtIHYueCwgZHkgPSB0aGlzLnkgLSB2LnksIGR6ID0gdGhpcy56IC0gdi56O1xyXG5cclxuXHRcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHo7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1hbmhhdHRhbkRpc3RhbmNlVG86IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCAtIHYueCApICsgTWF0aC5hYnMoIHRoaXMueSAtIHYueSApICsgTWF0aC5hYnMoIHRoaXMueiAtIHYueiApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tU3BoZXJpY2FsOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbVNwaGVyaWNhbENvb3Jkcyggcy5yYWRpdXMsIHMucGhpLCBzLnRoZXRhICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21TcGhlcmljYWxDb29yZHM6IGZ1bmN0aW9uICggcmFkaXVzLCBwaGksIHRoZXRhICkge1xyXG5cclxuXHRcdHZhciBzaW5QaGlSYWRpdXMgPSBNYXRoLnNpbiggcGhpICkgKiByYWRpdXM7XHJcblxyXG5cdFx0dGhpcy54ID0gc2luUGhpUmFkaXVzICogTWF0aC5zaW4oIHRoZXRhICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmNvcyggcGhpICkgKiByYWRpdXM7XHJcblx0XHR0aGlzLnogPSBzaW5QaGlSYWRpdXMgKiBNYXRoLmNvcyggdGhldGEgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbUN5bGluZHJpY2FsOiBmdW5jdGlvbiAoIGMgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbUN5bGluZHJpY2FsQ29vcmRzKCBjLnJhZGl1cywgYy50aGV0YSwgYy55ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21DeWxpbmRyaWNhbENvb3JkczogZnVuY3Rpb24gKCByYWRpdXMsIHRoZXRhLCB5ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHJhZGl1cyAqIE1hdGguc2luKCB0aGV0YSApO1xyXG5cdFx0dGhpcy55ID0geTtcclxuXHRcdHRoaXMueiA9IHJhZGl1cyAqIE1hdGguY29zKCB0aGV0YSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tTWF0cml4UG9zaXRpb246IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XHJcblxyXG5cdFx0dGhpcy54ID0gZVsgMTIgXTtcclxuXHRcdHRoaXMueSA9IGVbIDEzIF07XHJcblx0XHR0aGlzLnogPSBlWyAxNCBdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tTWF0cml4U2NhbGU6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHR2YXIgc3ggPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDAgKS5sZW5ndGgoKTtcclxuXHRcdHZhciBzeSA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMSApLmxlbmd0aCgpO1xyXG5cdFx0dmFyIHN6ID0gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAyICkubGVuZ3RoKCk7XHJcblxyXG5cdFx0dGhpcy54ID0gc3g7XHJcblx0XHR0aGlzLnkgPSBzeTtcclxuXHRcdHRoaXMueiA9IHN6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tTWF0cml4Q29sdW1uOiBmdW5jdGlvbiAoIG0sIGluZGV4ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmZyb21BcnJheSggbS5lbGVtZW50cywgaW5kZXggKiA0ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgJiYgKCB2LnogPT09IHRoaXMueiApICk7XHJcblxyXG5cdH0sXHJcblxyXG4gICAgcm90YXRlQnlWZWN0b3IgOmZ1bmN0aW9uKHZlYzEsIHZlYzIsIGFuZ2xlKSB7XHJcbiAgICAgICAgdmFyIHYxID0gdmVjMS50b0FycmF5KCk7XHJcbiAgICAgICAgdmFyIHYyID0gdmVjMi50b0FycmF5KCk7XHJcbiAgICAgICAgYW5nbGUgPSAtIGFuZ2xlO1xyXG4gICAgICAgIHZhciBwb3MgPSBbXTtcclxuICAgICAgICBwb3NbMF0gPSB2MVswXSAqIE1hdGguY29zKGFuZ2xlKSArICh2MlsxXSAqIHYxWzJdIC0gdjJbMl0gKiB2MVsxXSkgKiBNYXRoLnNpbihhbmdsZSkgKyB2MlswXSAqICh2MlswXSAqIHYxWzBdICsgdjJbMV0gKiB2MVsxXSArIHYyWzJdICogdjFbMl0pICogKDEgLSBNYXRoLmNvcyhhbmdsZSkpO1xyXG4gICAgICAgIHBvc1sxXSA9IHYxWzFdICogTWF0aC5jb3MoYW5nbGUpICsgKHYyWzJdICogdjFbMF0gLSB2MlswXSAqIHYxWzJdKSAqIE1hdGguc2luKGFuZ2xlKSArIHYyWzFdICogKHYyWzBdICogdjFbMF0gKyB2MlsxXSAqIHYxWzFdICsgdjJbMl0gKiB2MVsyXSkgKiAoMSAtIE1hdGguY29zKGFuZ2xlKSk7XHJcbiAgICAgICAgcG9zWzJdID0gdjFbMl0gKiBNYXRoLmNvcyhhbmdsZSkgKyAodjJbMF0gKiB2MVsxXSAtIHYyWzFdICogdjFbMF0pICogTWF0aC5zaW4oYW5nbGUpICsgdjJbMl0gKiAodjJbMF0gKiB2MVswXSArIHYyWzFdICogdjFbMV0gKyB2MlsyXSAqIHYxWzJdKSAqICgxIC0gTWF0aC5jb3MoYW5nbGUpKTtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkocG9zKTtcclxuICAgIH0sXHJcblxyXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcclxuXHRcdHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XHJcblx0XHR0aGlzLnogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy56O1xyXG5cclxuXHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0fSxcclxuXHJcblx0ZnJvbUJ1ZmZlckF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBvZmZzZXQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ0NPT0wuVmVjdG9yMzogb2Zmc2V0IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSgpLicgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy54ID0gYXR0cmlidXRlLmdldFgoIGluZGV4ICk7XHJcblx0XHR0aGlzLnkgPSBhdHRyaWJ1dGUuZ2V0WSggaW5kZXggKTtcclxuXHRcdHRoaXMueiA9IGF0dHJpYnV0ZS5nZXRaKCBpbmRleCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcblxyXG5cclxuZXhwb3J0IHsgVmVjdG9yMyB9O1xyXG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi9WZWN0b3IzLmpzJztcclxuaW1wb3J0IHsgU3BoZXJlIH0gZnJvbSAnLi9TcGhlcmUuanMnO1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gQm94MyggbWluLCBtYXggKSB7XHJcblxyXG5cdHRoaXMubWluID0gKCBtaW4gIT09IHVuZGVmaW5lZCApID8gbWluIDogbmV3IFZlY3RvcjMoICsgSW5maW5pdHksICsgSW5maW5pdHksICsgSW5maW5pdHkgKTtcclxuXHR0aGlzLm1heCA9ICggbWF4ICE9PSB1bmRlZmluZWQgKSA/IG1heCA6IG5ldyBWZWN0b3IzKCAtIEluZmluaXR5LCAtIEluZmluaXR5LCAtIEluZmluaXR5ICk7XHJcblxyXG59XHJcblxyXG5PYmplY3QuYXNzaWduKCBCb3gzLnByb3RvdHlwZSwge1xyXG5cclxuXHRpc0JveDM6IHRydWUsXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5jb3B5KCBtaW4gKTtcclxuXHRcdHRoaXMubWF4LmNvcHkoIG1heCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XHJcblxyXG5cdFx0dmFyIG1pblggPSArIEluZmluaXR5O1xyXG5cdFx0dmFyIG1pblkgPSArIEluZmluaXR5O1xyXG5cdFx0dmFyIG1pblogPSArIEluZmluaXR5O1xyXG5cclxuXHRcdHZhciBtYXhYID0gLSBJbmZpbml0eTtcclxuXHRcdHZhciBtYXhZID0gLSBJbmZpbml0eTtcclxuXHRcdHZhciBtYXhaID0gLSBJbmZpbml0eTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHR2YXIgeCA9IGFycmF5WyBpIF07XHJcblx0XHRcdHZhciB5ID0gYXJyYXlbIGkgKyAxIF07XHJcblx0XHRcdHZhciB6ID0gYXJyYXlbIGkgKyAyIF07XHJcblxyXG5cdFx0XHRpZiAoIHggPCBtaW5YICkgbWluWCA9IHg7XHJcblx0XHRcdGlmICggeSA8IG1pblkgKSBtaW5ZID0geTtcclxuXHRcdFx0aWYgKCB6IDwgbWluWiApIG1pblogPSB6O1xyXG5cclxuXHRcdFx0aWYgKCB4ID4gbWF4WCApIG1heFggPSB4O1xyXG5cdFx0XHRpZiAoIHkgPiBtYXhZICkgbWF4WSA9IHk7XHJcblx0XHRcdGlmICggeiA+IG1heFogKSBtYXhaID0gejtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5taW4uc2V0KCBtaW5YLCBtaW5ZLCBtaW5aICk7XHJcblx0XHR0aGlzLm1heC5zZXQoIG1heFgsIG1heFksIG1heFogKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0dmFyIG1pblggPSArIEluZmluaXR5O1xyXG5cdFx0dmFyIG1pblkgPSArIEluZmluaXR5O1xyXG5cdFx0dmFyIG1pblogPSArIEluZmluaXR5O1xyXG5cclxuXHRcdHZhciBtYXhYID0gLSBJbmZpbml0eTtcclxuXHRcdHZhciBtYXhZID0gLSBJbmZpbml0eTtcclxuXHRcdHZhciBtYXhaID0gLSBJbmZpbml0eTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBhdHRyaWJ1dGUuY291bnQ7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHggPSBhdHRyaWJ1dGUuZ2V0WCggaSApO1xyXG5cdFx0XHR2YXIgeSA9IGF0dHJpYnV0ZS5nZXRZKCBpICk7XHJcblx0XHRcdHZhciB6ID0gYXR0cmlidXRlLmdldFooIGkgKTtcclxuXHJcblx0XHRcdGlmICggeCA8IG1pblggKSBtaW5YID0geDtcclxuXHRcdFx0aWYgKCB5IDwgbWluWSApIG1pblkgPSB5O1xyXG5cdFx0XHRpZiAoIHogPCBtaW5aICkgbWluWiA9IHo7XHJcblxyXG5cdFx0XHRpZiAoIHggPiBtYXhYICkgbWF4WCA9IHg7XHJcblx0XHRcdGlmICggeSA+IG1heFkgKSBtYXhZID0geTtcclxuXHRcdFx0aWYgKCB6ID4gbWF4WiApIG1heFogPSB6O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm1pbi5zZXQoIG1pblgsIG1pblksIG1pblogKTtcclxuXHRcdHRoaXMubWF4LnNldCggbWF4WCwgbWF4WSwgbWF4WiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoIHBvaW50cyApIHtcclxuXHJcblx0XHR0aGlzLm1ha2VFbXB0eSgpO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoIHBvaW50c1sgaSBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tQ2VudGVyQW5kU2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHNldEZyb21DZW50ZXJBbmRTaXplKCBjZW50ZXIsIHNpemUgKSB7XHJcblxyXG5cdFx0XHR2YXIgaGFsZlNpemUgPSB2MS5jb3B5KCBzaXplICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG5cclxuXHRcdFx0dGhpcy5taW4uY29weSggY2VudGVyICkuc3ViKCBoYWxmU2l6ZSApO1xyXG5cdFx0XHR0aGlzLm1heC5jb3B5KCBjZW50ZXIgKS5hZGQoIGhhbGZTaXplICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHNldEZyb21PYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRcdHRoaXMubWFrZUVtcHR5KCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZXhwYW5kQnlPYmplY3QoIG9iamVjdCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0dGhpcy5taW4uY29weSggYm94Lm1pbiApO1xyXG5cdFx0dGhpcy5tYXguY29weSggYm94Lm1heCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlRW1wdHk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLm1pbi54ID0gdGhpcy5taW4ueSA9IHRoaXMubWluLnogPSArIEluZmluaXR5O1xyXG5cdFx0dGhpcy5tYXgueCA9IHRoaXMubWF4LnkgPSB0aGlzLm1heC56ID0gLSBJbmZpbml0eTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHRoaXMgaXMgYSBtb3JlIHJvYnVzdCBjaGVjayBmb3IgZW1wdHkgdGhhbiAoIHZvbHVtZSA8PSAwICkgYmVjYXVzZSB2b2x1bWUgY2FuIGdldCBwb3NpdGl2ZSB3aXRoIHR3byBuZWdhdGl2ZSBheGVzXHJcblxyXG5cdFx0cmV0dXJuICggdGhpcy5tYXgueCA8IHRoaXMubWluLnggKSB8fCAoIHRoaXMubWF4LnkgPCB0aGlzLm1pbi55ICkgfHwgKCB0aGlzLm1heC56IDwgdGhpcy5taW4ueiApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICggdGFyZ2V0ICkge1xyXG5cclxuXHRcdGlmICggdGFyZ2V0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdDT09MLkJveDM6IC5nZXRDZW50ZXIoKSB0YXJnZXQgaXMgbm93IHJlcXVpcmVkJyApO1xyXG5cdFx0XHR0YXJnZXQgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyB0YXJnZXQuc2V0KCAwLCAwLCAwICkgOiB0YXJnZXQuYWRkVmVjdG9ycyggdGhpcy5taW4sIHRoaXMubWF4ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRTaXplOiBmdW5jdGlvbiAoIHRhcmdldCApIHtcclxuXHJcblx0XHRpZiAoIHRhcmdldCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5Cb3gzOiAuZ2V0U2l6ZSgpIHRhcmdldCBpcyBub3cgcmVxdWlyZWQnICk7XHJcblx0XHRcdHRhcmdldCA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IHRhcmdldC5zZXQoIDAsIDAsIDAgKSA6IHRhcmdldC5zdWJWZWN0b3JzKCB0aGlzLm1heCwgdGhpcy5taW4gKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZXhwYW5kQnlQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5taW4oIHBvaW50ICk7XHJcblx0XHR0aGlzLm1heC5tYXgoIHBvaW50ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGV4cGFuZEJ5VmVjdG9yOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5zdWIoIHZlY3RvciApO1xyXG5cdFx0dGhpcy5tYXguYWRkKCB2ZWN0b3IgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXhwYW5kQnlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdHRoaXMubWluLmFkZFNjYWxhciggLSBzY2FsYXIgKTtcclxuXHRcdHRoaXMubWF4LmFkZFNjYWxhciggc2NhbGFyICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGV4cGFuZEJ5T2JqZWN0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gQ29tcHV0ZXMgdGhlIHdvcmxkLWF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggb2YgYW4gb2JqZWN0IChpbmNsdWRpbmcgaXRzIGNoaWxkcmVuKSxcclxuXHRcdC8vIGFjY291bnRpbmcgZm9yIGJvdGggdGhlIG9iamVjdCdzLCBhbmQgY2hpbGRyZW4ncywgd29ybGQgdHJhbnNmb3Jtc1xyXG5cclxuXHRcdHZhciBzY29wZSwgaSwgbDtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdGZ1bmN0aW9uIHRyYXZlcnNlKCBub2RlICkge1xyXG5cclxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gbm9kZS5nZW9tZXRyeTtcclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBnZW9tZXRyeS5pc0dlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHYxLmNvcHkoIHZlcnRpY2VzWyBpIF0gKTtcclxuXHRcdFx0XHRcdFx0djEuYXBwbHlNYXRyaXg0KCBub2RlLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHRcdFx0XHRzY29wZS5leHBhbmRCeVBvaW50KCB2MSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgYXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBhdHRyaWJ1dGUuY291bnQ7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2MS5mcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGkgKS5hcHBseU1hdHJpeDQoIG5vZGUubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0c2NvcGUuZXhwYW5kQnlQb2ludCggdjEgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGV4cGFuZEJ5T2JqZWN0KCBvYmplY3QgKSB7XHJcblxyXG5cdFx0XHRzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0XHRvYmplY3QudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcclxuXHJcblx0XHRcdG9iamVjdC50cmF2ZXJzZSggdHJhdmVyc2UgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHRyZXR1cm4gcG9pbnQueCA8IHRoaXMubWluLnggfHwgcG9pbnQueCA+IHRoaXMubWF4LnggfHxcclxuXHRcdFx0cG9pbnQueSA8IHRoaXMubWluLnkgfHwgcG9pbnQueSA+IHRoaXMubWF4LnkgfHxcclxuXHRcdFx0cG9pbnQueiA8IHRoaXMubWluLnogfHwgcG9pbnQueiA+IHRoaXMubWF4LnogPyBmYWxzZSA6IHRydWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbnRhaW5zQm94OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5taW4ueCA8PSBib3gubWluLnggJiYgYm94Lm1heC54IDw9IHRoaXMubWF4LnggJiZcclxuXHRcdFx0dGhpcy5taW4ueSA8PSBib3gubWluLnkgJiYgYm94Lm1heC55IDw9IHRoaXMubWF4LnkgJiZcclxuXHRcdFx0dGhpcy5taW4ueiA8PSBib3gubWluLnogJiYgYm94Lm1heC56IDw9IHRoaXMubWF4Lno7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldFBhcmFtZXRlcjogZnVuY3Rpb24gKCBwb2ludCwgdGFyZ2V0ICkge1xyXG5cclxuXHRcdC8vIFRoaXMgY2FuIHBvdGVudGlhbGx5IGhhdmUgYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgYm94XHJcblx0XHQvLyBoYXMgYSBzaXplIGRpbWVuc2lvbiBvZiAwLlxyXG5cclxuXHRcdGlmICggdGFyZ2V0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdDT09MLkJveDM6IC5nZXRQYXJhbWV0ZXIoKSB0YXJnZXQgaXMgbm93IHJlcXVpcmVkJyApO1xyXG5cdFx0XHR0YXJnZXQgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGFyZ2V0LnNldChcclxuXHRcdFx0KCBwb2ludC54IC0gdGhpcy5taW4ueCApIC8gKCB0aGlzLm1heC54IC0gdGhpcy5taW4ueCApLFxyXG5cdFx0XHQoIHBvaW50LnkgLSB0aGlzLm1pbi55ICkgLyAoIHRoaXMubWF4LnkgLSB0aGlzLm1pbi55ICksXHJcblx0XHRcdCggcG9pbnQueiAtIHRoaXMubWluLnogKSAvICggdGhpcy5tYXgueiAtIHRoaXMubWluLnogKVxyXG5cdFx0KTtcclxuXHJcblx0fSxcclxuXHJcblx0aW50ZXJzZWN0c0JveDogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0Ly8gdXNpbmcgNiBzcGxpdHRpbmcgcGxhbmVzIHRvIHJ1bGUgb3V0IGludGVyc2VjdGlvbnMuXHJcblx0XHRyZXR1cm4gYm94Lm1heC54IDwgdGhpcy5taW4ueCB8fCBib3gubWluLnggPiB0aGlzLm1heC54IHx8XHJcblx0XHRcdGJveC5tYXgueSA8IHRoaXMubWluLnkgfHwgYm94Lm1pbi55ID4gdGhpcy5tYXgueSB8fFxyXG5cdFx0XHRib3gubWF4LnogPCB0aGlzLm1pbi56IHx8IGJveC5taW4ueiA+IHRoaXMubWF4LnogPyBmYWxzZSA6IHRydWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGludGVyc2VjdHNTcGhlcmU6ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBjbG9zZXN0UG9pbnQgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSB7XHJcblxyXG5cdFx0XHQvLyBGaW5kIHRoZSBwb2ludCBvbiB0aGUgQUFCQiBjbG9zZXN0IHRvIHRoZSBzcGhlcmUgY2VudGVyLlxyXG5cdFx0XHR0aGlzLmNsYW1wUG9pbnQoIHNwaGVyZS5jZW50ZXIsIGNsb3Nlc3RQb2ludCApO1xyXG5cclxuXHRcdFx0Ly8gSWYgdGhhdCBwb2ludCBpcyBpbnNpZGUgdGhlIHNwaGVyZSwgdGhlIEFBQkIgYW5kIHNwaGVyZSBpbnRlcnNlY3QuXHJcblx0XHRcdHJldHVybiBjbG9zZXN0UG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQoIHNwaGVyZS5jZW50ZXIgKSA8PSAoIHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSApKCksXHJcblxyXG5cdGludGVyc2VjdHNQbGFuZTogZnVuY3Rpb24gKCBwbGFuZSApIHtcclxuXHJcblx0XHQvLyBXZSBjb21wdXRlIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGRvdCBwcm9kdWN0IHZhbHVlcy4gSWYgdGhvc2UgdmFsdWVzXHJcblx0XHQvLyBhcmUgb24gdGhlIHNhbWUgc2lkZSAoYmFjayBvciBmcm9udCkgb2YgdGhlIHBsYW5lLCB0aGVuIHRoZXJlIGlzIG5vIGludGVyc2VjdGlvbi5cclxuXHJcblx0XHR2YXIgbWluLCBtYXg7XHJcblxyXG5cdFx0aWYgKCBwbGFuZS5ub3JtYWwueCA+IDAgKSB7XHJcblxyXG5cdFx0XHRtaW4gPSBwbGFuZS5ub3JtYWwueCAqIHRoaXMubWluLng7XHJcblx0XHRcdG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0bWluID0gcGxhbmUubm9ybWFsLnggKiB0aGlzLm1heC54O1xyXG5cdFx0XHRtYXggPSBwbGFuZS5ub3JtYWwueCAqIHRoaXMubWluLng7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcGxhbmUubm9ybWFsLnkgPiAwICkge1xyXG5cclxuXHRcdFx0bWluICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5taW4ueTtcclxuXHRcdFx0bWF4ICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5tYXgueTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0bWluICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5tYXgueTtcclxuXHRcdFx0bWF4ICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5taW4ueTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBwbGFuZS5ub3JtYWwueiA+IDAgKSB7XHJcblxyXG5cdFx0XHRtaW4gKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1pbi56O1xyXG5cdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1heC56O1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRtaW4gKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1heC56O1xyXG5cdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1pbi56O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gKCBtaW4gPD0gLSBwbGFuZS5jb25zdGFudCAmJiBtYXggPj0gLSBwbGFuZS5jb25zdGFudCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbnRlcnNlY3RzVHJpYW5nbGU6ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHRyaWFuZ2xlIGNlbnRlcmVkIHZlcnRpY2VzXHJcblx0XHR2YXIgdjAgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHZhciB2MiA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0Ly8gdHJpYW5nbGUgZWRnZSB2ZWN0b3JzXHJcblx0XHR2YXIgZjAgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0dmFyIGYxID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHZhciBmMiA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0dmFyIHRlc3RBeGlzID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHR2YXIgY2VudGVyID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHZhciBleHRlbnRzID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHR2YXIgdHJpYW5nbGVOb3JtYWwgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdGZ1bmN0aW9uIHNhdEZvckF4ZXMoIGF4ZXMgKSB7XHJcblxyXG5cdFx0XHR2YXIgaSwgajtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwLCBqID0gYXhlcy5sZW5ndGggLSAzOyBpIDw9IGo7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0dGVzdEF4aXMuZnJvbUFycmF5KCBheGVzLCBpICk7XHJcblx0XHRcdFx0Ly8gcHJvamVjdCB0aGUgYWFiYiBvbnRvIHRoZSBzZXBlcmF0aW5nIGF4aXNcclxuXHRcdFx0XHR2YXIgciA9IGV4dGVudHMueCAqIE1hdGguYWJzKCB0ZXN0QXhpcy54ICkgKyBleHRlbnRzLnkgKiBNYXRoLmFicyggdGVzdEF4aXMueSApICsgZXh0ZW50cy56ICogTWF0aC5hYnMoIHRlc3RBeGlzLnogKTtcclxuXHRcdFx0XHQvLyBwcm9qZWN0IGFsbCAzIHZlcnRpY2VzIG9mIHRoZSB0cmlhbmdsZSBvbnRvIHRoZSBzZXBlcmF0aW5nIGF4aXNcclxuXHRcdFx0XHR2YXIgcDAgPSB2MC5kb3QoIHRlc3RBeGlzICk7XHJcblx0XHRcdFx0dmFyIHAxID0gdjEuZG90KCB0ZXN0QXhpcyApO1xyXG5cdFx0XHRcdHZhciBwMiA9IHYyLmRvdCggdGVzdEF4aXMgKTtcclxuXHRcdFx0XHQvLyBhY3R1YWwgdGVzdCwgYmFzaWNhbGx5IHNlZSBpZiBlaXRoZXIgb2YgdGhlIG1vc3QgZXh0cmVtZSBvZiB0aGUgdHJpYW5nbGUgcG9pbnRzIGludGVyc2VjdHMgclxyXG5cdFx0XHRcdGlmICggTWF0aC5tYXgoIC0gTWF0aC5tYXgoIHAwLCBwMSwgcDIgKSwgTWF0aC5taW4oIHAwLCBwMSwgcDIgKSApID4gciApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBwb2ludHMgb2YgdGhlIHByb2plY3RlZCB0cmlhbmdsZSBhcmUgb3V0c2lkZSB0aGUgcHJvamVjdGVkIGhhbGYtbGVuZ3RoIG9mIHRoZSBhYWJiXHJcblx0XHRcdFx0XHQvLyB0aGUgYXhpcyBpcyBzZXBlcmF0aW5nIGFuZCB3ZSBjYW4gZXhpdFxyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdHNUcmlhbmdsZSggdHJpYW5nbGUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuaXNFbXB0eSgpICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBjb21wdXRlIGJveCBjZW50ZXIgYW5kIGV4dGVudHNcclxuXHRcdFx0dGhpcy5nZXRDZW50ZXIoIGNlbnRlciApO1xyXG5cdFx0XHRleHRlbnRzLnN1YlZlY3RvcnMoIHRoaXMubWF4LCBjZW50ZXIgKTtcclxuXHJcblx0XHRcdC8vIHRyYW5zbGF0ZSB0cmlhbmdsZSB0byBhYWJiIG9yaWdpblxyXG5cdFx0XHR2MC5zdWJWZWN0b3JzKCB0cmlhbmdsZS5hLCBjZW50ZXIgKTtcclxuXHRcdFx0djEuc3ViVmVjdG9ycyggdHJpYW5nbGUuYiwgY2VudGVyICk7XHJcblx0XHRcdHYyLnN1YlZlY3RvcnMoIHRyaWFuZ2xlLmMsIGNlbnRlciApO1xyXG5cclxuXHRcdFx0Ly8gY29tcHV0ZSBlZGdlIHZlY3RvcnMgZm9yIHRyaWFuZ2xlXHJcblx0XHRcdGYwLnN1YlZlY3RvcnMoIHYxLCB2MCApO1xyXG5cdFx0XHRmMS5zdWJWZWN0b3JzKCB2MiwgdjEgKTtcclxuXHRcdFx0ZjIuc3ViVmVjdG9ycyggdjAsIHYyICk7XHJcblxyXG5cdFx0XHQvLyB0ZXN0IGFnYWluc3QgYXhlcyB0aGF0IGFyZSBnaXZlbiBieSBjcm9zcyBwcm9kdWN0IGNvbWJpbmF0aW9ucyBvZiB0aGUgZWRnZXMgb2YgdGhlIHRyaWFuZ2xlIGFuZCB0aGUgZWRnZXMgb2YgdGhlIGFhYmJcclxuXHRcdFx0Ly8gbWFrZSBhbiBheGlzIHRlc3Rpbmcgb2YgZWFjaCBvZiB0aGUgMyBzaWRlcyBvZiB0aGUgYWFiYiBhZ2FpbnN0IGVhY2ggb2YgdGhlIDMgc2lkZXMgb2YgdGhlIHRyaWFuZ2xlID0gOSBheGlzIG9mIHNlcGFyYXRpb25cclxuXHRcdFx0Ly8gYXhpc19paiA9IHVfaSB4IGZfaiAodTAsIHUxLCB1MiA9IGZhY2Ugbm9ybWFscyBvZiBhYWJiID0geCx5LHogYXhlcyB2ZWN0b3JzIHNpbmNlIGFhYmIgaXMgYXhpcyBhbGlnbmVkKVxyXG5cdFx0XHR2YXIgYXhlcyA9IFtcclxuXHRcdFx0XHQwLCAtIGYwLnosIGYwLnksIDAsIC0gZjEueiwgZjEueSwgMCwgLSBmMi56LCBmMi55LFxyXG5cdFx0XHRcdGYwLnosIDAsIC0gZjAueCwgZjEueiwgMCwgLSBmMS54LCBmMi56LCAwLCAtIGYyLngsXHJcblx0XHRcdFx0LSBmMC55LCBmMC54LCAwLCAtIGYxLnksIGYxLngsIDAsIC0gZjIueSwgZjIueCwgMFxyXG5cdFx0XHRdO1xyXG5cdFx0XHRpZiAoICEgc2F0Rm9yQXhlcyggYXhlcyApICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB0ZXN0IDMgZmFjZSBub3JtYWxzIGZyb20gdGhlIGFhYmJcclxuXHRcdFx0YXhlcyA9IFsgMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMSBdO1xyXG5cdFx0XHRpZiAoICEgc2F0Rm9yQXhlcyggYXhlcyApICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBmaW5hbGx5IHRlc3RpbmcgdGhlIGZhY2Ugbm9ybWFsIG9mIHRoZSB0cmlhbmdsZVxyXG5cdFx0XHQvLyB1c2UgYWxyZWFkeSBleGlzdGluZyB0cmlhbmdsZSBlZGdlIHZlY3RvcnMgaGVyZVxyXG5cdFx0XHR0cmlhbmdsZU5vcm1hbC5jcm9zc1ZlY3RvcnMoIGYwLCBmMSApO1xyXG5cdFx0XHRheGVzID0gWyB0cmlhbmdsZU5vcm1hbC54LCB0cmlhbmdsZU5vcm1hbC55LCB0cmlhbmdsZU5vcm1hbC56IF07XHJcblx0XHRcdHJldHVybiBzYXRGb3JBeGVzKCBheGVzICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSApKCksXHJcblxyXG5cdGNsYW1wUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIHRhcmdldCApIHtcclxuXHJcblx0XHRpZiAoIHRhcmdldCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5Cb3gzOiAuY2xhbXBQb2ludCgpIHRhcmdldCBpcyBub3cgcmVxdWlyZWQnICk7XHJcblx0XHRcdHRhcmdldCA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0YXJnZXQuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2xhbXBlZFBvaW50ID0gdjEuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XHJcblx0XHRcdHJldHVybiBjbGFtcGVkUG9pbnQuc3ViKCBwb2ludCApLmxlbmd0aCgpO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Z2V0Qm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRCb3VuZGluZ1NwaGVyZSggdGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0aWYgKCB0YXJnZXQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5Cb3gzOiAuZ2V0Qm91bmRpbmdTcGhlcmUoKSB0YXJnZXQgaXMgbm93IHJlcXVpcmVkJyApO1xyXG5cdFx0XHRcdHRhcmdldCA9IG5ldyBTcGhlcmUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZ2V0Q2VudGVyKCB0YXJnZXQuY2VudGVyICk7XHJcblxyXG5cdFx0XHR0YXJnZXQucmFkaXVzID0gdGhpcy5nZXRTaXplKCB2MSApLmxlbmd0aCgpICogMC41O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRhcmdldDtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGludGVyc2VjdDogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0dGhpcy5taW4ubWF4KCBib3gubWluICk7XHJcblx0XHR0aGlzLm1heC5taW4oIGJveC5tYXggKTtcclxuXHJcblx0XHQvLyBlbnN1cmUgdGhhdCBpZiB0aGVyZSBpcyBubyBvdmVybGFwLCB0aGUgcmVzdWx0IGlzIGZ1bGx5IGVtcHR5LCBub3Qgc2xpZ2h0bHkgZW1wdHkgd2l0aCBub24taW5mLytpbmYgdmFsdWVzIHRoYXQgd2lsbCBjYXVzZSBzdWJzZXF1ZW5jZSBpbnRlcnNlY3RzIHRvIGVycm9uZW91c2x5IHJldHVybiB2YWxpZCB2YWx1ZXMuXHJcblx0XHRpZiAoIHRoaXMuaXNFbXB0eSgpICkgdGhpcy5tYWtlRW1wdHkoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dW5pb246IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdHRoaXMubWluLm1pbiggYm94Lm1pbiApO1xyXG5cdFx0dGhpcy5tYXgubWF4KCBib3gubWF4ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBwb2ludHMgPSBbXHJcblx0XHRcdG5ldyBWZWN0b3IzKCksXHJcblx0XHRcdG5ldyBWZWN0b3IzKCksXHJcblx0XHRcdG5ldyBWZWN0b3IzKCksXHJcblx0XHRcdG5ldyBWZWN0b3IzKCksXHJcblx0XHRcdG5ldyBWZWN0b3IzKCksXHJcblx0XHRcdG5ldyBWZWN0b3IzKCksXHJcblx0XHRcdG5ldyBWZWN0b3IzKCksXHJcblx0XHRcdG5ldyBWZWN0b3IzKClcclxuXHRcdF07XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGFwcGx5TWF0cml4NCggbWF0cml4ICkge1xyXG5cclxuXHRcdFx0Ly8gdHJhbnNmb3JtIG9mIGVtcHR5IGJveCBpcyBhbiBlbXB0eSBib3guXHJcblx0XHRcdGlmICggdGhpcy5pc0VtcHR5KCkgKSByZXR1cm4gdGhpcztcclxuXHJcblx0XHRcdC8vIE5PVEU6IEkgYW0gdXNpbmcgYSBiaW5hcnkgcGF0dGVybiB0byBzcGVjaWZ5IGFsbCAyXjMgY29tYmluYXRpb25zIGJlbG93XHJcblx0XHRcdHBvaW50c1sgMCBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5taW4ueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAwMFxyXG5cdFx0XHRwb2ludHNbIDEgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWluLnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMDFcclxuXHRcdFx0cG9pbnRzWyAyIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1heC55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDEwXHJcblx0XHRcdHBvaW50c1sgMyBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAxMVxyXG5cdFx0XHRwb2ludHNbIDQgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWluLnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMDBcclxuXHRcdFx0cG9pbnRzWyA1IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTAxXHJcblx0XHRcdHBvaW50c1sgNiBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDExMFxyXG5cdFx0XHRwb2ludHNbIDcgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWF4LnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMTFcclxuXHJcblx0XHRcdHRoaXMuc2V0RnJvbVBvaW50cyggcG9pbnRzICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0dGhpcy5taW4uYWRkKCBvZmZzZXQgKTtcclxuXHRcdHRoaXMubWF4LmFkZCggb2Zmc2V0ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0cmV0dXJuIGJveC5taW4uZXF1YWxzKCB0aGlzLm1pbiApICYmIGJveC5tYXguZXF1YWxzKCB0aGlzLm1heCApO1xyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcblxyXG5cclxuZXhwb3J0IHsgQm94MyB9O1xyXG4iLCJpbXBvcnQgeyBCb3gzIH0gZnJvbSAnLi9Cb3gzLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4vVmVjdG9yMy5qcyc7XHJcblxyXG4vKipcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIFNwaGVyZSggY2VudGVyLCByYWRpdXMgKSB7XHJcblxyXG5cdHRoaXMuY2VudGVyID0gKCBjZW50ZXIgIT09IHVuZGVmaW5lZCApID8gY2VudGVyIDogbmV3IFZlY3RvcjMoKTtcclxuXHR0aGlzLnJhZGl1cyA9ICggcmFkaXVzICE9PSB1bmRlZmluZWQgKSA/IHJhZGl1cyA6IDA7XHJcblxyXG59XHJcblxyXG5PYmplY3QuYXNzaWduKCBTcGhlcmUucHJvdG90eXBlLCB7XHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCBjZW50ZXIsIHJhZGl1cyApIHtcclxuXHJcblx0XHR0aGlzLmNlbnRlci5jb3B5KCBjZW50ZXIgKTtcclxuXHRcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGJveCA9IG5ldyBCb3gzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHNldEZyb21Qb2ludHMoIHBvaW50cywgb3B0aW9uYWxDZW50ZXIgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2VudGVyID0gdGhpcy5jZW50ZXI7XHJcblxyXG5cdFx0XHRpZiAoIG9wdGlvbmFsQ2VudGVyICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNlbnRlci5jb3B5KCBvcHRpb25hbENlbnRlciApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ym94LnNldEZyb21Qb2ludHMoIHBvaW50cyApLmdldENlbnRlciggY2VudGVyICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgbWF4UmFkaXVzU3EgPSAwO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0bWF4UmFkaXVzU3EgPSBNYXRoLm1heCggbWF4UmFkaXVzU3EsIGNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnRzWyBpIF0gKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5yYWRpdXMgPSBNYXRoLnNxcnQoIG1heFJhZGl1c1NxICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcclxuXHJcblx0XHR0aGlzLmNlbnRlci5jb3B5KCBzcGhlcmUuY2VudGVyICk7XHJcblx0XHR0aGlzLnJhZGl1cyA9IHNwaGVyZS5yYWRpdXM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVtcHR5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuICggdGhpcy5yYWRpdXMgPD0gMCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuXHRcdHJldHVybiAoIHBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKCB0aGlzLmNlbnRlciApIDw9ICggdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHRyZXR1cm4gKCBwb2ludC5kaXN0YW5jZVRvKCB0aGlzLmNlbnRlciApIC0gdGhpcy5yYWRpdXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0aW50ZXJzZWN0c1NwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XHJcblxyXG5cdFx0dmFyIHJhZGl1c1N1bSA9IHRoaXMucmFkaXVzICsgc3BoZXJlLnJhZGl1cztcclxuXHJcblx0XHRyZXR1cm4gc3BoZXJlLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5jZW50ZXIgKSA8PSAoIHJhZGl1c1N1bSAqIHJhZGl1c1N1bSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbnRlcnNlY3RzQm94OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHRyZXR1cm4gYm94LmludGVyc2VjdHNTcGhlcmUoIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0aW50ZXJzZWN0c1BsYW5lOiBmdW5jdGlvbiAoIHBsYW5lICkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLmFicyggcGxhbmUuZGlzdGFuY2VUb1BvaW50KCB0aGlzLmNlbnRlciApICkgPD0gdGhpcy5yYWRpdXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsYW1wUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIHRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgZGVsdGFMZW5ndGhTcSA9IHRoaXMuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xyXG5cclxuXHRcdGlmICggdGFyZ2V0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdDT09MLlNwaGVyZTogLmNsYW1wUG9pbnQoKSB0YXJnZXQgaXMgbm93IHJlcXVpcmVkJyApO1xyXG5cdFx0XHR0YXJnZXQgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0YXJnZXQuY29weSggcG9pbnQgKTtcclxuXHJcblx0XHRpZiAoIGRlbHRhTGVuZ3RoU3EgPiAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApIHtcclxuXHJcblx0XHRcdHRhcmdldC5zdWIoIHRoaXMuY2VudGVyICkubm9ybWFsaXplKCk7XHJcblx0XHRcdHRhcmdldC5tdWx0aXBseVNjYWxhciggdGhpcy5yYWRpdXMgKS5hZGQoIHRoaXMuY2VudGVyICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0YXJnZXQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEJvdW5kaW5nQm94OiBmdW5jdGlvbiAoIHRhcmdldCApIHtcclxuXHJcblx0XHRpZiAoIHRhcmdldCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5TcGhlcmU6IC5nZXRCb3VuZGluZ0JveCgpIHRhcmdldCBpcyBub3cgcmVxdWlyZWQnICk7XHJcblx0XHRcdHRhcmdldCA9IG5ldyBCb3gzKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRhcmdldC5zZXQoIHRoaXMuY2VudGVyLCB0aGlzLmNlbnRlciApO1xyXG5cdFx0dGFyZ2V0LmV4cGFuZEJ5U2NhbGFyKCB0aGlzLnJhZGl1cyApO1xyXG5cclxuXHRcdHJldHVybiB0YXJnZXQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG5cdFx0dGhpcy5jZW50ZXIuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcclxuXHRcdHRoaXMucmFkaXVzID0gdGhpcy5yYWRpdXMgKiBtYXRyaXguZ2V0TWF4U2NhbGVPbkF4aXMoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcclxuXHJcblx0XHR0aGlzLmNlbnRlci5hZGQoIG9mZnNldCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggc3BoZXJlICkge1xyXG5cclxuXHRcdHJldHVybiBzcGhlcmUuY2VudGVyLmVxdWFscyggdGhpcy5jZW50ZXIgKSAmJiAoIHNwaGVyZS5yYWRpdXMgPT09IHRoaXMucmFkaXVzICk7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuXHJcblxyXG5leHBvcnQgeyBTcGhlcmUgfTtcclxuIiwiaW1wb3J0IHtWZWN0b3IzfSBmcm9tIFwiLi4vbWF0aC9WZWN0b3IzXCI7XHJcbmltcG9ydCB7U3BoZXJlfSBmcm9tIFwiLi4vbWF0aC9TcGhlcmVcIjtcclxuaW1wb3J0IHtCb3gzfSBmcm9tIFwiLi4vbWF0aC9Cb3gzXCI7XHJcblxyXG5jbGFzcyBCb3hHZW9tZXRyeSB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbSkge1xyXG4gICAgICAgIHBhcmFtID0gcGFyYW0gfHwge307XHJcblxyXG4gICAgICAgIHRoaXMudXYgPSBwYXJhbS51diB8fCBuZXcgRmxvYXQzMkFycmF5KFsgICAvLyBWZXJ0ZXggY29vcmRpbmF0ZXNcclxuXHJcbiAgICAgICAgICAgIDEsMSwgMCwxLCAwLDAsIDEsMCwgIC8vIHYwLXYxLXYyLXYzIGZyb250XHJcbiAgICAgICAgICAgIDAsMSwgMCwwLCAxLDAsIDEsMSwgIC8vIHYwLXYzLXY0LXY1IHJpZ2h0XHJcbiAgICAgICAgICAgIDEsMCwgMSwxLCAwLDEsIDAsMCwgIC8vIHYwLXY1LXY2LXYxIHVwXHJcbiAgICAgICAgICAgIDEsMSwgMCwxLCAwLDAsIDEsMCwgIC8vIHYxLXY2LXY3LXYyIGxlZnRcclxuICAgICAgICAgICAgMCwxLCAxLDEsIDEsMCwgMCwwLCAgLy8gdjctdjQtdjMtdjIgZG93blxyXG4gICAgICAgICAgICAxLDAsIDAsMCwgMCwxLCAxLDEgICAvLyB2NC12Ny12Ni12NSBiYWNrXHJcblxyXG4gICAgICAgIF0pO1xyXG5cclxuICAgICAgICB0aGlzLnZlcnRpY2VzID0gcGFyYW0uaW5kaWNlcyB8fCBuZXcgRmxvYXQzMkFycmF5KFsgICAvLyBWZXJ0ZXggY29vcmRpbmF0ZXNcclxuICAgICAgICAgICAgMC41LCAwLjUsIDAuNSwgIC0wLjUsIDAuNSwgMC41LCAgLTAuNSwtMC41LCAwLjUsICAgMC41LC0wLjUsIDAuNSwgIC8vIHYwLXYxLXYyLXYzIGZyb250XHJcbiAgICAgICAgICAgIDAuNSwgMC41LCAwLjUsICAgMC41LC0wLjUsIDAuNSwgICAwLjUsLTAuNSwtMC41LCAgIDAuNSwgMC41LC0wLjUsICAvLyB2MC12My12NC12NSByaWdodFxyXG4gICAgICAgICAgICAwLjUsIDAuNSwgMC41LCAgIDAuNSwgMC41LC0wLjUsICAtMC41LCAwLjUsLTAuNSwgIC0wLjUsIDAuNSwgMC41LCAgLy8gdjAtdjUtdjYtdjEgdXBcclxuICAgICAgICAgICAgLTAuNSwgMC41LCAwLjUsICAtMC41LCAwLjUsLTAuNSwgIC0wLjUsLTAuNSwtMC41LCAgLTAuNSwtMC41LCAwLjUsICAvLyB2MS12Ni12Ny12MiBsZWZ0XHJcbiAgICAgICAgICAgIC0wLjUsLTAuNSwtMC41LCAgIDAuNSwtMC41LC0wLjUsICAgMC41LC0wLjUsIDAuNSwgIC0wLjUsLTAuNSwgMC41LCAgLy8gdjctdjQtdjMtdjIgZG93blxyXG4gICAgICAgICAgICAwLjUsLTAuNSwtMC41LCAgLTAuNSwtMC41LC0wLjUsICAtMC41LCAwLjUsLTAuNSwgICAwLjUsIDAuNSwtMC41ICAgLy8gdjQtdjctdjYtdjUgYmFja1xyXG4gICAgICAgIF0pO1xyXG5cclxuICAgICAgICB0aGlzLm5vcm1hbCA9IHBhcmFtLm5vcm1hbCB8fCB0aGlzLnZlcnRpY2VzO1xyXG5cclxuICAgICAgICB0aGlzLmluZGljZXMgPSBwYXJhbS5pbmRpY2VzIHx8IG5ldyBVaW50MTZBcnJheShbICAgICAgIC8vIEluZGljZXMgb2YgdGhlIHZlcnRpY2VzXHJcbiAgICAgICAgICAgIDAsIDEsIDIsICAgMCwgMiwgMywgICAgLy8gZnJvbnRcclxuICAgICAgICAgICAgNCwgNSwgNiwgICA0LCA2LCA3LCAgICAvLyByaWdodFxyXG4gICAgICAgICAgICA4LCA5LDEwLCAgIDgsMTAsMTEsICAgIC8vIHVwXHJcbiAgICAgICAgICAgIDEyLDEzLDE0LCAgMTIsMTQsMTUsICAgIC8vIGxlZnRcclxuICAgICAgICAgICAgMTYsMTcsMTgsICAxNiwxOCwxOSwgICAgLy8gZG93blxyXG4gICAgICAgICAgICAyMCwyMSwyMiwgIDIwLDIyLDIzICAgICAvLyBiYWNrXHJcbiAgICAgICAgXSk7XHJcblxyXG4gICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IG5ldyBCb3gzKCk7XHJcbiAgICAgICAgdGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcclxuICAgICAgICAvLyB0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZU5vcm1hbCgpO1xyXG5cclxuICAgICAgICB0aGlzLnVwZGF0YUJ1ZmZlcigpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGFCdWZmZXIoKXtcclxuICAgICAgICB2YXIgYnVmZmVyID0gW107XHJcbiAgICAgICAgdmFyIHV2ID0gdGhpcy51djtcclxuICAgICAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xyXG4gICAgICAgIHZhciBub3JtYWwgPSB0aGlzLm5vcm1hbDtcclxuICAgICAgICBmb3IodmFyIGk9MDsgaTx2ZXJ0aWNlcy5sZW5ndGg7IGkrPTMpe1xyXG4gICAgICAgICAgICBidWZmZXIucHVzaCh2ZXJ0aWNlc1tpKzBdKTtcclxuICAgICAgICAgICAgYnVmZmVyLnB1c2godmVydGljZXNbaSsxXSk7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKHZlcnRpY2VzW2krMl0pO1xyXG5cclxuICAgICAgICAgICAgYnVmZmVyLnB1c2gobm9ybWFsW2krMF0pO1xyXG4gICAgICAgICAgICBidWZmZXIucHVzaChub3JtYWxbaSsxXSk7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKG5vcm1hbFtpKzJdKTtcclxuXHJcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKHV2W2kvMyoyKzBdKTtcclxuICAgICAgICAgICAgYnVmZmVyLnB1c2godXZbaS8zKjIrMV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcik7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlTm9ybWFsKCl7XHJcbiAgICAgICAgdmFyIG5vcm1hbCA9IFtdO1xyXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8dmVydGljZXMubGVuZ3RoOyBpKz0zKjQpe1xyXG4gICAgICAgICAgICB2YXIgbGluZTEgPSBuZXcgVmVjdG9yMygpLnN1YlZlY3RvcnMoXHJcbiAgICAgICAgICAgICAgICBuZXcgVmVjdG9yMyh2ZXJ0aWNlc1tpKzBdLCB2ZXJ0aWNlc1tpKzFdLCB2ZXJ0aWNlc1tpKzJdKSxcclxuICAgICAgICAgICAgICAgIG5ldyBWZWN0b3IzKHZlcnRpY2VzW2krM10sIHZlcnRpY2VzW2krNF0sIHZlcnRpY2VzW2krNV0pXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHZhciBsaW5lMiA9IG5ldyBWZWN0b3IzKCkuc3ViVmVjdG9ycyhcclxuICAgICAgICAgICAgICAgIG5ldyBWZWN0b3IzKHZlcnRpY2VzW2krM10sIHZlcnRpY2VzW2krNF0sIHZlcnRpY2VzW2krNV0pLFxyXG4gICAgICAgICAgICAgICAgbmV3IFZlY3RvcjModmVydGljZXNbaSs2XSwgdmVydGljZXNbaSs3XSwgdmVydGljZXNbaSs4XSksXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHZhciBjdXJfbm9ybWFsID0gbmV3IFZlY3RvcjMoKS5jcm9zc1ZlY3RvcnMoXHJcbiAgICAgICAgICAgICAgICBsaW5lMSxcclxuICAgICAgICAgICAgICAgIGxpbmUyXHJcbiAgICAgICAgICAgICkudG9BcnJheSgpO1xyXG4gICAgICAgICAgICBmb3IodmFyIGo9MCA7ajw0OyBqKyspe1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsLnB1c2goY3VyX25vcm1hbFswXSwgY3VyX25vcm1hbFsxXSwgY3VyX25vcm1hbFsyXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ub3JtYWwgPSBuZXcgRmxvYXQzMkFycmF5KG5vcm1hbCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpe1xyXG5cclxuICAgICAgICAvLyBpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSB7XHJcbiAgICAgICAgLy8gICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIC8vIHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0RnJvbVBvaW50cyggdGhpcy52ZXJ0aWNlcyApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXB1dGVCb3VuZGluZ0JveCAoKSB7XHJcbiAgICAgICAgdmFyIHZlcnRpY2VzVjMgPSBbXTtcclxuICAgICAgICBmb3IodmFyIGk9MDsgaTx0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSs9Myl7XHJcbiAgICAgICAgICAgIHZlcnRpY2VzVjMucHVzaChuZXcgVmVjdG9yMyh0aGlzLnZlcnRpY2VzW2ldLCB0aGlzLnZlcnRpY2VzW2krMV0sIHRoaXMudmVydGljZXNbaSsyXSkpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3guc2V0RnJvbVBvaW50cyh2ZXJ0aWNlc1YzKTtcclxuICAgIH1cclxuXHJcbiAgICBjbG9uZSgpe1xyXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBCb3hHZW9tZXRyeSh7XHJcbiAgICAgICAgICAgIHZlcnRpY2VzOiB0aGlzLnZlcnRpY2VzLnNsaWNlKDApLFxyXG4gICAgICAgICAgICBpbmRpY2VzOiB0aGlzLmluZGljZXMuc2xpY2UoMClcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGdlb21ldHJ5O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBCb3hHZW9tZXRyeTtcclxuIiwiXHJcbmNsYXNzIE1hdGVyaWFsIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtKSB7XHJcbiAgICAgICAgcGFyYW0gPSBwYXJhbSB8fCB7fTtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnTWF0ZXJpYWwnO1xyXG4gICAgICAgIHRoaXMubWFwID0gcGFyYW0ubWFwO1xyXG4gICAgICAgIHRoaXMuZW52TWFwID0gcGFyYW0uZW52TWFwO1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBwYXJhbS5jb2xvciB8fCBbMSwxLDEsMV07XHJcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gdGhpcy5jb2xvclszXTtcclxuICAgICAgICBpZih0aGlzLmNvbG9yWzNdICYmIHRoaXMuY29sb3JbM108MSl7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNwYXJlbnQgPSB0cnVlO1xyXG4gICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgdGhpcy50cmFuc3BhcmVudCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1ldGFsbmVzcyA9IHBhcmFtLm1ldGFsbmVzcyA9PSB1bmRlZmluZWQgPyAwLjUgOiBwYXJhbS5tZXRhbG5lc3M7XHJcblxyXG4gICAgICAgIHRoaXMud2lyZWZyYW1lID0gcGFyYW0ud2lyZWZyYW1lID09IHVuZGVmaW5lZCA/IGZhbHNlIDogcGFyYW0ud2lyZWZyYW1lO1xyXG5cclxuICAgICAgICB2YXIgVlNIQURFUl9TT1VSQ0UgPVxyXG5cclxuICAgICAgICAgICAgJ3ByZWNpc2lvbiBoaWdocCBpbnQ7XFxuJyArXHJcbiAgICAgICAgICAgICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXHJcbiAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjNCBhX1Bvc2l0aW9uO1xcbicgK1xyXG4gICAgICAgICAgICAndW5pZm9ybSBtYXQ0IHVfTXZNYXRyaXg7XFxuJyArXHJcbiAgICAgICAgICAgICd1bmlmb3JtIG1hdDQgdV9QTWF0cml4O1xcbicgK1xyXG5cclxuICAgICAgICAgICAgJyNpZmRlZiBVU0VfU2hhZG93XFxuJyArXHJcbiAgICAgICAgICAgICd1bmlmb3JtIG1hdDQgdV9QTWF0cml4RnJvbUxpZ2h0O1xcbicgK1xyXG4gICAgICAgICAgICAndmFyeWluZyB2ZWM0IHZfUG9zaXRpb25Gcm9tTGlnaHQ7XFxuJyArXHJcbiAgICAgICAgICAgICcjZW5kaWZcXG4nICtcclxuXHJcbiAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhX1RleENvb3JkO1xcbicgK1xyXG4gICAgICAgICAgICAndmFyeWluZyB2ZWMyIHZfVGV4Q29vcmQ7XFxuJyArXHJcbiAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMyBhX05vcm1hbDtcXG4nICtcclxuICAgICAgICAgICAgJ3ZhcnlpbmcgdmVjMyB2X05vcm1hbDtcXG4nICtcclxuXHJcbiAgICAgICAgICAgICcjaWZkZWYgVVNFX1NDb2xvclxcbicgK1xyXG4gICAgICAgICAgICAndmFyeWluZyB2ZWMzIHZfUG9zaXRpb25WMztcXG4nICtcclxuICAgICAgICAgICAgJyNlbHNlXFxuJyArXHJcbiAgICAgICAgICAgICcgICAjaWZkZWYgVVNFX2Vudk1hcFxcbicgK1xyXG4gICAgICAgICAgICAnICAgdmFyeWluZyB2ZWMzIHZfUG9zaXRpb25WMztcXG4nICtcclxuICAgICAgICAgICAgJyAgICNlbmRpZlxcbicgK1xyXG4gICAgICAgICAgICAnI2VuZGlmXFxuJyArXHJcblxyXG4gICAgICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xyXG4gICAgICAgICAgICAnICB2ZWM0IHBvc2l0aW9uVjQgPSB1X1BNYXRyaXggKiB1X012TWF0cml4ICogYV9Qb3NpdGlvbjtcXG4nICtcclxuICAgICAgICAgICAgJyAgZ2xfUG9zaXRpb24gPSBwb3NpdGlvblY0O1xcbicgK1xyXG4gICAgICAgICAgICAnICB2X1RleENvb3JkID0gYV9UZXhDb29yZDtcXG4nICtcclxuICAgICAgICAgICAgJyAgdl9Ob3JtYWwgPSBtYXQzKHVfTXZNYXRyaXgpICogYV9Ob3JtYWw7XFxuJyArXHJcbiAgICAgICAgICAgIC8vICcgIHZfTm9ybWFsID0gKHVfTXZNYXRyaXggKiB2ZWM0KGFfTm9ybWFsLCAwLjApKS54eXo7XFxuJyArXHJcbiAgICAgICAgICAgIC8vICcgIHZfTm9ybWFsID0gYV9Ob3JtYWw7XFxuJyArXHJcblxyXG4gICAgICAgICAgICAnI2lmZGVmIFVTRV9TaGFkb3dcXG4nICtcclxuICAgICAgICAgICAgJyAgdl9Qb3NpdGlvbkZyb21MaWdodCA9IHVfUE1hdHJpeEZyb21MaWdodCAqIHVfTXZNYXRyaXggKiBhX1Bvc2l0aW9uO1xcbicgK1xyXG4gICAgICAgICAgICAnI2VuZGlmXFxuJyArXHJcblxyXG4gICAgICAgICAgICAnI2lmZGVmIFVTRV9TQ29sb3JcXG4nICtcclxuICAgICAgICAgICAgJyAgdmVjNCBwb3NpdGlvblY0UmVsID0gdV9Ndk1hdHJpeCAqIGFfUG9zaXRpb247XFxuJyArXHJcbiAgICAgICAgICAgICcgIHZfUG9zaXRpb25WMyA9IHBvc2l0aW9uVjRSZWwueHl6IC8gcG9zaXRpb25WNFJlbC53O1xcbicgK1xyXG4gICAgICAgICAgICAnI2Vsc2VcXG4nICtcclxuICAgICAgICAgICAgJyAgICNpZmRlZiBVU0VfZW52TWFwXFxuJyArXHJcbiAgICAgICAgICAgICcgICB2ZWM0IHBvc2l0aW9uVjRSZWwgPSB1X012TWF0cml4ICogYV9Qb3NpdGlvbjtcXG4nICtcclxuICAgICAgICAgICAgJyAgIHZfUG9zaXRpb25WMyA9IHBvc2l0aW9uVjRSZWwueHl6IC8gcG9zaXRpb25WNFJlbC53O1xcbicgK1xyXG4gICAgICAgICAgICAnICAgI2VuZGlmXFxuJyArXHJcbiAgICAgICAgICAgICcjZW5kaWZcXG4nICtcclxuXHJcbiAgICAgICAgICAgICd9XFxuJztcclxuXHJcbiAgICAgICAgdmFyIEZTSEFERVJfU09VUkNFID1cclxuICAgICAgICAgICAgJ3ByZWNpc2lvbiBoaWdocCBpbnQ7XFxuJyArXHJcbiAgICAgICAgICAgICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXHJcbiAgICAgICAgICAgICd1bmlmb3JtIHZlYzQgdV9Db2xvcjtcXG4nICtcclxuICAgICAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2X1RleENvb3JkO1xcbicgK1xyXG4gICAgICAgICAgICAndmFyeWluZyB2ZWMzIHZfTm9ybWFsO1xcbicgK1xyXG5cclxuICAgICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9NZXRhbG5lc3M7XFxuJyArXHJcblxyXG4gICAgICAgICAgICAnI2lmZGVmIFVTRV9NYXBcXG4nICtcclxuICAgICAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVfU2FtcGxlcjtcXG4nICtcclxuICAgICAgICAgICAgJyNlbmRpZlxcbicgK1xyXG5cclxuICAgICAgICAgICAgJyNpZmRlZiBVU0VfZW52TWFwXFxuJyArXHJcbiAgICAgICAgICAgICd1bmlmb3JtIHNhbXBsZXJDdWJlIHVfZW52TWFwO1xcbicgK1xyXG4gICAgICAgICAgICAnI2VuZGlmXFxuJyArXHJcblxyXG4gICAgICAgICAgICAnI2lmZGVmIFVTRV9BbWJpZW50TGlnaHRcXG4nICtcclxuICAgICAgICAgICAgJ3VuaWZvcm0gdmVjMyB1X0FtYmllbnRMaWdodF9Db2xvcjtcXG4nICtcclxuICAgICAgICAgICAgJyNlbmRpZlxcbicgK1xyXG5cclxuICAgICAgICAgICAgJyNpZmRlZiBVU0VfRGlyZWN0aW9uYWxMaWdodFxcbicgK1xyXG4gICAgICAgICAgICAndW5pZm9ybSB2ZWMzIHVfRGlyZWN0aW9uYWxMaWdodF9EaXJlY3Rpb247XFxuJyArXHJcbiAgICAgICAgICAgICd1bmlmb3JtIHZlYzMgdV9EaXJlY3Rpb25hbExpZ2h0X0NvbG9yO1xcbicgK1xyXG4gICAgICAgICAgICAnI2VuZGlmXFxuJyArXHJcblxyXG4gICAgICAgICAgICAnI2lmZGVmIFVTRV9TQ29sb3JcXG4nICtcclxuICAgICAgICAgICAgJ3VuaWZvcm0gdmVjMyB1X0NhbWVyYV9Qb3NpdGlvbjtcXG4nICtcclxuICAgICAgICAgICAgJ3ZhcnlpbmcgdmVjMyB2X1Bvc2l0aW9uVjM7XFxuJyArXHJcbiAgICAgICAgICAgICcjZWxzZVxcbicgK1xyXG4gICAgICAgICAgICAnICAgI2lmZGVmIFVTRV9lbnZNYXBcXG4nICtcclxuICAgICAgICAgICAgJyAgIHVuaWZvcm0gdmVjMyB1X0NhbWVyYV9Qb3NpdGlvbjtcXG4nICtcclxuICAgICAgICAgICAgJyAgIHZhcnlpbmcgdmVjMyB2X1Bvc2l0aW9uVjM7XFxuJyArXHJcbiAgICAgICAgICAgICcgICAjZW5kaWZcXG4nICtcclxuICAgICAgICAgICAgJyNlbmRpZlxcbicgK1xyXG5cclxuICAgICAgICAgICAgJyNpZmRlZiBVU0VfU2hhZG93XFxuJyArXHJcbiAgICAgICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1X1NoYWRvd01hcDtcXG4nICtcclxuICAgICAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2X1Bvc2l0aW9uRnJvbUxpZ2h0O1xcbicgK1xyXG5cclxuICAgICAgICAgICAgJ2Zsb2F0IHVucGFja0RlcHRoKGNvbnN0IGluIHZlYzQgcmdiYURlcHRoKSB7XFxuJyArXHJcbiAgICAgICAgICAgICcgIGNvbnN0IHZlYzQgYml0U2hpZnQgPSB2ZWM0KDEuMCwgMS4wLzI1Ni4wLCAxLjAvKDI1Ni4wKjI1Ni4wKSwgMS4wLygyNTYuMCoyNTYuMCoyNTYuMCkpO1xcbicgK1xyXG4gICAgICAgICAgICAnICBmbG9hdCBkZXB0aCA9IGRvdChyZ2JhRGVwdGgsIGJpdFNoaWZ0KTtcXG4nICsgLy8gVXNlIGRvdCgpIHNpbmNlIHRoZSBjYWxjdWxhdGlvbnMgaXMgc2FtZVxyXG4gICAgICAgICAgICAnICByZXR1cm4gZGVwdGg7XFxuJyArXHJcbiAgICAgICAgICAgICd9XFxuJyArXHJcblxyXG4gICAgICAgICAgICAnI2VuZGlmXFxuJyArXHJcblxyXG4gICAgICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xyXG4gICAgICAgICAgICAnICB2ZWM0IGNvbG9yID0gdV9Db2xvcjtcXG4nICtcclxuICAgICAgICAgICAgJyAgdmVjMyB2X05vcm1hbDAgPSBub3JtYWxpemUodl9Ob3JtYWwpO1xcbicgK1xyXG5cclxuICAgICAgICAgICAgJyNpZmRlZiBVU0VfTWFwXFxuJyArXHJcbiAgICAgICAgICAgICcgIGNvbG9yID0gdGV4dHVyZTJEKHVfU2FtcGxlciwgdl9UZXhDb29yZCk7XFxuJyArXHJcbiAgICAgICAgICAgICcjZW5kaWZcXG4nICtcclxuXHJcbiAgICAgICAgICAgICcgIHZlYzMgY29sb3JWMyA9IGNvbG9yLnJnYjtcXG4nICtcclxuICAgICAgICAgICAgJyAgZmxvYXQgdXNlTGlnaHQgPSAwLjA7XFxuJyArXHJcbiAgICAgICAgICAgICcgIHZlYzMgZmluYWxDb2xvclYzID0gY29sb3JWMy5yZ2I7XFxuJyArXHJcblxyXG4gICAgICAgICAgICAnI2lmZGVmIFVTRV9BbWJpZW50TGlnaHRcXG4nICtcclxuICAgICAgICAgICAgJyAgdmVjMyBBX2NvbG9yID0gY29sb3JWMyAqIHVfQW1iaWVudExpZ2h0X0NvbG9yICogMC41O1xcbicgK1xyXG4gICAgICAgICAgICAnICBmaW5hbENvbG9yVjMgPSBBX2NvbG9yO1xcbicgK1xyXG4gICAgICAgICAgICAnICB1c2VMaWdodCA9IDEuMDtcXG4nICtcclxuICAgICAgICAgICAgJyNlbmRpZlxcbicgK1xyXG5cclxuICAgICAgICAgICAgJyNpZmRlZiBVU0VfRGlyZWN0aW9uYWxMaWdodFxcbicgK1xyXG4gICAgICAgICAgICAnICBmbG9hdCBEX3dlaWdodCA9IG1heChkb3QodV9EaXJlY3Rpb25hbExpZ2h0X0RpcmVjdGlvbiwgdl9Ob3JtYWwwKSwgMC4wKTtcXG4nICtcclxuICAgICAgICAgICAgJyAgdmVjMyBEX2NvbG9yID0gY29sb3JWMyAqIHVfRGlyZWN0aW9uYWxMaWdodF9Db2xvciAqIERfd2VpZ2h0ICogKDEuMCAtIHVfTWV0YWxuZXNzKTtcXG4nICtcclxuXHJcbiAgICAgICAgICAgICcgIGlmKHVzZUxpZ2h0PjAuNSl7XFxuJyArXHJcbiAgICAgICAgICAgICcgICAgZmluYWxDb2xvclYzID0gZmluYWxDb2xvclYzICsgRF9jb2xvcjtcXG4nICtcclxuICAgICAgICAgICAgJyAgfWVsc2V7XFxuJyArXHJcbiAgICAgICAgICAgICcgICAgZmluYWxDb2xvclYzID0gRF9jb2xvcjtcXG4nICtcclxuICAgICAgICAgICAgJyAgfVxcbicgK1xyXG4gICAgICAgICAgICAnICB1c2VMaWdodCA9IDEuMDtcXG4nICtcclxuICAgICAgICAgICAgJyNlbmRpZlxcbicgK1xyXG5cclxuICAgICAgICAgICAgJyNpZmRlZiBVU0VfU0NvbG9yXFxuJyArXHJcbiAgICAgICAgICAgICcgIHZlYzMgciA9IG5vcm1hbGl6ZSggcmVmbGVjdCgtdV9EaXJlY3Rpb25hbExpZ2h0X0RpcmVjdGlvbiwgdl9Ob3JtYWwwKSApO1xcbicgK1xyXG4gICAgICAgICAgICAnICB2ZWMzIHYgPSBub3JtYWxpemUoIHVfQ2FtZXJhX1Bvc2l0aW9uIC0gdl9Qb3NpdGlvblYzICk7XFxuJyArXHJcbiAgICAgICAgICAgICcgIGZsb2F0IHJkb3R2ID0gbWF4KCBkb3QociAsdiksIDAuMCApO1xcbicgK1xyXG4gICAgICAgICAgICAnICBmbG9hdCBTX3dlaWdodCA9IHBvdyggcmRvdHYsIDEwMC4wICk7XFxuJyArXHJcbiAgICAgICAgICAgICcgIHZlYzMgU19jb2xvciA9IGNvbG9yVjMgKiB1X0RpcmVjdGlvbmFsTGlnaHRfQ29sb3IgKiBTX3dlaWdodCAqIHVfTWV0YWxuZXNzO1xcbicgK1xyXG5cclxuICAgICAgICAgICAgJyAgaWYodXNlTGlnaHQ+MC41KXtcXG4nICtcclxuICAgICAgICAgICAgJyAgICBmaW5hbENvbG9yVjMgPSBmaW5hbENvbG9yVjMgKyBTX2NvbG9yO1xcbicgK1xyXG4gICAgICAgICAgICAnICB9ZWxzZXtcXG4nICtcclxuICAgICAgICAgICAgJyAgICBmaW5hbENvbG9yVjMgPSBTX2NvbG9yO1xcbicgK1xyXG4gICAgICAgICAgICAnICB9XFxuJyArXHJcbiAgICAgICAgICAgICcgIHVzZUxpZ2h0ID0gMS4wO1xcbicgK1xyXG4gICAgICAgICAgICAnI2VuZGlmXFxuJyArXHJcblxyXG4gICAgICAgICAgICAnICBjb2xvciA9IHZlYzQoZmluYWxDb2xvclYzLCBjb2xvci5hKTtcXG4nICtcclxuXHJcbiAgICAgICAgICAgICcjaWZkZWYgVVNFX2Vudk1hcFxcbicgK1xyXG4gICAgICAgICAgICAvLyAnICAgdmVjMyB2MSA9IG5vcm1hbGl6ZSggdV9DYW1lcmFfUG9zaXRpb24gLSB2X1Bvc2l0aW9uVjMgKTtcXG4nICtcclxuICAgICAgICAgICAgLy8gJyAgIHZlYzMgcjEgPSBub3JtYWxpemUoIHJlZmxlY3QodjEsIHZfTm9ybWFsMCkgKTtcXG4nICtcclxuICAgICAgICAgICAgJyAgIHZlYzMgdjEgPSB1X0NhbWVyYV9Qb3NpdGlvbiAtIHZfUG9zaXRpb25WMztcXG4nICtcclxuICAgICAgICAgICAgJyAgIHZlYzMgcjEgPSByZWZsZWN0KC12MSwgdl9Ob3JtYWwwKTtcXG4nICtcclxuXHJcbiAgICAgICAgICAgICcgICB2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmUodV9lbnZNYXAsIHIxKTtcXG4nICtcclxuICAgICAgICAgICAgLy8gJyAgIHZlYzMgcmVmID0gdjEgLSAyLjAgKiBkb3Qodl9Ob3JtYWwwLCB2MSkgKiB2X05vcm1hbDA7XFxuJytcclxuICAgICAgICAgICAgLy8gJyAgIHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZSh1X2Vudk1hcCwgcmVmKTtcXG4nICtcclxuICAgICAgICAgICAgJyAgIGNvbG9yID0gdmVjNChlbnZNYXBDb2xvci5yZ2IsIGNvbG9yLmEpO1xcbicgK1xyXG4gICAgICAgICAgICAnI2VuZGlmXFxuJyArXHJcblxyXG5cclxuICAgICAgICAgICAgJyNpZmRlZiBVU0VfU2hhZG93XFxuJyArXHJcbiAgICAgICAgICAgICcgIHZlYzMgc2hhZG93Q29vcmQgPSAodl9Qb3NpdGlvbkZyb21MaWdodC54eXovdl9Qb3NpdGlvbkZyb21MaWdodC53KS8yLjAgKyAwLjU7XFxuJyArXHJcbiAgICAgICAgICAgICcgIHZlYzQgcmdiYURlcHRoID0gdGV4dHVyZTJEKHVfU2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSk7XFxuJyArXHJcbiAgICAgICAgICAgICcgIGZsb2F0IGRlcHRoID0gdW5wYWNrRGVwdGgocmdiYURlcHRoKTtcXG4nICtcclxuICAgICAgICAgICAgJyAgZmxvYXQgdmlzaWJpbGl0eSA9IChzaGFkb3dDb29yZC56ID4gZGVwdGggKyAwLjAwMTUpID8gMC43IDogMS4wO1xcbicgK1xyXG4gICAgICAgICAgICAnICBjb2xvciA9IHZlYzQoY29sb3IucmdiICogdmlzaWJpbGl0eSwgY29sb3IuYSk7XFxuJyArXHJcbiAgICAgICAgICAgICcjZW5kaWZcXG4nICtcclxuXHJcbiAgICAgICAgICAgICcgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xyXG5cclxuICAgICAgICAgICAgJ31cXG4nO1xyXG5cclxuICAgICAgICB0aGlzLnZzaGFkZXJTb3VyY2UgPSBWU0hBREVSX1NPVVJDRTtcclxuICAgICAgICB0aGlzLmZzaGFkZXJTb3VyY2UgPSBGU0hBREVSX1NPVVJDRTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRPcGFjaXR5KG9wYWNpdHkpe1xyXG4gICAgICAgIHRoaXMub3BhY2l0eSA9IG9wYWNpdHk7XHJcbiAgICAgICAgdGhpcy5jb2xvclszXSA9IG9wYWNpdHk7XHJcbiAgICAgICAgdGhpcy50cmFuc3BhcmVudCA9IG9wYWNpdHk8MTtcclxuICAgIH1cclxuXHJcbiAgICBjbG9uZSgpe1xyXG5cclxuICAgICAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgTWF0ZXJpYWwoe1xyXG4gICAgICAgICAgICBtYXA6IHRoaXMubWFwLFxyXG4gICAgICAgICAgICBjb2xvcjogdGhpcy5jb2xvci5zbGljZSgwKVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gbWF0ZXJpYWw7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNYXRlcmlhbDtcclxuIiwiaW1wb3J0IHsgUXVhdGVybmlvbiB9IGZyb20gJy4vUXVhdGVybmlvbi5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuL1ZlY3RvcjMuanMnO1xyXG5pbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi9NYXRyaXg0LmpzJztcclxuaW1wb3J0IHsgX01hdGggfSBmcm9tICcuL01hdGguanMnO1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gRXVsZXIoIHgsIHksIHosIG9yZGVyICkge1xyXG5cclxuXHR0aGlzLl94ID0geCB8fCAwO1xyXG5cdHRoaXMuX3kgPSB5IHx8IDA7XHJcblx0dGhpcy5feiA9IHogfHwgMDtcclxuXHR0aGlzLl9vcmRlciA9IG9yZGVyIHx8IEV1bGVyLkRlZmF1bHRPcmRlcjtcclxuXHJcbn1cclxuXHJcbkV1bGVyLlJvdGF0aW9uT3JkZXJzID0gWyAnWFlaJywgJ1laWCcsICdaWFknLCAnWFpZJywgJ1lYWicsICdaWVgnIF07XHJcblxyXG5FdWxlci5EZWZhdWx0T3JkZXIgPSAnWFlaJztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBFdWxlci5wcm90b3R5cGUsIHtcclxuXHJcblx0eDoge1xyXG5cclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuX3g7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl94ID0gdmFsdWU7XHJcblx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0eToge1xyXG5cclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuX3k7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl95ID0gdmFsdWU7XHJcblx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0ejoge1xyXG5cclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuX3o7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl96ID0gdmFsdWU7XHJcblx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0b3JkZXI6IHtcclxuXHJcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLl9vcmRlcjtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdHRoaXMuX29yZGVyID0gdmFsdWU7XHJcblx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufSApO1xyXG5cclxuT2JqZWN0LmFzc2lnbiggRXVsZXIucHJvdG90eXBlLCB7XHJcblxyXG5cdGlzRXVsZXI6IHRydWUsXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCB4LCB5LCB6LCBvcmRlciApIHtcclxuXHJcblx0XHR0aGlzLl94ID0geDtcclxuXHRcdHRoaXMuX3kgPSB5O1xyXG5cdFx0dGhpcy5feiA9IHo7XHJcblx0XHR0aGlzLl9vcmRlciA9IG9yZGVyIHx8IHRoaXMuX29yZGVyO1xyXG5cclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fb3JkZXIgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBldWxlciApIHtcclxuXHJcblx0XHR0aGlzLl94ID0gZXVsZXIuX3g7XHJcblx0XHR0aGlzLl95ID0gZXVsZXIuX3k7XHJcblx0XHR0aGlzLl96ID0gZXVsZXIuX3o7XHJcblx0XHR0aGlzLl9vcmRlciA9IGV1bGVyLl9vcmRlcjtcclxuXHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0sIG9yZGVyLCB1cGRhdGUgKSB7XHJcblxyXG5cdFx0dmFyIGNsYW1wID0gX01hdGguY2xhbXA7XHJcblxyXG5cdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcclxuXHJcblx0XHR2YXIgdGUgPSBtLmVsZW1lbnRzO1xyXG5cdFx0dmFyIG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF07XHJcblx0XHR2YXIgbTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXTtcclxuXHRcdHZhciBtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXTtcclxuXHJcblx0XHRvcmRlciA9IG9yZGVyIHx8IHRoaXMuX29yZGVyO1xyXG5cclxuXHRcdGlmICggb3JkZXIgPT09ICdYWVonICkge1xyXG5cclxuXHRcdFx0dGhpcy5feSA9IE1hdGguYXNpbiggY2xhbXAoIG0xMywgLSAxLCAxICkgKTtcclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIG0xMyApIDwgMC45OTk5OSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMzMgKTtcclxuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0xMSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTIyICk7XHJcblx0XHRcdFx0dGhpcy5feiA9IDA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWFonICkge1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IE1hdGguYXNpbiggLSBjbGFtcCggbTIzLCAtIDEsIDEgKSApO1xyXG5cclxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTIzICkgPCAwLjk5OTk5ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcclxuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMjIgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTExICk7XHJcblx0XHRcdFx0dGhpcy5feiA9IDA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWFknICkge1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IE1hdGguYXNpbiggY2xhbXAoIG0zMiwgLSAxLCAxICkgKTtcclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIG0zMiApIDwgMC45OTk5OSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMzMgKTtcclxuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0yMiApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feSA9IDA7XHJcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWVgnICkge1xyXG5cclxuXHRcdFx0dGhpcy5feSA9IE1hdGguYXNpbiggLSBjbGFtcCggbTMxLCAtIDEsIDEgKSApO1xyXG5cclxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTMxICkgPCAwLjk5OTk5ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMzMgKTtcclxuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMTEgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3ggPSAwO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTIyICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWlgnICkge1xyXG5cclxuXHRcdFx0dGhpcy5feiA9IE1hdGguYXNpbiggY2xhbXAoIG0yMSwgLSAxLCAxICkgKTtcclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIG0yMSApIDwgMC45OTk5OSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMjIgKTtcclxuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0xMSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feCA9IDA7XHJcblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTMzICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdYWlknICkge1xyXG5cclxuXHRcdFx0dGhpcy5feiA9IE1hdGguYXNpbiggLSBjbGFtcCggbTEyLCAtIDEsIDEgKSApO1xyXG5cclxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTEyICkgPCAwLjk5OTk5ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcclxuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMTEgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTMzICk7XHJcblx0XHRcdFx0dGhpcy5feSA9IDA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ0NPT0wuRXVsZXI6IC5zZXRGcm9tUm90YXRpb25NYXRyaXgoKSBnaXZlbiB1bnN1cHBvcnRlZCBvcmRlcjogJyArIG9yZGVyICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX29yZGVyID0gb3JkZXI7XHJcblxyXG5cdFx0aWYgKCB1cGRhdGUgIT09IGZhbHNlICkgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHNldEZyb21RdWF0ZXJuaW9uKCBxLCBvcmRlciwgdXBkYXRlICkge1xyXG5cclxuXHRcdFx0bWF0cml4Lm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG1hdHJpeCwgb3JkZXIsIHVwZGF0ZSApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0c2V0RnJvbVZlY3RvcjM6IGZ1bmN0aW9uICggdiwgb3JkZXIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0KCB2LngsIHYueSwgdi56LCBvcmRlciB8fCB0aGlzLl9vcmRlciApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyZW9yZGVyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gV0FSTklORzogdGhpcyBkaXNjYXJkcyByZXZvbHV0aW9uIGluZm9ybWF0aW9uIC1iaG91c3RvblxyXG5cclxuXHRcdHZhciBxID0gbmV3IFF1YXRlcm5pb24oKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gcmVvcmRlciggbmV3T3JkZXIgKSB7XHJcblxyXG5cdFx0XHRxLnNldEZyb21FdWxlciggdGhpcyApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0RnJvbVF1YXRlcm5pb24oIHEsIG5ld09yZGVyICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggZXVsZXIgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggZXVsZXIuX3ggPT09IHRoaXMuX3ggKSAmJiAoIGV1bGVyLl95ID09PSB0aGlzLl95ICkgJiYgKCBldWxlci5feiA9PT0gdGhpcy5feiApICYmICggZXVsZXIuX29yZGVyID09PSB0aGlzLl9vcmRlciApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XHJcblxyXG5cdFx0dGhpcy5feCA9IGFycmF5WyAwIF07XHJcblx0XHR0aGlzLl95ID0gYXJyYXlbIDEgXTtcclxuXHRcdHRoaXMuX3ogPSBhcnJheVsgMiBdO1xyXG5cdFx0aWYgKCBhcnJheVsgMyBdICE9PSB1bmRlZmluZWQgKSB0aGlzLl9vcmRlciA9IGFycmF5WyAzIF07XHJcblxyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xyXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5feDtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLl95O1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuX3o7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy5fb3JkZXI7XHJcblxyXG5cdFx0cmV0dXJuIGFycmF5O1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b1ZlY3RvcjM6IGZ1bmN0aW9uICggb3B0aW9uYWxSZXN1bHQgKSB7XHJcblxyXG5cdFx0aWYgKCBvcHRpb25hbFJlc3VsdCApIHtcclxuXHJcblx0XHRcdHJldHVybiBvcHRpb25hbFJlc3VsdC5zZXQoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3ogKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cmV0dXJuIG5ldyBWZWN0b3IzKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRvbkNoYW5nZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcclxuXHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0b25DaGFuZ2VDYWxsYmFjazogZnVuY3Rpb24gKCkge31cclxuXHJcbn0gKTtcclxuXHJcblxyXG5leHBvcnQgeyBFdWxlciB9O1xyXG4iLCIvKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cclxuICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIFZlY3RvcjIoIHgsIHkgKSB7XHJcblxyXG5cdHRoaXMueCA9IHggfHwgMDtcclxuXHR0aGlzLnkgPSB5IHx8IDA7XHJcblxyXG59XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVmVjdG9yMi5wcm90b3R5cGUsIHtcclxuXHJcblx0XCJ3aWR0aFwiOiB7XHJcblxyXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy54O1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gdmFsdWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRcImhlaWdodFwiOiB7XHJcblxyXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy55O1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0dGhpcy55ID0gdmFsdWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcblxyXG5PYmplY3QuYXNzaWduKCBWZWN0b3IyLnByb3RvdHlwZSwge1xyXG5cclxuXHRpc1ZlY3RvcjI6IHRydWUsXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCB4LCB5ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHg7XHJcblx0XHR0aGlzLnkgPSB5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHNjYWxhcjtcclxuXHRcdHRoaXMueSA9IHNjYWxhcjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WDogZnVuY3Rpb24gKCB4ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHg7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFk6IGZ1bmN0aW9uICggeSApIHtcclxuXHJcblx0XHR0aGlzLnkgPSB5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXgsIHZhbHVlICkge1xyXG5cclxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0Y2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xyXG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0Y2FzZSAwOiByZXR1cm4gdGhpcy54O1xyXG5cdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XHJcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHYueDtcclxuXHRcdHRoaXMueSA9IHYueTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkOiBmdW5jdGlvbiAoIHYsIHcgKSB7XHJcblxyXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdDT09MLlZlY3RvcjI6IC5hZGQoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5hZGRWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmFkZFZlY3RvcnMoIHYsIHcgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy54ICs9IHYueDtcclxuXHRcdHRoaXMueSArPSB2Lnk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMueCArPSBzO1xyXG5cdFx0dGhpcy55ICs9IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZFZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBhLnggKyBiLng7XHJcblx0XHR0aGlzLnkgPSBhLnkgKyBiLnk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZFNjYWxlZFZlY3RvcjogZnVuY3Rpb24gKCB2LCBzICkge1xyXG5cclxuXHRcdHRoaXMueCArPSB2LnggKiBzO1xyXG5cdFx0dGhpcy55ICs9IHYueSAqIHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHN1YjogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5WZWN0b3IyOiAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMueCAtPSB2Lng7XHJcblx0XHR0aGlzLnkgLT0gdi55O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzdWJTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcclxuXHJcblx0XHR0aGlzLnggLT0gcztcclxuXHRcdHRoaXMueSAtPSBzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzdWJWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gYS54IC0gYi54O1xyXG5cdFx0dGhpcy55ID0gYS55IC0gYi55O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCAqPSB2Lng7XHJcblx0XHR0aGlzLnkgKj0gdi55O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XHJcblxyXG5cdFx0dGhpcy54ICo9IHNjYWxhcjtcclxuXHRcdHRoaXMueSAqPSBzY2FsYXI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpdmlkZTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCAvPSB2Lng7XHJcblx0XHR0aGlzLnkgLz0gdi55O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gc2NhbGFyICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5TWF0cml4MzogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55O1xyXG5cdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyAzIF0gKiB5ICsgZVsgNiBdO1xyXG5cdFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA3IF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1pbjogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGgubWluKCB0aGlzLngsIHYueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5taW4oIHRoaXMueSwgdi55ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1heDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCB0aGlzLngsIHYueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIHRoaXMueSwgdi55ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsYW1wOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xyXG5cclxuXHRcdC8vIGFzc3VtZXMgbWluIDwgbWF4LCBjb21wb25lbnR3aXNlXHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIG1pbi54LCBNYXRoLm1pbiggbWF4LngsIHRoaXMueCApICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggbWluLnksIE1hdGgubWluKCBtYXgueSwgdGhpcy55ICkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xhbXBTY2FsYXI6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgbWluID0gbmV3IFZlY3RvcjIoKTtcclxuXHRcdHZhciBtYXggPSBuZXcgVmVjdG9yMigpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBjbGFtcFNjYWxhciggbWluVmFsLCBtYXhWYWwgKSB7XHJcblxyXG5cdFx0XHRtaW4uc2V0KCBtaW5WYWwsIG1pblZhbCApO1xyXG5cdFx0XHRtYXguc2V0KCBtYXhWYWwsIG1heFZhbCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuY2xhbXAoIG1pbiwgbWF4ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRjbGFtcExlbmd0aDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcclxuXHJcblx0XHR2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIGxlbmd0aCB8fCAxICkubXVsdGlwbHlTY2FsYXIoIE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIGxlbmd0aCApICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjZWlsOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdW5kOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0cm91bmRUb1plcm86IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcclxuXHRcdHRoaXMueSA9ICggdGhpcy55IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnkgKSA6IE1hdGguZmxvb3IoIHRoaXMueSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnggPSAtIHRoaXMueDtcclxuXHRcdHRoaXMueSA9IC0gdGhpcy55O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55O1xyXG5cclxuXHR9LFxyXG5cclxuXHRjcm9zczogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnggKiB2LnkgLSB0aGlzLnkgKiB2Lng7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueTtcclxuXHJcblx0fSxcclxuXHJcblx0bGVuZ3RoOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1hbmhhdHRhbkxlbmd0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSB8fCAxICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFuZ2xlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gY29tcHV0ZXMgdGhlIGFuZ2xlIGluIHJhZGlhbnMgd2l0aCByZXNwZWN0IHRvIHRoZSBwb3NpdGl2ZSB4LWF4aXNcclxuXHJcblx0XHR2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKCB0aGlzLnksIHRoaXMueCApO1xyXG5cclxuXHRcdGlmICggYW5nbGUgPCAwICkgYW5nbGUgKz0gMiAqIE1hdGguUEk7XHJcblxyXG5cdFx0cmV0dXJuIGFuZ2xlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVRvU3F1YXJlZCggdiApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3RhbmNlVG9TcXVhcmVkOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0dmFyIGR4ID0gdGhpcy54IC0gdi54LCBkeSA9IHRoaXMueSAtIHYueTtcclxuXHRcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcclxuXHJcblx0fSxcclxuXHJcblx0bWFuaGF0dGFuRGlzdGFuY2VUbzogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54IC0gdi54ICkgKyBNYXRoLmFicyggdGhpcy55IC0gdi55ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldExlbmd0aDogZnVuY3Rpb24gKCBsZW5ndGggKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIGxlbmd0aCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZXJwOiBmdW5jdGlvbiAoIHYsIGFscGhhICkge1xyXG5cclxuXHRcdHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XHJcblx0XHR0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZXJwVmVjdG9yczogZnVuY3Rpb24gKCB2MSwgdjIsIGFscGhhICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYyLCB2MSApLm11bHRpcGx5U2NhbGFyKCBhbHBoYSApLmFkZCggdjEgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHR0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XHJcblx0XHR0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XHJcblxyXG5cdFx0cmV0dXJuIGFycmF5O1xyXG5cclxuXHR9LFxyXG5cclxuXHRmcm9tQnVmZmVyQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIG9mZnNldCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5WZWN0b3IyOiBvZmZzZXQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIC5mcm9tQnVmZmVyQXR0cmlidXRlKCkuJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnggPSBhdHRyaWJ1dGUuZ2V0WCggaW5kZXggKTtcclxuXHRcdHRoaXMueSA9IGF0dHJpYnV0ZS5nZXRZKCBpbmRleCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyb3RhdGVBcm91bmQ6IGZ1bmN0aW9uICggY2VudGVyLCBhbmdsZSApIHtcclxuXHJcblx0XHR2YXIgYyA9IE1hdGguY29zKCBhbmdsZSApLCBzID0gTWF0aC5zaW4oIGFuZ2xlICk7XHJcblxyXG5cdFx0dmFyIHggPSB0aGlzLnggLSBjZW50ZXIueDtcclxuXHRcdHZhciB5ID0gdGhpcy55IC0gY2VudGVyLnk7XHJcblxyXG5cdFx0dGhpcy54ID0geCAqIGMgLSB5ICogcyArIGNlbnRlci54O1xyXG5cdFx0dGhpcy55ID0geCAqIHMgKyB5ICogYyArIGNlbnRlci55O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcblxyXG5cclxuZXhwb3J0IHsgVmVjdG9yMiB9O1xyXG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi9WZWN0b3IzLmpzJztcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gUmF5KCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcclxuXHJcblx0dGhpcy5vcmlnaW4gPSAoIG9yaWdpbiAhPT0gdW5kZWZpbmVkICkgPyBvcmlnaW4gOiBuZXcgVmVjdG9yMygpO1xyXG5cdHRoaXMuZGlyZWN0aW9uID0gKCBkaXJlY3Rpb24gIT09IHVuZGVmaW5lZCApID8gZGlyZWN0aW9uIDogbmV3IFZlY3RvcjMoKTtcclxuXHJcbn1cclxuXHJcbk9iamVjdC5hc3NpZ24oIFJheS5wcm90b3R5cGUsIHtcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIG9yaWdpbiwgZGlyZWN0aW9uICkge1xyXG5cclxuXHRcdHRoaXMub3JpZ2luLmNvcHkoIG9yaWdpbiApO1xyXG5cdFx0dGhpcy5kaXJlY3Rpb24uY29weSggZGlyZWN0aW9uICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHJheSApIHtcclxuXHJcblx0XHR0aGlzLm9yaWdpbi5jb3B5KCByYXkub3JpZ2luICk7XHJcblx0XHR0aGlzLmRpcmVjdGlvbi5jb3B5KCByYXkuZGlyZWN0aW9uICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGF0OiBmdW5jdGlvbiAoIHQsIHRhcmdldCApIHtcclxuXHJcblx0XHRpZiAoIHRhcmdldCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5SYXk6IC5hdCgpIHRhcmdldCBpcyBub3cgcmVxdWlyZWQnICk7XHJcblx0XHRcdHRhcmdldCA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0YXJnZXQuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy5vcmlnaW4gKTtcclxuXHJcblx0fSxcclxuXHJcblx0bG9va0F0OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0dGhpcy5kaXJlY3Rpb24uY29weSggdiApLnN1YiggdGhpcy5vcmlnaW4gKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0cmVjYXN0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gcmVjYXN0KCB0ICkge1xyXG5cclxuXHRcdFx0dGhpcy5vcmlnaW4uY29weSggdGhpcy5hdCggdCwgdjEgKSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRjbG9zZXN0UG9pbnRUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50LCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0aWYgKCB0YXJnZXQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ0NPT0wuUmF5OiAuY2xvc2VzdFBvaW50VG9Qb2ludCgpIHRhcmdldCBpcyBub3cgcmVxdWlyZWQnICk7XHJcblx0XHRcdHRhcmdldCA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRhcmdldC5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5vcmlnaW4gKTtcclxuXHJcblx0XHR2YXIgZGlyZWN0aW9uRGlzdGFuY2UgPSB0YXJnZXQuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xyXG5cclxuXHRcdGlmICggZGlyZWN0aW9uRGlzdGFuY2UgPCAwICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KCB0aGlzLm9yaWdpbiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIGRpcmVjdGlvbkRpc3RhbmNlICkuYWRkKCB0aGlzLm9yaWdpbiApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVNxVG9Qb2ludCggcG9pbnQgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVNxVG9Qb2ludDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGRpc3RhbmNlU3FUb1BvaW50KCBwb2ludCApIHtcclxuXHJcblx0XHRcdHZhciBkaXJlY3Rpb25EaXN0YW5jZSA9IHYxLnN1YlZlY3RvcnMoIHBvaW50LCB0aGlzLm9yaWdpbiApLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcclxuXHJcblx0XHRcdC8vIHBvaW50IGJlaGluZCB0aGUgcmF5XHJcblxyXG5cdFx0XHRpZiAoIGRpcmVjdGlvbkRpc3RhbmNlIDwgMCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXMub3JpZ2luLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0djEuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggZGlyZWN0aW9uRGlzdGFuY2UgKS5hZGQoIHRoaXMub3JpZ2luICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdjEuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRkaXN0YW5jZVNxVG9TZWdtZW50OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHNlZ0NlbnRlciA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHR2YXIgc2VnRGlyID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHZhciBkaWZmID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gZGlzdGFuY2VTcVRvU2VnbWVudCggdjAsIHYxLCBvcHRpb25hbFBvaW50T25SYXksIG9wdGlvbmFsUG9pbnRPblNlZ21lbnQgKSB7XHJcblxyXG5cdFx0XHQvLyBmcm9tIGh0dHA6Ly93d3cuZ2VvbWV0cmljdG9vbHMuY29tL0dURW5naW5lL0luY2x1ZGUvTWF0aGVtYXRpY3MvR3RlRGlzdFJheVNlZ21lbnQuaFxyXG5cdFx0XHQvLyBJdCByZXR1cm5zIHRoZSBtaW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgcmF5IGFuZCB0aGUgc2VnbWVudFxyXG5cdFx0XHQvLyBkZWZpbmVkIGJ5IHYwIGFuZCB2MVxyXG5cdFx0XHQvLyBJdCBjYW4gYWxzbyBzZXQgdHdvIG9wdGlvbmFsIHRhcmdldHMgOlxyXG5cdFx0XHQvLyAtIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSByYXlcclxuXHRcdFx0Ly8gLSBUaGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgc2VnbWVudFxyXG5cclxuXHRcdFx0c2VnQ2VudGVyLmNvcHkoIHYwICkuYWRkKCB2MSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcclxuXHRcdFx0c2VnRGlyLmNvcHkoIHYxICkuc3ViKCB2MCApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0XHRkaWZmLmNvcHkoIHRoaXMub3JpZ2luICkuc3ViKCBzZWdDZW50ZXIgKTtcclxuXHJcblx0XHRcdHZhciBzZWdFeHRlbnQgPSB2MC5kaXN0YW5jZVRvKCB2MSApICogMC41O1xyXG5cdFx0XHR2YXIgYTAxID0gLSB0aGlzLmRpcmVjdGlvbi5kb3QoIHNlZ0RpciApO1xyXG5cdFx0XHR2YXIgYjAgPSBkaWZmLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcclxuXHRcdFx0dmFyIGIxID0gLSBkaWZmLmRvdCggc2VnRGlyICk7XHJcblx0XHRcdHZhciBjID0gZGlmZi5sZW5ndGhTcSgpO1xyXG5cdFx0XHR2YXIgZGV0ID0gTWF0aC5hYnMoIDEgLSBhMDEgKiBhMDEgKTtcclxuXHRcdFx0dmFyIHMwLCBzMSwgc3FyRGlzdCwgZXh0RGV0O1xyXG5cclxuXHRcdFx0aWYgKCBkZXQgPiAwICkge1xyXG5cclxuXHRcdFx0XHQvLyBUaGUgcmF5IGFuZCBzZWdtZW50IGFyZSBub3QgcGFyYWxsZWwuXHJcblxyXG5cdFx0XHRcdHMwID0gYTAxICogYjEgLSBiMDtcclxuXHRcdFx0XHRzMSA9IGEwMSAqIGIwIC0gYjE7XHJcblx0XHRcdFx0ZXh0RGV0ID0gc2VnRXh0ZW50ICogZGV0O1xyXG5cclxuXHRcdFx0XHRpZiAoIHMwID49IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBzMSA+PSAtIGV4dERldCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggczEgPD0gZXh0RGV0ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHQvLyByZWdpb24gMFxyXG5cdFx0XHRcdFx0XHRcdC8vIE1pbmltdW0gYXQgaW50ZXJpb3IgcG9pbnRzIG9mIHJheSBhbmQgc2VnbWVudC5cclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIGludkRldCA9IDEgLyBkZXQ7XHJcblx0XHRcdFx0XHRcdFx0czAgKj0gaW52RGV0O1xyXG5cdFx0XHRcdFx0XHRcdHMxICo9IGludkRldDtcclxuXHRcdFx0XHRcdFx0XHRzcXJEaXN0ID0gczAgKiAoIHMwICsgYTAxICogczEgKyAyICogYjAgKSArIHMxICogKCBhMDEgKiBzMCArIHMxICsgMiAqIGIxICkgKyBjO1xyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDFcclxuXHJcblx0XHRcdFx0XHRcdFx0czEgPSBzZWdFeHRlbnQ7XHJcblx0XHRcdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHMxICsgYjAgKSApO1xyXG5cdFx0XHRcdFx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIHJlZ2lvbiA1XHJcblxyXG5cdFx0XHRcdFx0XHRzMSA9IC0gc2VnRXh0ZW50O1xyXG5cdFx0XHRcdFx0XHRzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogczEgKyBiMCApICk7XHJcblx0XHRcdFx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGlmICggczEgPD0gLSBleHREZXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyByZWdpb24gNFxyXG5cclxuXHRcdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIC0gYTAxICogc2VnRXh0ZW50ICsgYjAgKSApO1xyXG5cdFx0XHRcdFx0XHRzMSA9ICggczAgPiAwICkgPyAtIHNlZ0V4dGVudCA6IE1hdGgubWluKCBNYXRoLm1heCggLSBzZWdFeHRlbnQsIC0gYjEgKSwgc2VnRXh0ZW50ICk7XHJcblx0XHRcdFx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggczEgPD0gZXh0RGV0ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDNcclxuXHJcblx0XHRcdFx0XHRcdHMwID0gMDtcclxuXHRcdFx0XHRcdFx0czEgPSBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xyXG5cdFx0XHRcdFx0XHRzcXJEaXN0ID0gczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyByZWdpb24gMlxyXG5cclxuXHRcdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHNlZ0V4dGVudCArIGIwICkgKTtcclxuXHRcdFx0XHRcdFx0czEgPSAoIHMwID4gMCApID8gc2VnRXh0ZW50IDogTWF0aC5taW4oIE1hdGgubWF4KCAtIHNlZ0V4dGVudCwgLSBiMSApLCBzZWdFeHRlbnQgKTtcclxuXHRcdFx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIFJheSBhbmQgc2VnbWVudCBhcmUgcGFyYWxsZWwuXHJcblxyXG5cdFx0XHRcdHMxID0gKCBhMDEgPiAwICkgPyAtIHNlZ0V4dGVudCA6IHNlZ0V4dGVudDtcclxuXHRcdFx0XHRzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogczEgKyBiMCApICk7XHJcblx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggb3B0aW9uYWxQb2ludE9uUmF5ICkge1xyXG5cclxuXHRcdFx0XHRvcHRpb25hbFBvaW50T25SYXkuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggczAgKS5hZGQoIHRoaXMub3JpZ2luICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG9wdGlvbmFsUG9pbnRPblNlZ21lbnQgKSB7XHJcblxyXG5cdFx0XHRcdG9wdGlvbmFsUG9pbnRPblNlZ21lbnQuY29weSggc2VnRGlyICkubXVsdGlwbHlTY2FsYXIoIHMxICkuYWRkKCBzZWdDZW50ZXIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBzcXJEaXN0O1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0aW50ZXJzZWN0U3BoZXJlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0U3BoZXJlKCBzcGhlcmUsIHRhcmdldCApIHtcclxuXHJcblx0XHRcdHYxLnN1YlZlY3RvcnMoIHNwaGVyZS5jZW50ZXIsIHRoaXMub3JpZ2luICk7XHJcblx0XHRcdHZhciB0Y2EgPSB2MS5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XHJcblx0XHRcdHZhciBkMiA9IHYxLmRvdCggdjEgKSAtIHRjYSAqIHRjYTtcclxuXHRcdFx0dmFyIHJhZGl1czIgPSBzcGhlcmUucmFkaXVzICogc3BoZXJlLnJhZGl1cztcclxuXHJcblx0XHRcdGlmICggZDIgPiByYWRpdXMyICkgcmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHR2YXIgdGhjID0gTWF0aC5zcXJ0KCByYWRpdXMyIC0gZDIgKTtcclxuXHJcblx0XHRcdC8vIHQwID0gZmlyc3QgaW50ZXJzZWN0IHBvaW50IC0gZW50cmFuY2Ugb24gZnJvbnQgb2Ygc3BoZXJlXHJcblx0XHRcdHZhciB0MCA9IHRjYSAtIHRoYztcclxuXHJcblx0XHRcdC8vIHQxID0gc2Vjb25kIGludGVyc2VjdCBwb2ludCAtIGV4aXQgcG9pbnQgb24gYmFjayBvZiBzcGhlcmVcclxuXHRcdFx0dmFyIHQxID0gdGNhICsgdGhjO1xyXG5cclxuXHRcdFx0Ly8gdGVzdCB0byBzZWUgaWYgYm90aCB0MCBhbmQgdDEgYXJlIGJlaGluZCB0aGUgcmF5IC0gaWYgc28sIHJldHVybiBudWxsXHJcblx0XHRcdGlmICggdDAgPCAwICYmIHQxIDwgMCApIHJldHVybiBudWxsO1xyXG5cclxuXHRcdFx0Ly8gdGVzdCB0byBzZWUgaWYgdDAgaXMgYmVoaW5kIHRoZSByYXk6XHJcblx0XHRcdC8vIGlmIGl0IGlzLCB0aGUgcmF5IGlzIGluc2lkZSB0aGUgc3BoZXJlLCBzbyByZXR1cm4gdGhlIHNlY29uZCBleGl0IHBvaW50IHNjYWxlZCBieSB0MSxcclxuXHRcdFx0Ly8gaW4gb3JkZXIgdG8gYWx3YXlzIHJldHVybiBhbiBpbnRlcnNlY3QgcG9pbnQgdGhhdCBpcyBpbiBmcm9udCBvZiB0aGUgcmF5LlxyXG5cdFx0XHRpZiAoIHQwIDwgMCApIHJldHVybiB0aGlzLmF0KCB0MSwgdGFyZ2V0ICk7XHJcblxyXG5cdFx0XHQvLyBlbHNlIHQwIGlzIGluIGZyb250IG9mIHRoZSByYXksIHNvIHJldHVybiB0aGUgZmlyc3QgY29sbGlzaW9uIHBvaW50IHNjYWxlZCBieSB0MFxyXG5cdFx0XHRyZXR1cm4gdGhpcy5hdCggdDAsIHRhcmdldCApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0aW50ZXJzZWN0c1NwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZGlzdGFuY2VTcVRvUG9pbnQoIHNwaGVyZS5jZW50ZXIgKSA8PSAoIHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3RhbmNlVG9QbGFuZTogZnVuY3Rpb24gKCBwbGFuZSApIHtcclxuXHJcblx0XHR2YXIgZGVub21pbmF0b3IgPSBwbGFuZS5ub3JtYWwuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xyXG5cclxuXHRcdGlmICggZGVub21pbmF0b3IgPT09IDAgKSB7XHJcblxyXG5cdFx0XHQvLyBsaW5lIGlzIGNvcGxhbmFyLCByZXR1cm4gb3JpZ2luXHJcblx0XHRcdGlmICggcGxhbmUuZGlzdGFuY2VUb1BvaW50KCB0aGlzLm9yaWdpbiApID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gMDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIE51bGwgaXMgcHJlZmVyYWJsZSB0byB1bmRlZmluZWQgc2luY2UgdW5kZWZpbmVkIG1lYW5zLi4uLiBpdCBpcyB1bmRlZmluZWRcclxuXHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdCA9IC0gKCB0aGlzLm9yaWdpbi5kb3QoIHBsYW5lLm5vcm1hbCApICsgcGxhbmUuY29uc3RhbnQgKSAvIGRlbm9taW5hdG9yO1xyXG5cclxuXHRcdC8vIFJldHVybiBpZiB0aGUgcmF5IG5ldmVyIGludGVyc2VjdHMgdGhlIHBsYW5lXHJcblxyXG5cdFx0cmV0dXJuIHQgPj0gMCA/IHQgOiBudWxsO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbnRlcnNlY3RQbGFuZTogZnVuY3Rpb24gKCBwbGFuZSwgdGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciB0ID0gdGhpcy5kaXN0YW5jZVRvUGxhbmUoIHBsYW5lICk7XHJcblxyXG5cdFx0aWYgKCB0ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmF0KCB0LCB0YXJnZXQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0aW50ZXJzZWN0c1BsYW5lOiBmdW5jdGlvbiAoIHBsYW5lICkge1xyXG5cclxuXHRcdC8vIGNoZWNrIGlmIHRoZSByYXkgbGllcyBvbiB0aGUgcGxhbmUgZmlyc3RcclxuXHJcblx0XHR2YXIgZGlzdFRvUG9pbnQgPSBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHRoaXMub3JpZ2luICk7XHJcblxyXG5cdFx0aWYgKCBkaXN0VG9Qb2ludCA9PT0gMCApIHtcclxuXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZGVub21pbmF0b3IgPSBwbGFuZS5ub3JtYWwuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xyXG5cclxuXHRcdGlmICggZGVub21pbmF0b3IgKiBkaXN0VG9Qb2ludCA8IDAgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcmF5IG9yaWdpbiBpcyBiZWhpbmQgdGhlIHBsYW5lIChhbmQgaXMgcG9pbnRpbmcgYmVoaW5kIGl0KVxyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0fSxcclxuXHJcblx0aW50ZXJzZWN0Qm94OiBmdW5jdGlvbiAoIGJveCwgdGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciB0bWluLCB0bWF4LCB0eW1pbiwgdHltYXgsIHR6bWluLCB0em1heDtcclxuXHJcblx0XHR2YXIgaW52ZGlyeCA9IDEgLyB0aGlzLmRpcmVjdGlvbi54LFxyXG5cdFx0XHRpbnZkaXJ5ID0gMSAvIHRoaXMuZGlyZWN0aW9uLnksXHJcblx0XHRcdGludmRpcnogPSAxIC8gdGhpcy5kaXJlY3Rpb24uejtcclxuXHJcblx0XHR2YXIgb3JpZ2luID0gdGhpcy5vcmlnaW47XHJcblxyXG5cdFx0aWYgKCBpbnZkaXJ4ID49IDAgKSB7XHJcblxyXG5cdFx0XHR0bWluID0gKCBib3gubWluLnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcclxuXHRcdFx0dG1heCA9ICggYm94Lm1heC54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRtaW4gPSAoIGJveC5tYXgueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xyXG5cdFx0XHR0bWF4ID0gKCBib3gubWluLnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBpbnZkaXJ5ID49IDAgKSB7XHJcblxyXG5cdFx0XHR0eW1pbiA9ICggYm94Lm1pbi55IC0gb3JpZ2luLnkgKSAqIGludmRpcnk7XHJcblx0XHRcdHR5bWF4ID0gKCBib3gubWF4LnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dHltaW4gPSAoIGJveC5tYXgueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xyXG5cdFx0XHR0eW1heCA9ICggYm94Lm1pbi55IC0gb3JpZ2luLnkgKSAqIGludmRpcnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggKCB0bWluID4gdHltYXggKSB8fCAoIHR5bWluID4gdG1heCApICkgcmV0dXJuIG51bGw7XHJcblxyXG5cdFx0Ly8gVGhlc2UgbGluZXMgYWxzbyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdG1pbiBvciB0bWF4IGlzIE5hTlxyXG5cdFx0Ly8gKHJlc3VsdCBvZiAwICogSW5maW5pdHkpLiB4ICE9PSB4IHJldHVybnMgdHJ1ZSBpZiB4IGlzIE5hTlxyXG5cclxuXHRcdGlmICggdHltaW4gPiB0bWluIHx8IHRtaW4gIT09IHRtaW4gKSB0bWluID0gdHltaW47XHJcblxyXG5cdFx0aWYgKCB0eW1heCA8IHRtYXggfHwgdG1heCAhPT0gdG1heCApIHRtYXggPSB0eW1heDtcclxuXHJcblx0XHRpZiAoIGludmRpcnogPj0gMCApIHtcclxuXHJcblx0XHRcdHR6bWluID0gKCBib3gubWluLnogLSBvcmlnaW4ueiApICogaW52ZGlyejtcclxuXHRcdFx0dHptYXggPSAoIGJveC5tYXgueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0em1pbiA9ICggYm94Lm1heC56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XHJcblx0XHRcdHR6bWF4ID0gKCBib3gubWluLnogLSBvcmlnaW4ueiApICogaW52ZGlyejtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCAoIHRtaW4gPiB0em1heCApIHx8ICggdHptaW4gPiB0bWF4ICkgKSByZXR1cm4gbnVsbDtcclxuXHJcblx0XHRpZiAoIHR6bWluID4gdG1pbiB8fCB0bWluICE9PSB0bWluICkgdG1pbiA9IHR6bWluO1xyXG5cclxuXHRcdGlmICggdHptYXggPCB0bWF4IHx8IHRtYXggIT09IHRtYXggKSB0bWF4ID0gdHptYXg7XHJcblxyXG5cdFx0Ly9yZXR1cm4gcG9pbnQgY2xvc2VzdCB0byB0aGUgcmF5IChwb3NpdGl2ZSBzaWRlKVxyXG5cclxuXHRcdGlmICggdG1heCA8IDAgKSByZXR1cm4gbnVsbDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hdCggdG1pbiA+PSAwID8gdG1pbiA6IHRtYXgsIHRhcmdldCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbnRlcnNlY3RzQm94OiAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdiA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdHNCb3goIGJveCApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmludGVyc2VjdEJveCggYm94LCB2ICkgIT09IG51bGw7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSApKCksXHJcblxyXG5cdGludGVyc2VjdFRyaWFuZ2xlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gQ29tcHV0ZSB0aGUgb2Zmc2V0IG9yaWdpbiwgZWRnZXMsIGFuZCBub3JtYWwuXHJcblx0XHR2YXIgZGlmZiA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHR2YXIgZWRnZTEgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0dmFyIGVkZ2UyID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHZhciBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RUcmlhbmdsZSggYSwgYiwgYywgYmFja2ZhY2VDdWxsaW5nLCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0XHQvLyBmcm9tIGh0dHA6Ly93d3cuZ2VvbWV0cmljdG9vbHMuY29tL0dURW5naW5lL0luY2x1ZGUvTWF0aGVtYXRpY3MvR3RlSW50clJheTNUcmlhbmdsZTMuaFxyXG5cclxuXHRcdFx0ZWRnZTEuc3ViVmVjdG9ycyggYiwgYSApO1xyXG5cdFx0XHRlZGdlMi5zdWJWZWN0b3JzKCBjLCBhICk7XHJcblx0XHRcdG5vcm1hbC5jcm9zc1ZlY3RvcnMoIGVkZ2UxLCBlZGdlMiApO1xyXG5cclxuXHRcdFx0Ly8gU29sdmUgUSArIHQqRCA9IGIxKkUxICsgYjIqRTIgKFEgPSBrRGlmZiwgRCA9IHJheSBkaXJlY3Rpb24sXHJcblx0XHRcdC8vIEUxID0ga0VkZ2UxLCBFMiA9IGtFZGdlMiwgTiA9IENyb3NzKEUxLEUyKSkgYnlcclxuXHRcdFx0Ly8gICB8RG90KEQsTil8KmIxID0gc2lnbihEb3QoRCxOKSkqRG90KEQsQ3Jvc3MoUSxFMikpXHJcblx0XHRcdC8vICAgfERvdChELE4pfCpiMiA9IHNpZ24oRG90KEQsTikpKkRvdChELENyb3NzKEUxLFEpKVxyXG5cdFx0XHQvLyAgIHxEb3QoRCxOKXwqdCA9IC1zaWduKERvdChELE4pKSpEb3QoUSxOKVxyXG5cdFx0XHR2YXIgRGROID0gdGhpcy5kaXJlY3Rpb24uZG90KCBub3JtYWwgKTtcclxuXHRcdFx0dmFyIHNpZ247XHJcblxyXG5cdFx0XHRpZiAoIERkTiA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggYmFja2ZhY2VDdWxsaW5nICkgcmV0dXJuIG51bGw7XHJcblx0XHRcdFx0c2lnbiA9IDE7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBEZE4gPCAwICkge1xyXG5cclxuXHRcdFx0XHRzaWduID0gLSAxO1xyXG5cdFx0XHRcdERkTiA9IC0gRGROO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRkaWZmLnN1YlZlY3RvcnMoIHRoaXMub3JpZ2luLCBhICk7XHJcblx0XHRcdHZhciBEZFF4RTIgPSBzaWduICogdGhpcy5kaXJlY3Rpb24uZG90KCBlZGdlMi5jcm9zc1ZlY3RvcnMoIGRpZmYsIGVkZ2UyICkgKTtcclxuXHJcblx0XHRcdC8vIGIxIDwgMCwgbm8gaW50ZXJzZWN0aW9uXHJcblx0XHRcdGlmICggRGRReEUyIDwgMCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgRGRFMXhRID0gc2lnbiAqIHRoaXMuZGlyZWN0aW9uLmRvdCggZWRnZTEuY3Jvc3MoIGRpZmYgKSApO1xyXG5cclxuXHRcdFx0Ly8gYjIgPCAwLCBubyBpbnRlcnNlY3Rpb25cclxuXHRcdFx0aWYgKCBEZEUxeFEgPCAwICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGIxK2IyID4gMSwgbm8gaW50ZXJzZWN0aW9uXHJcblx0XHRcdGlmICggRGRReEUyICsgRGRFMXhRID4gRGROICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIExpbmUgaW50ZXJzZWN0cyB0cmlhbmdsZSwgY2hlY2sgaWYgcmF5IGRvZXMuXHJcblx0XHRcdHZhciBRZE4gPSAtIHNpZ24gKiBkaWZmLmRvdCggbm9ybWFsICk7XHJcblxyXG5cdFx0XHQvLyB0IDwgMCwgbm8gaW50ZXJzZWN0aW9uXHJcblx0XHRcdGlmICggUWROIDwgMCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBSYXkgaW50ZXJzZWN0cyB0cmlhbmdsZS5cclxuXHRcdFx0cmV0dXJuIHRoaXMuYXQoIFFkTiAvIERkTiwgdGFyZ2V0ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbWF0cml4NCApIHtcclxuXHJcblx0XHR0aGlzLm9yaWdpbi5hcHBseU1hdHJpeDQoIG1hdHJpeDQgKTtcclxuXHRcdHRoaXMuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbiggbWF0cml4NCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggcmF5ICkge1xyXG5cclxuXHRcdHJldHVybiByYXkub3JpZ2luLmVxdWFscyggdGhpcy5vcmlnaW4gKSAmJiByYXkuZGlyZWN0aW9uLmVxdWFscyggdGhpcy5kaXJlY3Rpb24gKTtcclxuXHJcblx0fVxyXG5cclxufSApO1xyXG5cclxuXHJcbmV4cG9ydCB7IFJheSB9O1xyXG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi9WZWN0b3IzLmpzJztcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gVHJpYW5nbGUoIGEsIGIsIGMgKSB7XHJcblxyXG5cdHRoaXMuYSA9ICggYSAhPT0gdW5kZWZpbmVkICkgPyBhIDogbmV3IFZlY3RvcjMoKTtcclxuXHR0aGlzLmIgPSAoIGIgIT09IHVuZGVmaW5lZCApID8gYiA6IG5ldyBWZWN0b3IzKCk7XHJcblx0dGhpcy5jID0gKCBjICE9PSB1bmRlZmluZWQgKSA/IGMgOiBuZXcgVmVjdG9yMygpO1xyXG5cclxufVxyXG5cclxuT2JqZWN0LmFzc2lnbiggVHJpYW5nbGUsIHtcclxuXHJcblx0Z2V0Tm9ybWFsOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYwID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0Tm9ybWFsKCBhLCBiLCBjLCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRhcmdldCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdDT09MLlRyaWFuZ2xlOiAuZ2V0Tm9ybWFsKCkgdGFyZ2V0IGlzIG5vdyByZXF1aXJlZCcgKTtcclxuXHRcdFx0XHR0YXJnZXQgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGFyZ2V0LnN1YlZlY3RvcnMoIGMsIGIgKTtcclxuXHRcdFx0djAuc3ViVmVjdG9ycyggYSwgYiApO1xyXG5cdFx0XHR0YXJnZXQuY3Jvc3MoIHYwICk7XHJcblxyXG5cdFx0XHR2YXIgdGFyZ2V0TGVuZ3RoU3EgPSB0YXJnZXQubGVuZ3RoU3EoKTtcclxuXHRcdFx0aWYgKCB0YXJnZXRMZW5ndGhTcSA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0YXJnZXQubXVsdGlwbHlTY2FsYXIoIDEgLyBNYXRoLnNxcnQoIHRhcmdldExlbmd0aFNxICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0YXJnZXQuc2V0KCAwLCAwLCAwICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHQvLyBzdGF0aWMvaW5zdGFuY2UgbWV0aG9kIHRvIGNhbGN1bGF0ZSBiYXJ5Y2VudHJpYyBjb29yZGluYXRlc1xyXG5cdC8vIGJhc2VkIG9uOiBodHRwOi8vd3d3LmJsYWNrcGF3bi5jb20vdGV4dHMvcG9pbnRpbnBvbHkvZGVmYXVsdC5odG1sXHJcblx0Z2V0QmFyeWNvb3JkOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYwID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHR2YXIgdjIgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRCYXJ5Y29vcmQoIHBvaW50LCBhLCBiLCBjLCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0XHR2MC5zdWJWZWN0b3JzKCBjLCBhICk7XHJcblx0XHRcdHYxLnN1YlZlY3RvcnMoIGIsIGEgKTtcclxuXHRcdFx0djIuc3ViVmVjdG9ycyggcG9pbnQsIGEgKTtcclxuXHJcblx0XHRcdHZhciBkb3QwMCA9IHYwLmRvdCggdjAgKTtcclxuXHRcdFx0dmFyIGRvdDAxID0gdjAuZG90KCB2MSApO1xyXG5cdFx0XHR2YXIgZG90MDIgPSB2MC5kb3QoIHYyICk7XHJcblx0XHRcdHZhciBkb3QxMSA9IHYxLmRvdCggdjEgKTtcclxuXHRcdFx0dmFyIGRvdDEyID0gdjEuZG90KCB2MiApO1xyXG5cclxuXHRcdFx0dmFyIGRlbm9tID0gKCBkb3QwMCAqIGRvdDExIC0gZG90MDEgKiBkb3QwMSApO1xyXG5cclxuXHRcdFx0aWYgKCB0YXJnZXQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5UcmlhbmdsZTogLmdldEJhcnljb29yZCgpIHRhcmdldCBpcyBub3cgcmVxdWlyZWQnICk7XHJcblx0XHRcdFx0dGFyZ2V0ID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGNvbGxpbmVhciBvciBzaW5ndWxhciB0cmlhbmdsZVxyXG5cdFx0XHRpZiAoIGRlbm9tID09PSAwICkge1xyXG5cclxuXHRcdFx0XHQvLyBhcmJpdHJhcnkgbG9jYXRpb24gb3V0c2lkZSBvZiB0cmlhbmdsZT9cclxuXHRcdFx0XHQvLyBub3Qgc3VyZSBpZiB0aGlzIGlzIHRoZSBiZXN0IGlkZWEsIG1heWJlIHNob3VsZCBiZSByZXR1cm5pbmcgdW5kZWZpbmVkXHJcblx0XHRcdFx0cmV0dXJuIHRhcmdldC5zZXQoIC0gMiwgLSAxLCAtIDEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBpbnZEZW5vbSA9IDEgLyBkZW5vbTtcclxuXHRcdFx0dmFyIHUgPSAoIGRvdDExICogZG90MDIgLSBkb3QwMSAqIGRvdDEyICkgKiBpbnZEZW5vbTtcclxuXHRcdFx0dmFyIHYgPSAoIGRvdDAwICogZG90MTIgLSBkb3QwMSAqIGRvdDAyICkgKiBpbnZEZW5vbTtcclxuXHJcblx0XHRcdC8vIGJhcnljZW50cmljIGNvb3JkaW5hdGVzIG11c3QgYWx3YXlzIHN1bSB0byAxXHJcblx0XHRcdHJldHVybiB0YXJnZXQuc2V0KCAxIC0gdSAtIHYsIHYsIHUgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBjb250YWluc1BvaW50KCBwb2ludCwgYSwgYiwgYyApIHtcclxuXHJcblx0XHRcdFRyaWFuZ2xlLmdldEJhcnljb29yZCggcG9pbnQsIGEsIGIsIGMsIHYxICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gKCB2MS54ID49IDAgKSAmJiAoIHYxLnkgPj0gMCApICYmICggKCB2MS54ICsgdjEueSApIDw9IDEgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGdldFVWOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGJhcnljb29yZCA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGdldFVWKCBwb2ludCwgcDEsIHAyLCBwMywgdXYxLCB1djIsIHV2MywgdGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0dGhpcy5nZXRCYXJ5Y29vcmQoIHBvaW50LCBwMSwgcDIsIHAzLCBiYXJ5Y29vcmQgKTtcclxuXHJcblx0XHRcdHRhcmdldC5zZXQoIDAsIDAgKTtcclxuXHRcdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3RvciggdXYxLCBiYXJ5Y29vcmQueCApO1xyXG5cdFx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCB1djIsIGJhcnljb29yZC55ICk7XHJcblx0XHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIHV2MywgYmFyeWNvb3JkLnogKTtcclxuXHJcblx0XHRcdHJldHVybiB0YXJnZXQ7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpXHJcblxyXG59ICk7XHJcblxyXG5PYmplY3QuYXNzaWduKCBUcmlhbmdsZS5wcm90b3R5cGUsIHtcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIGEsIGIsIGMgKSB7XHJcblxyXG5cdFx0dGhpcy5hLmNvcHkoIGEgKTtcclxuXHRcdHRoaXMuYi5jb3B5KCBiICk7XHJcblx0XHR0aGlzLmMuY29weSggYyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tUG9pbnRzQW5kSW5kaWNlczogZnVuY3Rpb24gKCBwb2ludHMsIGkwLCBpMSwgaTIgKSB7XHJcblxyXG5cdFx0dGhpcy5hLmNvcHkoIHBvaW50c1sgaTAgXSApO1xyXG5cdFx0dGhpcy5iLmNvcHkoIHBvaW50c1sgaTEgXSApO1xyXG5cdFx0dGhpcy5jLmNvcHkoIHBvaW50c1sgaTIgXSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCB0cmlhbmdsZSApIHtcclxuXHJcblx0XHR0aGlzLmEuY29weSggdHJpYW5nbGUuYSApO1xyXG5cdFx0dGhpcy5iLmNvcHkoIHRyaWFuZ2xlLmIgKTtcclxuXHRcdHRoaXMuYy5jb3B5KCB0cmlhbmdsZS5jICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEFyZWE6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjAgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0QXJlYSgpIHtcclxuXHJcblx0XHRcdHYwLnN1YlZlY3RvcnMoIHRoaXMuYywgdGhpcy5iICk7XHJcblx0XHRcdHYxLnN1YlZlY3RvcnMoIHRoaXMuYSwgdGhpcy5iICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdjAuY3Jvc3MoIHYxICkubGVuZ3RoKCkgKiAwLjU7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRnZXRNaWRwb2ludDogZnVuY3Rpb24gKCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0aWYgKCB0YXJnZXQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ0NPT0wuVHJpYW5nbGU6IC5nZXRNaWRwb2ludCgpIHRhcmdldCBpcyBub3cgcmVxdWlyZWQnICk7XHJcblx0XHRcdHRhcmdldCA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0YXJnZXQuYWRkVmVjdG9ycyggdGhpcy5hLCB0aGlzLmIgKS5hZGQoIHRoaXMuYyApLm11bHRpcGx5U2NhbGFyKCAxIC8gMyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXROb3JtYWw6IGZ1bmN0aW9uICggdGFyZ2V0ICkge1xyXG5cclxuXHRcdHJldHVybiBUcmlhbmdsZS5nZXROb3JtYWwoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIHRhcmdldCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRQbGFuZTogZnVuY3Rpb24gKCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0aWYgKCB0YXJnZXQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ0NPT0wuVHJpYW5nbGU6IC5nZXRQbGFuZSgpIHRhcmdldCBpcyBub3cgcmVxdWlyZWQnICk7XHJcblx0XHRcdHRhcmdldCA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0YXJnZXQuc2V0RnJvbUNvcGxhbmFyUG9pbnRzKCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEJhcnljb29yZDogZnVuY3Rpb24gKCBwb2ludCwgdGFyZ2V0ICkge1xyXG5cclxuXHRcdHJldHVybiBUcmlhbmdsZS5nZXRCYXJ5Y29vcmQoIHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCB0YXJnZXQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHRyZXR1cm4gVHJpYW5nbGUuY29udGFpbnNQb2ludCggcG9pbnQsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0VVY6IGZ1bmN0aW9uICggcG9pbnQsIHV2MSwgdXYyLCB1djMsIHJlc3VsdCApIHtcclxuXHJcblx0XHRyZXR1cm4gVHJpYW5nbGUuZ2V0VVYoIHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCB1djEsIHV2MiwgdXYzLCByZXN1bHQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0aW50ZXJzZWN0c0JveDogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0cmV0dXJuIGJveC5pbnRlcnNlY3RzVHJpYW5nbGUoIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvc2VzdFBvaW50VG9Qb2ludDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2YWIgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0dmFyIHZhYyA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHR2YXIgdmJjID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHZhciB2YXAgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0dmFyIHZicCA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHR2YXIgdmNwID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gY2xvc2VzdFBvaW50VG9Qb2ludCggcCwgdGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0aWYgKCB0YXJnZXQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5UcmlhbmdsZTogLmNsb3Nlc3RQb2ludFRvUG9pbnQoKSB0YXJnZXQgaXMgbm93IHJlcXVpcmVkJyApO1xyXG5cdFx0XHRcdHRhcmdldCA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgYSA9IHRoaXMuYSwgYiA9IHRoaXMuYiwgYyA9IHRoaXMuYztcclxuXHRcdFx0dmFyIHYsIHc7XHJcblxyXG5cdFx0XHQvLyBhbGdvcml0aG0gdGhhbmtzIHRvIFJlYWwtVGltZSBDb2xsaXNpb24gRGV0ZWN0aW9uIGJ5IENocmlzdGVyIEVyaWNzb24sXHJcblx0XHRcdC8vIHB1Ymxpc2hlZCBieSBNb3JnYW4gS2F1Zm1hbm4gUHVibGlzaGVycywgKGMpIDIwMDUgRWxzZXZpZXIgSW5jLixcclxuXHRcdFx0Ly8gdW5kZXIgdGhlIGFjY29tcGFueWluZyBsaWNlbnNlOyBzZWUgY2hhcHRlciA1LjEuNSBmb3IgZGV0YWlsZWQgZXhwbGFuYXRpb24uXHJcblx0XHRcdC8vIGJhc2ljYWxseSwgd2UncmUgZGlzdGluZ3Vpc2hpbmcgd2hpY2ggb2YgdGhlIHZvcm9ub2kgcmVnaW9ucyBvZiB0aGUgdHJpYW5nbGVcclxuXHRcdFx0Ly8gdGhlIHBvaW50IGxpZXMgaW4gd2l0aCB0aGUgbWluaW11bSBhbW91bnQgb2YgcmVkdW5kYW50IGNvbXB1dGF0aW9uLlxyXG5cclxuXHRcdFx0dmFiLnN1YlZlY3RvcnMoIGIsIGEgKTtcclxuXHRcdFx0dmFjLnN1YlZlY3RvcnMoIGMsIGEgKTtcclxuXHRcdFx0dmFwLnN1YlZlY3RvcnMoIHAsIGEgKTtcclxuXHRcdFx0dmFyIGQxID0gdmFiLmRvdCggdmFwICk7XHJcblx0XHRcdHZhciBkMiA9IHZhYy5kb3QoIHZhcCApO1xyXG5cdFx0XHRpZiAoIGQxIDw9IDAgJiYgZDIgPD0gMCApIHtcclxuXHJcblx0XHRcdFx0Ly8gdmVydGV4IHJlZ2lvbiBvZiBBOyBiYXJ5Y2VudHJpYyBjb29yZHMgKDEsIDAsIDApXHJcblx0XHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBhICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YnAuc3ViVmVjdG9ycyggcCwgYiApO1xyXG5cdFx0XHR2YXIgZDMgPSB2YWIuZG90KCB2YnAgKTtcclxuXHRcdFx0dmFyIGQ0ID0gdmFjLmRvdCggdmJwICk7XHJcblx0XHRcdGlmICggZDMgPj0gMCAmJiBkNCA8PSBkMyApIHtcclxuXHJcblx0XHRcdFx0Ly8gdmVydGV4IHJlZ2lvbiBvZiBCOyBiYXJ5Y2VudHJpYyBjb29yZHMgKDAsIDEsIDApXHJcblx0XHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBiICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgdmMgPSBkMSAqIGQ0IC0gZDMgKiBkMjtcclxuXHRcdFx0aWYgKCB2YyA8PSAwICYmIGQxID49IDAgJiYgZDMgPD0gMCApIHtcclxuXHJcblx0XHRcdFx0diA9IGQxIC8gKCBkMSAtIGQzICk7XHJcblx0XHRcdFx0Ly8gZWRnZSByZWdpb24gb2YgQUI7IGJhcnljZW50cmljIGNvb3JkcyAoMS12LCB2LCAwKVxyXG5cdFx0XHRcdHJldHVybiB0YXJnZXQuY29weSggYSApLmFkZFNjYWxlZFZlY3RvciggdmFiLCB2ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2Y3Auc3ViVmVjdG9ycyggcCwgYyApO1xyXG5cdFx0XHR2YXIgZDUgPSB2YWIuZG90KCB2Y3AgKTtcclxuXHRcdFx0dmFyIGQ2ID0gdmFjLmRvdCggdmNwICk7XHJcblx0XHRcdGlmICggZDYgPj0gMCAmJiBkNSA8PSBkNiApIHtcclxuXHJcblx0XHRcdFx0Ly8gdmVydGV4IHJlZ2lvbiBvZiBDOyBiYXJ5Y2VudHJpYyBjb29yZHMgKDAsIDAsIDEpXHJcblx0XHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBjICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgdmIgPSBkNSAqIGQyIC0gZDEgKiBkNjtcclxuXHRcdFx0aWYgKCB2YiA8PSAwICYmIGQyID49IDAgJiYgZDYgPD0gMCApIHtcclxuXHJcblx0XHRcdFx0dyA9IGQyIC8gKCBkMiAtIGQ2ICk7XHJcblx0XHRcdFx0Ly8gZWRnZSByZWdpb24gb2YgQUM7IGJhcnljZW50cmljIGNvb3JkcyAoMS13LCAwLCB3KVxyXG5cdFx0XHRcdHJldHVybiB0YXJnZXQuY29weSggYSApLmFkZFNjYWxlZFZlY3RvciggdmFjLCB3ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgdmEgPSBkMyAqIGQ2IC0gZDUgKiBkNDtcclxuXHRcdFx0aWYgKCB2YSA8PSAwICYmICggZDQgLSBkMyApID49IDAgJiYgKCBkNSAtIGQ2ICkgPj0gMCApIHtcclxuXHJcblx0XHRcdFx0dmJjLnN1YlZlY3RvcnMoIGMsIGIgKTtcclxuXHRcdFx0XHR3ID0gKCBkNCAtIGQzICkgLyAoICggZDQgLSBkMyApICsgKCBkNSAtIGQ2ICkgKTtcclxuXHRcdFx0XHQvLyBlZGdlIHJlZ2lvbiBvZiBCQzsgYmFyeWNlbnRyaWMgY29vcmRzICgwLCAxLXcsIHcpXHJcblx0XHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBiICkuYWRkU2NhbGVkVmVjdG9yKCB2YmMsIHcgKTsgLy8gZWRnZSByZWdpb24gb2YgQkNcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGZhY2UgcmVnaW9uXHJcblx0XHRcdHZhciBkZW5vbSA9IDEgLyAoIHZhICsgdmIgKyB2YyApO1xyXG5cdFx0XHQvLyB1ID0gdmEgKiBkZW5vbVxyXG5cdFx0XHR2ID0gdmIgKiBkZW5vbTtcclxuXHRcdFx0dyA9IHZjICogZGVub207XHJcblx0XHRcdHJldHVybiB0YXJnZXQuY29weSggYSApLmFkZFNjYWxlZFZlY3RvciggdmFiLCB2ICkuYWRkU2NhbGVkVmVjdG9yKCB2YWMsIHcgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCB0cmlhbmdsZSApIHtcclxuXHJcblx0XHRyZXR1cm4gdHJpYW5nbGUuYS5lcXVhbHMoIHRoaXMuYSApICYmIHRyaWFuZ2xlLmIuZXF1YWxzKCB0aGlzLmIgKSAmJiB0cmlhbmdsZS5jLmVxdWFscyggdGhpcy5jICk7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuXHJcblxyXG5leHBvcnQgeyBUcmlhbmdsZSB9O1xyXG4iLCJpbXBvcnQge19NYXRofSBmcm9tICcuL01hdGguanMnO1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxudmFyIENvbG9yS2V5d29yZHMgPSB7ICdhbGljZWJsdWUnOiAweEYwRjhGRiwgJ2FudGlxdWV3aGl0ZSc6IDB4RkFFQkQ3LCAnYXF1YSc6IDB4MDBGRkZGLCAnYXF1YW1hcmluZSc6IDB4N0ZGRkQ0LCAnYXp1cmUnOiAweEYwRkZGRixcclxuXHQnYmVpZ2UnOiAweEY1RjVEQywgJ2Jpc3F1ZSc6IDB4RkZFNEM0LCAnYmxhY2snOiAweDAwMDAwMCwgJ2JsYW5jaGVkYWxtb25kJzogMHhGRkVCQ0QsICdibHVlJzogMHgwMDAwRkYsICdibHVldmlvbGV0JzogMHg4QTJCRTIsXHJcblx0J2Jyb3duJzogMHhBNTJBMkEsICdidXJseXdvb2QnOiAweERFQjg4NywgJ2NhZGV0Ymx1ZSc6IDB4NUY5RUEwLCAnY2hhcnRyZXVzZSc6IDB4N0ZGRjAwLCAnY2hvY29sYXRlJzogMHhEMjY5MUUsICdjb3JhbCc6IDB4RkY3RjUwLFxyXG5cdCdjb3JuZmxvd2VyYmx1ZSc6IDB4NjQ5NUVELCAnY29ybnNpbGsnOiAweEZGRjhEQywgJ2NyaW1zb24nOiAweERDMTQzQywgJ2N5YW4nOiAweDAwRkZGRiwgJ2RhcmtibHVlJzogMHgwMDAwOEIsICdkYXJrY3lhbic6IDB4MDA4QjhCLFxyXG5cdCdkYXJrZ29sZGVucm9kJzogMHhCODg2MEIsICdkYXJrZ3JheSc6IDB4QTlBOUE5LCAnZGFya2dyZWVuJzogMHgwMDY0MDAsICdkYXJrZ3JleSc6IDB4QTlBOUE5LCAnZGFya2toYWtpJzogMHhCREI3NkIsICdkYXJrbWFnZW50YSc6IDB4OEIwMDhCLFxyXG5cdCdkYXJrb2xpdmVncmVlbic6IDB4NTU2QjJGLCAnZGFya29yYW5nZSc6IDB4RkY4QzAwLCAnZGFya29yY2hpZCc6IDB4OTkzMkNDLCAnZGFya3JlZCc6IDB4OEIwMDAwLCAnZGFya3NhbG1vbic6IDB4RTk5NjdBLCAnZGFya3NlYWdyZWVuJzogMHg4RkJDOEYsXHJcblx0J2RhcmtzbGF0ZWJsdWUnOiAweDQ4M0Q4QiwgJ2RhcmtzbGF0ZWdyYXknOiAweDJGNEY0RiwgJ2RhcmtzbGF0ZWdyZXknOiAweDJGNEY0RiwgJ2Rhcmt0dXJxdW9pc2UnOiAweDAwQ0VEMSwgJ2Rhcmt2aW9sZXQnOiAweDk0MDBEMyxcclxuXHQnZGVlcHBpbmsnOiAweEZGMTQ5MywgJ2RlZXBza3libHVlJzogMHgwMEJGRkYsICdkaW1ncmF5JzogMHg2OTY5NjksICdkaW1ncmV5JzogMHg2OTY5NjksICdkb2RnZXJibHVlJzogMHgxRTkwRkYsICdmaXJlYnJpY2snOiAweEIyMjIyMixcclxuXHQnZmxvcmFsd2hpdGUnOiAweEZGRkFGMCwgJ2ZvcmVzdGdyZWVuJzogMHgyMjhCMjIsICdmdWNoc2lhJzogMHhGRjAwRkYsICdnYWluc2Jvcm8nOiAweERDRENEQywgJ2dob3N0d2hpdGUnOiAweEY4RjhGRiwgJ2dvbGQnOiAweEZGRDcwMCxcclxuXHQnZ29sZGVucm9kJzogMHhEQUE1MjAsICdncmF5JzogMHg4MDgwODAsICdncmVlbic6IDB4MDA4MDAwLCAnZ3JlZW55ZWxsb3cnOiAweEFERkYyRiwgJ2dyZXknOiAweDgwODA4MCwgJ2hvbmV5ZGV3JzogMHhGMEZGRjAsICdob3RwaW5rJzogMHhGRjY5QjQsXHJcblx0J2luZGlhbnJlZCc6IDB4Q0Q1QzVDLCAnaW5kaWdvJzogMHg0QjAwODIsICdpdm9yeSc6IDB4RkZGRkYwLCAna2hha2knOiAweEYwRTY4QywgJ2xhdmVuZGVyJzogMHhFNkU2RkEsICdsYXZlbmRlcmJsdXNoJzogMHhGRkYwRjUsICdsYXduZ3JlZW4nOiAweDdDRkMwMCxcclxuXHQnbGVtb25jaGlmZm9uJzogMHhGRkZBQ0QsICdsaWdodGJsdWUnOiAweEFERDhFNiwgJ2xpZ2h0Y29yYWwnOiAweEYwODA4MCwgJ2xpZ2h0Y3lhbic6IDB4RTBGRkZGLCAnbGlnaHRnb2xkZW5yb2R5ZWxsb3cnOiAweEZBRkFEMiwgJ2xpZ2h0Z3JheSc6IDB4RDNEM0QzLFxyXG5cdCdsaWdodGdyZWVuJzogMHg5MEVFOTAsICdsaWdodGdyZXknOiAweEQzRDNEMywgJ2xpZ2h0cGluayc6IDB4RkZCNkMxLCAnbGlnaHRzYWxtb24nOiAweEZGQTA3QSwgJ2xpZ2h0c2VhZ3JlZW4nOiAweDIwQjJBQSwgJ2xpZ2h0c2t5Ymx1ZSc6IDB4ODdDRUZBLFxyXG5cdCdsaWdodHNsYXRlZ3JheSc6IDB4Nzc4ODk5LCAnbGlnaHRzbGF0ZWdyZXknOiAweDc3ODg5OSwgJ2xpZ2h0c3RlZWxibHVlJzogMHhCMEM0REUsICdsaWdodHllbGxvdyc6IDB4RkZGRkUwLCAnbGltZSc6IDB4MDBGRjAwLCAnbGltZWdyZWVuJzogMHgzMkNEMzIsXHJcblx0J2xpbmVuJzogMHhGQUYwRTYsICdtYWdlbnRhJzogMHhGRjAwRkYsICdtYXJvb24nOiAweDgwMDAwMCwgJ21lZGl1bWFxdWFtYXJpbmUnOiAweDY2Q0RBQSwgJ21lZGl1bWJsdWUnOiAweDAwMDBDRCwgJ21lZGl1bW9yY2hpZCc6IDB4QkE1NUQzLFxyXG5cdCdtZWRpdW1wdXJwbGUnOiAweDkzNzBEQiwgJ21lZGl1bXNlYWdyZWVuJzogMHgzQ0IzNzEsICdtZWRpdW1zbGF0ZWJsdWUnOiAweDdCNjhFRSwgJ21lZGl1bXNwcmluZ2dyZWVuJzogMHgwMEZBOUEsICdtZWRpdW10dXJxdW9pc2UnOiAweDQ4RDFDQyxcclxuXHQnbWVkaXVtdmlvbGV0cmVkJzogMHhDNzE1ODUsICdtaWRuaWdodGJsdWUnOiAweDE5MTk3MCwgJ21pbnRjcmVhbSc6IDB4RjVGRkZBLCAnbWlzdHlyb3NlJzogMHhGRkU0RTEsICdtb2NjYXNpbic6IDB4RkZFNEI1LCAnbmF2YWpvd2hpdGUnOiAweEZGREVBRCxcclxuXHQnbmF2eSc6IDB4MDAwMDgwLCAnb2xkbGFjZSc6IDB4RkRGNUU2LCAnb2xpdmUnOiAweDgwODAwMCwgJ29saXZlZHJhYic6IDB4NkI4RTIzLCAnb3JhbmdlJzogMHhGRkE1MDAsICdvcmFuZ2VyZWQnOiAweEZGNDUwMCwgJ29yY2hpZCc6IDB4REE3MEQ2LFxyXG5cdCdwYWxlZ29sZGVucm9kJzogMHhFRUU4QUEsICdwYWxlZ3JlZW4nOiAweDk4RkI5OCwgJ3BhbGV0dXJxdW9pc2UnOiAweEFGRUVFRSwgJ3BhbGV2aW9sZXRyZWQnOiAweERCNzA5MywgJ3BhcGF5YXdoaXAnOiAweEZGRUZENSwgJ3BlYWNocHVmZic6IDB4RkZEQUI5LFxyXG5cdCdwZXJ1JzogMHhDRDg1M0YsICdwaW5rJzogMHhGRkMwQ0IsICdwbHVtJzogMHhEREEwREQsICdwb3dkZXJibHVlJzogMHhCMEUwRTYsICdwdXJwbGUnOiAweDgwMDA4MCwgJ3JlYmVjY2FwdXJwbGUnOiAweDY2MzM5OSwgJ3JlZCc6IDB4RkYwMDAwLCAncm9zeWJyb3duJzogMHhCQzhGOEYsXHJcblx0J3JveWFsYmx1ZSc6IDB4NDE2OUUxLCAnc2FkZGxlYnJvd24nOiAweDhCNDUxMywgJ3NhbG1vbic6IDB4RkE4MDcyLCAnc2FuZHlicm93bic6IDB4RjRBNDYwLCAnc2VhZ3JlZW4nOiAweDJFOEI1NywgJ3NlYXNoZWxsJzogMHhGRkY1RUUsXHJcblx0J3NpZW5uYSc6IDB4QTA1MjJELCAnc2lsdmVyJzogMHhDMEMwQzAsICdza3libHVlJzogMHg4N0NFRUIsICdzbGF0ZWJsdWUnOiAweDZBNUFDRCwgJ3NsYXRlZ3JheSc6IDB4NzA4MDkwLCAnc2xhdGVncmV5JzogMHg3MDgwOTAsICdzbm93JzogMHhGRkZBRkEsXHJcblx0J3NwcmluZ2dyZWVuJzogMHgwMEZGN0YsICdzdGVlbGJsdWUnOiAweDQ2ODJCNCwgJ3Rhbic6IDB4RDJCNDhDLCAndGVhbCc6IDB4MDA4MDgwLCAndGhpc3RsZSc6IDB4RDhCRkQ4LCAndG9tYXRvJzogMHhGRjYzNDcsICd0dXJxdW9pc2UnOiAweDQwRTBEMCxcclxuXHQndmlvbGV0JzogMHhFRTgyRUUsICd3aGVhdCc6IDB4RjVERUIzLCAnd2hpdGUnOiAweEZGRkZGRiwgJ3doaXRlc21va2UnOiAweEY1RjVGNSwgJ3llbGxvdyc6IDB4RkZGRjAwLCAneWVsbG93Z3JlZW4nOiAweDlBQ0QzMiB9O1xyXG5cclxuZnVuY3Rpb24gQ29sb3IoIHIsIGcsIGIgKSB7XHJcblxyXG5cdGlmICggZyA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHQvLyByIGlzIENPT0wuQ29sb3IsIGhleCBvciBzdHJpbmdcclxuXHRcdHJldHVybiB0aGlzLnNldCggciApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzLnNldFJHQiggciwgZywgYiApO1xyXG5cclxufVxyXG5cclxuT2JqZWN0LmFzc2lnbiggQ29sb3IucHJvdG90eXBlLCB7XHJcblxyXG5cdGlzQ29sb3I6IHRydWUsXHJcblxyXG5cdHI6IDEsIGc6IDEsIGI6IDEsXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRpZiAoIHZhbHVlICYmIHZhbHVlLmlzQ29sb3IgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNvcHkoIHZhbHVlICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyApIHtcclxuXHJcblx0XHRcdHRoaXMuc2V0SGV4KCB2YWx1ZSApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnNldFN0eWxlKCB2YWx1ZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcclxuXHJcblx0XHR0aGlzLnIgPSBzY2FsYXI7XHJcblx0XHR0aGlzLmcgPSBzY2FsYXI7XHJcblx0XHR0aGlzLmIgPSBzY2FsYXI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEhleDogZnVuY3Rpb24gKCBoZXggKSB7XHJcblxyXG5cdFx0aGV4ID0gTWF0aC5mbG9vciggaGV4ICk7XHJcblxyXG5cdFx0dGhpcy5yID0gKCBoZXggPj4gMTYgJiAyNTUgKSAvIDI1NTtcclxuXHRcdHRoaXMuZyA9ICggaGV4ID4+IDggJiAyNTUgKSAvIDI1NTtcclxuXHRcdHRoaXMuYiA9ICggaGV4ICYgMjU1ICkgLyAyNTU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFJHQjogZnVuY3Rpb24gKCByLCBnLCBiICkge1xyXG5cclxuXHRcdHRoaXMuciA9IHI7XHJcblx0XHR0aGlzLmcgPSBnO1xyXG5cdFx0dGhpcy5iID0gYjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0SFNMOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0ZnVuY3Rpb24gaHVlMnJnYiggcCwgcSwgdCApIHtcclxuXHJcblx0XHRcdGlmICggdCA8IDAgKSB0ICs9IDE7XHJcblx0XHRcdGlmICggdCA+IDEgKSB0IC09IDE7XHJcblx0XHRcdGlmICggdCA8IDEgLyA2ICkgcmV0dXJuIHAgKyAoIHEgLSBwICkgKiA2ICogdDtcclxuXHRcdFx0aWYgKCB0IDwgMSAvIDIgKSByZXR1cm4gcTtcclxuXHRcdFx0aWYgKCB0IDwgMiAvIDMgKSByZXR1cm4gcCArICggcSAtIHAgKSAqIDYgKiAoIDIgLyAzIC0gdCApO1xyXG5cdFx0XHRyZXR1cm4gcDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHNldEhTTCggaCwgcywgbCApIHtcclxuXHJcblx0XHRcdC8vIGgscyxsIHJhbmdlcyBhcmUgaW4gMC4wIC0gMS4wXHJcblx0XHRcdGggPSBfTWF0aC5ldWNsaWRlYW5Nb2R1bG8oIGgsIDEgKTtcclxuXHRcdFx0cyA9IF9NYXRoLmNsYW1wKCBzLCAwLCAxICk7XHJcblx0XHRcdGwgPSBfTWF0aC5jbGFtcCggbCwgMCwgMSApO1xyXG5cclxuXHRcdFx0aWYgKCBzID09PSAwICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnIgPSB0aGlzLmcgPSB0aGlzLmIgPSBsO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dmFyIHAgPSBsIDw9IDAuNSA/IGwgKiAoIDEgKyBzICkgOiBsICsgcyAtICggbCAqIHMgKTtcclxuXHRcdFx0XHR2YXIgcSA9ICggMiAqIGwgKSAtIHA7XHJcblxyXG5cdFx0XHRcdHRoaXMuciA9IGh1ZTJyZ2IoIHEsIHAsIGggKyAxIC8gMyApO1xyXG5cdFx0XHRcdHRoaXMuZyA9IGh1ZTJyZ2IoIHEsIHAsIGggKTtcclxuXHRcdFx0XHR0aGlzLmIgPSBodWUycmdiKCBxLCBwLCBoIC0gMSAvIDMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uICggc3R5bGUgKSB7XHJcblxyXG5cdFx0ZnVuY3Rpb24gaGFuZGxlQWxwaGEoIHN0cmluZyApIHtcclxuXHJcblx0XHRcdGlmICggc3RyaW5nID09PSB1bmRlZmluZWQgKSByZXR1cm47XHJcblxyXG5cdFx0XHRpZiAoIHBhcnNlRmxvYXQoIHN0cmluZyApIDwgMSApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5Db2xvcjogQWxwaGEgY29tcG9uZW50IG9mICcgKyBzdHlsZSArICcgd2lsbCBiZSBpZ25vcmVkLicgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHRcdHZhciBtO1xyXG5cclxuXHRcdGlmICggbSA9IC9eKCg/OnJnYnxoc2wpYT8pXFwoXFxzKihbXlxcKV0qKVxcKS8uZXhlYyggc3R5bGUgKSApIHtcclxuXHJcblx0XHRcdC8vIHJnYiAvIGhzbFxyXG5cclxuXHRcdFx0dmFyIGNvbG9yO1xyXG5cdFx0XHR2YXIgbmFtZSA9IG1bIDEgXTtcclxuXHRcdFx0dmFyIGNvbXBvbmVudHMgPSBtWyAyIF07XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBuYW1lICkge1xyXG5cclxuXHRcdFx0XHRjYXNlICdyZ2InOlxyXG5cdFx0XHRcdGNhc2UgJ3JnYmEnOlxyXG5cclxuXHRcdFx0XHRcdGlmICggY29sb3IgPSAvXihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyooLFxccyooWzAtOV0qXFwuP1swLTldKylcXHMqKT8kLy5leGVjKCBjb21wb25lbnRzICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyByZ2IoMjU1LDAsMCkgcmdiYSgyNTUsMCwwLDAuNSlcclxuXHRcdFx0XHRcdFx0dGhpcy5yID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAxIF0sIDEwICkgKSAvIDI1NTtcclxuXHRcdFx0XHRcdFx0dGhpcy5nID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgKSAvIDI1NTtcclxuXHRcdFx0XHRcdFx0dGhpcy5iID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDI1NTtcclxuXHJcblx0XHRcdFx0XHRcdGhhbmRsZUFscGhhKCBjb2xvclsgNSBdICk7XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBjb2xvciA9IC9eKFxcZCspXFwlXFxzKixcXHMqKFxcZCspXFwlXFxzKixcXHMqKFxcZCspXFwlXFxzKigsXFxzKihbMC05XSpcXC4/WzAtOV0rKVxccyopPyQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIHJnYigxMDAlLDAlLDAlKSByZ2JhKDEwMCUsMCUsMCUsMC41KVxyXG5cdFx0XHRcdFx0XHR0aGlzLnIgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDEgXSwgMTAgKSApIC8gMTAwO1xyXG5cdFx0XHRcdFx0XHR0aGlzLmcgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSApIC8gMTAwO1xyXG5cdFx0XHRcdFx0XHR0aGlzLmIgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDMgXSwgMTAgKSApIC8gMTAwO1xyXG5cclxuXHRcdFx0XHRcdFx0aGFuZGxlQWxwaGEoIGNvbG9yWyA1IF0gKTtcclxuXHJcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnaHNsJzpcclxuXHRcdFx0XHRjYXNlICdoc2xhJzpcclxuXHJcblx0XHRcdFx0XHRpZiAoIGNvbG9yID0gL14oWzAtOV0qXFwuP1swLTldKylcXHMqLFxccyooXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqKCxcXHMqKFswLTldKlxcLj9bMC05XSspXFxzKik/JC8uZXhlYyggY29tcG9uZW50cyApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gaHNsKDEyMCw1MCUsNTAlKSBoc2xhKDEyMCw1MCUsNTAlLDAuNSlcclxuXHRcdFx0XHRcdFx0dmFyIGggPSBwYXJzZUZsb2F0KCBjb2xvclsgMSBdICkgLyAzNjA7XHJcblx0XHRcdFx0XHRcdHZhciBzID0gcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgLyAxMDA7XHJcblx0XHRcdFx0XHRcdHZhciBsID0gcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgLyAxMDA7XHJcblxyXG5cdFx0XHRcdFx0XHRoYW5kbGVBbHBoYSggY29sb3JbIDUgXSApO1xyXG5cclxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0SFNMKCBoLCBzLCBsICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG0gPSAvXlxcIyhbQS1GYS1mMC05XSspJC8uZXhlYyggc3R5bGUgKSApIHtcclxuXHJcblx0XHRcdC8vIGhleCBjb2xvclxyXG5cclxuXHRcdFx0dmFyIGhleCA9IG1bIDEgXTtcclxuXHRcdFx0dmFyIHNpemUgPSBoZXgubGVuZ3RoO1xyXG5cclxuXHRcdFx0aWYgKCBzaXplID09PSAzICkge1xyXG5cclxuXHRcdFx0XHQvLyAjZmYwXHJcblx0XHRcdFx0dGhpcy5yID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDAgKSArIGhleC5jaGFyQXQoIDAgKSwgMTYgKSAvIDI1NTtcclxuXHRcdFx0XHR0aGlzLmcgPSBwYXJzZUludCggaGV4LmNoYXJBdCggMSApICsgaGV4LmNoYXJBdCggMSApLCAxNiApIC8gMjU1O1xyXG5cdFx0XHRcdHRoaXMuYiA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAyICkgKyBoZXguY2hhckF0KCAyICksIDE2ICkgLyAyNTU7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggc2l6ZSA9PT0gNiApIHtcclxuXHJcblx0XHRcdFx0Ly8gI2ZmMDAwMFxyXG5cdFx0XHRcdHRoaXMuciA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAwICkgKyBoZXguY2hhckF0KCAxICksIDE2ICkgLyAyNTU7XHJcblx0XHRcdFx0dGhpcy5nID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDIgKSArIGhleC5jaGFyQXQoIDMgKSwgMTYgKSAvIDI1NTtcclxuXHRcdFx0XHR0aGlzLmIgPSBwYXJzZUludCggaGV4LmNoYXJBdCggNCApICsgaGV4LmNoYXJBdCggNSApLCAxNiApIC8gMjU1O1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBzdHlsZSAmJiBzdHlsZS5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0Ly8gY29sb3Iga2V5d29yZHNcclxuXHRcdFx0dmFyIGhleCA9IENvbG9yS2V5d29yZHNbIHN0eWxlIF07XHJcblxyXG5cdFx0XHRpZiAoIGhleCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHQvLyByZWRcclxuXHRcdFx0XHR0aGlzLnNldEhleCggaGV4ICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyB1bmtub3duIGNvbG9yXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5Db2xvcjogVW5rbm93biBjb2xvciAnICsgc3R5bGUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLnIsIHRoaXMuZywgdGhpcy5iICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggY29sb3IgKSB7XHJcblxyXG5cdFx0dGhpcy5yID0gY29sb3IucjtcclxuXHRcdHRoaXMuZyA9IGNvbG9yLmc7XHJcblx0XHR0aGlzLmIgPSBjb2xvci5iO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5R2FtbWFUb0xpbmVhcjogZnVuY3Rpb24gKCBjb2xvciwgZ2FtbWFGYWN0b3IgKSB7XHJcblxyXG5cdFx0aWYgKCBnYW1tYUZhY3RvciA9PT0gdW5kZWZpbmVkICkgZ2FtbWFGYWN0b3IgPSAyLjA7XHJcblxyXG5cdFx0dGhpcy5yID0gTWF0aC5wb3coIGNvbG9yLnIsIGdhbW1hRmFjdG9yICk7XHJcblx0XHR0aGlzLmcgPSBNYXRoLnBvdyggY29sb3IuZywgZ2FtbWFGYWN0b3IgKTtcclxuXHRcdHRoaXMuYiA9IE1hdGgucG93KCBjb2xvci5iLCBnYW1tYUZhY3RvciApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5TGluZWFyVG9HYW1tYTogZnVuY3Rpb24gKCBjb2xvciwgZ2FtbWFGYWN0b3IgKSB7XHJcblxyXG5cdFx0aWYgKCBnYW1tYUZhY3RvciA9PT0gdW5kZWZpbmVkICkgZ2FtbWFGYWN0b3IgPSAyLjA7XHJcblxyXG5cdFx0dmFyIHNhZmVJbnZlcnNlID0gKCBnYW1tYUZhY3RvciA+IDAgKSA/ICggMS4wIC8gZ2FtbWFGYWN0b3IgKSA6IDEuMDtcclxuXHJcblx0XHR0aGlzLnIgPSBNYXRoLnBvdyggY29sb3Iuciwgc2FmZUludmVyc2UgKTtcclxuXHRcdHRoaXMuZyA9IE1hdGgucG93KCBjb2xvci5nLCBzYWZlSW52ZXJzZSApO1xyXG5cdFx0dGhpcy5iID0gTWF0aC5wb3coIGNvbG9yLmIsIHNhZmVJbnZlcnNlICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbnZlcnRHYW1tYVRvTGluZWFyOiBmdW5jdGlvbiAoIGdhbW1hRmFjdG9yICkge1xyXG5cclxuXHRcdHRoaXMuY29weUdhbW1hVG9MaW5lYXIoIHRoaXMsIGdhbW1hRmFjdG9yICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbnZlcnRMaW5lYXJUb0dhbW1hOiBmdW5jdGlvbiAoIGdhbW1hRmFjdG9yICkge1xyXG5cclxuXHRcdHRoaXMuY29weUxpbmVhclRvR2FtbWEoIHRoaXMsIGdhbW1hRmFjdG9yICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHlTUkdCVG9MaW5lYXI6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRmdW5jdGlvbiBTUkdCVG9MaW5lYXIoIGMgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gKCBjIDwgMC4wNDA0NSApID8gYyAqIDAuMDc3Mzk5MzgwOCA6IE1hdGgucG93KCBjICogMC45NDc4NjcyOTg2ICsgMC4wNTIxMzI3MDE0LCAyLjQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNvcHlTUkdCVG9MaW5lYXIoIGNvbG9yICkge1xyXG5cclxuXHRcdFx0dGhpcy5yID0gU1JHQlRvTGluZWFyKCBjb2xvci5yICk7XHJcblx0XHRcdHRoaXMuZyA9IFNSR0JUb0xpbmVhciggY29sb3IuZyApO1xyXG5cdFx0XHR0aGlzLmIgPSBTUkdCVG9MaW5lYXIoIGNvbG9yLmIgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Y29weUxpbmVhclRvU1JHQjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGZ1bmN0aW9uIExpbmVhclRvU1JHQiggYyApIHtcclxuXHJcblx0XHRcdHJldHVybiAoIGMgPCAwLjAwMzEzMDggKSA/IGMgKiAxMi45MiA6IDEuMDU1ICogKCBNYXRoLnBvdyggYywgMC40MTY2NiApICkgLSAwLjA1NTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNvcHlMaW5lYXJUb1NSR0IoIGNvbG9yICkge1xyXG5cclxuXHRcdFx0dGhpcy5yID0gTGluZWFyVG9TUkdCKCBjb2xvci5yICk7XHJcblx0XHRcdHRoaXMuZyA9IExpbmVhclRvU1JHQiggY29sb3IuZyApO1xyXG5cdFx0XHR0aGlzLmIgPSBMaW5lYXJUb1NSR0IoIGNvbG9yLmIgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Y29udmVydFNSR0JUb0xpbmVhcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuY29weVNSR0JUb0xpbmVhciggdGhpcyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0TGluZWFyVG9TUkdCOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5jb3B5TGluZWFyVG9TUkdCKCB0aGlzICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEhleDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiAoIHRoaXMuciAqIDI1NSApIDw8IDE2IF4gKCB0aGlzLmcgKiAyNTUgKSA8PCA4IF4gKCB0aGlzLmIgKiAyNTUgKSA8PCAwO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRIZXhTdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gKCAnMDAwMDAwJyArIHRoaXMuZ2V0SGV4KCkudG9TdHJpbmcoIDE2ICkgKS5zbGljZSggLSA2ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEhTTDogZnVuY3Rpb24gKCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0Ly8gaCxzLGwgcmFuZ2VzIGFyZSBpbiAwLjAgLSAxLjBcclxuXHJcblx0XHRpZiAoIHRhcmdldCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5Db2xvcjogLmdldEhTTCgpIHRhcmdldCBpcyBub3cgcmVxdWlyZWQnICk7XHJcblx0XHRcdHRhcmdldCA9IHsgaDogMCwgczogMCwgbDogMCB9O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgciA9IHRoaXMuciwgZyA9IHRoaXMuZywgYiA9IHRoaXMuYjtcclxuXHJcblx0XHR2YXIgbWF4ID0gTWF0aC5tYXgoIHIsIGcsIGIgKTtcclxuXHRcdHZhciBtaW4gPSBNYXRoLm1pbiggciwgZywgYiApO1xyXG5cclxuXHRcdHZhciBodWUsIHNhdHVyYXRpb247XHJcblx0XHR2YXIgbGlnaHRuZXNzID0gKCBtaW4gKyBtYXggKSAvIDIuMDtcclxuXHJcblx0XHRpZiAoIG1pbiA9PT0gbWF4ICkge1xyXG5cclxuXHRcdFx0aHVlID0gMDtcclxuXHRcdFx0c2F0dXJhdGlvbiA9IDA7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHZhciBkZWx0YSA9IG1heCAtIG1pbjtcclxuXHJcblx0XHRcdHNhdHVyYXRpb24gPSBsaWdodG5lc3MgPD0gMC41ID8gZGVsdGEgLyAoIG1heCArIG1pbiApIDogZGVsdGEgLyAoIDIgLSBtYXggLSBtaW4gKTtcclxuXHJcblx0XHRcdHN3aXRjaCAoIG1heCApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSByOiBodWUgPSAoIGcgLSBiICkgLyBkZWx0YSArICggZyA8IGIgPyA2IDogMCApOyBicmVhaztcclxuXHRcdFx0XHRjYXNlIGc6IGh1ZSA9ICggYiAtIHIgKSAvIGRlbHRhICsgMjsgYnJlYWs7XHJcblx0XHRcdFx0Y2FzZSBiOiBodWUgPSAoIHIgLSBnICkgLyBkZWx0YSArIDQ7IGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aHVlIC89IDY7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRhcmdldC5oID0gaHVlO1xyXG5cdFx0dGFyZ2V0LnMgPSBzYXR1cmF0aW9uO1xyXG5cdFx0dGFyZ2V0LmwgPSBsaWdodG5lc3M7XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldDtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0U3R5bGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ3JnYignICsgKCAoIHRoaXMuciAqIDI1NSApIHwgMCApICsgJywnICsgKCAoIHRoaXMuZyAqIDI1NSApIHwgMCApICsgJywnICsgKCAoIHRoaXMuYiAqIDI1NSApIHwgMCApICsgJyknO1xyXG5cclxuXHR9LFxyXG5cclxuXHRvZmZzZXRIU0w6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgaHNsID0ge307XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggaCwgcywgbCApIHtcclxuXHJcblx0XHRcdHRoaXMuZ2V0SFNMKCBoc2wgKTtcclxuXHJcblx0XHRcdGhzbC5oICs9IGg7IGhzbC5zICs9IHM7IGhzbC5sICs9IGw7XHJcblxyXG5cdFx0XHR0aGlzLnNldEhTTCggaHNsLmgsIGhzbC5zLCBoc2wubCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRhZGQ6IGZ1bmN0aW9uICggY29sb3IgKSB7XHJcblxyXG5cdFx0dGhpcy5yICs9IGNvbG9yLnI7XHJcblx0XHR0aGlzLmcgKz0gY29sb3IuZztcclxuXHRcdHRoaXMuYiArPSBjb2xvci5iO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGRDb2xvcnM6IGZ1bmN0aW9uICggY29sb3IxLCBjb2xvcjIgKSB7XHJcblxyXG5cdFx0dGhpcy5yID0gY29sb3IxLnIgKyBjb2xvcjIucjtcclxuXHRcdHRoaXMuZyA9IGNvbG9yMS5nICsgY29sb3IyLmc7XHJcblx0XHR0aGlzLmIgPSBjb2xvcjEuYiArIGNvbG9yMi5iO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGRTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcclxuXHJcblx0XHR0aGlzLnIgKz0gcztcclxuXHRcdHRoaXMuZyArPSBzO1xyXG5cdFx0dGhpcy5iICs9IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHN1YjogZnVuY3Rpb24gKCBjb2xvciApIHtcclxuXHJcblx0XHR0aGlzLnIgPSBNYXRoLm1heCggMCwgdGhpcy5yIC0gY29sb3IuciApO1xyXG5cdFx0dGhpcy5nID0gTWF0aC5tYXgoIDAsIHRoaXMuZyAtIGNvbG9yLmcgKTtcclxuXHRcdHRoaXMuYiA9IE1hdGgubWF4KCAwLCB0aGlzLmIgLSBjb2xvci5iICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5OiBmdW5jdGlvbiAoIGNvbG9yICkge1xyXG5cclxuXHRcdHRoaXMuciAqPSBjb2xvci5yO1xyXG5cdFx0dGhpcy5nICo9IGNvbG9yLmc7XHJcblx0XHR0aGlzLmIgKj0gY29sb3IuYjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcclxuXHJcblx0XHR0aGlzLnIgKj0gcztcclxuXHRcdHRoaXMuZyAqPSBzO1xyXG5cdFx0dGhpcy5iICo9IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlcnA6IGZ1bmN0aW9uICggY29sb3IsIGFscGhhICkge1xyXG5cclxuXHRcdHRoaXMuciArPSAoIGNvbG9yLnIgLSB0aGlzLnIgKSAqIGFscGhhO1xyXG5cdFx0dGhpcy5nICs9ICggY29sb3IuZyAtIHRoaXMuZyApICogYWxwaGE7XHJcblx0XHR0aGlzLmIgKz0gKCBjb2xvci5iIC0gdGhpcy5iICkgKiBhbHBoYTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bGVycEhTTDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBoc2xBID0geyBoOiAwLCBzOiAwLCBsOiAwIH07XHJcblx0XHR2YXIgaHNsQiA9IHsgaDogMCwgczogMCwgbDogMCB9O1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBsZXJwSFNMKCBjb2xvciwgYWxwaGEgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmdldEhTTCggaHNsQSApO1xyXG5cdFx0XHRjb2xvci5nZXRIU0woIGhzbEIgKTtcclxuXHJcblx0XHRcdHZhciBoID0gX01hdGgubGVycCggaHNsQS5oLCBoc2xCLmgsIGFscGhhICk7XHJcblx0XHRcdHZhciBzID0gX01hdGgubGVycCggaHNsQS5zLCBoc2xCLnMsIGFscGhhICk7XHJcblx0XHRcdHZhciBsID0gX01hdGgubGVycCggaHNsQS5sLCBoc2xCLmwsIGFscGhhICk7XHJcblxyXG5cdFx0XHR0aGlzLnNldEhTTCggaCwgcywgbCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggYyApIHtcclxuXHJcblx0XHRyZXR1cm4gKCBjLnIgPT09IHRoaXMuciApICYmICggYy5nID09PSB0aGlzLmcgKSAmJiAoIGMuYiA9PT0gdGhpcy5iICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdHRoaXMuciA9IGFycmF5WyBvZmZzZXQgXTtcclxuXHRcdHRoaXMuZyA9IGFycmF5WyBvZmZzZXQgKyAxIF07XHJcblx0XHR0aGlzLmIgPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMucjtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLmc7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5iO1xyXG5cclxuXHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0fSxcclxuXHJcblx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0SGV4KCk7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuXHJcblxyXG5leHBvcnQgeyBDb2xvciB9O1xyXG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uL21hdGgvQ29sb3IuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEZhY2UzKCBhLCBiLCBjLCBub3JtYWwsIGNvbG9yLCBtYXRlcmlhbEluZGV4ICkge1xyXG5cclxuXHR0aGlzLmEgPSBhO1xyXG5cdHRoaXMuYiA9IGI7XHJcblx0dGhpcy5jID0gYztcclxuXHJcblx0dGhpcy5ub3JtYWwgPSAoIG5vcm1hbCAmJiBub3JtYWwuaXNWZWN0b3IzICkgPyBub3JtYWwgOiBuZXcgVmVjdG9yMygpO1xyXG5cdHRoaXMudmVydGV4Tm9ybWFscyA9IEFycmF5LmlzQXJyYXkoIG5vcm1hbCApID8gbm9ybWFsIDogW107XHJcblxyXG5cdHRoaXMuY29sb3IgPSAoIGNvbG9yICYmIGNvbG9yLmlzQ29sb3IgKSA/IGNvbG9yIDogbmV3IENvbG9yKCk7XHJcblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBBcnJheS5pc0FycmF5KCBjb2xvciApID8gY29sb3IgOiBbXTtcclxuXHJcblx0dGhpcy5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWxJbmRleCA6IDA7XHJcblxyXG59XHJcblxyXG5PYmplY3QuYXNzaWduKCBGYWNlMy5wcm90b3R5cGUsIHtcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdHRoaXMuYSA9IHNvdXJjZS5hO1xyXG5cdFx0dGhpcy5iID0gc291cmNlLmI7XHJcblx0XHR0aGlzLmMgPSBzb3VyY2UuYztcclxuXHJcblx0XHR0aGlzLm5vcm1hbC5jb3B5KCBzb3VyY2Uubm9ybWFsICk7XHJcblx0XHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xyXG5cclxuXHRcdHRoaXMubWF0ZXJpYWxJbmRleCA9IHNvdXJjZS5tYXRlcmlhbEluZGV4O1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBzb3VyY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMudmVydGV4Tm9ybWFsc1sgaSBdID0gc291cmNlLnZlcnRleE5vcm1hbHNbIGkgXS5jbG9uZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gc291cmNlLnZlcnRleENvbG9ycy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMudmVydGV4Q29sb3JzWyBpIF0gPSBzb3VyY2UudmVydGV4Q29sb3JzWyBpIF0uY2xvbmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuXHJcblxyXG5leHBvcnQgeyBGYWNlMyB9O1xyXG4iLCJpbXBvcnQgQm94R2VvbWV0cnkgZnJvbSBcIi4vQm94R2VvbWV0cnkuanNcIjtcclxuaW1wb3J0IE1hdGVyaWFsIGZyb20gXCIuLi9tYXRlcmlhbC9NYXRlcmlhbC5qc1wiO1xyXG5pbXBvcnQge01hdHJpeDR9IGZyb20gXCIuLi9tYXRoL01hdHJpeDRcIjtcclxuaW1wb3J0IHtFdWxlcn0gZnJvbSBcIi4uL21hdGgvRXVsZXJcIjtcclxuaW1wb3J0IHtRdWF0ZXJuaW9ufSBmcm9tIFwiLi4vbWF0aC9RdWF0ZXJuaW9uXCI7XHJcbmltcG9ydCB7VmVjdG9yM30gZnJvbSBcIi4uL21hdGgvVmVjdG9yM1wiO1xyXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IyLmpzJztcclxuaW1wb3J0IHtSYXl9IGZyb20gXCIuLi9tYXRoL1JheVwiO1xyXG5cclxuaW1wb3J0IHsgU3BoZXJlIH0gZnJvbSAnLi4vbWF0aC9TcGhlcmUuanMnO1xyXG5pbXBvcnQgeyBUcmlhbmdsZSB9IGZyb20gJy4uL21hdGgvVHJpYW5nbGUuanMnO1xyXG5pbXBvcnQgeyBGYWNlMyB9IGZyb20gJy4uL2NvcmUvRmFjZTMuanMnO1xyXG5pbXBvcnQge0JveDN9IGZyb20gXCIuLi9tYXRoL0JveDNcIjtcclxuXHJcblxyXG5cclxuY2xhc3MgTWVzaCB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbSkge1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdNZXNoJztcclxuICAgICAgICBwYXJhbSA9IHBhcmFtIHx8IHt9O1xyXG4gICAgICAgIHRoaXMuZ2VvbWV0cnkgPSBwYXJhbS5nZW9tZXRyeTtcclxuICAgICAgICB0aGlzLm1hdGVyaWFsID0gcGFyYW0ubWF0ZXJpYWwgfHwgbmV3IE1hdGVyaWFsKCk7XHJcblxyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwYXJhbS5wb3NpdGlvbiB8fCBbMCwwLDBdO1xyXG4gICAgICAgIHRoaXMucm90YXRpb24gPSBwYXJhbS5yb3RhdGlvbiB8fCBuZXcgRXVsZXIoKTtcclxuICAgICAgICB0aGlzLnNjYWxlID0gcGFyYW0uc2NhbGUgfHwgWzEsMSwxXTtcclxuXHJcbiAgICAgICAgdGhpcy5xdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKS5zZXRGcm9tRXVsZXIoIHRoaXMucm90YXRpb24sIGZhbHNlICk7XHJcblxyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XHJcblxyXG4gICAgICAgIHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcclxuICAgICAgICB0aGlzLm1hdHJpeFdvcmxkID0gbmV3IE1hdHJpeDQoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBzZXRQb3NpdGlvbihwb3NpdGlvbil7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gICAgICAgIHRoaXMudXBkYXRlTWF0cml4KCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0Um90YXRpb24ocm90YXRpb25BcnJheSl7XHJcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IG5ldyBFdWxlcigpLmZyb21BcnJheShyb3RhdGlvbkFycmF5KTtcclxuICAgICAgICB2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCkuc2V0RnJvbUV1bGVyKCB0aGlzLnJvdGF0aW9uLCBmYWxzZSApO1xyXG4gICAgICAgIHRoaXMuc2V0UXVhdGVybmlvbihxdWF0ZXJuaW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRRdWF0ZXJuaW9uKHF1YXRlcm5pb24pe1xyXG5cclxuICAgICAgICB0aGlzLnF1YXRlcm5pb24gPSBxdWF0ZXJuaW9uO1xyXG4gICAgICAgIHRoaXMucm90YXRpb24uc2V0RnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24sIHVuZGVmaW5lZCwgZmFsc2UgKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFNjYWxlKHNjYWxlQXJyYXkpe1xyXG4gICAgICAgIHRoaXMuc2NhbGUgPSBzY2FsZUFycmF5O1xyXG4gICAgICAgIHRoaXMudXBkYXRlTWF0cml4KCk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlTWF0cml4KCl7XHJcbiAgICAgICAgdGhpcy5tYXRyaXguY29tcG9zZSggbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkodGhpcy5wb3NpdGlvbiksIHRoaXMucXVhdGVybmlvbiwgbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkodGhpcy5zY2FsZSkgKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkICgpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldE1hdHJpeChtYXRyaXgpe1xyXG4gICAgICAgIHRoaXMubWF0cml4ID0gbWF0cml4O1xyXG4gICAgICAgIHRoaXMudXBkYXRlTWF0cml4V29ybGQgKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlTWF0cml4V29ybGQgKCkge1xyXG5cclxuICAgICAgICAvLyB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMucGFyZW50ID09PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5tYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4LmNsb25lKCk7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXMoIHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLCB0aGlzLm1hdHJpeCApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW5NYXRyaXhXb3JsZCgpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBnZXRXb3JsZFBvc2l0aW9uKCkge1xyXG5cclxuICAgICAgICB2YXIgdGFyZ2V0ID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgLy8gdGhpcy51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGFyZ2V0LnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVDaGlsZHJlbk1hdHJpeFdvcmxkKCl7XHJcblxyXG4gICAgICAgIGZvcih2YXIgaSBpbiB0aGlzLmNoaWxkcmVuKXtcclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgY2xvbmUoKXtcclxuICAgICAgICB2YXIgbWVzaCA9IG5ldyBNZXNoKHtcclxuICAgICAgICAgICAgZ2VvbWV0cnk6IHRoaXMuZ2VvbWV0cnkuY2xvbmUoKSxcclxuICAgICAgICAgICAgbWF0ZXJpYWw6IHRoaXMubWF0ZXJpYWwuY2xvbmUoKSxcclxuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMucG9zaXRpb24uc2xpY2UoMCksXHJcbiAgICAgICAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLmNsb25lKCksXHJcbiAgICAgICAgICAgIHNjYWxlOiB0aGlzLnNjYWxlLnNsaWNlKDApXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBtZXNoO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZChtZXNoKXtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2gobWVzaCk7XHJcbiAgICAgICAgbWVzaC5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgIG1lc2gudXBkYXRlTWF0cml4KCk7XHJcbiAgICB9XHJcblxyXG4gICAgcm90YXRlT25BeGlzIChheGlzLCBhbmdsZSkge1xyXG5cclxuICAgICAgICB2YXIgcTEgPSBuZXcgUXVhdGVybmlvbigpO1xyXG4gICAgICAgIHExLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICk7XHJcbiAgICAgICAgdmFyIHF1YXRlcm5pb24gPSB0aGlzLnF1YXRlcm5pb24ubXVsdGlwbHkoIHExICk7XHJcbiAgICAgICAgdGhpcy5zZXRRdWF0ZXJuaW9uKHF1YXRlcm5pb24pO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICByb3RhdGVYIChhbmdsZSkge1xyXG5cclxuICAgICAgICB0aGlzLnJvdGF0ZU9uQXhpcyggbmV3IFZlY3RvcjMoMSwwLDApLCBhbmdsZSApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICByb3RhdGVZIChhbmdsZSkge1xyXG5cclxuICAgICAgICB0aGlzLnJvdGF0ZU9uQXhpcyggbmV3IFZlY3RvcjMoMCwxLDApLCBhbmdsZSApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICByb3RhdGVaIChhbmdsZSkge1xyXG5cclxuICAgICAgICB0aGlzLnJvdGF0ZU9uQXhpcyggbmV3IFZlY3RvcjMoMCwwLDEpLCBhbmdsZSApO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcclxuXHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuICAgICAgICB2YXIgaW52ZXJzZU1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XHJcbiAgICAgICAgdmFyIHJheSA9IG5ldyBSYXkoKTtcclxuICAgICAgICB2YXIgc3BoZXJlID0gbmV3IFNwaGVyZSgpO1xyXG5cclxuICAgICAgICB2YXIgdkEgPSBuZXcgVmVjdG9yMygpO1xyXG4gICAgICAgIHZhciB2QiA9IG5ldyBWZWN0b3IzKCk7XHJcbiAgICAgICAgdmFyIHZDID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgdmFyIHRlbXBBID0gbmV3IFZlY3RvcjMoKTtcclxuICAgICAgICB2YXIgdGVtcEIgPSBuZXcgVmVjdG9yMygpO1xyXG4gICAgICAgIHZhciB0ZW1wQyA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG4gICAgICAgIHZhciB1dkEgPSBuZXcgVmVjdG9yMigpO1xyXG4gICAgICAgIHZhciB1dkIgPSBuZXcgVmVjdG9yMigpO1xyXG4gICAgICAgIHZhciB1dkMgPSBuZXcgVmVjdG9yMigpO1xyXG5cclxuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uUG9pbnQgPSBuZXcgVmVjdG9yMygpO1xyXG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gY2hlY2tJbnRlcnNlY3Rpb24oIG9iamVjdCwgbWF0ZXJpYWwsIHJheWNhc3RlciwgcmF5LCBwQSwgcEIsIHBDLCBwb2ludCApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3Q7XHJcblxyXG4gICAgICAgICAgICBpZiAoIG1hdGVyaWFsLnNpZGUgPT09IEJhY2tTaWRlICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGludGVyc2VjdCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZSggcEMsIHBCLCBwQSwgdHJ1ZSwgcG9pbnQgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKCBwQSwgcEIsIHBDLCBtYXRlcmlhbC5zaWRlICE9PSBEb3VibGVTaWRlLCBwb2ludCApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBpbnRlcnNlY3QgPT09IG51bGwgKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50V29ybGQuY29weSggcG9pbnQgKTtcclxuICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRXb3JsZC5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xyXG5cclxuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJzZWN0aW9uUG9pbnRXb3JsZCApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcclxuICAgICAgICAgICAgICAgIHBvaW50OiBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmNsb25lKCksXHJcbiAgICAgICAgICAgICAgICBvYmplY3Q6IG9iamVjdFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24oIG9iamVjdCwgbWF0ZXJpYWwsIHJheWNhc3RlciwgcmF5LCBwb3NpdGlvbiwgdXYsIGEsIGIsIGMgKSB7XHJcblxyXG4gICAgICAgICAgICB2QS5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgYSApO1xyXG4gICAgICAgICAgICB2Qi5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgYiApO1xyXG4gICAgICAgICAgICB2Qy5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgYyApO1xyXG5cclxuICAgICAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IGNoZWNrSW50ZXJzZWN0aW9uKCBvYmplY3QsIG1hdGVyaWFsLCByYXljYXN0ZXIsIHJheSwgdkEsIHZCLCB2QywgaW50ZXJzZWN0aW9uUG9pbnQgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggaW50ZXJzZWN0aW9uICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggdXYgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHV2QS5mcm9tQnVmZmVyQXR0cmlidXRlKCB1diwgYSApO1xyXG4gICAgICAgICAgICAgICAgICAgIHV2Qi5mcm9tQnVmZmVyQXR0cmlidXRlKCB1diwgYiApO1xyXG4gICAgICAgICAgICAgICAgICAgIHV2Qy5mcm9tQnVmZmVyQXR0cmlidXRlKCB1diwgYyApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb24udXYgPSBUcmlhbmdsZS5nZXRVViggaW50ZXJzZWN0aW9uUG9pbnQsIHZBLCB2QiwgdkMsIHV2QSwgdXZCLCB1dkMsIG5ldyBWZWN0b3IyKCkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGZhY2UgPSBuZXcgRmFjZTMoIGEsIGIsIGMgKTtcclxuICAgICAgICAgICAgICAgIFRyaWFuZ2xlLmdldE5vcm1hbCggdkEsIHZCLCB2QywgZmFjZS5ub3JtYWwgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb24uZmFjZSA9IGZhY2U7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJzZWN0aW9uO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XHJcbiAgICAgICAgdmFyIG1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcclxuICAgICAgICB2YXIgbWF0cml4V29ybGQgPSB0aGlzLm1hdHJpeFdvcmxkO1xyXG5cclxuICAgICAgICBpZiAoIG1hdGVyaWFsID09PSB1bmRlZmluZWQgKSByZXR1cm47XHJcblxyXG4gICAgICAgIC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlIGRpc3RhbmNlIHRvIHJheVxyXG5cclxuICAgICAgICBpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG4gICAgICAgIHNwaGVyZS5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApO1xyXG4gICAgICAgIHNwaGVyZS5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XHJcblxyXG4gICAgICAgIHZhciBib3gzID0gbmV3IEJveDMoKS5jb3B5KGdlb21ldHJ5LmJvdW5kaW5nQm94KTtcclxuICAgICAgICBib3gzLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcclxuXHJcbiAgICAgICAgLy8gcmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSB8fFxyXG4gICAgICAgIGlmICggcmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RzQm94KCBib3gzICkgKSB7XHJcbiAgICAgICAgICAgIHZhciB3b3JsZFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcclxuICAgICAgICAgICAgdGhhdC5kaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIHdvcmxkUG9zaXRpb24gKTtcclxuICAgICAgICAgICAgaW50ZXJzZWN0cy5wdXNoKHRoYXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBpbnZlcnNlTWF0cml4LmdldEludmVyc2UoIG1hdHJpeFdvcmxkICk7XHJcbiAgICAgICAgLy8gcmF5LmNvcHkoIHJheWNhc3Rlci5yYXkgKS5hcHBseU1hdHJpeDQoIGludmVyc2VNYXRyaXggKTtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIC8vIENoZWNrIGJvdW5kaW5nQm94IGJlZm9yZSBjb250aW51aW5nXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgIGlmICggcmF5LmludGVyc2VjdHNCb3goIGdlb21ldHJ5LmJvdW5kaW5nQm94ICkgPT09IGZhbHNlICkgcmV0dXJuO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gdmFyIGludGVyc2VjdGlvbjtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIGlmICggZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICB2YXIgYSwgYiwgYztcclxuICAgICAgICAvLyAgICAgdmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XHJcbiAgICAgICAgLy8gICAgIHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XHJcbiAgICAgICAgLy8gICAgIHZhciB1diA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMudXY7XHJcbiAgICAgICAgLy8gICAgIHZhciBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XHJcbiAgICAgICAgLy8gICAgIHZhciBkcmF3UmFuZ2UgPSBnZW9tZXRyeS5kcmF3UmFuZ2U7XHJcbiAgICAgICAgLy8gICAgIHZhciBpLCBqLCBpbCwgamw7XHJcbiAgICAgICAgLy8gICAgIHZhciBncm91cCwgZ3JvdXBNYXRlcmlhbDtcclxuICAgICAgICAvLyAgICAgdmFyIHN0YXJ0LCBlbmQ7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgaWYgKCBpbmRleCAhPT0gbnVsbCApIHtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgLy8gaW5kZXhlZCBidWZmZXIgZ2VvbWV0cnlcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KCBtYXRlcmlhbCApICkge1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgZm9yICggaSA9IDAsIGlsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIGdyb3VwID0gZ3JvdXBzWyBpIF07XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbFsgZ3JvdXAubWF0ZXJpYWxJbmRleCBdO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoIGdyb3VwLnN0YXJ0LCBkcmF3UmFuZ2Uuc3RhcnQgKTtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgZW5kID0gTWF0aC5taW4oICggZ3JvdXAuc3RhcnQgKyBncm91cC5jb3VudCApLCAoIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCApICk7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgZm9yICggaiA9IHN0YXJ0LCBqbCA9IGVuZDsgaiA8IGpsOyBqICs9IDMgKSB7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIGEgPSBpbmRleC5nZXRYKCBqICk7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICBiID0gaW5kZXguZ2V0WCggaiArIDEgKTtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIGMgPSBpbmRleC5nZXRYKCBqICsgMiApO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb24gPSBjaGVja0J1ZmZlckdlb21ldHJ5SW50ZXJzZWN0aW9uKCB0aGlzLCBncm91cE1hdGVyaWFsLCByYXljYXN0ZXIsIHJheSwgcG9zaXRpb24sIHV2LCBhLCBiLCBjICk7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIGlmICggaW50ZXJzZWN0aW9uICkge1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IE1hdGguZmxvb3IoIGogLyAzICk7IC8vIHRyaWFuZ2xlIG51bWJlciBpbiBpbmRleGVkIGJ1ZmZlciBzZW1hbnRpY3NcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3RzLnB1c2goIGludGVyc2VjdGlvbiApO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgfVxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1heCggMCwgZHJhd1JhbmdlLnN0YXJ0ICk7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgZW5kID0gTWF0aC5taW4oIGluZGV4LmNvdW50LCAoIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCApICk7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICBmb3IgKCBpID0gc3RhcnQsIGlsID0gZW5kOyBpIDwgaWw7IGkgKz0gMyApIHtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICBhID0gaW5kZXguZ2V0WCggaSApO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICBiID0gaW5kZXguZ2V0WCggaSArIDEgKTtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgYyA9IGluZGV4LmdldFgoIGkgKyAyICk7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uID0gY2hlY2tCdWZmZXJHZW9tZXRyeUludGVyc2VjdGlvbiggdGhpcywgbWF0ZXJpYWwsIHJheWNhc3RlciwgcmF5LCBwb3NpdGlvbiwgdXYsIGEsIGIsIGMgKTtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICBpZiAoIGludGVyc2VjdGlvbiApIHtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IE1hdGguZmxvb3IoIGkgLyAzICk7IC8vIHRyaWFuZ2xlIG51bWJlciBpbiBpbmRleGVkIGJ1ZmZlciBzZW1hbnRpY3NcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0aW9uICk7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgfVxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICB9XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgfSBlbHNlIGlmICggcG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgLy8gbm9uLWluZGV4ZWQgYnVmZmVyIGdlb21ldHJ5XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgIGlmICggQXJyYXkuaXNBcnJheSggbWF0ZXJpYWwgKSApIHtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIGZvciAoIGkgPSAwLCBpbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICBncm91cCA9IGdyb3Vwc1sgaSBdO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxbIGdyb3VwLm1hdGVyaWFsSW5kZXggXTtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICBzdGFydCA9IE1hdGgubWF4KCBncm91cC5zdGFydCwgZHJhd1JhbmdlLnN0YXJ0ICk7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKCAoIGdyb3VwLnN0YXJ0ICsgZ3JvdXAuY291bnQgKSwgKCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQgKSApO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIGZvciAoIGogPSBzdGFydCwgamwgPSBlbmQ7IGogPCBqbDsgaiArPSAzICkge1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICBhID0gajtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIGIgPSBqICsgMTtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIGMgPSBqICsgMjtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uID0gY2hlY2tCdWZmZXJHZW9tZXRyeUludGVyc2VjdGlvbiggdGhpcywgZ3JvdXBNYXRlcmlhbCwgcmF5Y2FzdGVyLCByYXksIHBvc2l0aW9uLCB1diwgYSwgYiwgYyApO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICBpZiAoIGludGVyc2VjdGlvbiApIHtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbi5mYWNlSW5kZXggPSBNYXRoLmZsb29yKCBqIC8gMyApOyAvLyB0cmlhbmdsZSBudW1iZXIgaW4gbm9uLWluZGV4ZWQgYnVmZmVyIHNlbWFudGljc1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0aW9uICk7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICB9XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICBzdGFydCA9IE1hdGgubWF4KCAwLCBkcmF3UmFuZ2Uuc3RhcnQgKTtcclxuICAgICAgICAvLyAgICAgICAgICAgICBlbmQgPSBNYXRoLm1pbiggcG9zaXRpb24uY291bnQsICggZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50ICkgKTtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIGZvciAoIGkgPSBzdGFydCwgaWwgPSBlbmQ7IGkgPCBpbDsgaSArPSAzICkge1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIGEgPSBpO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICBiID0gaSArIDE7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIGMgPSBpICsgMjtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb24gPSBjaGVja0J1ZmZlckdlb21ldHJ5SW50ZXJzZWN0aW9uKCB0aGlzLCBtYXRlcmlhbCwgcmF5Y2FzdGVyLCByYXksIHBvc2l0aW9uLCB1diwgYSwgYiwgYyApO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIGlmICggaW50ZXJzZWN0aW9uICkge1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gTWF0aC5mbG9vciggaSAvIDMgKTsgLy8gdHJpYW5nbGUgbnVtYmVyIGluIG5vbi1pbmRleGVkIGJ1ZmZlciBzZW1hbnRpY3NcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0aW9uICk7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgfVxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICB9XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gfSBlbHNlIGlmICggZ2VvbWV0cnkuaXNHZW9tZXRyeSApIHtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICB2YXIgZnZBLCBmdkIsIGZ2QztcclxuICAgICAgICAvLyAgICAgdmFyIGlzTXVsdGlNYXRlcmlhbCA9IEFycmF5LmlzQXJyYXkoIG1hdGVyaWFsICk7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XHJcbiAgICAgICAgLy8gICAgIHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xyXG4gICAgICAgIC8vICAgICB2YXIgdXZzO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgIHZhciBmYWNlVmVydGV4VXZzID0gZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgMCBdO1xyXG4gICAgICAgIC8vICAgICBpZiAoIGZhY2VWZXJ0ZXhVdnMubGVuZ3RoID4gMCApIHV2cyA9IGZhY2VWZXJ0ZXhVdnM7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgZm9yICggdmFyIGYgPSAwLCBmbCA9IGZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICB2YXIgZmFjZSA9IGZhY2VzWyBmIF07XHJcbiAgICAgICAgLy8gICAgICAgICB2YXIgZmFjZU1hdGVyaWFsID0gaXNNdWx0aU1hdGVyaWFsID8gbWF0ZXJpYWxbIGZhY2UubWF0ZXJpYWxJbmRleCBdIDogbWF0ZXJpYWw7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgIGlmICggZmFjZU1hdGVyaWFsID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgZnZBID0gdmVydGljZXNbIGZhY2UuYSBdO1xyXG4gICAgICAgIC8vICAgICAgICAgZnZCID0gdmVydGljZXNbIGZhY2UuYiBdO1xyXG4gICAgICAgIC8vICAgICAgICAgZnZDID0gdmVydGljZXNbIGZhY2UuYyBdO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICBpZiAoIGZhY2VNYXRlcmlhbC5tb3JwaFRhcmdldHMgPT09IHRydWUgKSB7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICB2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIHZhciBtb3JwaEluZmx1ZW5jZXMgPSB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIHZBLnNldCggMCwgMCwgMCApO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIHZCLnNldCggMCwgMCwgMCApO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIHZDLnNldCggMCwgMCwgMCApO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgZm9yICggdmFyIHQgPSAwLCB0bCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IHQgPCB0bDsgdCArKyApIHtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB2YXIgaW5mbHVlbmNlID0gbW9ycGhJbmZsdWVuY2VzWyB0IF07XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgaWYgKCBpbmZsdWVuY2UgPT09IDAgKSBjb250aW51ZTtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0cyA9IG1vcnBoVGFyZ2V0c1sgdCBdLnZlcnRpY2VzO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHZBLmFkZFNjYWxlZFZlY3RvciggdGVtcEEuc3ViVmVjdG9ycyggdGFyZ2V0c1sgZmFjZS5hIF0sIGZ2QSApLCBpbmZsdWVuY2UgKTtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgdkIuYWRkU2NhbGVkVmVjdG9yKCB0ZW1wQi5zdWJWZWN0b3JzKCB0YXJnZXRzWyBmYWNlLmIgXSwgZnZCICksIGluZmx1ZW5jZSApO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB2Qy5hZGRTY2FsZWRWZWN0b3IoIHRlbXBDLnN1YlZlY3RvcnMoIHRhcmdldHNbIGZhY2UuYyBdLCBmdkMgKSwgaW5mbHVlbmNlICk7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICB9XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgICAgICB2QS5hZGQoIGZ2QSApO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIHZCLmFkZCggZnZCICk7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgdkMuYWRkKCBmdkMgKTtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIGZ2QSA9IHZBO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIGZ2QiA9IHZCO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIGZ2QyA9IHZDO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICB9XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgIGludGVyc2VjdGlvbiA9IGNoZWNrSW50ZXJzZWN0aW9uKCB0aGlzLCBmYWNlTWF0ZXJpYWwsIHJheWNhc3RlciwgcmF5LCBmdkEsIGZ2QiwgZnZDLCBpbnRlcnNlY3Rpb25Qb2ludCApO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICBpZiAoIGludGVyc2VjdGlvbiApIHtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIGlmICggdXZzICYmIHV2c1sgZiBdICkge1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHZhciB1dnNfZiA9IHV2c1sgZiBdO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB1dkEuY29weSggdXZzX2ZbIDAgXSApO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB1dkIuY29weSggdXZzX2ZbIDEgXSApO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB1dkMuY29weSggdXZzX2ZbIDIgXSApO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbi51diA9IFRyaWFuZ2xlLmdldFVWKCBpbnRlcnNlY3Rpb25Qb2ludCwgZnZBLCBmdkIsIGZ2QywgdXZBLCB1dkIsIHV2QywgbmV3IFZlY3RvcjIoKSApO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgfVxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgaW50ZXJzZWN0aW9uLmZhY2UgPSBmYWNlO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIGludGVyc2VjdGlvbi5mYWNlSW5kZXggPSBmO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0aW9uICk7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICAgIH1cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyB9XHJcblxyXG4gICAgfVxyXG5cclxuXHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNZXNoO1xyXG4iLCIvKlxyXG4gKiBDb3B5cmlnaHQgMjAxMCwgR29vZ2xlIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XHJcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcclxuICogbWV0OlxyXG4gKlxyXG4gKiAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxyXG4gKiBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbiAqICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcclxuICogY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lclxyXG4gKiBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXHJcbiAqIGRpc3RyaWJ1dGlvbi5cclxuICogICAgICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xyXG4gKiBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxyXG4gKiB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxyXG4gKlxyXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXHJcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcclxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXHJcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXHJcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxyXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXHJcbiAqIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxyXG4gKiBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcclxuICogVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxyXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcclxuICogT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEBmaWxlb3ZlcnZpZXcgVGhpcyBmaWxlIGNvbnRhaW5zIGZ1bmN0aW9ucyBldmVyeSB3ZWJnbCBwcm9ncmFtIHdpbGwgbmVlZFxyXG4gKiBhIHZlcnNpb24gb2Ygb25lIHdheSBvciBhbm90aGVyLlxyXG4gKlxyXG4gKiBJbnN0ZWFkIG9mIHNldHRpbmcgdXAgYSBjb250ZXh0IG1hbnVhbGx5IGl0IGlzIHJlY29tbWVuZGVkIHRvXHJcbiAqIHVzZS4gVGhpcyB3aWxsIGNoZWNrIGZvciBzdWNjZXNzIG9yIGZhaWx1cmUuIE9uIGZhaWx1cmUgaXRcclxuICogd2lsbCBhdHRlbXB0IHRvIHByZXNlbnQgYW4gYXBwcm9yaWF0ZSBtZXNzYWdlIHRvIHRoZSB1c2VyLlxyXG4gKlxyXG4gKiAgICAgICBnbCA9IFdlYkdMVXRpbHMuc2V0dXBXZWJHTChjYW52YXMpO1xyXG4gKlxyXG4gKiBGb3IgYW5pbWF0ZWQgV2ViR0wgYXBwcyB1c2Ugb2Ygc2V0VGltZW91dCBvciBzZXRJbnRlcnZhbCBhcmVcclxuICogZGlzY291cmFnZWQuIEl0IGlzIHJlY29tbWVuZGVkIHlvdSBzdHJ1Y3R1cmUgeW91ciByZW5kZXJpbmdcclxuICogbG9vcCBsaWtlIHRoaXMuXHJcbiAqXHJcbiAqICAgICAgIGZ1bmN0aW9uIHJlbmRlcigpIHtcclxuICogICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlciwgY2FudmFzKTtcclxuICpcclxuICogICAgICAgICAvLyBkbyByZW5kZXJpbmdcclxuICogICAgICAgICAuLi5cclxuICogICAgICAgfVxyXG4gKiAgICAgICByZW5kZXIoKTtcclxuICpcclxuICogVGhpcyB3aWxsIGNhbGwgeW91ciByZW5kZXJpbmcgZnVuY3Rpb24gdXAgdG8gdGhlIHJlZnJlc2ggcmF0ZVxyXG4gKiBvZiB5b3VyIGRpc3BsYXkgYnV0IHdpbGwgc3RvcCByZW5kZXJpbmcgaWYgeW91ciBhcHAgaXMgbm90XHJcbiAqIHZpc2libGUuXHJcbiAqL1xyXG5cclxudmFyIFdlYkdMVXRpbHMgPSBmdW5jdGlvbigpIHtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIHRoZSBIVExNIGZvciBhIGZhaWx1cmUgbWVzc2FnZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gY2FudmFzQ29udGFpbmVySWQgaWQgb2YgY29udGFpbmVyIG9mIHRoXHJcbiAqICAgICAgICBjYW52YXMuXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGh0bWwuXHJcbiAqL1xyXG52YXIgbWFrZUZhaWxIVE1MID0gZnVuY3Rpb24obXNnKSB7XHJcbiAgcmV0dXJuICcnICtcclxuICAgICAgICAnPGRpdiBzdHlsZT1cIm1hcmdpbjogYXV0bzsgd2lkdGg6NTAwcHg7ei1pbmRleDoxMDAwMDttYXJnaW4tdG9wOjIwZW07dGV4dC1hbGlnbjpjZW50ZXI7XCI+JyArIG1zZyArICc8L2Rpdj4nO1xyXG4gIHJldHVybiAnJyArXHJcbiAgICAnPHRhYmxlIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjogIzhDRTsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTtcIj48dHI+JyArXHJcbiAgICAnPHRkIGFsaWduPVwiY2VudGVyXCI+JyArXHJcbiAgICAnPGRpdiBzdHlsZT1cImRpc3BsYXk6IHRhYmxlLWNlbGw7IHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XCI+JyArXHJcbiAgICAnPGRpdiBzdHlsZT1cIlwiPicgKyBtc2cgKyAnPC9kaXY+JyArXHJcbiAgICAnPC9kaXY+JyArXHJcbiAgICAnPC90ZD48L3RyPjwvdGFibGU+JztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNZXNhc2dlIGZvciBnZXR0aW5nIGEgd2ViZ2wgYnJvd3NlclxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cclxudmFyIEdFVF9BX1dFQkdMX0JST1dTRVIgPSAnJyArXHJcbiAgJ1RoaXMgcGFnZSByZXF1aXJlcyBhIGJyb3dzZXIgdGhhdCBzdXBwb3J0cyBXZWJHTC48YnIvPicgK1xyXG4gICc8YSBocmVmPVwiaHR0cDovL2dldC53ZWJnbC5vcmdcIj5DbGljayBoZXJlIHRvIHVwZ3JhZGUgeW91ciBicm93c2VyLjwvYT4nO1xyXG5cclxuLyoqXHJcbiAqIE1lc2FzZ2UgZm9yIG5lZWQgYmV0dGVyIGhhcmR3YXJlXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xyXG52YXIgT1RIRVJfUFJPQkxFTSA9ICcnICtcclxuICBcIkl0IGRvZXNuJ3QgYXBwZWFyIHlvdXIgY29tcHV0ZXIgY2FuIHN1cHBvcnQgV2ViR0wuPGJyLz5cIiArXHJcbiAgJzxhIGhyZWY9XCJodHRwOi8vZ2V0LndlYmdsLm9yZ1wiPkNsaWNrIGhlcmUgZm9yIG1vcmUgaW5mb3JtYXRpb24uPC9hPic7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIHdlYmdsIGNvbnRleHQuIElmIGNyZWF0aW9uIGZhaWxzIGl0IHdpbGxcclxuICogY2hhbmdlIHRoZSBjb250ZW50cyBvZiB0aGUgY29udGFpbmVyIG9mIHRoZSA8Y2FudmFzPlxyXG4gKiB0YWcgdG8gYW4gZXJyb3IgbWVzc2FnZSB3aXRoIHRoZSBjb3JyZWN0IGxpbmtzIGZvciBXZWJHTC5cclxuICogQHBhcmFtIHtFbGVtZW50fSBjYW52YXMuIFRoZSBjYW52YXMgZWxlbWVudCB0byBjcmVhdGUgYVxyXG4gKiAgICAgY29udGV4dCBmcm9tLlxyXG4gKiBAcGFyYW0ge1dlYkdMQ29udGV4dENyZWF0aW9uQXR0aXJidXRlc30gb3B0X2F0dHJpYnMgQW55XHJcbiAqICAgICBjcmVhdGlvbiBhdHRyaWJ1dGVzIHlvdSB3YW50IHRvIHBhc3MgaW4uXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb246KG1zZyl9IG9wdF9vbkVycm9yIEFuIGZ1bmN0aW9uIHRvIGNhbGxcclxuICogICAgIGlmIHRoZXJlIGlzIGFuIGVycm9yIGR1cmluZyBjcmVhdGlvbi5cclxuICogQHJldHVybiB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBUaGUgY3JlYXRlZCBjb250ZXh0LlxyXG4gKi9cclxudmFyIHNldHVwV2ViR0wgPSBmdW5jdGlvbihjYW52YXMsIG9wdF9hdHRyaWJzLCBvcHRfb25FcnJvcikge1xyXG4gIGZ1bmN0aW9uIGhhbmRsZUNyZWF0aW9uRXJyb3IobXNnKSB7XHJcbiAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImJvZHlcIilbMF07XHJcbiAgICAvL3ZhciBjb250YWluZXIgPSBjYW52YXMucGFyZW50Tm9kZTtcclxuICAgIGlmIChjb250YWluZXIpIHtcclxuICAgICAgdmFyIHN0ciA9IHdpbmRvdy5XZWJHTFJlbmRlcmluZ0NvbnRleHQgP1xyXG4gICAgICAgICAgIE9USEVSX1BST0JMRU0gOlxyXG4gICAgICAgICAgIEdFVF9BX1dFQkdMX0JST1dTRVI7XHJcbiAgICAgIGlmIChtc2cpIHtcclxuICAgICAgICBzdHIgKz0gXCI8YnIvPjxici8+U3RhdHVzOiBcIiArIG1zZztcclxuICAgICAgfVxyXG4gICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gbWFrZUZhaWxIVE1MKHN0cik7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgb3B0X29uRXJyb3IgPSBvcHRfb25FcnJvciB8fCBoYW5kbGVDcmVhdGlvbkVycm9yO1xyXG5cclxuICBpZiAoY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIpIHtcclxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0Y3JlYXRpb25lcnJvclwiLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgb3B0X29uRXJyb3IoZXZlbnQuc3RhdHVzTWVzc2FnZSk7XHJcbiAgICAgICAgfSwgZmFsc2UpO1xyXG4gIH1cclxuICB2YXIgY29udGV4dCA9IGNyZWF0ZTNEQ29udGV4dChjYW52YXMsIG9wdF9hdHRyaWJzKTtcclxuICBpZiAoIWNvbnRleHQpIHtcclxuICAgIGlmICghd2luZG93LldlYkdMUmVuZGVyaW5nQ29udGV4dCkge1xyXG4gICAgICBvcHRfb25FcnJvcihcIlwiKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG9wdF9vbkVycm9yKFwiXCIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGNvbnRleHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIHdlYmdsIGNvbnRleHQuXHJcbiAqIEBwYXJhbSB7IUNhbnZhc30gY2FudmFzIFRoZSBjYW52YXMgdGFnIHRvIGdldCBjb250ZXh0XHJcbiAqICAgICBmcm9tLiBJZiBvbmUgaXMgbm90IHBhc3NlZCBpbiBvbmUgd2lsbCBiZSBjcmVhdGVkLlxyXG4gKiBAcmV0dXJuIHshV2ViR0xDb250ZXh0fSBUaGUgY3JlYXRlZCBjb250ZXh0LlxyXG4gKi9cclxudmFyIGNyZWF0ZTNEQ29udGV4dCA9IGZ1bmN0aW9uKGNhbnZhcywgb3B0X2F0dHJpYnMpIHtcclxuICB2YXIgbmFtZXMgPSBbXCJ3ZWJnbFwiLCBcImV4cGVyaW1lbnRhbC13ZWJnbFwiLCBcIndlYmtpdC0zZFwiLCBcIm1vei13ZWJnbFwiXTtcclxuICB2YXIgY29udGV4dCA9IG51bGw7XHJcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG5hbWVzLmxlbmd0aDsgKytpaSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KG5hbWVzW2lpXSwgb3B0X2F0dHJpYnMpO1xyXG4gICAgfSBjYXRjaChlKSB7fVxyXG4gICAgaWYgKGNvbnRleHQpIHtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBjb250ZXh0O1xyXG59XHJcblxyXG5yZXR1cm4ge1xyXG4gIGNyZWF0ZTNEQ29udGV4dDogY3JlYXRlM0RDb250ZXh0LFxyXG4gIHNldHVwV2ViR0w6IHNldHVwV2ViR0xcclxufTtcclxufSgpO1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVzIHJlcXVlc3RBbmltYXRpb25GcmFtZSBpbiBhIGNyb3NzIGJyb3dzZXJcclxuICogd2F5LlxyXG4gKi9cclxuaWYgKCF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XHJcbiAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IChmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XHJcbiAgICAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuICAgICAgICAgICB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICAgICAgIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICAgICAgIGZ1bmN0aW9uKC8qIGZ1bmN0aW9uIEZyYW1lUmVxdWVzdENhbGxiYWNrICovIGNhbGxiYWNrLCAvKiBET01FbGVtZW50IEVsZW1lbnQgKi8gZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAvNjApO1xyXG4gICAgICAgICAgIH07XHJcbiAgfSkoKTtcclxufVxyXG5cclxuLyoqICogRVJSQVRBOiAnY2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJyByZW5hbWVkIHRvICdjYW5jZWxBbmltYXRpb25GcmFtZScgdG8gcmVmbGVjdCBhbiB1cGRhdGUgdG8gdGhlIFczQyBBbmltYXRpb24tVGltaW5nIFNwZWMuIFxyXG4gKiBcclxuICogQ2FuY2VscyBhbiBhbmltYXRpb24gZnJhbWUgcmVxdWVzdC4gXHJcbiAqIENoZWNrcyBmb3IgY3Jvc3MtYnJvd3NlciBzdXBwb3J0LCBmYWxscyBiYWNrIHRvIGNsZWFyVGltZW91dC4gXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSAgQW5pbWF0aW9uIGZyYW1lIHJlcXVlc3QuICovXHJcbmlmICghd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKSB7XHJcbiAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gKHdpbmRvdy5jYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm1zQ2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5vQ2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm9DYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFdlYkdMVXRpbHM7IiwiLy9Db3B5cmlnaHQgKGMpIDIwMDkgVGhlIENocm9taXVtIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4vL2ZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUuXHJcblxyXG4vLyBWYXJpb3VzIGZ1bmN0aW9ucyBmb3IgaGVscGluZyBkZWJ1ZyBXZWJHTCBhcHBzLlxyXG5cclxudmFyIFdlYkdMRGVidWdVdGlscyA9IGZ1bmN0aW9uKCkge1xyXG5cclxuLyoqXHJcbiAqIFdyYXBwZWQgbG9nZ2luZyBmdW5jdGlvbi5cclxuICogQHBhcmFtIHtzdHJpbmd9IG1zZyBNZXNzYWdlIHRvIGxvZy5cclxuICovXHJcbnZhciBsb2cgPSBmdW5jdGlvbihtc2cpIHtcclxuICBpZiAod2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUubG9nKSB7XHJcbiAgICB3aW5kb3cuY29uc29sZS5sb2cobXNnKTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogV2hpY2ggYXJndWVtZW50cyBhcmUgZW51bXMuXHJcbiAqIEB0eXBlIHshT2JqZWN0LjxudW1iZXIsIHN0cmluZz59XHJcbiAqL1xyXG52YXIgZ2xWYWxpZEVudW1Db250ZXh0cyA9IHtcclxuXHJcbiAgLy8gR2VuZXJpYyBzZXR0ZXJzIGFuZCBnZXR0ZXJzXHJcblxyXG4gICdlbmFibGUnOiB7IDA6dHJ1ZSB9LFxyXG4gICdkaXNhYmxlJzogeyAwOnRydWUgfSxcclxuICAnZ2V0UGFyYW1ldGVyJzogeyAwOnRydWUgfSxcclxuXHJcbiAgLy8gUmVuZGVyaW5nXHJcblxyXG4gICdkcmF3QXJyYXlzJzogeyAwOnRydWUgfSxcclxuICAnZHJhd0VsZW1lbnRzJzogeyAwOnRydWUsIDI6dHJ1ZSB9LFxyXG5cclxuICAvLyBTaGFkZXJzXHJcblxyXG4gICdjcmVhdGVTaGFkZXInOiB7IDA6dHJ1ZSB9LFxyXG4gICdnZXRTaGFkZXJQYXJhbWV0ZXInOiB7IDE6dHJ1ZSB9LFxyXG4gICdnZXRQcm9ncmFtUGFyYW1ldGVyJzogeyAxOnRydWUgfSxcclxuXHJcbiAgLy8gVmVydGV4IGF0dHJpYnV0ZXNcclxuXHJcbiAgJ2dldFZlcnRleEF0dHJpYic6IHsgMTp0cnVlIH0sXHJcbiAgJ3ZlcnRleEF0dHJpYlBvaW50ZXInOiB7IDI6dHJ1ZSB9LFxyXG5cclxuICAvLyBUZXh0dXJlc1xyXG5cclxuICAnYmluZFRleHR1cmUnOiB7IDA6dHJ1ZSB9LFxyXG4gICdhY3RpdmVUZXh0dXJlJzogeyAwOnRydWUgfSxcclxuICAnZ2V0VGV4UGFyYW1ldGVyJzogeyAwOnRydWUsIDE6dHJ1ZSB9LFxyXG4gICd0ZXhQYXJhbWV0ZXJmJzogeyAwOnRydWUsIDE6dHJ1ZSB9LFxyXG4gICd0ZXhQYXJhbWV0ZXJpJzogeyAwOnRydWUsIDE6dHJ1ZSwgMjp0cnVlIH0sXHJcbiAgJ3RleEltYWdlMkQnOiB7IDA6dHJ1ZSwgMjp0cnVlLCA2OnRydWUsIDc6dHJ1ZSB9LFxyXG4gICd0ZXhTdWJJbWFnZTJEJzogeyAwOnRydWUsIDY6dHJ1ZSwgNzp0cnVlIH0sXHJcbiAgJ2NvcHlUZXhJbWFnZTJEJzogeyAwOnRydWUsIDI6dHJ1ZSB9LFxyXG4gICdjb3B5VGV4U3ViSW1hZ2UyRCc6IHsgMDp0cnVlIH0sXHJcbiAgJ2dlbmVyYXRlTWlwbWFwJzogeyAwOnRydWUgfSxcclxuXHJcbiAgLy8gQnVmZmVyIG9iamVjdHNcclxuXHJcbiAgJ2JpbmRCdWZmZXInOiB7IDA6dHJ1ZSB9LFxyXG4gICdidWZmZXJEYXRhJzogeyAwOnRydWUsIDI6dHJ1ZSB9LFxyXG4gICdidWZmZXJTdWJEYXRhJzogeyAwOnRydWUgfSxcclxuICAnZ2V0QnVmZmVyUGFyYW1ldGVyJzogeyAwOnRydWUsIDE6dHJ1ZSB9LFxyXG5cclxuICAvLyBSZW5kZXJidWZmZXJzIGFuZCBmcmFtZWJ1ZmZlcnNcclxuXHJcbiAgJ3BpeGVsU3RvcmVpJzogeyAwOnRydWUsIDE6dHJ1ZSB9LFxyXG4gICdyZWFkUGl4ZWxzJzogeyA0OnRydWUsIDU6dHJ1ZSB9LFxyXG4gICdiaW5kUmVuZGVyYnVmZmVyJzogeyAwOnRydWUgfSxcclxuICAnYmluZEZyYW1lYnVmZmVyJzogeyAwOnRydWUgfSxcclxuICAnY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyc6IHsgMDp0cnVlIH0sXHJcbiAgJ2ZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyJzogeyAwOnRydWUsIDE6dHJ1ZSwgMjp0cnVlIH0sXHJcbiAgJ2ZyYW1lYnVmZmVyVGV4dHVyZTJEJzogeyAwOnRydWUsIDE6dHJ1ZSwgMjp0cnVlIH0sXHJcbiAgJ2dldEZyYW1lYnVmZmVyQXR0YWNobWVudFBhcmFtZXRlcic6IHsgMDp0cnVlLCAxOnRydWUsIDI6dHJ1ZSB9LFxyXG4gICdnZXRSZW5kZXJidWZmZXJQYXJhbWV0ZXInOiB7IDA6dHJ1ZSwgMTp0cnVlIH0sXHJcbiAgJ3JlbmRlcmJ1ZmZlclN0b3JhZ2UnOiB7IDA6dHJ1ZSwgMTp0cnVlIH0sXHJcblxyXG4gIC8vIEZyYW1lIGJ1ZmZlciBvcGVyYXRpb25zIChjbGVhciwgYmxlbmQsIGRlcHRoIHRlc3QsIHN0ZW5jaWwpXHJcblxyXG4gICdjbGVhcic6IHsgMDp0cnVlIH0sXHJcbiAgJ2RlcHRoRnVuYyc6IHsgMDp0cnVlIH0sXHJcbiAgJ2JsZW5kRnVuYyc6IHsgMDp0cnVlLCAxOnRydWUgfSxcclxuICAnYmxlbmRGdW5jU2VwYXJhdGUnOiB7IDA6dHJ1ZSwgMTp0cnVlLCAyOnRydWUsIDM6dHJ1ZSB9LFxyXG4gICdibGVuZEVxdWF0aW9uJzogeyAwOnRydWUgfSxcclxuICAnYmxlbmRFcXVhdGlvblNlcGFyYXRlJzogeyAwOnRydWUsIDE6dHJ1ZSB9LFxyXG4gICdzdGVuY2lsRnVuYyc6IHsgMDp0cnVlIH0sXHJcbiAgJ3N0ZW5jaWxGdW5jU2VwYXJhdGUnOiB7IDA6dHJ1ZSwgMTp0cnVlIH0sXHJcbiAgJ3N0ZW5jaWxNYXNrU2VwYXJhdGUnOiB7IDA6dHJ1ZSB9LFxyXG4gICdzdGVuY2lsT3AnOiB7IDA6dHJ1ZSwgMTp0cnVlLCAyOnRydWUgfSxcclxuICAnc3RlbmNpbE9wU2VwYXJhdGUnOiB7IDA6dHJ1ZSwgMTp0cnVlLCAyOnRydWUsIDM6dHJ1ZSB9LFxyXG5cclxuICAvLyBDdWxsaW5nXHJcblxyXG4gICdjdWxsRmFjZSc6IHsgMDp0cnVlIH0sXHJcbiAgJ2Zyb250RmFjZSc6IHsgMDp0cnVlIH0sXHJcbn07XHJcblxyXG4vKipcclxuICogTWFwIG9mIG51bWJlcnMgdG8gbmFtZXMuXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqL1xyXG52YXIgZ2xFbnVtcyA9IG51bGw7XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZXMgdGhpcyBtb2R1bGUuIFNhZmUgdG8gY2FsbCBtb3JlIHRoYW4gb25jZS5cclxuICogQHBhcmFtIHshV2ViR0xSZW5kZXJpbmdDb250ZXh0fSBjdHggQSBXZWJHTCBjb250ZXh0LiBJZlxyXG4gKiAgICB5b3UgaGF2ZSBtb3JlIHRoYW4gb25lIGNvbnRleHQgaXQgZG9lc24ndCBtYXR0ZXIgd2hpY2ggb25lXHJcbiAqICAgIHlvdSBwYXNzIGluLCBpdCBpcyBvbmx5IHVzZWQgdG8gcHVsbCBvdXQgY29uc3RhbnRzLlxyXG4gKi9cclxuZnVuY3Rpb24gaW5pdChjdHgpIHtcclxuICBpZiAoZ2xFbnVtcyA9PSBudWxsKSB7XHJcbiAgICBnbEVudW1zID0geyB9O1xyXG4gICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIGN0eCkge1xyXG4gICAgICBpZiAodHlwZW9mIGN0eFtwcm9wZXJ0eU5hbWVdID09ICdudW1iZXInKSB7XHJcbiAgICAgICAgZ2xFbnVtc1tjdHhbcHJvcGVydHlOYW1lXV0gPSBwcm9wZXJ0eU5hbWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgdGhlIHV0aWxzIGhhdmUgYmVlbiBpbml0aWFsaXplZC5cclxuICovXHJcbmZ1bmN0aW9uIGNoZWNrSW5pdCgpIHtcclxuICBpZiAoZ2xFbnVtcyA9PSBudWxsKSB7XHJcbiAgICB0aHJvdyAnV2ViR0xEZWJ1Z1V0aWxzLmluaXQoY3R4KSBub3QgY2FsbGVkJztcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgaWYgdmFsdWUgbWF0Y2hlcyBhbnkgV2ViR0wgZW51bVxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGNoZWNrIGlmIGl0IG1pZ2h0IGJlIGFuIGVudW0uXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgbWF0Y2hlcyBvbmUgb2YgdGhlIFdlYkdMIGRlZmluZWQgZW51bXNcclxuICovXHJcbmZ1bmN0aW9uIG1pZ2h0QmVFbnVtKHZhbHVlKSB7XHJcbiAgY2hlY2tJbml0KCk7XHJcbiAgcmV0dXJuIChnbEVudW1zW3ZhbHVlXSAhPT0gdW5kZWZpbmVkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgYW4gc3RyaW5nIHZlcnNpb24gb2YgYW4gV2ViR0wgZW51bS5cclxuICpcclxuICogRXhhbXBsZTpcclxuICogICB2YXIgc3RyID0gV2ViR0xEZWJ1Z1V0aWwuZ2xFbnVtVG9TdHJpbmcoY3R4LmdldEVycm9yKCkpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gcmV0dXJuIGFuIGVudW0gZm9yXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZyB2ZXJzaW9uIG9mIHRoZSBlbnVtLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2xFbnVtVG9TdHJpbmcodmFsdWUpIHtcclxuICBjaGVja0luaXQoKTtcclxuICB2YXIgbmFtZSA9IGdsRW51bXNbdmFsdWVdO1xyXG4gIHJldHVybiAobmFtZSAhPT0gdW5kZWZpbmVkKSA/IG5hbWUgOlxyXG4gICAgICAoXCIqVU5LTk9XTiBXZWJHTCBFTlVNICgweFwiICsgdmFsdWUudG9TdHJpbmcoMTYpICsgXCIpXCIpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgc3RyaW5nIHZlcnNpb24gb2YgYSBXZWJHTCBhcmd1bWVudC5cclxuICogQXR0ZW1wdHMgdG8gY29udmVydCBlbnVtIGFyZ3VtZW50cyB0byBzdHJpbmdzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25OYW1lIHRoZSBuYW1lIG9mIHRoZSBXZWJHTCBmdW5jdGlvbi5cclxuICogQHBhcmFtIHtudW1iZXJ9IGFyZ3VtZW50SW5keCB0aGUgaW5kZXggb2YgdGhlIGFyZ3VtZW50LlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgYXJndW1lbnQuXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHZhbHVlIGFzIGEgc3RyaW5nLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2xGdW5jdGlvbkFyZ1RvU3RyaW5nKGZ1bmN0aW9uTmFtZSwgYXJndW1lbnRJbmRleCwgdmFsdWUpIHtcclxuICB2YXIgZnVuY0luZm8gPSBnbFZhbGlkRW51bUNvbnRleHRzW2Z1bmN0aW9uTmFtZV07XHJcbiAgaWYgKGZ1bmNJbmZvICE9PSB1bmRlZmluZWQpIHtcclxuICAgIGlmIChmdW5jSW5mb1thcmd1bWVudEluZGV4XSkge1xyXG4gICAgICByZXR1cm4gZ2xFbnVtVG9TdHJpbmcodmFsdWUpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGEgV2ViR0wgY29udGV4dCByZXR1cm5zIGEgd3JhcHBlZCBjb250ZXh0IHRoYXQgY2FsbHNcclxuICogZ2wuZ2V0RXJyb3IgYWZ0ZXIgZXZlcnkgY29tbWFuZCBhbmQgY2FsbHMgYSBmdW5jdGlvbiBpZiB0aGVcclxuICogcmVzdWx0IGlzIG5vdCBnbC5OT19FUlJPUi5cclxuICpcclxuICogQHBhcmFtIHshV2ViR0xSZW5kZXJpbmdDb250ZXh0fSBjdHggVGhlIHdlYmdsIGNvbnRleHQgdG9cclxuICogICAgICAgIHdyYXAuXHJcbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKGVyciwgZnVuY05hbWUsIGFyZ3MpOiB2b2lkfSBvcHRfb25FcnJvckZ1bmNcclxuICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gZ2wuZ2V0RXJyb3IgcmV0dXJucyBhblxyXG4gKiAgICAgICAgZXJyb3IuIElmIG5vdCBzcGVjaWZpZWQgdGhlIGRlZmF1bHQgZnVuY3Rpb24gY2FsbHNcclxuICogICAgICAgIGNvbnNvbGUubG9nIHdpdGggYSBtZXNzYWdlLlxyXG4gKi9cclxuZnVuY3Rpb24gbWFrZURlYnVnQ29udGV4dChjdHgsIG9wdF9vbkVycm9yRnVuYykge1xyXG4gIGluaXQoY3R4KTtcclxuICBvcHRfb25FcnJvckZ1bmMgPSBvcHRfb25FcnJvckZ1bmMgfHwgZnVuY3Rpb24oZXJyLCBmdW5jdGlvbk5hbWUsIGFyZ3MpIHtcclxuICAgICAgICAvLyBhcHBhcmVudGx5IHdlIGNhbid0IGRvIGFyZ3Muam9pbihcIixcIik7XHJcbiAgICAgICAgdmFyIGFyZ1N0ciA9IFwiXCI7XHJcbiAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGFyZ3MubGVuZ3RoOyArK2lpKSB7XHJcbiAgICAgICAgICBhcmdTdHIgKz0gKChpaSA9PSAwKSA/ICcnIDogJywgJykgK1xyXG4gICAgICAgICAgICAgIGdsRnVuY3Rpb25BcmdUb1N0cmluZyhmdW5jdGlvbk5hbWUsIGlpLCBhcmdzW2lpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxvZyhcIldlYkdMIGVycm9yIFwiKyBnbEVudW1Ub1N0cmluZyhlcnIpICsgXCIgaW4gXCIrIGZ1bmN0aW9uTmFtZSArXHJcbiAgICAgICAgICAgIFwiKFwiICsgYXJnU3RyICsgXCIpXCIpO1xyXG4gICAgICB9O1xyXG5cclxuICAvLyBIb2xkcyBib29sZWFucyBmb3IgZWFjaCBHTCBlcnJvciBzbyBhZnRlciB3ZSBnZXQgdGhlIGVycm9yIG91cnNlbHZlc1xyXG4gIC8vIHdlIGNhbiBzdGlsbCByZXR1cm4gaXQgdG8gdGhlIGNsaWVudCBhcHAuXHJcbiAgdmFyIGdsRXJyb3JTaGFkb3cgPSB7IH07XHJcblxyXG4gIC8vIE1ha2VzIGEgZnVuY3Rpb24gdGhhdCBjYWxscyBhIFdlYkdMIGZ1bmN0aW9uIGFuZCB0aGVuIGNhbGxzIGdldEVycm9yLlxyXG4gIGZ1bmN0aW9uIG1ha2VFcnJvcldyYXBwZXIoY3R4LCBmdW5jdGlvbk5hbWUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIHJlc3VsdCA9IGN0eFtmdW5jdGlvbk5hbWVdLmFwcGx5KGN0eCwgYXJndW1lbnRzKTtcclxuICAgICAgdmFyIGVyciA9IGN0eC5nZXRFcnJvcigpO1xyXG4gICAgICBpZiAoZXJyICE9IDApIHtcclxuICAgICAgICBnbEVycm9yU2hhZG93W2Vycl0gPSB0cnVlO1xyXG4gICAgICAgIG9wdF9vbkVycm9yRnVuYyhlcnIsIGZ1bmN0aW9uTmFtZSwgYXJndW1lbnRzKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIE1ha2UgYSBhbiBvYmplY3QgdGhhdCBoYXMgYSBjb3B5IG9mIGV2ZXJ5IHByb3BlcnR5IG9mIHRoZSBXZWJHTCBjb250ZXh0XHJcbiAgLy8gYnV0IHdyYXBzIGFsbCBmdW5jdGlvbnMuXHJcbiAgdmFyIHdyYXBwZXIgPSB7fTtcclxuICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gY3R4KSB7XHJcbiAgICBpZiAodHlwZW9mIGN0eFtwcm9wZXJ0eU5hbWVdID09ICdmdW5jdGlvbicpIHtcclxuICAgICAgIHdyYXBwZXJbcHJvcGVydHlOYW1lXSA9IG1ha2VFcnJvcldyYXBwZXIoY3R4LCBwcm9wZXJ0eU5hbWUpO1xyXG4gICAgIH0gZWxzZSB7XHJcbiAgICAgICB3cmFwcGVyW3Byb3BlcnR5TmFtZV0gPSBjdHhbcHJvcGVydHlOYW1lXTtcclxuICAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBPdmVycmlkZSB0aGUgZ2V0RXJyb3IgZnVuY3Rpb24gd2l0aCBvbmUgdGhhdCByZXR1cm5zIG91ciBzYXZlZCByZXN1bHRzLlxyXG4gIHdyYXBwZXIuZ2V0RXJyb3IgPSBmdW5jdGlvbigpIHtcclxuICAgIGZvciAodmFyIGVyciBpbiBnbEVycm9yU2hhZG93KSB7XHJcbiAgICAgIGlmIChnbEVycm9yU2hhZG93W2Vycl0pIHtcclxuICAgICAgICBnbEVycm9yU2hhZG93W2Vycl0gPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gZXJyO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3R4Lk5PX0VSUk9SO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiB3cmFwcGVyO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXNldFRvSW5pdGlhbFN0YXRlKGN0eCkge1xyXG4gIHZhciBudW1BdHRyaWJzID0gY3R4LmdldFBhcmFtZXRlcihjdHguTUFYX1ZFUlRFWF9BVFRSSUJTKTtcclxuICB2YXIgdG1wID0gY3R4LmNyZWF0ZUJ1ZmZlcigpO1xyXG4gIGN0eC5iaW5kQnVmZmVyKGN0eC5BUlJBWV9CVUZGRVIsIHRtcCk7XHJcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG51bUF0dHJpYnM7ICsraWkpIHtcclxuICAgIGN0eC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoaWkpO1xyXG4gICAgY3R4LnZlcnRleEF0dHJpYlBvaW50ZXIoaWksIDQsIGN0eC5GTE9BVCwgZmFsc2UsIDAsIDApO1xyXG4gICAgY3R4LnZlcnRleEF0dHJpYjFmKGlpLCAwKTtcclxuICB9XHJcbiAgY3R4LmRlbGV0ZUJ1ZmZlcih0bXApO1xyXG5cclxuICB2YXIgbnVtVGV4dHVyZVVuaXRzID0gY3R4LmdldFBhcmFtZXRlcihjdHguTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMpO1xyXG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBudW1UZXh0dXJlVW5pdHM7ICsraWkpIHtcclxuICAgIGN0eC5hY3RpdmVUZXh0dXJlKGN0eC5URVhUVVJFMCArIGlpKTtcclxuICAgIGN0eC5iaW5kVGV4dHVyZShjdHguVEVYVFVSRV9DVUJFX01BUCwgbnVsbCk7XHJcbiAgICBjdHguYmluZFRleHR1cmUoY3R4LlRFWFRVUkVfMkQsIG51bGwpO1xyXG4gIH1cclxuXHJcbiAgY3R4LmFjdGl2ZVRleHR1cmUoY3R4LlRFWFRVUkUwKTtcclxuICBjdHgudXNlUHJvZ3JhbShudWxsKTtcclxuICBjdHguYmluZEJ1ZmZlcihjdHguQVJSQVlfQlVGRkVSLCBudWxsKTtcclxuICBjdHguYmluZEJ1ZmZlcihjdHguRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG51bGwpO1xyXG4gIGN0eC5iaW5kRnJhbWVidWZmZXIoY3R4LkZSQU1FQlVGRkVSLCBudWxsKTtcclxuICBjdHguYmluZFJlbmRlcmJ1ZmZlcihjdHguUkVOREVSQlVGRkVSLCBudWxsKTtcclxuICBjdHguZGlzYWJsZShjdHguQkxFTkQpO1xyXG4gIGN0eC5kaXNhYmxlKGN0eC5DVUxMX0ZBQ0UpO1xyXG4gIGN0eC5kaXNhYmxlKGN0eC5ERVBUSF9URVNUKTtcclxuICBjdHguZGlzYWJsZShjdHguRElUSEVSKTtcclxuICBjdHguZGlzYWJsZShjdHguU0NJU1NPUl9URVNUKTtcclxuICBjdHguYmxlbmRDb2xvcigwLCAwLCAwLCAwKTtcclxuICBjdHguYmxlbmRFcXVhdGlvbihjdHguRlVOQ19BREQpO1xyXG4gIGN0eC5ibGVuZEZ1bmMoY3R4Lk9ORSwgY3R4LlpFUk8pO1xyXG4gIGN0eC5jbGVhckNvbG9yKDAsIDAsIDAsIDApO1xyXG4gIGN0eC5jbGVhckRlcHRoKDEpO1xyXG4gIGN0eC5jbGVhclN0ZW5jaWwoLTEpO1xyXG4gIGN0eC5jb2xvck1hc2sodHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgY3R4LmN1bGxGYWNlKGN0eC5CQUNLKTtcclxuICBjdHguZGVwdGhGdW5jKGN0eC5MRVNTKTtcclxuICBjdHguZGVwdGhNYXNrKHRydWUpO1xyXG4gIGN0eC5kZXB0aFJhbmdlKDAsIDEpO1xyXG4gIGN0eC5mcm9udEZhY2UoY3R4LkNDVyk7XHJcbiAgY3R4LmhpbnQoY3R4LkdFTkVSQVRFX01JUE1BUF9ISU5ULCBjdHguRE9OVF9DQVJFKTtcclxuICBjdHgubGluZVdpZHRoKDEpO1xyXG4gIGN0eC5waXhlbFN0b3JlaShjdHguUEFDS19BTElHTk1FTlQsIDQpO1xyXG4gIGN0eC5waXhlbFN0b3JlaShjdHguVU5QQUNLX0FMSUdOTUVOVCwgNCk7XHJcbiAgY3R4LnBpeGVsU3RvcmVpKGN0eC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XHJcbiAgY3R4LnBpeGVsU3RvcmVpKGN0eC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIGZhbHNlKTtcclxuICAvLyBUT0RPOiBEZWxldGUgdGhpcyBJRi5cclxuICBpZiAoY3R4LlVOUEFDS19DT0xPUlNQQUNFX0NPTlZFUlNJT05fV0VCR0wpIHtcclxuICAgIGN0eC5waXhlbFN0b3JlaShjdHguVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTCwgY3R4LkJST1dTRVJfREVGQVVMVF9XRUJHTCk7XHJcbiAgfVxyXG4gIGN0eC5wb2x5Z29uT2Zmc2V0KDAsIDApO1xyXG4gIGN0eC5zYW1wbGVDb3ZlcmFnZSgxLCBmYWxzZSk7XHJcbiAgY3R4LnNjaXNzb3IoMCwgMCwgY3R4LmNhbnZhcy53aWR0aCwgY3R4LmNhbnZhcy5oZWlnaHQpO1xyXG4gIGN0eC5zdGVuY2lsRnVuYyhjdHguQUxXQVlTLCAwLCAweEZGRkZGRkZGKTtcclxuICBjdHguc3RlbmNpbE1hc2soMHhGRkZGRkZGRik7XHJcbiAgY3R4LnN0ZW5jaWxPcChjdHguS0VFUCwgY3R4LktFRVAsIGN0eC5LRUVQKTtcclxuICBjdHgudmlld3BvcnQoMCwgMCwgY3R4LmNhbnZhcy5jbGllbnRXaWR0aCwgY3R4LmNhbnZhcy5jbGllbnRIZWlnaHQpO1xyXG4gIGN0eC5jbGVhcihjdHguQ09MT1JfQlVGRkVSX0JJVCB8IGN0eC5ERVBUSF9CVUZGRVJfQklUIHwgY3R4LlNURU5DSUxfQlVGRkVSX0JJVCk7XHJcblxyXG4gIC8vIFRPRE86IFRoaXMgc2hvdWxkIE5PVCBiZSBuZWVkZWQgYnV0IEZpcmVmb3ggZmFpbHMgd2l0aCAnaGludCdcclxuICB3aGlsZShjdHguZ2V0RXJyb3IoKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1ha2VMb3N0Q29udGV4dFNpbXVsYXRpbmdDb250ZXh0KGN0eCkge1xyXG4gIHZhciB3cmFwcGVyXyA9IHt9O1xyXG4gIHZhciBjb250ZXh0SWRfID0gMTtcclxuICB2YXIgY29udGV4dExvc3RfID0gZmFsc2U7XHJcbiAgdmFyIHJlc291cmNlSWRfID0gMDtcclxuICB2YXIgcmVzb3VyY2VEYl8gPSBbXTtcclxuICB2YXIgb25Mb3N0XyA9IHVuZGVmaW5lZDtcclxuICB2YXIgb25SZXN0b3JlZF8gPSB1bmRlZmluZWQ7XHJcbiAgdmFyIG5leHRPblJlc3RvcmVkXyA9IHVuZGVmaW5lZDtcclxuXHJcbiAgLy8gSG9sZHMgYm9vbGVhbnMgZm9yIGVhY2ggR0wgZXJyb3Igc28gY2FuIHNpbXVsYXRlIGVycm9ycy5cclxuICB2YXIgZ2xFcnJvclNoYWRvd18gPSB7IH07XHJcblxyXG4gIGZ1bmN0aW9uIGlzV2ViR0xPYmplY3Qob2JqKSB7XHJcbiAgICAvL3JldHVybiBmYWxzZTtcclxuICAgIHJldHVybiAob2JqIGluc3RhbmNlb2YgV2ViR0xCdWZmZXIgfHxcclxuICAgICAgICAgICAgb2JqIGluc3RhbmNlb2YgV2ViR0xGcmFtZWJ1ZmZlciB8fFxyXG4gICAgICAgICAgICBvYmogaW5zdGFuY2VvZiBXZWJHTFByb2dyYW0gfHxcclxuICAgICAgICAgICAgb2JqIGluc3RhbmNlb2YgV2ViR0xSZW5kZXJidWZmZXIgfHxcclxuICAgICAgICAgICAgb2JqIGluc3RhbmNlb2YgV2ViR0xTaGFkZXIgfHxcclxuICAgICAgICAgICAgb2JqIGluc3RhbmNlb2YgV2ViR0xUZXh0dXJlKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNoZWNrUmVzb3VyY2VzKGFyZ3MpIHtcclxuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBhcmdzLmxlbmd0aDsgKytpaSkge1xyXG4gICAgICB2YXIgYXJnID0gYXJnc1tpaV07XHJcbiAgICAgIGlmIChpc1dlYkdMT2JqZWN0KGFyZykpIHtcclxuICAgICAgICByZXR1cm4gYXJnLl9fd2ViZ2xEZWJ1Z0NvbnRleHRMb3N0SWRfXyA9PSBjb250ZXh0SWRfO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNsZWFyRXJyb3JzKCkge1xyXG4gICAgdmFyIGsgPSBPYmplY3Qua2V5cyhnbEVycm9yU2hhZG93Xyk7XHJcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgay5sZW5ndGg7ICsraWkpIHtcclxuICAgICAgZGVsZXRlIGdsRXJyb3JTaGRvd19ba107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBNYWtlcyBhIGZ1bmN0aW9uIHRoYXQgc2ltdWxhdGVzIFdlYkdMIHdoZW4gb3V0IG9mIGNvbnRleHQuXHJcbiAgZnVuY3Rpb24gbWFrZUxvc3RDb250ZXh0V3JhcHBlcihjdHgsIGZ1bmN0aW9uTmFtZSkge1xyXG4gICAgdmFyIGYgPSBjdHhbZnVuY3Rpb25OYW1lXTtcclxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgLy8gT25seSBjYWxsIHRoZSBmdW5jdGlvbnMgaWYgdGhlIGNvbnRleHQgaXMgbm90IGxvc3QuXHJcbiAgICAgIGlmICghY29udGV4dExvc3RfKSB7XHJcbiAgICAgICAgaWYgKCFjaGVja1Jlc291cmNlcyhhcmd1bWVudHMpKSB7XHJcbiAgICAgICAgICBnbEVycm9yU2hhZG93X1tjdHguSU5WQUxJRF9PUEVSQVRJT05dID0gdHJ1ZTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGYuYXBwbHkoY3R4LCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gY3R4KSB7XHJcbiAgICBpZiAodHlwZW9mIGN0eFtwcm9wZXJ0eU5hbWVdID09ICdmdW5jdGlvbicpIHtcclxuICAgICAgIHdyYXBwZXJfW3Byb3BlcnR5TmFtZV0gPSBtYWtlTG9zdENvbnRleHRXcmFwcGVyKGN0eCwgcHJvcGVydHlOYW1lKTtcclxuICAgICB9IGVsc2Uge1xyXG4gICAgICAgd3JhcHBlcl9bcHJvcGVydHlOYW1lXSA9IGN0eFtwcm9wZXJ0eU5hbWVdO1xyXG4gICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG1ha2VXZWJHTENvbnRleHRFdmVudChzdGF0dXNNZXNzYWdlKSB7XHJcbiAgICByZXR1cm4ge3N0YXR1c01lc3NhZ2U6IHN0YXR1c01lc3NhZ2V9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZnJlZVJlc291cmNlcygpIHtcclxuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCByZXNvdXJjZURiXy5sZW5ndGg7ICsraWkpIHtcclxuICAgICAgdmFyIHJlc291cmNlID0gcmVzb3VyY2VEYl9baWldO1xyXG4gICAgICBpZiAocmVzb3VyY2UgaW5zdGFuY2VvZiBXZWJHTEJ1ZmZlcikge1xyXG4gICAgICAgIGN0eC5kZWxldGVCdWZmZXIocmVzb3VyY2UpO1xyXG4gICAgICB9IGVsc2UgaWYgKHJlc291cmNlIGluc3RhbmNlb2YgV2ViY3R4RnJhbWVidWZmZXIpIHtcclxuICAgICAgICBjdHguZGVsZXRlRnJhbWVidWZmZXIocmVzb3VyY2UpO1xyXG4gICAgICB9IGVsc2UgaWYgKHJlc291cmNlIGluc3RhbmNlb2YgV2ViY3R4UHJvZ3JhbSkge1xyXG4gICAgICAgIGN0eC5kZWxldGVQcm9ncmFtKHJlc291cmNlKTtcclxuICAgICAgfSBlbHNlIGlmIChyZXNvdXJjZSBpbnN0YW5jZW9mIFdlYmN0eFJlbmRlcmJ1ZmZlcikge1xyXG4gICAgICAgIGN0eC5kZWxldGVSZW5kZXJidWZmZXIocmVzb3VyY2UpO1xyXG4gICAgICB9IGVsc2UgaWYgKHJlc291cmNlIGluc3RhbmNlb2YgV2ViY3R4U2hhZGVyKSB7XHJcbiAgICAgICAgY3R4LmRlbGV0ZVNoYWRlcihyZXNvdXJjZSk7XHJcbiAgICAgIH0gZWxzZSBpZiAocmVzb3VyY2UgaW5zdGFuY2VvZiBXZWJjdHhUZXh0dXJlKSB7XHJcbiAgICAgICAgY3R4LmRlbGV0ZVRleHR1cmUocmVzb3VyY2UpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB3cmFwcGVyXy5sb3NlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKCFjb250ZXh0TG9zdF8pIHtcclxuICAgICAgY29udGV4dExvc3RfID0gdHJ1ZTtcclxuICAgICAgKytjb250ZXh0SWRfO1xyXG4gICAgICB3aGlsZSAoY3R4LmdldEVycm9yKCkpO1xyXG4gICAgICBjbGVhckVycm9ycygpO1xyXG4gICAgICBnbEVycm9yU2hhZG93X1tjdHguQ09OVEVYVF9MT1NUX1dFQkdMXSA9IHRydWU7XHJcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBpZiAob25Mb3N0Xykge1xyXG4gICAgICAgICAgICBvbkxvc3RfKG1ha2VXZWJHTENvbnRleHRFdmVudChcImNvbnRleHQgbG9zdFwiKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgd3JhcHBlcl8ucmVzdG9yZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcclxuICAgIGlmIChjb250ZXh0TG9zdF8pIHtcclxuICAgICAgaWYgKG9uUmVzdG9yZWRfKSB7XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgZnJlZVJlc291cmNlcygpO1xyXG4gICAgICAgICAgICByZXNldFRvSW5pdGlhbFN0YXRlKGN0eCk7XHJcbiAgICAgICAgICAgIGNvbnRleHRMb3N0XyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAob25SZXN0b3JlZF8pIHtcclxuICAgICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBvblJlc3RvcmVkXztcclxuICAgICAgICAgICAgICBvblJlc3RvcmVkXyA9IG5leHRPblJlc3RvcmVkXztcclxuICAgICAgICAgICAgICBuZXh0T25SZXN0b3JlZF8gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgY2FsbGJhY2sobWFrZVdlYkdMQ29udGV4dEV2ZW50KFwiY29udGV4dCByZXN0b3JlZFwiKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0sIDApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IFwiWW91IGNhbiBub3QgcmVzdG9yZSB0aGUgY29udGV4dCB3aXRob3V0IGEgbGlzdGVuZXJcIlxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gV3JhcCBhIGZldyBmdW5jdGlvbnMgc3BlY2lhbGx5LlxyXG4gIHdyYXBwZXJfLmdldEVycm9yID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAoIWNvbnRleHRMb3N0Xykge1xyXG4gICAgICB2YXIgZXJyO1xyXG4gICAgICB3aGlsZSAoZXJyID0gY3R4LmdldEVycm9yKCkpIHtcclxuICAgICAgICBnbEVycm9yU2hhZG93X1tlcnJdID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgZXJyIGluIGdsRXJyb3JTaGFkb3dfKSB7XHJcbiAgICAgIGlmIChnbEVycm9yU2hhZG93X1tlcnJdKSB7XHJcbiAgICAgICAgZGVsZXRlIGdsRXJyb3JTaGFkb3dfW2Vycl07XHJcbiAgICAgICAgcmV0dXJuIGVycjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGN0eC5OT19FUlJPUjtcclxuICB9O1xyXG5cclxuICB2YXIgY3JlYXRpb25GdW5jdGlvbnMgPSBbXHJcbiAgICBcImNyZWF0ZUJ1ZmZlclwiLFxyXG4gICAgXCJjcmVhdGVGcmFtZWJ1ZmZlclwiLFxyXG4gICAgXCJjcmVhdGVQcm9ncmFtXCIsXHJcbiAgICBcImNyZWF0ZVJlbmRlcmJ1ZmZlclwiLFxyXG4gICAgXCJjcmVhdGVTaGFkZXJcIixcclxuICAgIFwiY3JlYXRlVGV4dHVyZVwiXHJcbiAgXTtcclxuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgY3JlYXRpb25GdW5jdGlvbnMubGVuZ3RoOyArK2lpKSB7XHJcbiAgICB2YXIgZnVuY3Rpb25OYW1lID0gY3JlYXRpb25GdW5jdGlvbnNbaWldO1xyXG4gICAgd3JhcHBlcl9bZnVuY3Rpb25OYW1lXSA9IGZ1bmN0aW9uKGYpIHtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmIChjb250ZXh0TG9zdF8pIHtcclxuICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb2JqID0gZi5hcHBseShjdHgsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgb2JqLl9fd2ViZ2xEZWJ1Z0NvbnRleHRMb3N0SWRfXyA9IGNvbnRleHRJZF87XHJcbiAgICAgICAgcmVzb3VyY2VEYl8ucHVzaChvYmopO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgIH07XHJcbiAgICB9KGN0eFtmdW5jdGlvbk5hbWVdKTtcclxuICB9XHJcblxyXG4gIHZhciBmdW5jdGlvbnNUaGF0U2hvdWxkUmV0dXJuTnVsbCA9IFtcclxuICAgIFwiZ2V0QWN0aXZlQXR0cmliXCIsXHJcbiAgICBcImdldEFjdGl2ZVVuaWZvcm1cIixcclxuICAgIFwiZ2V0QnVmZmVyUGFyYW1ldGVyXCIsXHJcbiAgICBcImdldENvbnRleHRBdHRyaWJ1dGVzXCIsXHJcbiAgICBcImdldEF0dGFjaGVkU2hhZGVyc1wiLFxyXG4gICAgXCJnZXRGcmFtZWJ1ZmZlckF0dGFjaG1lbnRQYXJhbWV0ZXJcIixcclxuICAgIFwiZ2V0UGFyYW1ldGVyXCIsXHJcbiAgICBcImdldFByb2dyYW1QYXJhbWV0ZXJcIixcclxuICAgIFwiZ2V0UHJvZ3JhbUluZm9Mb2dcIixcclxuICAgIFwiZ2V0UmVuZGVyYnVmZmVyUGFyYW1ldGVyXCIsXHJcbiAgICBcImdldFNoYWRlclBhcmFtZXRlclwiLFxyXG4gICAgXCJnZXRTaGFkZXJJbmZvTG9nXCIsXHJcbiAgICBcImdldFNoYWRlclNvdXJjZVwiLFxyXG4gICAgXCJnZXRUZXhQYXJhbWV0ZXJcIixcclxuICAgIFwiZ2V0VW5pZm9ybVwiLFxyXG4gICAgXCJnZXRVbmlmb3JtTG9jYXRpb25cIixcclxuICAgIFwiZ2V0VmVydGV4QXR0cmliXCJcclxuICBdO1xyXG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBmdW5jdGlvbnNUaGF0U2hvdWxkUmV0dXJuTnVsbC5sZW5ndGg7ICsraWkpIHtcclxuICAgIHZhciBmdW5jdGlvbk5hbWUgPSBmdW5jdGlvbnNUaGF0U2hvdWxkUmV0dXJuTnVsbFtpaV07XHJcbiAgICB3cmFwcGVyX1tmdW5jdGlvbk5hbWVdID0gZnVuY3Rpb24oZikge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKGNvbnRleHRMb3N0Xykge1xyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmLmFwcGx5KGN0eCwgYXJndW1lbnRzKTtcclxuICAgICAgfVxyXG4gICAgfSh3cmFwcGVyX1tmdW5jdGlvbk5hbWVdKTtcclxuICB9XHJcblxyXG4gIHZhciBpc0Z1bmN0aW9ucyA9IFtcclxuICAgIFwiaXNCdWZmZXJcIixcclxuICAgIFwiaXNFbmFibGVkXCIsXHJcbiAgICBcImlzRnJhbWVidWZmZXJcIixcclxuICAgIFwiaXNQcm9ncmFtXCIsXHJcbiAgICBcImlzUmVuZGVyYnVmZmVyXCIsXHJcbiAgICBcImlzU2hhZGVyXCIsXHJcbiAgICBcImlzVGV4dHVyZVwiXHJcbiAgXTtcclxuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgaXNGdW5jdGlvbnMubGVuZ3RoOyArK2lpKSB7XHJcbiAgICB2YXIgZnVuY3Rpb25OYW1lID0gaXNGdW5jdGlvbnNbaWldO1xyXG4gICAgd3JhcHBlcl9bZnVuY3Rpb25OYW1lXSA9IGZ1bmN0aW9uKGYpIHtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmIChjb250ZXh0TG9zdF8pIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGYuYXBwbHkoY3R4LCBhcmd1bWVudHMpO1xyXG4gICAgICB9XHJcbiAgICB9KHdyYXBwZXJfW2Z1bmN0aW9uTmFtZV0pO1xyXG4gIH1cclxuXHJcbiAgd3JhcHBlcl8uY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyA9IGZ1bmN0aW9uKGYpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKGNvbnRleHRMb3N0Xykge1xyXG4gICAgICAgIHJldHVybiBjdHguRlJBTUVCVUZGRVJfVU5TVVBQT1JURUQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGYuYXBwbHkoY3R4LCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICB9KHdyYXBwZXJfLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMpO1xyXG5cclxuICB3cmFwcGVyXy5nZXRBdHRyaWJMb2NhdGlvbiA9IGZ1bmN0aW9uKGYpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKGNvbnRleHRMb3N0Xykge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZi5hcHBseShjdHgsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gIH0od3JhcHBlcl8uZ2V0QXR0cmliTG9jYXRpb24pO1xyXG5cclxuICB3cmFwcGVyXy5nZXRWZXJ0ZXhBdHRyaWJPZmZzZXQgPSBmdW5jdGlvbihmKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmIChjb250ZXh0TG9zdF8pIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZi5hcHBseShjdHgsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gIH0od3JhcHBlcl8uZ2V0VmVydGV4QXR0cmliT2Zmc2V0KTtcclxuXHJcbiAgd3JhcHBlcl8uaXNDb250ZXh0TG9zdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIGNvbnRleHRMb3N0XztcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiB3cmFwRXZlbnQobGlzdGVuZXIpIHtcclxuICAgIGlmICh0eXBlb2YobGlzdGVuZXIpID09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICByZXR1cm4gbGlzdGVuZXI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24oaW5mbykge1xyXG4gICAgICAgIGxpc3RlbmVyLmhhbmRsZUV2ZW50KGluZm8pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB3cmFwcGVyXy5yZWdpc3Rlck9uQ29udGV4dExvc3RMaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XHJcbiAgICBvbkxvc3RfID0gd3JhcEV2ZW50KGxpc3RlbmVyKTtcclxuICB9O1xyXG5cclxuICB3cmFwcGVyXy5yZWdpc3Rlck9uQ29udGV4dFJlc3RvcmVkTGlzdGVuZXIgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xyXG4gICAgaWYgKGNvbnRleHRMb3N0Xykge1xyXG4gICAgICBuZXh0T25SZXN0b3JlZF8gPSB3cmFwRXZlbnQobGlzdGVuZXIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgb25SZXN0b3JlZF8gPSB3cmFwRXZlbnQobGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHdyYXBwZXJfO1xyXG59XHJcblxyXG5yZXR1cm4ge1xyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemVzIHRoaXMgbW9kdWxlLiBTYWZlIHRvIGNhbGwgbW9yZSB0aGFuIG9uY2UuXHJcbiAgICogQHBhcmFtIHshV2ViR0xSZW5kZXJpbmdDb250ZXh0fSBjdHggQSBXZWJHTCBjb250ZXh0LiBJZlxyXG4gICAqICAgIHlvdSBoYXZlIG1vcmUgdGhhbiBvbmUgY29udGV4dCBpdCBkb2Vzbid0IG1hdHRlciB3aGljaCBvbmVcclxuICAgKiAgICB5b3UgcGFzcyBpbiwgaXQgaXMgb25seSB1c2VkIHRvIHB1bGwgb3V0IGNvbnN0YW50cy5cclxuICAgKi9cclxuICAnaW5pdCc6IGluaXQsXHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBvciBmYWxzZSBpZiB2YWx1ZSBtYXRjaGVzIGFueSBXZWJHTCBlbnVtXHJcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBjaGVjayBpZiBpdCBtaWdodCBiZSBhbiBlbnVtLlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgbWF0Y2hlcyBvbmUgb2YgdGhlIFdlYkdMIGRlZmluZWQgZW51bXNcclxuICAgKi9cclxuICAnbWlnaHRCZUVudW0nOiBtaWdodEJlRW51bSxcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBhbiBzdHJpbmcgdmVyc2lvbiBvZiBhbiBXZWJHTCBlbnVtLlxyXG4gICAqXHJcbiAgICogRXhhbXBsZTpcclxuICAgKiAgIFdlYkdMRGVidWdVdGlsLmluaXQoY3R4KTtcclxuICAgKiAgIHZhciBzdHIgPSBXZWJHTERlYnVnVXRpbC5nbEVudW1Ub1N0cmluZyhjdHguZ2V0RXJyb3IoKSk7XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gcmV0dXJuIGFuIGVudW0gZm9yXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5nIHZlcnNpb24gb2YgdGhlIGVudW0uXHJcbiAgICovXHJcbiAgJ2dsRW51bVRvU3RyaW5nJzogZ2xFbnVtVG9TdHJpbmcsXHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnRzIHRoZSBhcmd1bWVudCBvZiBhIFdlYkdMIGZ1bmN0aW9uIHRvIGEgc3RyaW5nLlxyXG4gICAqIEF0dGVtcHRzIHRvIGNvbnZlcnQgZW51bSBhcmd1bWVudHMgdG8gc3RyaW5ncy5cclxuICAgKlxyXG4gICAqIEV4YW1wbGU6XHJcbiAgICogICBXZWJHTERlYnVnVXRpbC5pbml0KGN0eCk7XHJcbiAgICogICB2YXIgc3RyID0gV2ViR0xEZWJ1Z1V0aWwuZ2xGdW5jdGlvbkFyZ1RvU3RyaW5nKCdiaW5kVGV4dHVyZScsIDAsIGdsLlRFWFRVUkVfMkQpO1xyXG4gICAqXHJcbiAgICogd291bGQgcmV0dXJuICdURVhUVVJFXzJEJ1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uTmFtZSB0aGUgbmFtZSBvZiB0aGUgV2ViR0wgZnVuY3Rpb24uXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFyZ3VtZW50SW5keCB0aGUgaW5kZXggb2YgdGhlIGFyZ3VtZW50LlxyXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBhcmd1bWVudC5cclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB2YWx1ZSBhcyBhIHN0cmluZy5cclxuICAgKi9cclxuICAnZ2xGdW5jdGlvbkFyZ1RvU3RyaW5nJzogZ2xGdW5jdGlvbkFyZ1RvU3RyaW5nLFxyXG5cclxuICAvKipcclxuICAgKiBHaXZlbiBhIFdlYkdMIGNvbnRleHQgcmV0dXJucyBhIHdyYXBwZWQgY29udGV4dCB0aGF0IGNhbGxzXHJcbiAgICogZ2wuZ2V0RXJyb3IgYWZ0ZXIgZXZlcnkgY29tbWFuZCBhbmQgY2FsbHMgYSBmdW5jdGlvbiBpZiB0aGVcclxuICAgKiByZXN1bHQgaXMgbm90IE5PX0VSUk9SLlxyXG4gICAqXHJcbiAgICogWW91IGNhbiBzdXBwbHkgeW91ciBvd24gZnVuY3Rpb24gaWYgeW91IHdhbnQuIEZvciBleGFtcGxlLCBpZiB5b3UnZCBsaWtlXHJcbiAgICogYW4gZXhjZXB0aW9uIHRocm93biBvbiBhbnkgR0wgZXJyb3IgeW91IGNvdWxkIGRvIHRoaXNcclxuICAgKlxyXG4gICAqICAgIGZ1bmN0aW9uIHRocm93T25HTEVycm9yKGVyciwgZnVuY05hbWUsIGFyZ3MpIHtcclxuICAgKiAgICAgIHRocm93IFdlYkdMRGVidWdVdGlscy5nbEVudW1Ub1N0cmluZyhlcnIpICsgXCIgd2FzIGNhdXNlZCBieSBjYWxsIHRvXCIgK1xyXG4gICAqICAgICAgICAgICAgZnVuY05hbWU7XHJcbiAgICogICAgfTtcclxuICAgKlxyXG4gICAqICAgIGN0eCA9IFdlYkdMRGVidWdVdGlscy5tYWtlRGVidWdDb250ZXh0KFxyXG4gICAqICAgICAgICBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIpLCB0aHJvd09uR0xFcnJvcik7XHJcbiAgICpcclxuICAgKiBAcGFyYW0geyFXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGN0eCBUaGUgd2ViZ2wgY29udGV4dCB0byB3cmFwLlxyXG4gICAqIEBwYXJhbSB7IWZ1bmN0aW9uKGVyciwgZnVuY05hbWUsIGFyZ3MpOiB2b2lkfSBvcHRfb25FcnJvckZ1bmMgVGhlIGZ1bmN0aW9uXHJcbiAgICogICAgIHRvIGNhbGwgd2hlbiBnbC5nZXRFcnJvciByZXR1cm5zIGFuIGVycm9yLiBJZiBub3Qgc3BlY2lmaWVkIHRoZSBkZWZhdWx0XHJcbiAgICogICAgIGZ1bmN0aW9uIGNhbGxzIGNvbnNvbGUubG9nIHdpdGggYSBtZXNzYWdlLlxyXG4gICAqL1xyXG4gICdtYWtlRGVidWdDb250ZXh0JzogbWFrZURlYnVnQ29udGV4dCxcclxuXHJcbiAgLyoqXHJcbiAgICogR2l2ZW4gYSBXZWJHTCBjb250ZXh0IHJldHVybnMgYSB3cmFwcGVkIGNvbnRleHQgdGhhdCBhZGRzIDRcclxuICAgKiBmdW5jdGlvbnMuXHJcbiAgICpcclxuICAgKiBjdHgubG9zZUNvbnRleHQ6XHJcbiAgICogICBzaW11bGF0ZXMgYSBsb3N0IGNvbnRleHQgZXZlbnQuXHJcbiAgICpcclxuICAgKiBjdHgucmVzdG9yZUNvbnRleHQ6XHJcbiAgICogICBzaW11bGF0ZXMgdGhlIGNvbnRleHQgYmVpbmcgcmVzdG9yZWQuXHJcbiAgICpcclxuICAgKiBjdHgucmVnaXN0ZXJPbkNvbnRleHRMb3N0TGlzdGVuZXIobGlzdGVuZXIpOlxyXG4gICAqICAgbGV0cyB5b3UgcmVnaXN0ZXIgYSBsaXN0ZW5lciBmb3IgY29udGV4dCBsb3N0LiBVc2UgaW5zdGVhZFxyXG4gICAqICAgb2YgYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdGV2ZW50JywgbGlzdGVuZXIpO1xyXG4gICAqXHJcbiAgICogY3R4LnJlZ2lzdGVyT25Db250ZXh0UmVzdG9yZWRMaXN0ZW5lcihsaXN0ZW5lcik6XHJcbiAgICogICBsZXRzIHlvdSByZWdpc3RlciBhIGxpc3RlbmVyIGZvciBjb250ZXh0IHJlc3RvcmVkLiBVc2VcclxuICAgKiAgIGluc3RlYWQgb2YgYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLFxyXG4gICAqICAgbGlzdGVuZXIpO1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHshV2ViR0xSZW5kZXJpbmdDb250ZXh0fSBjdHggVGhlIHdlYmdsIGNvbnRleHQgdG8gd3JhcC5cclxuICAgKi9cclxuICAnbWFrZUxvc3RDb250ZXh0U2ltdWxhdGluZ0NvbnRleHQnOiBtYWtlTG9zdENvbnRleHRTaW11bGF0aW5nQ29udGV4dCxcclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXRzIGEgY29udGV4dCB0byB0aGUgaW5pdGlhbCBzdGF0ZS5cclxuICAgKiBAcGFyYW0geyFXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGN0eCBUaGUgd2ViZ2wgY29udGV4dCB0b1xyXG4gICAqICAgICByZXNldC5cclxuICAgKi9cclxuICAncmVzZXRUb0luaXRpYWxTdGF0ZSc6IHJlc2V0VG9Jbml0aWFsU3RhdGVcclxufTtcclxuXHJcbn0oKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFdlYkdMRGVidWdVdGlsczsiLCJpbXBvcnQgV2ViR0xVdGlscyBmcm9tIFwiLi93ZWJnbC11dGlscy5qc1wiO1xyXG5pbXBvcnQgV2ViR0xEZWJ1Z1V0aWxzIGZyb20gXCIuL3dlYmdsLWRlYnVnLmpzXCI7XHJcblxyXG5jb25zdCBVdGlsID0ge1xyXG4gICAgaW5pdFNoYWRlcnM6IGZ1bmN0aW9uKGdsLCB2c2hhZGVyLCBmc2hhZGVyKSB7XHJcbiAgICAgICAgdmFyIHByb2dyYW0gPSBVdGlsLmNyZWF0ZVByb2dyYW0oZ2wsIHZzaGFkZXIsIGZzaGFkZXIpO1xyXG4gICAgICAgIGlmICghcHJvZ3JhbSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRmFpbGVkIHRvIGNyZWF0ZSBwcm9ncmFtJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgZ2wucHJvZ3JhbSA9IHByb2dyYW07XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVQcm9ncmFtOiBmdW5jdGlvbihnbCwgdnNoYWRlciwgZnNoYWRlcikge1xyXG4gICAgICAgIC8vIENyZWF0ZSBzaGFkZXIgb2JqZWN0XHJcbiAgICAgICAgdmFyIHZlcnRleFNoYWRlciA9IFV0aWwubG9hZFNoYWRlcihnbCwgZ2wuVkVSVEVYX1NIQURFUiwgdnNoYWRlcik7XHJcbiAgICAgICAgdmFyIGZyYWdtZW50U2hhZGVyID0gVXRpbC5sb2FkU2hhZGVyKGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIGZzaGFkZXIpO1xyXG4gICAgICAgIGlmICghdmVydGV4U2hhZGVyIHx8ICFmcmFnbWVudFNoYWRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBhIHByb2dyYW0gb2JqZWN0XHJcbiAgICAgICAgdmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XHJcbiAgICAgICAgaWYgKCFwcm9ncmFtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXR0YWNoIHRoZSBzaGFkZXIgb2JqZWN0c1xyXG4gICAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xyXG4gICAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XHJcblxyXG4gICAgICAgIC8vIExpbmsgdGhlIHByb2dyYW0gb2JqZWN0XHJcbiAgICAgICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIHRoZSByZXN1bHQgb2YgbGlua2luZ1xyXG4gICAgICAgIHZhciBsaW5rZWQgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKTtcclxuICAgICAgICBpZiAoIWxpbmtlZCkge1xyXG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZhaWxlZCB0byBsaW5rIHByb2dyYW06ICcgKyBlcnJvcik7XHJcbiAgICAgICAgICAgIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgICAgIGdsLmRlbGV0ZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XHJcbiAgICAgICAgICAgIGdsLmRlbGV0ZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb2dyYW07XHJcbiAgICB9LFxyXG5cclxuICAgIGxvYWRTaGFkZXI6IGZ1bmN0aW9uKGdsLCB0eXBlLCBzb3VyY2UpIHtcclxuICAgICAgICAvLyBDcmVhdGUgc2hhZGVyIG9iamVjdFxyXG4gICAgICAgIHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XHJcbiAgICAgICAgaWYgKHNoYWRlciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCd1bmFibGUgdG8gY3JlYXRlIHNoYWRlcicpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNldCB0aGUgc2hhZGVyIHByb2dyYW1cclxuICAgICAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpO1xyXG5cclxuICAgICAgICAvLyBDb21waWxlIHRoZSBzaGFkZXJcclxuICAgICAgICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIHRoZSByZXN1bHQgb2YgY29tcGlsYXRpb25cclxuICAgICAgICB2YXIgY29tcGlsZWQgPSBnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUyk7XHJcbiAgICAgICAgaWYgKCFjb21waWxlZCkge1xyXG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcik7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGYWlsZWQgdG8gY29tcGlsZSBzaGFkZXI6ICcgKyBlcnJvcik7XHJcbiAgICAgICAgICAgIGdsLmRlbGV0ZVNoYWRlcihzaGFkZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzaGFkZXI7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFdlYkdMQ29udGV4dDogZnVuY3Rpb24oY2FudmFzLCBvcHRfZGVidWcpIHtcclxuICAgICAgICAvLyBHZXQgdGhlIHJlbmRlcmluZyBjb250ZXh0IGZvciBXZWJHTFxyXG4gICAgICAgIHZhciBnbCA9IFdlYkdMVXRpbHMuc2V0dXBXZWJHTChjYW52YXMpO1xyXG4gICAgICAgIGlmICghZ2wpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICAvLyBpZiBvcHRfZGVidWcgaXMgZXhwbGljaXRseSBmYWxzZSwgY3JlYXRlIHRoZSBjb250ZXh0IGZvciBkZWJ1Z2dpbmdcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIgfHwgb3B0X2RlYnVnKSB7XHJcbiAgICAgICAgICAgIGdsID0gV2ViR0xEZWJ1Z1V0aWxzLm1ha2VEZWJ1Z0NvbnRleHQoZ2wpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGdsO1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGUzRENvbnRleHQgOiBmdW5jdGlvbihjYW52YXMsIG9wdF9hdHRyaWJzKSB7XHJcbiAgICAgICAgdmFyIG5hbWVzID0gW1wid2ViZ2xcIiwgXCJleHBlcmltZW50YWwtd2ViZ2xcIiwgXCJ3ZWJraXQtM2RcIiwgXCJtb3otd2ViZ2xcIl07XHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSBudWxsO1xyXG4gICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBuYW1lcy5sZW5ndGg7ICsraWkpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChuYW1lc1tpaV0sIG9wdF9hdHRyaWJzKTtcclxuICAgICAgICAgICAgfSBjYXRjaChlKSB7fVxyXG4gICAgICAgICAgICBpZiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFV0aWw7IiwiXHJcbmNsYXNzIExpZ2h0IHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtKSB7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ0xpZ2h0JztcclxuXHJcbiAgICAgICAgcGFyYW0gPSBwYXJhbSB8fCB7fTtcclxuICAgICAgICB0aGlzLmNvbG9yID0gcGFyYW0uY29sb3IgfHwgWzEsMSwxXTtcclxuICAgICAgICB0aGlzLmludGVuc2l0eSA9IHBhcmFtLmludGVuc2l0eSAhPT0gdW5kZWZpbmVkID8gcGFyYW0uaW50ZW5zaXR5IDogMTtcclxuICAgICAgICB0aGlzLmNhc3RTaGFkb3cgPSBwYXJhbS5jYXN0U2hhZG93O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBMaWdodDtcclxuIiwiaW1wb3J0IExpZ2h0IGZyb20gXCIuL0xpZ2h0XCI7XHJcblxyXG5jbGFzcyBBbWJpZW50TGlnaHQgZXh0ZW5kcyBMaWdodHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtKSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW0pO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdBbWJpZW50TGlnaHQnO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBBbWJpZW50TGlnaHQ7XHJcbiIsImltcG9ydCBMaWdodCBmcm9tIFwiLi9MaWdodFwiO1xyXG5pbXBvcnQge1ZlY3RvcjN9IGZyb20gXCIuLi9tYXRoL1ZlY3RvcjNcIjtcclxuXHJcbmNsYXNzIERpcmVjdGlvbmFsTGlnaHQgZXh0ZW5kcyBMaWdodHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtKSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW0pO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdEaXJlY3Rpb25hbExpZ2h0JztcclxuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IFsxLDEsMV07XHJcbiAgICAgICAgdGhpcy5zZXREaXJlY3Rpb24ocGFyYW0uZGlyZWN0aW9uIHx8IFsxLDEsMV0pO1xyXG4gICAgfVxyXG5cclxuICAgIHNldERpcmVjdGlvbihkaXJlY3Rpb24pe1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gIG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KGRpcmVjdGlvbikubm9ybWFsaXplKCkudG9BcnJheSgpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEaXJlY3Rpb25hbExpZ2h0O1xyXG4iLCJcclxuaW1wb3J0IE1lc2ggZnJvbSBcIi4vTWVzaC5qc1wiO1xyXG5pbXBvcnQgVXRpbCBmcm9tIFwiLi4vdXRpbC9VdGlsXCI7XHJcbmltcG9ydCBBbWJpZW50TGlnaHQgZnJvbSBcIi4uL2xpZ2h0L0FtYmllbnRMaWdodFwiO1xyXG5pbXBvcnQgRGlyZWN0aW9uYWxMaWdodCBmcm9tIFwiLi4vbGlnaHQvRGlyZWN0aW9uYWxMaWdodFwiO1xyXG5pbXBvcnQge1ZlY3RvcjN9IGZyb20gXCIuLi9tYXRoL1ZlY3RvcjNcIjtcclxuaW1wb3J0IHtWZWN0b3I0fSBmcm9tIFwiLi4vbWF0aC9WZWN0b3I0XCI7XHJcbmltcG9ydCB7VmVjdG9yMn0gZnJvbSBcIi4uL21hdGgvVmVjdG9yMlwiO1xyXG5cclxuY2xhc3MgUmVuZGVyZXIge1xyXG4gICAgY29uc3RydWN0b3IocGFyYW0pIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgcGFyYW0gPSBwYXJhbSB8fCB7fTtcclxuICAgICAgICB0aGlzLmJ1ZmZlckxpc3QgPSBbXTtcclxuXHJcbiAgICAgICAgdGhpcy5wcm9ncmFtTGlzdCA9IHt9O1xyXG5cclxuICAgICAgICB0aGlzLmN1ckNhbWVyYVBvc2l0aW9uID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJlbmRlckxpc3QgPSB7XHJcbiAgICAgICAgICAgIG9wYWNpdHlMaXN0OltdLFxyXG4gICAgICAgICAgICB0cmFuc3BhcmVudExpc3Q6W11cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmNhbWVyYSA9IG51bGw7XHJcblxyXG4gICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd2ViZ2wnKTtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICByZW5kZXIoc2NlbmUsIGNhbWVyYSl7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHRoYXQuY2FtZXJhID0gY2FtZXJhO1xyXG4gICAgICAgIHRoYXQuY3VyQ2FtZXJhUG9zaXRpb24gPSBjYW1lcmEucG9zaXRpb247XHJcblxyXG4gICAgICAgIHZhciByZW5kZXJMaXN0ID0gdGhhdC5zb3J0UmVuZGVyTGlzdChzY2VuZSk7XHJcblxyXG4gICAgICAgIHZhciBnbCA9IHRoYXQuZ2w7XHJcblxyXG4gICAgICAgIGdsLmNsZWFyUmVjdCgwLDAsNjAwLDYwMCk7XHJcblxyXG4gICAgICAgIHZhciBhbWJpZW50TGlnaHQgPSBudWxsO1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb25hbExpZ2h0ID0gbnVsbDtcclxuXHJcbiAgICAgICAgZm9yKHZhciBpIGluIHNjZW5lLmxpZ2h0cyl7XHJcbiAgICAgICAgICAgIGlmKHNjZW5lLmxpZ2h0c1tpXS50eXBlID09PSAnRGlyZWN0aW9uYWxMaWdodCcpe1xyXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uYWxMaWdodCA9IHNjZW5lLmxpZ2h0c1tpXTtcclxuICAgICAgICAgICAgfWVsc2UgaWYoc2NlbmUubGlnaHRzW2ldLnR5cGUgPT09ICdBbWJpZW50TGlnaHQnKXtcclxuICAgICAgICAgICAgICAgIGFtYmllbnRMaWdodCA9IHNjZW5lLmxpZ2h0c1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYW1iaWVudExpZ2h0ID0gYW1iaWVudExpZ2h0IHx8IG5ldyBBbWJpZW50TGlnaHQoe2ludGVuc2l0eTowfSk7XHJcbiAgICAgICAgZGlyZWN0aW9uYWxMaWdodCA9IGRpcmVjdGlvbmFsTGlnaHQgfHwgbmV3IERpcmVjdGlvbmFsTGlnaHQoe2ludGVuc2l0eTowfSk7XHJcblxyXG4gICAgICAgIGZvcih2YXIgaSBpbiByZW5kZXJMaXN0KXtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJPbmVNZXNoKHJlbmRlckxpc3RbaV0sIGNhbWVyYSwgYW1iaWVudExpZ2h0LCBkaXJlY3Rpb25hbExpZ2h0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlck9uZU1lc2gobWVzaCwgY2FtZXJhLCBhbWJpZW50TGlnaHQsIGRpcmVjdGlvbmFsTGlnaHQpe1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuXHJcbiAgICAgICAgdmFyIG1lc2ggPSBtZXNoIHx8IG5ldyBNZXNoKCk7XHJcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gbWVzaC5nZW9tZXRyeTtcclxuICAgICAgICB2YXIgaW5kaWNlcyA9IGdlb21ldHJ5LmluZGljZXM7XHJcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XHJcblxyXG5cclxuICAgICAgICB2YXIgbWF0ZXJpYWwgPSBtZXNoLm1hdGVyaWFsO1xyXG4gICAgICAgIHZhciBtYXAgPSBtYXRlcmlhbC5tYXA7XHJcbiAgICAgICAgdmFyIGNvbG9yID0gbWF0ZXJpYWwuY29sb3I7XHJcblxyXG4gICAgICAgIHZhciBjdHggPSB0aGF0LmdsO1xyXG5cclxuICAgICAgICBmb3IodmFyIGk9MDsgaTxpbmRpY2VzLmxlbmd0aDsgaSs9Myl7XHJcbiAgICAgICAgICAgIHZhciBwb2ludDF4ID0gdmVydGljZXNbaW5kaWNlc1tpXSozXTtcclxuICAgICAgICAgICAgdmFyIHBvaW50MXkgPSB2ZXJ0aWNlc1tpbmRpY2VzW2ldKjMrMV07XHJcbiAgICAgICAgICAgIHZhciBwb2ludDF6ID0gdmVydGljZXNbaW5kaWNlc1tpXSozKzJdO1xyXG5cclxuICAgICAgICAgICAgdmFyIHBvaW50MnggPSB2ZXJ0aWNlc1tpbmRpY2VzW2krMV0qM107XHJcbiAgICAgICAgICAgIHZhciBwb2ludDJ5ID0gdmVydGljZXNbaW5kaWNlc1tpKzFdKjMrMV07XHJcbiAgICAgICAgICAgIHZhciBwb2ludDJ6ID0gdmVydGljZXNbaW5kaWNlc1tpKzFdKjMrMl07XHJcblxyXG4gICAgICAgICAgICB2YXIgcG9pbnQzeCA9IHZlcnRpY2VzW2luZGljZXNbaSsyXSozXTtcclxuICAgICAgICAgICAgdmFyIHBvaW50M3kgPSB2ZXJ0aWNlc1tpbmRpY2VzW2krMl0qMysxXTtcclxuICAgICAgICAgICAgdmFyIHBvaW50M3ogPSB2ZXJ0aWNlc1tpbmRpY2VzW2krMl0qMysyXTtcclxuXHJcbiAgICAgICAgICAgIHRoYXQuZHJhd1RyaWFuZ2xlKFxyXG4gICAgICAgICAgICAgICAgbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkoW3BvaW50MXgscG9pbnQxeSxwb2ludDF6XSksXHJcbiAgICAgICAgICAgICAgICBuZXcgVmVjdG9yMygpLmZyb21BcnJheShbcG9pbnQyeCxwb2ludDJ5LHBvaW50MnpdKSxcclxuICAgICAgICAgICAgICAgIG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KFtwb2ludDN4LHBvaW50M3kscG9pbnQzel0pLFxyXG4gICAgICAgICAgICAgICAgbWVzaFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgdjNUb3YyKHYzLCBtZXNoKXtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgICAgIHZhciB2cE1hdHJpeCA9IHRoYXQuY2FtZXJhLlZQbWF0cml4LmNsb25lKCk7XHJcbiAgICAgICAgdmFyIHY0ID0gdnBNYXRyaXguY29uY2F0KG1lc2gubWF0cml4V29ybGQpLm11bHRpcGx5VmVjdG9yNChuZXcgVmVjdG9yNCh2My54LCB2My55LCB2My56LCAxKSk7XHJcbiAgICAgICAgdmFyIHYzR0wgPSBuZXcgVmVjdG9yMyh2NC54L3Y0LncsIHY0LnkvdjQudywgdjQuei92NC53KTtcclxuICAgICAgICB2YXIgdjJHTCA9IG5ldyBWZWN0b3IyKHYzR0wueCwgdjNHTC55KTtcclxuICAgICAgICB2YXIgdjIgPSBuZXcgVmVjdG9yMigodjJHTC54LzIrMC41KSo2MDAsICgwLjUtdjJHTC55LzIpKjYwMCk7XHJcblxyXG4gICAgICAgIHJldHVybiB2MjtcclxuICAgIH1cclxuXHJcbiAgICBkcmF3VHJpYW5nbGUoYSxiLGMsIG1lc2gpe1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgY3R4ID0gdGhhdC5nbDtcclxuXHJcbiAgICAgICAgdmFyIGExID0gdGhhdC52M1RvdjIoYSwgbWVzaCk7XHJcbiAgICAgICAgdmFyIGIxID0gdGhhdC52M1RvdjIoYiwgbWVzaCk7XHJcbiAgICAgICAgdmFyIGMxID0gdGhhdC52M1RvdjIoYywgbWVzaCk7XHJcblxyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAnI2ZmMDAwMCc7XHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJyNmZjAwMDAnO1xyXG4gICAgICAgIC8vIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAvLyBjdHgubW92ZVRvKGExLngsYTEueSk7XHJcbiAgICAgICAgLy8gY3R4LmxpbmVUbyhiMS54LGIxLnkpO1xyXG4gICAgICAgIC8vIGN0eC5saW5lVG8oYzEueCxjMS55KTtcclxuICAgICAgICAvLyBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgLy8gY3R4LnN0cm9rZSgpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBzb3J0VEJ5WShhLGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEueSAtIGIueTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0cmlhbmdsZUxpc3QgPSBbYTEsYjEsYzFdLnNvcnQoc29ydFRCeVkpO1xyXG4gICAgICAgIHZhciBhMiA9IHRyaWFuZ2xlTGlzdFswXTtcclxuICAgICAgICB2YXIgYjIgPSB0cmlhbmdsZUxpc3RbMV07XHJcbiAgICAgICAgdmFyIGMyID0gdHJpYW5nbGVMaXN0WzJdO1xyXG4gICAgICAgIHZhciBmbGF0VG9wLGZsYXRCb3R0b207XHJcbiAgICAgICAgaWYoYjIueSA9PT0gYTIueSl7XHJcbiAgICAgICAgICAgIGZsYXRUb3AgPSBbYzIsYTIsYjJdO1xyXG4gICAgICAgIH1lbHNlIGlmKGIyLnkgPT09IGMyLnkpe1xyXG4gICAgICAgICAgICBmbGF0Qm90dG9tID0gW2EyLGIyLGMyXTtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgdmFyIGFscGhhID0gKGIyLnktYTIueSkvKGMyLnktYTIueSk7XHJcbiAgICAgICAgICAgIHZhciBhYyA9IG5ldyBWZWN0b3IyKCkuc3ViVmVjdG9ycyhjMixhMik7XHJcbiAgICAgICAgICAgIHZhciBkID0gYTIuY2xvbmUoKS5hZGRTY2FsZWRWZWN0b3IoYWMsIGFscGhhKTtcclxuXHJcbiAgICAgICAgICAgIGZsYXRCb3R0b20gPSBbYTIsYjIsZF07XHJcbiAgICAgICAgICAgIGZsYXRUb3AgPSBbYzIsYjIsZF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihmbGF0Qm90dG9tKXtcclxuICAgICAgICAgICAgdGhhdC5kcmF3RmxhdFQoZmxhdEJvdHRvbSxtZXNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoZmxhdFRvcCl7XHJcbiAgICAgICAgICAgIHRoYXQuZHJhd0ZsYXRUKGZsYXRUb3AsbWVzaCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBkcmF3VCh0KXtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGN0eCA9IHRoYXQuZ2w7XHJcblxyXG4gICAgICAgIHZhciBhMSA9IHRbMF07XHJcbiAgICAgICAgdmFyIGIxID0gdFsxXTtcclxuICAgICAgICB2YXIgYzEgPSB0WzJdO1xyXG5cclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gJyNmZjAwMDAnO1xyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjZmYwMDAwJztcclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY3R4Lm1vdmVUbyhhMS54LGExLnkpO1xyXG4gICAgICAgIGN0eC5saW5lVG8oYjEueCxiMS55KTtcclxuICAgICAgICBjdHgubGluZVRvKGMxLngsYzEueSk7XHJcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgIH1cclxuXHJcbiAgICBkcmF3RmxhdFQodCwgbWVzaCl7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjdHggPSB0aGF0LmdsO1xyXG5cclxuICAgICAgICB2YXIgYSA9IHRbMF07XHJcbiAgICAgICAgdmFyIGI7XHJcbiAgICAgICAgdmFyIGM7XHJcblxyXG4gICAgICAgIGlmKHRbMV0ueDx0WzJdLngpe1xyXG4gICAgICAgICAgICBiID0gdFsxXTtcclxuICAgICAgICAgICAgYyA9IHRbMl07XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIGMgPSB0WzFdO1xyXG4gICAgICAgICAgICBiID0gdFsyXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzdGFydFkgPSBNYXRoLnJvdW5kKGEueSk7XHJcbiAgICAgICAgdmFyIGVuZFkgPSBNYXRoLnJvdW5kKGIueSk7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IE1hdGguYWJzKGVuZFkgLSBzdGFydFkpO1xyXG5cclxuICAgICAgICB2YXIgYWIgPSBuZXcgVmVjdG9yMigpLnN1YlZlY3RvcnMoYixhKTtcclxuICAgICAgICB2YXIgYWMgPSBuZXcgVmVjdG9yMigpLnN1YlZlY3RvcnMoYyxhKTtcclxuXHJcbiAgICAgICAgbGV0IGR5ID0gMTtcclxuICAgICAgICBpZihlbmRZPHN0YXJ0WSl7XHJcbiAgICAgICAgICAgIGR5ID0gLTE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IodmFyIHk9c3RhcnRZOyAoeS1zdGFydFkpKih5LWVuZFkpPD0wOyB5Kz1keSl7XHJcbiAgICAgICAgICAgIGlmKHk8MHx8eT42MDApe1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IE1hdGguYWJzKHktc3RhcnRZKS9oZWlnaHQ7XHJcbiAgICAgICAgICAgIHZhciBzdGFydFYyID0gYS5jbG9uZSgpLmFkZFNjYWxlZFZlY3RvcihhYixhbHBoYSk7XHJcbiAgICAgICAgICAgIHZhciBlbmRWMiA9IGEuY2xvbmUoKS5hZGRTY2FsZWRWZWN0b3IoYWMsYWxwaGEpO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRYID0gTWF0aC5yb3VuZChzdGFydFYyLngpO1xyXG4gICAgICAgICAgICB2YXIgZW5kWCA9IE1hdGgucm91bmQoZW5kVjIueCk7XHJcblxyXG4gICAgICAgICAgICBmb3IodmFyIHg9c3RhcnRYOyB4PD1lbmRYOyB4Kyspe1xyXG4gICAgICAgICAgICAgICAgaWYoeDwwfHx4PjYwMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYignK3grJywnK3krJywwKSc7XHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoeCx5LDEsMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGdldEFsbE9iakxpc3Qob2JqLCBhbGxPYmpMaXN0KXtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgZm9yKHZhciBpIGluIG9iai5jaGlsZHJlbil7XHJcbiAgICAgICAgICAgIGlmKG9iai5jaGlsZHJlbltpXS5nZW9tZXRyeSl7XHJcbiAgICAgICAgICAgICAgICBhbGxPYmpMaXN0LnB1c2gob2JqLmNoaWxkcmVuW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGF0LmdldEFsbE9iakxpc3Qob2JqLmNoaWxkcmVuW2ldLGFsbE9iakxpc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYWxsT2JqTGlzdDtcclxuICAgIH1cclxuXHJcbiAgICBzb3J0UmVuZGVyTGlzdChzY2VuZSl7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuICAgICAgICB2YXIgYWxsT2JqTGlzdCA9IHRoYXQuZ2V0QWxsT2JqTGlzdChzY2VuZSAsW10pO1xyXG5cclxuICAgICAgICBmb3IodmFyIGkgaW4gYWxsT2JqTGlzdCl7XHJcbiAgICAgICAgICAgIHZhciBwYSA9IGFsbE9iakxpc3RbaV0uZ2V0V29ybGRQb3NpdGlvbigpO1xyXG4gICAgICAgICAgICB2YXIgcGMgPSBuZXcgVmVjdG9yMygpLmZyb21BcnJheSh0aGF0LmN1ckNhbWVyYVBvc2l0aW9uKTtcclxuICAgICAgICAgICAgdmFyIGRhID0gcGMuZGlzdGFuY2VUbyhwYSk7XHJcbiAgICAgICAgICAgIGFsbE9iakxpc3RbaV0uZGlzdGFuY2VUb0NhbWVyYSA9IGRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYWxsT2JqU29ydGVkTGlzdCA9IGFsbE9iakxpc3Quc29ydCh0aGF0LnNvcnRGdW4pO1xyXG4gICAgICAgIHJldHVybiBhbGxPYmpTb3J0ZWRMaXN0O1xyXG4gICAgfVxyXG5cclxuICAgIHNvcnRGdW4oYSwgYil7XHJcbiAgICAgICAgcmV0dXJuIGIuZGlzdGFuY2VUb0NhbWVyYSAtIGEuZGlzdGFuY2VUb0NhbWVyYTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFJlbmRlcmVyO1xyXG4iLCJcclxuaW1wb3J0IHtNYXRyaXg0fSBmcm9tIFwiLi4vbWF0aC9NYXRyaXg0XCI7XHJcbmltcG9ydCB7VmVjdG9yM30gZnJvbSBcIi4uL21hdGgvVmVjdG9yM1wiO1xyXG5pbXBvcnQge1F1YXRlcm5pb259IGZyb20gXCIuLi9tYXRoL1F1YXRlcm5pb25cIjtcclxuXHJcbmNsYXNzIENhbWVyYSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihmb3YsIGFzcGVjdCwgbmVhciwgZmFyKSB7XHJcbiAgICAgICAgdGhpcy5mb3YgPSBmb3Y7XHJcbiAgICAgICAgdGhpcy5hc3BlY3QgPSBhc3BlY3Q7XHJcbiAgICAgICAgdGhpcy5uZWFyID0gbmVhcjtcclxuICAgICAgICB0aGlzLmZhciA9IGZhcjtcclxuXHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFswLCAwLCAxMF07XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSBbMCwwLDBdO1xyXG4gICAgICAgIHRoaXMudXAgPSBbMCwxLDBdO1xyXG5cclxuICAgICAgICB0aGlzLlZQbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBbMCwwLC0xXTtcclxuICAgICAgICB0aGlzLnJpZ2h0ID0gWzEsMCwwXTtcclxuXHJcbiAgICAgICAgdGhpcy5zY2FsZSA9IFsxLDEsMV07XHJcbiAgICAgICAgdGhpcy5xdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcclxuICAgICAgICB0aGlzLm1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XHJcbiAgICAgICAgdGhpcy5tYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4O1xyXG4gICAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlQWxsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlQWxsKCl7XHJcbiAgICAgICAgdGhpcy51cGRhdGVPcHRpb24oKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlVlBNYXRyaXgoKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVNYXRyaXgoKXtcclxuICAgICAgICB2YXIgcXVhdGVybmlvbkQgPSBuZXcgUXVhdGVybmlvbigpLnNldEZyb21Vbml0VmVjdG9ycyhuZXcgVmVjdG9yMygwLDAsLTEpLCBuZXcgVmVjdG9yMygpLmZyb21BcnJheSh0aGlzLmRpcmVjdGlvbikpO1xyXG4gICAgICAgIHZhciByaWdodDIgPSBuZXcgVmVjdG9yMygxLDAsMCkuYXBwbHlRdWF0ZXJuaW9uKHF1YXRlcm5pb25EKTtcclxuICAgICAgICB2YXIgcXVhdGVybmlvblIgPSBuZXcgUXVhdGVybmlvbigpLnNldEZyb21Vbml0VmVjdG9ycyhyaWdodDIsIG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KHRoaXMucmlnaHQpKTtcclxuICAgICAgICB2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCkubXVsdGlwbHlRdWF0ZXJuaW9ucyhxdWF0ZXJuaW9uUiwgcXVhdGVybmlvbkQpO1xyXG4gICAgICAgIHRoaXMucXVhdGVybmlvbiA9IHF1YXRlcm5pb247XHJcblxyXG4gICAgICAgIHRoaXMubWF0cml4LmNvbXBvc2UoIG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KHRoaXMucG9zaXRpb24pLCB0aGlzLnF1YXRlcm5pb24sIG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KHRoaXMuc2NhbGUpICk7XHJcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQoKS5zZXRQZXJzcGVjdGl2ZSh0aGlzLmZvdiwgdGhpcy5hc3BlY3QsIHRoaXMubmVhciwgdGhpcy5mYXIpO1xyXG4gICAgICAgIC8vIHRoaXMudXBkYXRlTWF0cml4V29ybGQgKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlT3B0aW9uKCl7XHJcbiAgICAgICAgdmFyIHRhcmdldFYzID0gbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkodGhpcy50YXJnZXQpO1xyXG4gICAgICAgIHZhciBwb3NpdGlvblYzID0gbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkodGhpcy5wb3NpdGlvbik7XHJcbiAgICAgICAgdmFyIHVwVjMgPSBuZXcgVmVjdG9yMygpLmZyb21BcnJheSh0aGlzLnVwKTtcclxuXHJcbiAgICAgICAgdmFyIGRpcmVjdGlvblYzID0gbmV3IFZlY3RvcjMoKS5zdWJWZWN0b3JzKHRhcmdldFYzLCBwb3NpdGlvblYzKS5ub3JtYWxpemUoKTtcclxuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IGRpcmVjdGlvblYzLnRvQXJyYXkoKTtcclxuXHJcbiAgICAgICAgdmFyIHJpZ2h0VjMgPSBuZXcgVmVjdG9yMygpLmNyb3NzVmVjdG9ycyhkaXJlY3Rpb25WMywgdXBWMykubm9ybWFsaXplKCk7XHJcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0VjMudG9BcnJheSgpO1xyXG5cclxuICAgICAgICAvLyB0aGlzLnVwID0gbmV3IFZlY3RvcjMoKS5jcm9zc1ZlY3RvcnMocmlnaHRWMywgZGlyZWN0aW9uVjMpLm5vcm1hbGl6ZSgpLnRvQXJyYXkoKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRQb3NpdGlvbihwb3NpdGlvbil7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gICAgICAgIHRoaXMudXBkYXRlQWxsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0VGFyZ2V0KHRhcmdldCl7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGhpcy51cGRhdGVBbGwoKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRVcCh1cCl7XHJcbiAgICAgICAgdGhpcy51cCA9IG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KHVwKS5ub3JtYWxpemUoKS50b0FycmF5KCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVBbGwoKTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIHVwZGF0ZVZQTWF0cml4KCl7XHJcbiAgICAgICAgdGhpcy5WUG1hdHJpeCA9IG5ldyBNYXRyaXg0KCkuc2V0UGVyc3BlY3RpdmUodGhpcy5mb3YsIHRoaXMuYXNwZWN0LCB0aGlzLm5lYXIsIHRoaXMuZmFyKTtcclxuICAgICAgICB2YXIgVm1hdHJpeCA9IG5ldyBNYXRyaXg0KCkuZ2V0SW52ZXJzZSh0aGlzLm1hdHJpeCk7XHJcbiAgICAgICAgdGhpcy5WUG1hdHJpeC5jb25jYXQoVm1hdHJpeCk7XHJcbiAgICAgICAgLy/nrYnku7dcclxuICAgICAgICAvLyB0aGlzLlZQbWF0cml4Lmxvb2tBdDIodGhpcy5wb3NpdGlvblswXSx0aGlzLnBvc2l0aW9uWzFdLHRoaXMucG9zaXRpb25bMl0sIHRoaXMudGFyZ2V0WzBdLHRoaXMudGFyZ2V0WzFdLHRoaXMudGFyZ2V0WzJdLCB0aGlzLnVwWzBdLHRoaXMudXBbMV0sdGhpcy51cFsyXSk7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDYW1lcmE7XHJcblxyXG4iLCJcclxuaW1wb3J0IHtWZWN0b3IzfSBmcm9tIFwiLi4vbWF0aC9WZWN0b3IzXCI7XHJcblxyXG5jbGFzcyBDYW1lcmFDb250cm9sbGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNhbWVyYSkge1xyXG4gICAgICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xyXG5cclxuICAgICAgICB0aGlzLm1vdXNlMFN0YXRlID0gJ3VwJztcclxuICAgICAgICB0aGlzLm1vdXNlMVN0YXRlID0gJ3VwJztcclxuICAgICAgICB0aGlzLm1vdXNlMlN0YXRlID0gJ3VwJztcclxuXHJcbiAgICAgICAgdGhpcy54ID0gLTE7XHJcbiAgICAgICAgdGhpcy55ID0gLTE7XHJcblxyXG4gICAgICAgIHRoaXMubWluVGlsdCA9IDAuMTtcclxuICAgICAgICB0aGlzLm1heFRpbHQgPSAzLjA0O1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZSgpe1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuXHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coZS5idXR0b24rJyBkb3duICcrZS5jbGllbnRYKycsJytlLmNsaWVudFkpO1xyXG4gICAgICAgICAgICB2YXIgZG9tID0gIHdpbmRvdy5kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY2FudmFzJylbMF07XHJcbiAgICAgICAgICAgIGlmKCFkb20pe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByZWN0ID0gZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICBpZihlLmNsaWVudFggPCByZWN0LmxlZnQgfHwgZS5jbGllbnRYID4gcmVjdC5yaWdodCB8fCBlLmNsaWVudFkgPCByZWN0LnRvcCB8fCBlLmNsaWVudFkgPiByZWN0LmJvdHRvbSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoZS5idXR0b24gPT0gMCl7XHJcbiAgICAgICAgICAgICAgICB0aGF0Lm1vdXNlMFN0YXRlID0gJ2Rvd24nO1xyXG4gICAgICAgICAgICB9ZWxzZSBpZihlLmJ1dHRvbiA9PSAxKXtcclxuICAgICAgICAgICAgICAgIHRoYXQubW91c2UxU3RhdGUgPSAnZG93bic7XHJcbiAgICAgICAgICAgIH1lbHNlIGlmKGUuYnV0dG9uID09IDIpe1xyXG4gICAgICAgICAgICAgICAgdGhhdC5tb3VzZTJTdGF0ZSA9ICdkb3duJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coZS5idXR0b24rJyB1cCAnK2UuY2xpZW50WCsnLCcrZS5jbGllbnRZKTtcclxuICAgICAgICAgICAgaWYoZS5idXR0b24gPT0gMCl7XHJcbiAgICAgICAgICAgICAgICB0aGF0Lm1vdXNlMFN0YXRlID0gJ3VwJztcclxuICAgICAgICAgICAgfWVsc2UgaWYoZS5idXR0b24gPT0gMSl7XHJcbiAgICAgICAgICAgICAgICB0aGF0Lm1vdXNlMVN0YXRlID0gJ3VwJztcclxuICAgICAgICAgICAgfWVsc2UgaWYoZS5idXR0b24gPT0gMil7XHJcbiAgICAgICAgICAgICAgICB0aGF0Lm1vdXNlMlN0YXRlID0gJ3VwJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJyxmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhlLmJ1dHRvbisnIG1vdmUgJytlLmNsaWVudFgrJywnK2UuY2xpZW50WSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgY2FtZXJhID0gdGhhdC5jYW1lcmE7XHJcbiAgICAgICAgICAgIGlmKHRoYXQubW91c2UwU3RhdGUgPT0gJ2Rvd24nKXtcclxuICAgICAgICAgICAgICAgIHZhciBkZWx0YVggPSBlLmNsaWVudFggLSB0aGF0Lng7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGFZID0gZS5jbGllbnRZIC0gdGhhdC55O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHZhciBhbmdsZSA9IE1hdGguc3FydChkZWx0YVgqZGVsdGFYICsgZGVsdGFZKmRlbHRhWSkvODA7XHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gdmFyIHVwVjMgPSBuZXcgVmVjdG9yMyhjYW1lcmEudXApO1xyXG4gICAgICAgICAgICAgICAgLy8gdmFyIHJpZ2h0VjMgPSBuZXcgVmVjdG9yMyhjYW1lcmEucmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vIHZhciBheGlzVjMgPSBuZXcgVmVjdG9yMygpLmFkZFZlY3RvcnMoIG5ldyBWZWN0b3IzKCkuc2NhbGVWZWN0b3JzKHVwVjMsZGVsdGFYKSAsIG5ldyBWZWN0b3IzKCkuc2NhbGVWZWN0b3JzKHJpZ2h0VjMsZGVsdGFZKSkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gdmFyIG9sZFBvc2l0aW9uVjMgPSBuZXcgVmVjdG9yMyhjYW1lcmEucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgLy8gdmFyIG5ld1Bvc2l0aW9uVjMgPSBuZXcgVmVjdG9yMygpLnJvdGF0ZUJ5VmVjdG9yKG9sZFBvc2l0aW9uVjMsIGF4aXNWMywgYW5nbGUpO1xyXG4gICAgICAgICAgICAgICAgLy8gdmFyIG5ld1Bvc2l0aW9uID0gbmV3UG9zaXRpb25WMy50b0FycmF5KCk7XHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gY2FtZXJhLnNldFBvc2l0aW9uKG5ld1Bvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgYXhpc1lWMyA9IG5ldyBWZWN0b3IzKDAsMSwwKTtcclxuICAgICAgICAgICAgICAgIHZhciBhbmdsZVkgPSBkZWx0YVgvMjAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9sZFBvc2l0aW9uVjMgPSBuZXcgVmVjdG9yMygpLmZyb21BcnJheShjYW1lcmEucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld1Bvc2l0aW9uVjMgPSBuZXcgVmVjdG9yMygpLnJvdGF0ZUJ5VmVjdG9yKG9sZFBvc2l0aW9uVjMsIGF4aXNZVjMsIGFuZ2xlWSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3UG9zaXRpb24gPSBuZXdQb3NpdGlvblYzLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIGNhbWVyYS5zZXRQb3NpdGlvbihuZXdQb3NpdGlvbik7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBhbmdsZVggPSBkZWx0YVkvMjAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRpbHQgPSB0aGF0LmdldFRpbHQoKTtcclxuICAgICAgICAgICAgICAgIHZhciBlbmRUaWx0ID0gdGlsdCAtIGFuZ2xlWDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihlbmRUaWx0PHRoYXQubWF4VGlsdCAmJiBlbmRUaWx0PnRoYXQubWluVGlsdCl7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBheGlzWFYzID0gbmV3IFZlY3RvcjMoY2FtZXJhLnJpZ2h0WzBdLCBjYW1lcmEucmlnaHRbMV0sIGNhbWVyYS5yaWdodFsyXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgb2xkUG9zaXRpb25WMyA9IG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KGNhbWVyYS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UG9zaXRpb25WMyA9IG5ldyBWZWN0b3IzKCkucm90YXRlQnlWZWN0b3Iob2xkUG9zaXRpb25WMywgYXhpc1hWMywgYW5nbGVYKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdQb3NpdGlvbiA9IG5ld1Bvc2l0aW9uVjMudG9BcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbWVyYS5zZXRQb3NpdGlvbihuZXdQb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZih0aGF0Lm1vdXNlMlN0YXRlID09ICdkb3duJyl7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGFYID0gZS5jbGllbnRYIC0gdGhhdC54O1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhWSA9IGUuY2xpZW50WSAtIHRoYXQueTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdGVtcFVwID0gbmV3IFZlY3RvcjMoKS5jcm9zc1ZlY3RvcnMobmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkoY2FtZXJhLnJpZ2h0KSwgbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkoY2FtZXJhLmRpcmVjdGlvbikpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGF4aXNZVjMgPSB0ZW1wVXA7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG9sZFRhcmdldFYzID0gbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkoY2FtZXJhLnRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3VGFyZ2V0VjMgPSBuZXcgVmVjdG9yMygpLmFkZFZlY3RvcnMob2xkVGFyZ2V0VjMsIG5ldyBWZWN0b3IzKCkuc2NhbGVWZWN0b3JzKGF4aXNZVjMsIGRlbHRhWS8zMCkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld1RhcmdldFYzID0gbmV3VGFyZ2V0VjMudG9BcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgY2FtZXJhLnNldFRhcmdldChuZXdUYXJnZXRWMyk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG9sZFBvc2l0aW9uVjMgPSBuZXcgVmVjdG9yMygpLmZyb21BcnJheShjYW1lcmEucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld1Bvc2l0aW9uVjMgPSBuZXcgVmVjdG9yMygpLmFkZFZlY3RvcnMob2xkUG9zaXRpb25WMywgbmV3IFZlY3RvcjMoKS5zY2FsZVZlY3RvcnMoYXhpc1lWMywgZGVsdGFZLzMwKSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3UG9zaXRpb24gPSBuZXdQb3NpdGlvblYzLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIGNhbWVyYS5zZXRQb3NpdGlvbihuZXdQb3NpdGlvbik7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGF4aXNYVjMgPSBuZXcgVmVjdG9yMygpLmZyb21BcnJheShjYW1lcmEucmlnaHQpO1xyXG5cclxuICAgICAgICAgICAgICAgIG9sZFRhcmdldFYzID0gbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkoY2FtZXJhLnRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICBuZXdUYXJnZXRWMyA9IG5ldyBWZWN0b3IzKCkuYWRkVmVjdG9ycyhvbGRUYXJnZXRWMywgbmV3IFZlY3RvcjMoKS5zY2FsZVZlY3RvcnMoYXhpc1hWMywgLWRlbHRhWC8zMCkpO1xyXG4gICAgICAgICAgICAgICAgbmV3VGFyZ2V0VjMgPSBuZXdUYXJnZXRWMy50b0FycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBjYW1lcmEuc2V0VGFyZ2V0KG5ld1RhcmdldFYzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBvbGRQb3NpdGlvblYzID0gbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkoY2FtZXJhLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdQb3NpdGlvblYzID0gbmV3IFZlY3RvcjMoKS5hZGRWZWN0b3JzKG9sZFBvc2l0aW9uVjMsIG5ldyBWZWN0b3IzKCkuc2NhbGVWZWN0b3JzKGF4aXNYVjMsIC1kZWx0YVgvMzApKTtcclxuICAgICAgICAgICAgICAgIG5ld1Bvc2l0aW9uID0gbmV3UG9zaXRpb25WMy50b0FycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBjYW1lcmEuc2V0UG9zaXRpb24obmV3UG9zaXRpb24pO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhhdC54ID0gZS5jbGllbnRYO1xyXG4gICAgICAgICAgICB0aGF0LnkgPSBlLmNsaWVudFk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJyxmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhlLmJ1dHRvbisnIHdoZWVsICcrZS53aGVlbERlbHRhKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjYW1lcmEgPSB0aGF0LmNhbWVyYTtcclxuXHJcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IGUud2hlZWxEZWx0YTtcclxuXHJcbiAgICAgICAgICAgIGlmKGRlbHRhID09IDAgfHwgdHlwZW9mKGRlbHRhKSAhPSAnbnVtYmVyJyl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVsdGEgPSBNYXRoLmFicyhkZWx0YSkvZGVsdGE7XHJcblxyXG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uVjMgPSBuZXcgVmVjdG9yMygpLmZyb21BcnJheShjYW1lcmEuZGlyZWN0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBvbGRQb3NpdGlvblYzID0gbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkoY2FtZXJhLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgdmFyIGRpcyA9IG9sZFBvc2l0aW9uVjMubGVuZ3RoU3EoKTtcclxuICAgICAgICAgICAgZGlzID0gTWF0aC5zcXJ0KGRpcyk7XHJcbiAgICAgICAgICAgIHZhciBuZXdQb3NpdGlvblYzID0gbmV3IFZlY3RvcjMoKS5hZGRWZWN0b3JzKG9sZFBvc2l0aW9uVjMsIG5ldyBWZWN0b3IzKCkuc2NhbGVWZWN0b3JzKGRpcmVjdGlvblYzLCBkaXMvMTAqZGVsdGEpKTtcclxuICAgICAgICAgICAgdmFyIG5ld1Bvc2l0aW9uID0gbmV3UG9zaXRpb25WMy50b0FycmF5KCk7XHJcblxyXG4gICAgICAgICAgICBjYW1lcmEuc2V0UG9zaXRpb24obmV3UG9zaXRpb24pO1xyXG5cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRUaWx0KCl7XHJcbiAgICAgICAgdmFyIGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xyXG4gICAgICAgIHZhciBkaXIgPSBjYW1lcmEuZGlyZWN0aW9uO1xyXG4gICAgICAgIHZhciBheGl4WSA9IG5ldyBWZWN0b3IzKDAsLTEsMCk7XHJcbiAgICAgICAgdmFyIGRpclYzID0gbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkoZGlyKTtcclxuXHJcbiAgICAgICAgdmFyIHRpbHQgPSBheGl4WS5hbmdsZVRvKGRpclYzKTtcclxuICAgICAgICByZXR1cm4gdGlsdDtcclxuXHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IENhbWVyYUNvbnRyb2xsZXI7XHJcbiIsImltcG9ydCBNZXNoIGZyb20gXCIuL01lc2guanNcIjtcclxuaW1wb3J0IEFtYmllbnRMaWdodCBmcm9tIFwiLi4vbGlnaHQvQW1iaWVudExpZ2h0XCI7XHJcblxyXG5jbGFzcyBTY2VuZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbSkge1xyXG4gICAgICAgIHBhcmFtID0gcGFyYW0gfHwge307XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgIHRoaXMubGlnaHRzID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgYWRkKG9iail7XHJcbiAgICAgICAgaWYob2JqLnR5cGUgPT0gJ01lc2gnKXtcclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKG9iaik7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHRoaXMubGlnaHRzLnB1c2gob2JqKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNjZW5lOyIsIlxyXG5jbGFzcyBUZXh0dXJlIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtKSB7XHJcbiAgICAgICAgcGFyYW0gPSBwYXJhbSB8fCB7fTtcclxuICAgICAgICB0aGlzLmltYWdlID0gcGFyYW0uaW1hZ2UgfHwgbmV3IEltYWdlKCk7XHJcbiAgICAgICAgdGhpcy53cmFwUyA9IHBhcmFtLndyYXBTIHx8IENPT0wuUkVQRUFUO1xyXG4gICAgICAgIHRoaXMud3JhcFQgPSBwYXJhbS53cmFwVCB8fCBDT09MLlJFUEVBVDtcclxuICAgICAgICB0aGlzLm1hZ0ZpbHRlciA9IHBhcmFtLm1hZ0ZpbHRlciB8fCBDT09MLk5FQVJFU1Q7XHJcbiAgICAgICAgdGhpcy5taW5GaWx0ZXIgPSBwYXJhbS5taW5GaWx0ZXIgfHwgQ09PTC5ORUFSRVNUO1xyXG4gICAgfVxyXG5cclxuICAgIGNsb25lKCl7XHJcblxyXG4gICAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgIGltYWdlLnNyYyA9IHRoaXMuaW1hZ2Uuc3JjO1xyXG5cclxuICAgICAgICB2YXIgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKHtcclxuICAgICAgICAgICAgaW1hZ2U6IGltYWdlLFxyXG4gICAgICAgICAgICB3cmFwUzogdGhpcy53cmFwUyxcclxuICAgICAgICAgICAgd3JhcFQ6IHRoaXMud3JhcFQsXHJcbiAgICAgICAgICAgIG1hZ0ZpbHRlcjogdGhpcy5tYWdGaWx0ZXIsXHJcbiAgICAgICAgICAgIG1pbkZpbHRlcjogdGhpcy5taW5GaWx0ZXJcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUZXh0dXJlO1xyXG4iLCJpbXBvcnQgTWF0ZXJpYWwgZnJvbSBcIi4vTWF0ZXJpYWxcIjtcclxuXHJcbmNsYXNzIE1lc2hCYXNpY01hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWx7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnTWVzaEJhc2ljTWF0ZXJpYWwnO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTWVzaEJhc2ljTWF0ZXJpYWw7XHJcbiIsImltcG9ydCBNYXRlcmlhbCBmcm9tIFwiLi9NYXRlcmlhbFwiO1xyXG5cclxuY2xhc3MgTWVzaExhbWJlcnRNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFse1xyXG4gICAgY29uc3RydWN0b3IocGFyYW0pIHtcclxuICAgICAgICBzdXBlcihwYXJhbSk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ01lc2hMYW1iZXJ0TWF0ZXJpYWwnO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTWVzaExhbWJlcnRNYXRlcmlhbDtcclxuIiwiaW1wb3J0IE1hdGVyaWFsIGZyb20gXCIuL01hdGVyaWFsXCI7XHJcblxyXG5jbGFzcyBNZXNoU3RhbmRhcmRNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFse1xyXG4gICAgY29uc3RydWN0b3IocGFyYW0pIHtcclxuICAgICAgICBzdXBlcihwYXJhbSk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ01lc2hTdGFuZGFyZE1hdGVyaWFsJztcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1lc2hTdGFuZGFyZE1hdGVyaWFsO1xyXG4iLCJpbXBvcnQge1ZlY3RvcjN9IGZyb20gXCIuLi9tYXRoL1ZlY3RvcjNcIjtcclxuaW1wb3J0IHtTcGhlcmV9IGZyb20gXCIuLi9tYXRoL1NwaGVyZVwiO1xyXG5pbXBvcnQge0JveDN9IGZyb20gXCIuLi9tYXRoL0JveDNcIjtcclxuXHJcbmNsYXNzIEdlb21ldHJ5IHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtKSB7XHJcbiAgICAgICAgcGFyYW0gPSBwYXJhbSB8fCB7fTtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgY3ViZVxyXG4gICAgICAgIC8vICAgIHY2LS0tLS0gdjVcclxuICAgICAgICAvLyAgIC98ICAgICAgL3xcclxuICAgICAgICAvLyAgdjEtLS0tLS12MHxcclxuICAgICAgICAvLyAgfCB8ICAgICB8IHxcclxuICAgICAgICAvLyAgfCB8djctLS18LXx2NFxyXG4gICAgICAgIC8vICB8LyAgICAgIHwvXHJcbiAgICAgICAgLy8gIHYyLS0tLS0tdjNcclxuXHJcbiAgICAgICAgdGhpcy51diA9IHBhcmFtLnV2IHx8IG5ldyBGbG9hdDMyQXJyYXkoWyAgIC8vIFZlcnRleCBjb29yZGluYXRlc1xyXG5cclxuICAgICAgICAgICAgMSwxLCAwLDEsIDAsMCwgMSwwLCAgLy8gdjAtdjEtdjItdjMgZnJvbnRcclxuICAgICAgICAgICAgMCwxLCAwLDAsIDEsMCwgMSwxLCAgLy8gdjAtdjMtdjQtdjUgcmlnaHRcclxuICAgICAgICAgICAgMSwwLCAxLDEsIDAsMSwgMCwwLCAgLy8gdjAtdjUtdjYtdjEgdXBcclxuICAgICAgICAgICAgMSwxLCAwLDEsIDAsMCwgMSwwLCAgLy8gdjEtdjYtdjctdjIgbGVmdFxyXG4gICAgICAgICAgICAwLDEsIDEsMSwgMSwwLCAwLDAsICAvLyB2Ny12NC12My12MiBkb3duXHJcbiAgICAgICAgICAgIDEsMCwgMCwwLCAwLDEsIDEsMSAgIC8vIHY0LXY3LXY2LXY1IGJhY2tcclxuXHJcbiAgICAgICAgXSk7XHJcblxyXG4gICAgICAgIHRoaXMudmVydGljZXMgPSBwYXJhbS52ZXJ0aWNlcyB8fCBuZXcgRmxvYXQzMkFycmF5KFsgICAvLyBWZXJ0ZXggY29vcmRpbmF0ZXNcclxuICAgICAgICAgICAgMC41LCAwLjUsIDAuNSwgIC0wLjUsIDAuNSwgMC41LCAgLTAuNSwtMC41LCAwLjUsICAgMC41LC0wLjUsIDAuNSwgIC8vIHYwLXYxLXYyLXYzIGZyb250XHJcbiAgICAgICAgICAgIDAuNSwgMC41LCAwLjUsICAgMC41LC0wLjUsIDAuNSwgICAwLjUsLTAuNSwtMC41LCAgIDAuNSwgMC41LC0wLjUsICAvLyB2MC12My12NC12NSByaWdodFxyXG4gICAgICAgICAgICAwLjUsIDAuNSwgMC41LCAgIDAuNSwgMC41LC0wLjUsICAtMC41LCAwLjUsLTAuNSwgIC0wLjUsIDAuNSwgMC41LCAgLy8gdjAtdjUtdjYtdjEgdXBcclxuICAgICAgICAgICAgLTAuNSwgMC41LCAwLjUsICAtMC41LCAwLjUsLTAuNSwgIC0wLjUsLTAuNSwtMC41LCAgLTAuNSwtMC41LCAwLjUsICAvLyB2MS12Ni12Ny12MiBsZWZ0XHJcbiAgICAgICAgICAgIC0wLjUsLTAuNSwtMC41LCAgIDAuNSwtMC41LC0wLjUsICAgMC41LC0wLjUsIDAuNSwgIC0wLjUsLTAuNSwgMC41LCAgLy8gdjctdjQtdjMtdjIgZG93blxyXG4gICAgICAgICAgICAwLjUsLTAuNSwtMC41LCAgLTAuNSwtMC41LC0wLjUsICAtMC41LCAwLjUsLTAuNSwgICAwLjUsIDAuNSwtMC41ICAgLy8gdjQtdjctdjYtdjUgYmFja1xyXG4gICAgICAgIF0pO1xyXG5cclxuICAgICAgICB0aGlzLm5vcm1hbCA9IHBhcmFtLm5vcm1hbCB8fCB0aGlzLnZlcnRpY2VzO1xyXG5cclxuICAgICAgICBpZihwYXJhbS5pbmRpY2VzKXtcclxuICAgICAgICAgICAgdGhpcy5pbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KHBhcmFtLmluZGljZXMpO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICB2YXIgaW5kaWNlc0FycmF5ID0gW107XHJcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPHBhcmFtLnZlcnRpY2VzLmxlbmd0aC8zOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgaW5kaWNlc0FycmF5LnB1c2goaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5pbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KGluZGljZXNBcnJheSk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgdGhpcy5tb3JwaEF0dHJpYnV0ZXMgPSBwYXJhbS5tb3JwaEF0dHJpYnV0ZXM7XHJcblxyXG4gICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IG5ldyBCb3gzKCk7XHJcbiAgICAgICAgdGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcclxuXHJcbiAgICAgICAgLy8gdGhpcy51cGRhdGVOb3JtYWwoKTtcclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGFCdWZmZXIoKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRhQnVmZmVyKCl7XHJcbiAgICAgICAgdmFyIGJ1ZmZlciA9IFtdO1xyXG4gICAgICAgIHZhciB1diA9IHRoaXMudXY7XHJcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcclxuICAgICAgICB2YXIgbm9ybWFsID0gdGhpcy5ub3JtYWw7XHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8dmVydGljZXMubGVuZ3RoOyBpKz0zKXtcclxuICAgICAgICAgICAgYnVmZmVyLnB1c2godmVydGljZXNbaSswXSk7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKHZlcnRpY2VzW2krMV0pO1xyXG4gICAgICAgICAgICBidWZmZXIucHVzaCh2ZXJ0aWNlc1tpKzJdKTtcclxuXHJcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKG5vcm1hbFtpKzBdKTtcclxuICAgICAgICAgICAgYnVmZmVyLnB1c2gobm9ybWFsW2krMV0pO1xyXG4gICAgICAgICAgICBidWZmZXIucHVzaChub3JtYWxbaSsyXSk7XHJcblxyXG4gICAgICAgICAgICBidWZmZXIucHVzaCh1dltpLzMqMiswXSk7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKHV2W2kvMyoyKzFdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZU5vcm1hbCgpe1xyXG4gICAgICAgIHZhciBub3JtYWwgPSBbXTtcclxuICAgICAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHZlcnRpY2VzLmxlbmd0aDsgaSs9Myo0KXtcclxuICAgICAgICAgICAgdmFyIGxpbmUxID0gbmV3IFZlY3RvcjMoKS5zdWJWZWN0b3JzKFxyXG4gICAgICAgICAgICAgICAgbmV3IFZlY3RvcjModmVydGljZXNbaSswXSwgdmVydGljZXNbaSsxXSwgdmVydGljZXNbaSsyXSksXHJcbiAgICAgICAgICAgICAgICBuZXcgVmVjdG9yMyh2ZXJ0aWNlc1tpKzNdLCB2ZXJ0aWNlc1tpKzRdLCB2ZXJ0aWNlc1tpKzVdKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB2YXIgbGluZTIgPSBuZXcgVmVjdG9yMygpLnN1YlZlY3RvcnMoXHJcbiAgICAgICAgICAgICAgICBuZXcgVmVjdG9yMyh2ZXJ0aWNlc1tpKzNdLCB2ZXJ0aWNlc1tpKzRdLCB2ZXJ0aWNlc1tpKzVdKSxcclxuICAgICAgICAgICAgICAgIG5ldyBWZWN0b3IzKHZlcnRpY2VzW2krNl0sIHZlcnRpY2VzW2krN10sIHZlcnRpY2VzW2krOF0pLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB2YXIgY3VyX25vcm1hbCA9IG5ldyBWZWN0b3IzKCkuY3Jvc3NWZWN0b3JzKFxyXG4gICAgICAgICAgICAgICAgbGluZTEsXHJcbiAgICAgICAgICAgICAgICBsaW5lMlxyXG4gICAgICAgICAgICApLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgZm9yKHZhciBqPTAgO2o8NDsgaisrKXtcclxuICAgICAgICAgICAgICAgIG5vcm1hbC5wdXNoKGN1cl9ub3JtYWxbMF0sIGN1cl9ub3JtYWxbMV0sIGN1cl9ub3JtYWxbMl0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubm9ybWFsID0gbmV3IEZsb2F0MzJBcnJheShub3JtYWwpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBjb21wdXRlQm91bmRpbmdCb3ggKCkge1xyXG4gICAgICAgIHZhciB2ZXJ0aWNlc1YzID0gW107XHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8dGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkrPTMpe1xyXG4gICAgICAgICAgICB2ZXJ0aWNlc1YzLnB1c2gobmV3IFZlY3RvcjModGhpcy52ZXJ0aWNlc1tpXSwgdGhpcy52ZXJ0aWNlc1tpKzFdLCB0aGlzLnZlcnRpY2VzW2krMl0pKVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnNldEZyb21Qb2ludHModmVydGljZXNWMyk7XHJcbiAgICB9XHJcblxyXG4gICAgY2xvbmUoKXtcclxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgR2VvbWV0cnkoe1xyXG4gICAgICAgICAgICB2ZXJ0aWNlczogdGhpcy52ZXJ0aWNlcy5zbGljZSgwKSxcclxuICAgICAgICAgICAgaW5kaWNlczogdGhpcy5pbmRpY2VzLnNsaWNlKDApXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBnZW9tZXRyeTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgR2VvbWV0cnk7XHJcbiIsImltcG9ydCB7VmVjdG9yM30gZnJvbSBcIi4uL21hdGgvVmVjdG9yM1wiO1xyXG5pbXBvcnQge1NwaGVyZX0gZnJvbSBcIi4uL21hdGgvU3BoZXJlXCI7XHJcbmltcG9ydCB7Qm94M30gZnJvbSBcIi4uL21hdGgvQm94M1wiO1xyXG5cclxuY2xhc3MgU3BoZXJlR2VvbWV0cnkge1xyXG4gICAgY29uc3RydWN0b3IoIHJhZGl1cywgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGgsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xyXG5cclxuICAgICAgICByYWRpdXMgPSByYWRpdXMgfHwgMTtcclxuXHJcbiAgICAgICAgd2lkdGhTZWdtZW50cyA9IE1hdGgubWF4KCAzLCBNYXRoLmZsb29yKCB3aWR0aFNlZ21lbnRzICkgfHwgOCApO1xyXG4gICAgICAgIGhlaWdodFNlZ21lbnRzID0gTWF0aC5tYXgoIDIsIE1hdGguZmxvb3IoIGhlaWdodFNlZ21lbnRzICkgfHwgNiApO1xyXG5cclxuICAgICAgICBwaGlTdGFydCA9IHBoaVN0YXJ0ICE9PSB1bmRlZmluZWQgPyBwaGlTdGFydCA6IDA7XHJcbiAgICAgICAgcGhpTGVuZ3RoID0gcGhpTGVuZ3RoICE9PSB1bmRlZmluZWQgPyBwaGlMZW5ndGggOiBNYXRoLlBJICogMjtcclxuXHJcbiAgICAgICAgdGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xyXG4gICAgICAgIHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogTWF0aC5QSTtcclxuXHJcbiAgICAgICAgdmFyIHRoZXRhRW5kID0gdGhldGFTdGFydCArIHRoZXRhTGVuZ3RoO1xyXG5cclxuICAgICAgICB2YXIgaXgsIGl5O1xyXG5cclxuICAgICAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgICAgIHZhciBncmlkID0gW107XHJcblxyXG4gICAgICAgIHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xyXG4gICAgICAgIHZhciBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuICAgICAgICAvLyBidWZmZXJzXHJcblxyXG4gICAgICAgIHZhciBpbmRpY2VzID0gW107XHJcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gW107XHJcbiAgICAgICAgdmFyIG5vcm1hbHMgPSBbXTtcclxuICAgICAgICB2YXIgdXZzID0gW107XHJcblxyXG4gICAgICAgIC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcclxuXHJcbiAgICAgICAgZm9yICggaXkgPSAwOyBpeSA8PSBoZWlnaHRTZWdtZW50czsgaXkgKysgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgdmVydGljZXNSb3cgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIHZhciB2ID0gaXkgLyBoZWlnaHRTZWdtZW50cztcclxuXHJcbiAgICAgICAgICAgIGZvciAoIGl4ID0gMDsgaXggPD0gd2lkdGhTZWdtZW50czsgaXggKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHUgPSBpeCAvIHdpZHRoU2VnbWVudHM7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gdmVydGV4XHJcblxyXG4gICAgICAgICAgICAgICAgdmVydGV4ID0gbmV3IFZlY3RvcjMoXHJcbiAgICAgICAgICAgICAgICAgICAgLSByYWRpdXMgKiBNYXRoLmNvcyggcGhpU3RhcnQgKyB1ICogcGhpTGVuZ3RoICkgKiBNYXRoLnNpbiggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApLFxyXG4gICAgICAgICAgICAgICAgICAgIHJhZGl1cyAqIE1hdGguY29zKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICksXHJcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzICogTWF0aC5zaW4oIHBoaVN0YXJ0ICsgdSAqIHBoaUxlbmd0aCApICogTWF0aC5zaW4oIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKVxyXG4gICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbm9ybWFsXHJcblxyXG4gICAgICAgICAgICAgICAgbm9ybWFsID0gdmVydGV4LmNsb25lKCkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICBub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyB1dlxyXG5cclxuICAgICAgICAgICAgICAgIHV2cy5wdXNoKCB1LCAxIC0gdiApO1xyXG5cclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzUm93LnB1c2goIGluZGV4ICsrICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBncmlkLnB1c2goIHZlcnRpY2VzUm93ICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaW5kaWNlc1xyXG5cclxuICAgICAgICBmb3IgKCBpeSA9IDA7IGl5IDwgaGVpZ2h0U2VnbWVudHM7IGl5ICsrICkge1xyXG5cclxuICAgICAgICAgICAgZm9yICggaXggPSAwOyBpeCA8IHdpZHRoU2VnbWVudHM7IGl4ICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBhID0gZ3JpZFsgaXkgXVsgaXggKyAxIF07XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IGdyaWRbIGl5IF1bIGl4IF07XHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGdyaWRbIGl5ICsgMSBdWyBpeCBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBncmlkWyBpeSArIDEgXVsgaXggKyAxIF07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBpeSAhPT0gMCB8fCB0aGV0YVN0YXJ0ID4gMCApIGluZGljZXMucHVzaCggYSwgYiwgZCApO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBpeSAhPT0gaGVpZ2h0U2VnbWVudHMgLSAxIHx8IHRoZXRhRW5kIDwgTWF0aC5QSSApIGluZGljZXMucHVzaCggYiwgYywgZCApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZlcnRpY2VzKTtcclxuICAgICAgICB0aGlzLm5vcm1hbCA9IG5ldyBGbG9hdDMyQXJyYXkobm9ybWFscyk7XHJcbiAgICAgICAgdGhpcy51diA9IG5ldyBGbG9hdDMyQXJyYXkodXZzKTtcclxuXHJcbiAgICAgICAgdGhpcy5pbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KGluZGljZXMpO1xyXG5cclxuICAgICAgICB2YXIgYnVmZmVyID0gW107XHJcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcclxuICAgICAgICB2YXIgbm9ybWFsID0gdGhpcy5ub3JtYWw7XHJcbiAgICAgICAgdmFyIHV2ID0gdGhpcy51djtcclxuICAgICAgICBmb3IodmFyIGk9MDsgaTx2ZXJ0aWNlcy5sZW5ndGg7IGkrPTMpe1xyXG4gICAgICAgICAgICBidWZmZXIucHVzaCh2ZXJ0aWNlc1tpKzBdKTtcclxuICAgICAgICAgICAgYnVmZmVyLnB1c2godmVydGljZXNbaSsxXSk7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKHZlcnRpY2VzW2krMl0pO1xyXG5cclxuICAgICAgICAgICAgYnVmZmVyLnB1c2gobm9ybWFsW2krMF0pO1xyXG4gICAgICAgICAgICBidWZmZXIucHVzaChub3JtYWxbaSsxXSk7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKG5vcm1hbFtpKzJdKTtcclxuXHJcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKHV2W2kvMyoyKzBdKTtcclxuICAgICAgICAgICAgYnVmZmVyLnB1c2godXZbaS8zKjIrMV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcik7XHJcblxyXG4gICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IG5ldyBCb3gzKCk7XHJcbiAgICAgICAgdGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgY29tcHV0ZUJvdW5kaW5nQm94ICgpIHtcclxuICAgICAgICB2YXIgdmVydGljZXNWMyA9IFtdO1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHRoaXMudmVydGljZXMubGVuZ3RoOyBpKz0zKXtcclxuICAgICAgICAgICAgdmVydGljZXNWMy5wdXNoKG5ldyBWZWN0b3IzKHRoaXMudmVydGljZXNbaV0sIHRoaXMudmVydGljZXNbaSsxXSwgdGhpcy52ZXJ0aWNlc1tpKzJdKSlcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5zZXRGcm9tUG9pbnRzKHZlcnRpY2VzVjMpO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3BoZXJlR2VvbWV0cnk7XHJcbiIsImltcG9ydCBTY2VuZSBmcm9tIFwiLi9TY2VuZVwiO1xyXG5pbXBvcnQgTWVzaCBmcm9tIFwiLi9NZXNoXCI7XHJcbmltcG9ydCBHZW9tZXRyeSBmcm9tIFwiLi9HZW9tZXRyeVwiO1xyXG5pbXBvcnQgTWVzaExhbWJlcnRNYXRlcmlhbCBmcm9tIFwiLi4vbWF0ZXJpYWwvTWVzaExhbWJlcnRNYXRlcmlhbFwiO1xyXG5pbXBvcnQge1F1YXRlcm5pb259IGZyb20gXCIuLi9tYXRoL1F1YXRlcm5pb25cIjtcclxuaW1wb3J0IHtNYXRyaXg0fSBmcm9tIFwiLi4vbWF0aC9NYXRyaXg0XCI7XHJcblxyXG5jbGFzcyBHTFRGTG9hZGVye1xyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICB0aGlzLmdsdGZPYmogPSBudWxsO1xyXG4gICAgICAgIHRoaXMudXJsQmFzZSA9IG51bGw7XHJcblxyXG4gICAgICAgIHRoaXMuYXJyYXlCdWZmZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5hcnJheUJ1ZmZlckNvdW50ID0gMDtcclxuICAgICAgICB0aGlzLmRhdGFVcmlSZWdleCA9IC9eZGF0YTooLio/KSg7YmFzZTY0KT8sKC4qKSQvO1xyXG4gICAgfVxyXG5cclxuICAgIGxvYWQodXJsLCBvbkxvYWRTdWNjZXNzKXtcclxuICAgICAgICB0aGlzLmdsdGZPYmogPSBudWxsO1xyXG4gICAgICAgIHRoaXMudXJsQmFzZSA9IG51bGw7XHJcblxyXG4gICAgICAgIHRoaXMuYXJyYXlCdWZmZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5hcnJheUJ1ZmZlckNvdW50ID0gMDtcclxuXHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciB1cmxBcnJheSA9IHVybC5zcGxpdCgnLycpO1xyXG4gICAgICAgIHZhciBqc29uTmFtZSA9IHVybEFycmF5W3VybEFycmF5Lmxlbmd0aC0xXTtcclxuICAgICAgICB0aGF0LnVybEJhc2UgPSB1cmwuc3BsaXQoanNvbk5hbWUpWzBdO1xyXG5cclxuICAgICAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgIHJlcXVlc3Qub3BlbihcImdldFwiLCB1cmwpO1xyXG4gICAgICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT0gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ2x0Zk9iaiA9IEpTT04ucGFyc2UocmVxdWVzdC5yZXNwb25zZVRleHQpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5nbHRmT2JqID0gZ2x0Zk9iajtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGdsdGZPYmopO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoYXQuYXJyYXlCdWZmZXJDb3VudCA9IGdsdGZPYmouYnVmZmVycy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgbG9hZEJ1ZmZlckNvdW50ID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgaW4gZ2x0Zk9iai5idWZmZXJzKXtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGdsdGZPYmouYnVmZmVyc1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFVcmlSZWdleFJlc3VsdCA9IGJ1ZmZlci51cmkubWF0Y2goIHRoYXQuZGF0YVVyaVJlZ2V4ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZGF0YVVyaVJlZ2V4UmVzdWx0KXtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBidWZmZXIgPSB0aGF0LmJhc2U2NFRvQXJyYXlCdWZmZXIoZGF0YVVyaVJlZ2V4UmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYnVmZmVyKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYXJyYXlCdWZmZXJzW2ldID0gYnVmZmVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZEJ1ZmZlckNvdW50ICsrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGxvYWRCdWZmZXJDb3VudCA9IHRoYXQuYXJyYXlCdWZmZXJDb3VudCl7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY2VuZU9iaiA9IGdsdGZPYmouc2NlbmVzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY2VuZSA9IG5ldyBTY2VuZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgbm9kZWluZGV4IGluIHNjZW5lT2JqLm5vZGVzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVzSW5kZXggPSBzY2VuZU9iai5ub2Rlc1tub2RlaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZXNPYmogPSBnbHRmT2JqLm5vZGVzW25vZGVzSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyX21lc2ggPSB0aGF0Lm5vZGVUb01lc2gobm9kZXNPYmopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2VuZS5hZGQoY3VyX21lc2gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkxvYWRTdWNjZXNzKHNjZW5lKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1ZmZlckRhdGFVcmkgPSB0aGF0LnVybEJhc2UgKyBidWZmZXIudXJpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIub3BlbiggJ0dFVCcsIGJ1ZmZlckRhdGFVcmksIHRydWUgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgZnVuY3Rpb24gKCBldmVudCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5yZXNwb25zZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYXJyYXlCdWZmZXJzW2ldID0gYnVmZmVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZEJ1ZmZlckNvdW50ICsrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGxvYWRCdWZmZXJDb3VudCA9IHRoYXQuYXJyYXlCdWZmZXJDb3VudCl7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY2VuZU9iaiA9IGdsdGZPYmouc2NlbmVzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY2VuZSA9IG5ldyBTY2VuZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgbm9kZWluZGV4IGluIHNjZW5lT2JqLm5vZGVzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVzSW5kZXggPSBzY2VuZU9iai5ub2Rlc1tub2RlaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZXNPYmogPSBnbHRmT2JqLm5vZGVzW25vZGVzSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyX21lc2ggPSB0aGF0Lm5vZGVUb01lc2gobm9kZXNPYmopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2VuZS5hZGQoY3VyX21lc2gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkxvYWRTdWNjZXNzKHNjZW5lKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZmFsc2UgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZW5kKCBudWxsICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJlcXVlc3Quc2VuZChudWxsKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgbm9kZVRvTWVzaChub2RlKXtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgICAgIHZhciBtZXNoSW5kZXggPSBub2RlLm1lc2g7XHJcbiAgICAgICAgdmFyIG1lc2ggPSBudWxsO1xyXG5cclxuICAgICAgICBpZihtZXNoSW5kZXggIT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgdmFyIG1lc2hPYmogPSB0aGF0LmdsdGZPYmoubWVzaGVzW21lc2hJbmRleF07XHJcbiAgICAgICAgICAgIHZhciBnZW9tZXRyeUFuZE1hdGVyaWFsID0gdGhhdC5tZXNoVG9HZW9tZXRyeShtZXNoT2JqKTtcclxuICAgICAgICAgICAgbWVzaCA9IG5ldyBNZXNoKHtcclxuICAgICAgICAgICAgICAgIGdlb21ldHJ5Omdlb21ldHJ5QW5kTWF0ZXJpYWxbMF0sXHJcbiAgICAgICAgICAgICAgICBtYXRlcmlhbDpnZW9tZXRyeUFuZE1hdGVyaWFsWzFdXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICBtZXNoID0gbmV3IE1lc2goKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzY2FsZSA9IG5vZGUuc2NhbGU7XHJcbiAgICAgICAgaWYoc2NhbGUpe1xyXG4gICAgICAgICAgICBtZXNoLnNldFNjYWxlKHNjYWxlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciByb3RhdGlvbiA9IG5vZGUucm90YXRpb247XHJcbiAgICAgICAgaWYocm90YXRpb24pe1xyXG4gICAgICAgICAgICB2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCkuZnJvbUFycmF5KHJvdGF0aW9uKTtcclxuICAgICAgICAgICAgbWVzaC5zZXRRdWF0ZXJuaW9uKHF1YXRlcm5pb24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHRyYW5zbGF0aW9uID0gbm9kZS50cmFuc2xhdGlvbjtcclxuICAgICAgICBpZih0cmFuc2xhdGlvbil7XHJcbiAgICAgICAgICAgIG1lc2guc2V0UG9zaXRpb24odHJhbnNsYXRpb24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG1hdHJpeCA9IG5vZGUubWF0cml4O1xyXG4gICAgICAgIGlmKG1hdHJpeCl7XHJcbiAgICAgICAgICAgIG1lc2guc2V0TWF0cml4KG5ldyBNYXRyaXg0KCkuZnJvbUFycmF5KG1hdHJpeCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yKHZhciBpIGluIG5vZGUuY2hpbGRyZW4pe1xyXG4gICAgICAgICAgICB2YXIgbm9kZUNoaWxkID0gdGhhdC5nbHRmT2JqLm5vZGVzW25vZGUuY2hpbGRyZW5baV1dO1xyXG4gICAgICAgICAgICB2YXIgbWVzaENoaWxkID0gdGhhdC5ub2RlVG9NZXNoKG5vZGVDaGlsZCk7XHJcbiAgICAgICAgICAgIG1lc2guYWRkKG1lc2hDaGlsZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbWVzaDtcclxuICAgIH1cclxuXHJcbiAgICBtZXNoVG9HZW9tZXRyeShtZXNoKXtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgICAgIHZhciBwcmltaXRpdmUwID0gbWVzaC5wcmltaXRpdmVzWzBdO1xyXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gcHJpbWl0aXZlMC5hdHRyaWJ1dGVzO1xyXG5cclxuICAgICAgICB2YXIgcG9zaXRpb25BY2Nlc3NvckluZGV4ID0gYXR0cmlidXRlcy5QT1NJVElPTjtcclxuICAgICAgICB2YXIgcG9zaXRpb25BY2Nlc3NvciA9IHRoYXQuZ2x0Zk9iai5hY2Nlc3NvcnNbcG9zaXRpb25BY2Nlc3NvckluZGV4XTtcclxuICAgICAgICB2YXIgcG9zaXRpb25CdWZmZXJWaWV3SW5kZXggPSBwb3NpdGlvbkFjY2Vzc29yLmJ1ZmZlclZpZXc7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uQnVmZmVyVmlldyA9IHRoYXQuZ2x0Zk9iai5idWZmZXJWaWV3c1twb3NpdGlvbkJ1ZmZlclZpZXdJbmRleF07XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uRGF0YSA9IHRoYXQuZ2V0RGF0YUJ5QnVmZmVyVmlldyhwb3NpdGlvbkJ1ZmZlclZpZXcscG9zaXRpb25BY2Nlc3Nvcik7XHJcblxyXG4gICAgICAgIHZhciBub3JtYWxBY2Nlc3NvckluZGV4ID0gYXR0cmlidXRlcy5OT1JNQUw7XHJcbiAgICAgICAgdmFyIG5vcm1hbEFjY2Vzc29yID0gdGhhdC5nbHRmT2JqLmFjY2Vzc29yc1tub3JtYWxBY2Nlc3NvckluZGV4XTtcclxuICAgICAgICB2YXIgbm9ybWFsQnVmZmVyVmlld0luZGV4ID0gbm9ybWFsQWNjZXNzb3IuYnVmZmVyVmlldztcclxuICAgICAgICB2YXIgbm9ybWFsQnVmZmVyVmlldyA9IHRoYXQuZ2x0Zk9iai5idWZmZXJWaWV3c1tub3JtYWxCdWZmZXJWaWV3SW5kZXhdO1xyXG4gICAgICAgIHZhciBub3JtYWxEYXRhID0gdGhhdC5nZXREYXRhQnlCdWZmZXJWaWV3KG5vcm1hbEJ1ZmZlclZpZXcsbm9ybWFsQWNjZXNzb3IpO1xyXG5cclxuICAgICAgICAvL1RFWENPT1JEXzBcclxuICAgICAgICB2YXIgdXYwQWNjZXNzb3JJbmRleCA9IGF0dHJpYnV0ZXMuVEVYQ09PUkRfMDtcclxuICAgICAgICB2YXIgdXYwQWNjZXNzb3IgPSB0aGF0LmdsdGZPYmouYWNjZXNzb3JzW3V2MEFjY2Vzc29ySW5kZXhdO1xyXG4gICAgICAgIHZhciB1djBCdWZmZXJWaWV3SW5kZXggPSB1djBBY2Nlc3Nvci5idWZmZXJWaWV3O1xyXG4gICAgICAgIHZhciB1djBCdWZmZXJWaWV3ID0gdGhhdC5nbHRmT2JqLmJ1ZmZlclZpZXdzW3V2MEJ1ZmZlclZpZXdJbmRleF07XHJcbiAgICAgICAgdmFyIHV2MERhdGEgPSB0aGF0LmdldERhdGFCeUJ1ZmZlclZpZXcodXYwQnVmZmVyVmlldyx1djBBY2Nlc3Nvcik7XHJcblxyXG4gICAgICAgIHZhciBpbmRpY2VzRGF0YSA9IG51bGw7XHJcbiAgICAgICAgdmFyIGluZGljZXNBY2Nlc3NvckluZGV4ID0gcHJpbWl0aXZlMC5pbmRpY2VzO1xyXG5cclxuICAgICAgICBpZihpbmRpY2VzQWNjZXNzb3JJbmRleCAhPSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICB2YXIgaW5kaWNlc0FjY2Vzc29yID0gdGhhdC5nbHRmT2JqLmFjY2Vzc29yc1tpbmRpY2VzQWNjZXNzb3JJbmRleF07XHJcbiAgICAgICAgICAgIHZhciBpbmRpY2VzQnVmZmVyVmlld0luZGV4ID0gaW5kaWNlc0FjY2Vzc29yLmJ1ZmZlclZpZXc7XHJcbiAgICAgICAgICAgIHZhciBpbmRpY2VzQnVmZmVyVmlldyA9IHRoYXQuZ2x0Zk9iai5idWZmZXJWaWV3c1tpbmRpY2VzQnVmZmVyVmlld0luZGV4XTtcclxuICAgICAgICAgICAgaW5kaWNlc0RhdGEgPSB0aGF0LmdldERhdGFCeUJ1ZmZlclZpZXcoaW5kaWNlc0J1ZmZlclZpZXcsaW5kaWNlc0FjY2Vzc29yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBtYXRlcmlhbEluZGV4ID0gcHJpbWl0aXZlMC5tYXRlcmlhbDtcclxuICAgICAgICB2YXIgbWF0ZXJpYWxPYmogPSB0aGF0LmdsdGZPYmoubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xyXG5cclxuICAgICAgICBpZihtYXRlcmlhbE9iai5wYnJNZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlKXtcclxuICAgICAgICAgICAgdmFyIGJhc2VDb2xvclRleHR1cmVJbmRleCA9IG1hdGVyaWFsT2JqLnBick1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUuaW5kZXg7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlT2JqID0gdGhhdC5nbHRmT2JqLnRleHR1cmVzW2Jhc2VDb2xvclRleHR1cmVJbmRleF07XHJcbiAgICAgICAgICAgIHZhciBpbWFnZUluZGV4ID0gdGV4dHVyZU9iai5zb3VyY2U7XHJcbiAgICAgICAgICAgIHZhciBpbWFnZU9iaiA9IHRoYXQuZ2x0Zk9iai5pbWFnZXNbaW1hZ2VJbmRleF07XHJcbiAgICAgICAgICAgIHZhciBpbWFnZVVyaSA9IGltYWdlT2JqLnVyaTtcclxuXHJcbiAgICAgICAgICAgIHZhciBkYXRhVXJpUmVnZXhSZXN1bHQgPSBpbWFnZU9iai51cmkubWF0Y2goIHRoYXQuZGF0YVVyaVJlZ2V4ICk7XHJcbiAgICAgICAgICAgIGlmKCFkYXRhVXJpUmVnZXhSZXN1bHQpe1xyXG4gICAgICAgICAgICAgICAgaW1hZ2VVcmkgPSB0aGF0LnVybEJhc2UgKyBpbWFnZU9iai51cmk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzYW1wbGVySW5kZXggPSB0ZXh0dXJlT2JqLnNhbXBsZXI7XHJcbiAgICAgICAgICAgIHZhciBzYW1wbGVyID0gdGhhdC5nbHRmT2JqLnNhbXBsZXJzW3NhbXBsZXJJbmRleF07XHJcblxyXG4gICAgICAgICAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiO1xyXG4gICAgICAgICAgICBpbWFnZS5zcmM9IGltYWdlVXJpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHRleHR1cmUgPSBuZXcgQ09PTC5UZXh0dXJlKHtcclxuICAgICAgICAgICAgICAgIGltYWdlOmltYWdlLFxyXG4gICAgICAgICAgICAgICAgLy/ov5nkuKTkuKrlj4LmlbDmnInpl67popjvvIzmnInnmoQ5NzI5IDk5ODbmmK/ku4DkuYjkuJzopb9cclxuICAgICAgICAgICAgICAgIC8vIG1hZ0ZpbHRlcjogc2FtcGxlci5tYWdGaWx0ZXIsXHJcbiAgICAgICAgICAgICAgICAvLyBtaW5GaWx0ZXI6IHNhbXBsZXIubWluRmlsdGVyLFxyXG4gICAgICAgICAgICAgICAgd3JhcFM6IHNhbXBsZXIud3JhcFMsXHJcbiAgICAgICAgICAgICAgICB3cmFwVDogc2FtcGxlci53cmFwVCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgdmFyIG1hdGVyaWFsID0gbmV3IENPT0wuTWVzaExhbWJlcnRNYXRlcmlhbCh7bWFwOnRleHR1cmV9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgbmV3IEdlb21ldHJ5KHtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzOiBwb3NpdGlvbkRhdGEsXHJcbiAgICAgICAgICAgICAgICBpbmRpY2VzOiBpbmRpY2VzRGF0YSxcclxuICAgICAgICAgICAgICAgIG5vcm1hbDpub3JtYWxEYXRhLFxyXG4gICAgICAgICAgICAgICAgdXY6dXYwRGF0YVxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgbWF0ZXJpYWxcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIGdldERhdGFCeUJ1ZmZlclZpZXcoYnVmZmVyVmlldywgYWNjZXNzb3Ipe1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgYnVmZmVySW5kZXggPSBidWZmZXJWaWV3LmJ1ZmZlcjtcclxuXHJcbiAgICAgICAgdmFyIGJ5dGVMZW5ndGggPSBidWZmZXJWaWV3LmJ5dGVMZW5ndGggfHwgMDtcclxuICAgICAgICB2YXIgYnl0ZU9mZnNldCA9IGJ1ZmZlclZpZXcuYnl0ZU9mZnNldCB8fCAwO1xyXG5cclxuICAgICAgICB2YXIgYnVmZmVyID0gdGhhdC5nbHRmT2JqLmJ1ZmZlcnNbYnVmZmVySW5kZXhdO1xyXG4gICAgICAgIHZhciBidWZmZXJEYXRhVXJpID0gdGhhdC51cmxCYXNlICsgYnVmZmVyLnVyaTtcclxuXHJcbiAgICAgICAgdmFyIGFycmF5QnVmZmVyID0gdGhhdC5hcnJheUJ1ZmZlcnNbYnVmZmVySW5kZXhdO1xyXG5cclxuICAgICAgICB2YXIgY3VyX2J1ZmZlciA9IGFycmF5QnVmZmVyLnNsaWNlKCBieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCApO1xyXG5cclxuICAgICAgICB2YXIgYXJyYXkgPSBudWxsO1xyXG4gICAgICAgIHZhciBpdGVtU2l6ZSA9IG51bGw7XHJcblxyXG4gICAgICAgIHZhciBhY2Nlc3NvckJ5dGVPZmZzZXQgPSBhY2Nlc3Nvci5ieXRlT2Zmc2V0IHx8IDA7XHJcblxyXG4gICAgICAgIGlmKGFjY2Vzc29yLnR5cGUgPT0gJ1NDQUxBUicpe1xyXG4gICAgICAgICAgICBpdGVtU2l6ZSA9IDE7XHJcbiAgICAgICAgfWVsc2UgaWYoYWNjZXNzb3IudHlwZSA9PSAnVkVDMicpe1xyXG4gICAgICAgICAgICBpdGVtU2l6ZSA9IDI7XHJcbiAgICAgICAgfWVsc2UgaWYoYWNjZXNzb3IudHlwZSA9PSAnVkVDMycpe1xyXG4gICAgICAgICAgICBpdGVtU2l6ZSA9IDM7XHJcbiAgICAgICAgfWVsc2UgaWYoYWNjZXNzb3IudHlwZSA9PSAnVkVDNCcpe1xyXG4gICAgICAgICAgICBpdGVtU2l6ZSA9IDQ7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignYWNjZXNzb3IudHlwZSB1bmRlZmluZWQnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKGFjY2Vzc29yLmNvbXBvbmVudFR5cGUgPT0gNTEyNil7XHJcbiAgICAgICAgICAgIGFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggY3VyX2J1ZmZlciwgYWNjZXNzb3JCeXRlT2Zmc2V0LCBhY2Nlc3Nvci5jb3VudCAqIGl0ZW1TaXplICk7XHJcbiAgICAgICAgfWVsc2UgaWYoYWNjZXNzb3IuY29tcG9uZW50VHlwZSA9PSA1MTIzKXtcclxuICAgICAgICAgICAgYXJyYXkgPSBuZXcgVWludDE2QXJyYXkoIGN1cl9idWZmZXIsIGFjY2Vzc29yQnl0ZU9mZnNldCwgYWNjZXNzb3IuY291bnQgKiBpdGVtU2l6ZSApO1xyXG4gICAgICAgIH1lbHNlIGlmKGFjY2Vzc29yLmNvbXBvbmVudFR5cGUgPT0gNTEyMCl7XHJcbiAgICAgICAgICAgIGFycmF5ID0gbmV3IEludDhBcnJheSggY3VyX2J1ZmZlciwgYWNjZXNzb3JCeXRlT2Zmc2V0LCBhY2Nlc3Nvci5jb3VudCAqIGl0ZW1TaXplICk7XHJcbiAgICAgICAgfWVsc2UgaWYoYWNjZXNzb3IuY29tcG9uZW50VHlwZSA9PSA1MTIxKXtcclxuICAgICAgICAgICAgYXJyYXkgPSBuZXcgVWludDhBcnJheSggY3VyX2J1ZmZlciwgYWNjZXNzb3JCeXRlT2Zmc2V0LCBhY2Nlc3Nvci5jb3VudCAqIGl0ZW1TaXplICk7XHJcbiAgICAgICAgfWVsc2UgaWYoYWNjZXNzb3IuY29tcG9uZW50VHlwZSA9PSA1MTIyKXtcclxuICAgICAgICAgICAgYXJyYXkgPSBuZXcgSW50MTZBcnJheSggY3VyX2J1ZmZlciwgYWNjZXNzb3JCeXRlT2Zmc2V0LCBhY2Nlc3Nvci5jb3VudCAqIGl0ZW1TaXplICk7XHJcbiAgICAgICAgfWVsc2UgaWYoYWNjZXNzb3IuY29tcG9uZW50VHlwZSA9PSA1MTI1KXtcclxuICAgICAgICAgICAgYXJyYXkgPSBuZXcgVWludDMyQXJyYXkoIGN1cl9idWZmZXIsIGFjY2Vzc29yQnl0ZU9mZnNldCwgYWNjZXNzb3IuY291bnQgKiBpdGVtU2l6ZSApO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FjY2Vzc29yLmNvbXBvbmVudFR5cGUgdW5kZWZpbmVkJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYXJyYXk7XHJcblxyXG5cclxuICAgIH1cclxuXHJcbiAgICBiYXNlNjRUb0FycmF5QnVmZmVyKGRhdGFVcmlSZWdleFJlc3VsdCl7XHJcblxyXG4gICAgICAgIHZhciBkYXRhID0gZGF0YVVyaVJlZ2V4UmVzdWx0WyAzIF07XHJcbiAgICAgICAgZGF0YSA9IGRlY29kZVVSSUNvbXBvbmVudCggZGF0YSApO1xyXG4gICAgICAgIGRhdGEgPSBhdG9iKCBkYXRhICk7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KCBkYXRhLmxlbmd0aCApO1xyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArKyApIHtcclxuICAgICAgICAgICAgICAgIHZpZXdbIGkgXSA9IGRhdGEuY2hhckNvZGVBdCggaSApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgYXJyYXlCdWZmZXIgPSB2aWV3LmJ1ZmZlcjtcclxuICAgICAgICAgICAgcmV0dXJuIGFycmF5QnVmZmVyO1xyXG5cclxuICAgICAgICB9IGNhdGNoICggZXJyb3IgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEdMVEZMb2FkZXI7XHJcbiIsIlxyXG5pbXBvcnQge01hdHJpeDR9IGZyb20gXCIuLi9tYXRoL01hdHJpeDRcIjtcclxuaW1wb3J0IHtWZWN0b3IzfSBmcm9tIFwiLi4vbWF0aC9WZWN0b3IzXCI7XHJcblxyXG5jbGFzcyBPcnRob0NhbWVyYSB7XHJcbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xyXG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgdGhpcy5fcmlnaHQgPSByaWdodDtcclxuICAgICAgICB0aGlzLmJvdHRvbSA9IGJvdHRvbTtcclxuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcclxuICAgICAgICB0aGlzLm5lYXIgPSBuZWFyO1xyXG4gICAgICAgIHRoaXMuZmFyID0gZmFyO1xyXG5cclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gWzAsIDAsIDEwXTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IFswLDAsMF07XHJcbiAgICAgICAgdGhpcy51cCA9IFswLDEsMF07XHJcblxyXG4gICAgICAgIHRoaXMuVlBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xyXG5cclxuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IFswLDAsLTFdO1xyXG4gICAgICAgIHRoaXMucmlnaHQgPSBbMSwwLDBdO1xyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZUFsbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZUFsbCgpe1xyXG4gICAgICAgIHRoaXMudXBkYXRlT3B0aW9uKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVWUE1hdHJpeCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZU9wdGlvbigpe1xyXG4gICAgICAgIHZhciB0YXJnZXRWMyA9IG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KHRoaXMudGFyZ2V0KTtcclxuICAgICAgICB2YXIgcG9zaXRpb25WMyA9IG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KHRoaXMucG9zaXRpb24pO1xyXG4gICAgICAgIHZhciB1cFYzID0gbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkodGhpcy51cCk7XHJcblxyXG4gICAgICAgIHZhciBkaXJlY3Rpb25WMyA9IG5ldyBWZWN0b3IzKCkuc3ViVmVjdG9ycyh0YXJnZXRWMywgcG9zaXRpb25WMykubm9ybWFsaXplKCk7XHJcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBkaXJlY3Rpb25WMy50b0FycmF5KCk7XHJcblxyXG4gICAgICAgIHZhciByaWdodFYzID0gbmV3IFZlY3RvcjMoKS5jcm9zc1ZlY3RvcnMoZGlyZWN0aW9uVjMsIHVwVjMpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodFYzLnRvQXJyYXkoKTtcclxuXHJcbiAgICAgICAgLy8gdGhpcy51cCA9IG5ldyBWZWN0b3IzKCkuY3Jvc3NWZWN0b3JzKHJpZ2h0VjMsIGRpcmVjdGlvblYzKS5ub3JtYWxpemUoKS50b0FycmF5KCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0UG9zaXRpb24ocG9zaXRpb24pe1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgICAgICB0aGlzLnVwZGF0ZUFsbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFRhcmdldCh0YXJnZXQpe1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMudXBkYXRlQWxsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0VXAodXApe1xyXG4gICAgICAgIHRoaXMudXAgPSBuZXcgVmVjdG9yMygpLmZyb21BcnJheSh1cCkubm9ybWFsaXplKCkudG9BcnJheSgpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlQWxsKCk7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICB1cGRhdGVWUE1hdHJpeCgpe1xyXG4gICAgICAgIHRoaXMuVlBtYXRyaXggPSBuZXcgTWF0cml4NCgpLnNldE9ydGhvKHRoaXMubGVmdCwgdGhpcy5fcmlnaHQsIHRoaXMuYm90dG9tLCB0aGlzLnRvcCwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XHJcbiAgICAgICAgdGhpcy5WUG1hdHJpeC5sb29rQXQyKHRoaXMucG9zaXRpb25bMF0sdGhpcy5wb3NpdGlvblsxXSx0aGlzLnBvc2l0aW9uWzJdLCB0aGlzLnRhcmdldFswXSx0aGlzLnRhcmdldFsxXSx0aGlzLnRhcmdldFsyXSwgdGhpcy51cFswXSx0aGlzLnVwWzFdLHRoaXMudXBbMl0pO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgT3J0aG9DYW1lcmE7XHJcblxyXG4iLCJpbXBvcnQgTWVzaCBmcm9tIFwiLi4vY29yZS9NZXNoXCI7XHJcblxyXG5jbGFzcyBBbmltYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3IobWVzaCl7XHJcbiAgICAgICAgdGhpcy5tZXNoID0gbWVzaCB8fCBuZXcgTWVzaCgpO1xyXG4gICAgICAgIHRoaXMudGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xyXG4gICAgICAgIHRoaXMuZnJhbWVDb3VudCA9IHRoaXMubWVzaC5nZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24ubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIHBsYXkoKXtcclxuICAgICAgICB0aGlzLnRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICB0aGlzLmluZGV4ID0gMDtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvbkxvb3AoKTtcclxuICAgIH1cclxuXHJcbiAgICBhbmltYXRpb25Mb29wKCl7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjdXJUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgdmFyIGN1ckluZGV4ID0gTWF0aC5mbG9vcigoY3VyVGltZSAtIHRoaXMudGltZSkvMTAwMCoyMCkldGhpcy5mcmFtZUNvdW50O1xyXG4gICAgICAgIGlmKGN1ckluZGV4ICE9IHRoaXMuaW5kZXgpe1xyXG4gICAgICAgICAgICB0aGlzLm1lc2guZ2VvbWV0cnkudmVydGljZXMgPSB0aGlzLm1lc2guZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uW2N1ckluZGV4XS5hcnJheTtcclxuICAgICAgICAgICAgdGhpcy5tZXNoLmdlb21ldHJ5LnVwZGF0YUJ1ZmZlcigpO1xyXG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gY3VySW5kZXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoYXQuYW5pbWF0aW9uTG9vcCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQW5pbWF0aW9uO1xyXG4iLCJpbXBvcnQgeyBSYXkgfSBmcm9tICcuLi9tYXRoL1JheS5qcyc7XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cclxuICogQGF1dGhvciBzdGVwaG9taSAvIGh0dHA6Ly9zdGVwaGFuZWdpbmllci5jb20vXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gUmF5Y2FzdGVyKCBvcmlnaW4sIGRpcmVjdGlvbiwgbmVhciwgZmFyICkge1xyXG5cclxuXHR0aGlzLnJheSA9IG5ldyBSYXkoIG9yaWdpbiwgZGlyZWN0aW9uICk7XHJcblx0Ly8gZGlyZWN0aW9uIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZCAoZm9yIGFjY3VyYXRlIGRpc3RhbmNlIGNhbGN1bGF0aW9ucylcclxuXHJcblx0dGhpcy5uZWFyID0gbmVhciB8fCAwO1xyXG5cdHRoaXMuZmFyID0gZmFyIHx8IEluZmluaXR5O1xyXG5cclxuXHR0aGlzLnBhcmFtcyA9IHtcclxuXHRcdE1lc2g6IHt9LFxyXG5cdFx0TGluZToge30sXHJcblx0XHRMT0Q6IHt9LFxyXG5cdFx0UG9pbnRzOiB7IHRocmVzaG9sZDogMSB9LFxyXG5cdFx0U3ByaXRlOiB7fVxyXG5cdH07XHJcblxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLnBhcmFtcywge1xyXG5cdFx0UG9pbnRDbG91ZDoge1xyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5SYXljYXN0ZXI6IHBhcmFtcy5Qb2ludENsb3VkIGhhcyBiZWVuIHJlbmFtZWQgdG8gcGFyYW1zLlBvaW50cy4nICk7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuUG9pbnRzO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0gKTtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFzY1NvcnQoIGEsIGIgKSB7XHJcblxyXG5cdHJldHVybiBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZTtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGludGVyc2VjdE9iamVjdCggb2JqZWN0LCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSApIHtcclxuXHJcblx0aWYgKCBvYmplY3QudmlzaWJsZSA9PT0gZmFsc2UpIHJldHVybjtcclxuXHJcblx0aWYob2JqZWN0Lmdlb21ldHJ5KXtcclxuICAgICAgICBvYmplY3QucmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICk7XHJcblx0fVxyXG5cclxuXHRpZiAoIHJlY3Vyc2l2ZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHR2YXIgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGludGVyc2VjdE9iamVjdCggY2hpbGRyZW5bIGkgXSwgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCB0cnVlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5PYmplY3QuYXNzaWduKCBSYXljYXN0ZXIucHJvdG90eXBlLCB7XHJcblxyXG5cdGxpbmVQcmVjaXNpb246IDEsXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcclxuXHJcblx0XHQvLyBkaXJlY3Rpb24gaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkIChmb3IgYWNjdXJhdGUgZGlzdGFuY2UgY2FsY3VsYXRpb25zKVxyXG5cclxuXHRcdHRoaXMucmF5LnNldCggb3JpZ2luLCBkaXJlY3Rpb24gKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbUNhbWVyYTogZnVuY3Rpb24gKCBjb29yZHMsIGNhbWVyYSApIHtcclxuXHJcblx0XHRpZiAoIHRydWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnJheS5vcmlnaW4uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcclxuXHRcdFx0dGhpcy5yYXkuZGlyZWN0aW9uLnNldCggY29vcmRzLngsIGNvb3Jkcy55LCAwLjUgKS51bnByb2plY3QoIGNhbWVyYSApLnN1YiggdGhpcy5yYXkub3JpZ2luICkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0fVxyXG5cdFx0Ly8gZWxzZSBpZiAoICggY2FtZXJhICYmIGNhbWVyYS5pc09ydGhvZ3JhcGhpY0NhbWVyYSApICkge1xyXG5cdFx0Ly9cclxuXHRcdC8vIFx0dGhpcy5yYXkub3JpZ2luLnNldCggY29vcmRzLngsIGNvb3Jkcy55LCAoIGNhbWVyYS5uZWFyICsgY2FtZXJhLmZhciApIC8gKCBjYW1lcmEubmVhciAtIGNhbWVyYS5mYXIgKSApLnVucHJvamVjdCggY2FtZXJhICk7IC8vIHNldCBvcmlnaW4gaW4gcGxhbmUgb2YgY2FtZXJhXHJcblx0XHQvLyBcdHRoaXMucmF5LmRpcmVjdGlvbi5zZXQoIDAsIDAsIC0gMSApLnRyYW5zZm9ybURpcmVjdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XHJcblx0XHQvL1xyXG5cdFx0Ly8gfSBlbHNlIHtcclxuXHRcdC8vXHJcblx0XHQvLyBcdGNvbnNvbGUuZXJyb3IoICdDT09MLlJheWNhc3RlcjogVW5zdXBwb3J0ZWQgY2FtZXJhIHR5cGUuJyApO1xyXG5cdFx0Ly9cclxuXHRcdC8vIH1cclxuXHJcblx0fSxcclxuXHJcblx0aW50ZXJzZWN0T2JqZWN0OiBmdW5jdGlvbiAoIG9iamVjdCwgcmVjdXJzaXZlLCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgaW50ZXJzZWN0cyA9IG9wdGlvbmFsVGFyZ2V0IHx8IFtdO1xyXG5cclxuXHRcdGludGVyc2VjdE9iamVjdCggb2JqZWN0LCB0aGlzLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKTtcclxuXHJcblx0XHRpbnRlcnNlY3RzLnNvcnQoIGFzY1NvcnQgKTtcclxuXHJcblx0XHRyZXR1cm4gaW50ZXJzZWN0cztcclxuXHJcblx0fSxcclxuXHJcblx0aW50ZXJzZWN0T2JqZWN0czogZnVuY3Rpb24gKCBvYmplY3RzLCByZWN1cnNpdmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciBpbnRlcnNlY3RzID0gb3B0aW9uYWxUYXJnZXQgfHwgW107XHJcblxyXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBvYmplY3RzICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5SYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0czogb2JqZWN0cyBpcyBub3QgYW4gQXJyYXkuJyApO1xyXG5cdFx0XHRyZXR1cm4gaW50ZXJzZWN0cztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0aW50ZXJzZWN0T2JqZWN0KCBvYmplY3RzWyBpIF0sIHRoaXMsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpbnRlcnNlY3RzLnNvcnQoIGFzY1NvcnQgKTtcclxuXHJcblx0XHRyZXR1cm4gaW50ZXJzZWN0cztcclxuXHJcblx0fVxyXG5cclxufSApO1xyXG5cclxuXHJcbmV4cG9ydCB7IFJheWNhc3RlciB9O1xyXG4iLCIvKipcclxuICogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi9ldmVudGRpc3BhdGNoZXIuanMvXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gRXZlbnREaXNwYXRjaGVyKCkge31cclxuXHJcbk9iamVjdC5hc3NpZ24oIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUsIHtcclxuXHJcblx0YWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgdGhpcy5fbGlzdGVuZXJzID0ge307XHJcblxyXG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcclxuXHJcblx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRsaXN0ZW5lcnNbIHR5cGUgXSA9IFtdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgPT09IC0gMSApIHtcclxuXHJcblx0XHRcdGxpc3RlbmVyc1sgdHlwZSBdLnB1c2goIGxpc3RlbmVyICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRoYXNFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcclxuXHJcblx0XHRyZXR1cm4gbGlzdGVuZXJzWyB0eXBlIF0gIT09IHVuZGVmaW5lZCAmJiBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApICE9PSAtIDE7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHJldHVybjtcclxuXHJcblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xyXG5cdFx0dmFyIGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbIHR5cGUgXTtcclxuXHJcblx0XHRpZiAoIGxpc3RlbmVyQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHZhciBpbmRleCA9IGxpc3RlbmVyQXJyYXkuaW5kZXhPZiggbGlzdGVuZXIgKTtcclxuXHJcblx0XHRcdGlmICggaW5kZXggIT09IC0gMSApIHtcclxuXHJcblx0XHRcdFx0bGlzdGVuZXJBcnJheS5zcGxpY2UoIGluZGV4LCAxICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiAoIGV2ZW50ICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm47XHJcblxyXG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcclxuXHRcdHZhciBsaXN0ZW5lckFycmF5ID0gbGlzdGVuZXJzWyBldmVudC50eXBlIF07XHJcblxyXG5cdFx0aWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRldmVudC50YXJnZXQgPSB0aGlzO1xyXG5cclxuXHRcdFx0dmFyIGFycmF5ID0gbGlzdGVuZXJBcnJheS5zbGljZSggMCApO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0YXJyYXlbIGkgXS5jYWxsKCB0aGlzLCBldmVudCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufSApO1xyXG5cclxuXHJcbmV4cG9ydCB7IEV2ZW50RGlzcGF0Y2hlciB9O1xyXG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uL21hdGgvQ29sb3IuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEZhY2UzKCBhLCBiLCBjLCBub3JtYWwsIGNvbG9yLCBtYXRlcmlhbEluZGV4ICkge1xyXG5cclxuXHR0aGlzLmEgPSBhO1xyXG5cdHRoaXMuYiA9IGI7XHJcblx0dGhpcy5jID0gYztcclxuXHJcblx0dGhpcy5ub3JtYWwgPSAoIG5vcm1hbCAmJiBub3JtYWwuaXNWZWN0b3IzICkgPyBub3JtYWwgOiBuZXcgVmVjdG9yMygpO1xyXG5cdHRoaXMudmVydGV4Tm9ybWFscyA9IEFycmF5LmlzQXJyYXkoIG5vcm1hbCApID8gbm9ybWFsIDogW107XHJcblxyXG5cdHRoaXMuY29sb3IgPSAoIGNvbG9yICYmIGNvbG9yLmlzQ29sb3IgKSA/IGNvbG9yIDogbmV3IENvbG9yKCk7XHJcblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBBcnJheS5pc0FycmF5KCBjb2xvciApID8gY29sb3IgOiBbXTtcclxuXHJcblx0dGhpcy5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWxJbmRleCA6IDA7XHJcblxyXG59XHJcblxyXG5PYmplY3QuYXNzaWduKCBGYWNlMy5wcm90b3R5cGUsIHtcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdHRoaXMuYSA9IHNvdXJjZS5hO1xyXG5cdFx0dGhpcy5iID0gc291cmNlLmI7XHJcblx0XHR0aGlzLmMgPSBzb3VyY2UuYztcclxuXHJcblx0XHR0aGlzLm5vcm1hbC5jb3B5KCBzb3VyY2Uubm9ybWFsICk7XHJcblx0XHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xyXG5cclxuXHRcdHRoaXMubWF0ZXJpYWxJbmRleCA9IHNvdXJjZS5tYXRlcmlhbEluZGV4O1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBzb3VyY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMudmVydGV4Tm9ybWFsc1sgaSBdID0gc291cmNlLnZlcnRleE5vcm1hbHNbIGkgXS5jbG9uZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gc291cmNlLnZlcnRleENvbG9ycy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMudmVydGV4Q29sb3JzWyBpIF0gPSBzb3VyY2UudmVydGV4Q29sb3JzWyBpIF0uY2xvbmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuXHJcblxyXG5leHBvcnQgeyBGYWNlMyB9O1xyXG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi9WZWN0b3IzLmpzJztcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKiBAYXV0aG9yIHRzY2h3XHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gTWF0cml4MygpIHtcclxuXHJcblx0dGhpcy5lbGVtZW50cyA9IFtcclxuXHJcblx0XHQxLCAwLCAwLFxyXG5cdFx0MCwgMSwgMCxcclxuXHRcdDAsIDAsIDFcclxuXHJcblx0XTtcclxuXHJcblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRjb25zb2xlLmVycm9yKCAnQ09PTC5NYXRyaXgzOiB0aGUgY29uc3RydWN0b3Igbm8gbG9uZ2VyIHJlYWRzIGFyZ3VtZW50cy4gdXNlIC5zZXQoKSBpbnN0ZWFkLicgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuT2JqZWN0LmFzc2lnbiggTWF0cml4My5wcm90b3R5cGUsIHtcclxuXHJcblx0aXNNYXRyaXgzOiB0cnVlLFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggbjExLCBuMTIsIG4xMywgbjIxLCBuMjIsIG4yMywgbjMxLCBuMzIsIG4zMyApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRlWyAwIF0gPSBuMTE7IHRlWyAxIF0gPSBuMjE7IHRlWyAyIF0gPSBuMzE7XHJcblx0XHR0ZVsgMyBdID0gbjEyOyB0ZVsgNCBdID0gbjIyOyB0ZVsgNSBdID0gbjMyO1xyXG5cdFx0dGVbIDYgXSA9IG4xMzsgdGVbIDcgXSA9IG4yMzsgdGVbIDggXSA9IG4zMztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0aWRlbnRpdHk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHJcblx0XHRcdDEsIDAsIDAsXHJcblx0XHRcdDAsIDEsIDAsXHJcblx0XHRcdDAsIDAsIDFcclxuXHJcblx0XHQpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmZyb21BcnJheSggdGhpcy5lbGVtZW50cyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XHJcblxyXG5cdFx0dGVbIDAgXSA9IG1lWyAwIF07IHRlWyAxIF0gPSBtZVsgMSBdOyB0ZVsgMiBdID0gbWVbIDIgXTtcclxuXHRcdHRlWyAzIF0gPSBtZVsgMyBdOyB0ZVsgNCBdID0gbWVbIDQgXTsgdGVbIDUgXSA9IG1lWyA1IF07XHJcblx0XHR0ZVsgNiBdID0gbWVbIDYgXTsgdGVbIDcgXSA9IG1lWyA3IF07IHRlWyA4IF0gPSBtZVsgOCBdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tTWF0cml4NDogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XHJcblxyXG5cdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHRtZVsgMCBdLCBtZVsgNCBdLCBtZVsgOCBdLFxyXG5cdFx0XHRtZVsgMSBdLCBtZVsgNSBdLCBtZVsgOSBdLFxyXG5cdFx0XHRtZVsgMiBdLCBtZVsgNiBdLCBtZVsgMTAgXVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5VG9CdWZmZXJBdHRyaWJ1dGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBhcHBseVRvQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBhdHRyaWJ1dGUuY291bnQ7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2MS54ID0gYXR0cmlidXRlLmdldFgoIGkgKTtcclxuXHRcdFx0XHR2MS55ID0gYXR0cmlidXRlLmdldFkoIGkgKTtcclxuXHRcdFx0XHR2MS56ID0gYXR0cmlidXRlLmdldFooIGkgKTtcclxuXHJcblx0XHRcdFx0djEuYXBwbHlNYXRyaXgzKCB0aGlzICk7XHJcblxyXG5cdFx0XHRcdGF0dHJpYnV0ZS5zZXRYWVooIGksIHYxLngsIHYxLnksIHYxLnogKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBhdHRyaWJ1dGU7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRtdWx0aXBseTogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIHRoaXMsIG0gKTtcclxuXHJcblx0fSxcclxuXHJcblx0cHJlbXVsdGlwbHk6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCBtLCB0aGlzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5TWF0cmljZXM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHR2YXIgYWUgPSBhLmVsZW1lbnRzO1xyXG5cdFx0dmFyIGJlID0gYi5lbGVtZW50cztcclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dmFyIGExMSA9IGFlWyAwIF0sIGExMiA9IGFlWyAzIF0sIGExMyA9IGFlWyA2IF07XHJcblx0XHR2YXIgYTIxID0gYWVbIDEgXSwgYTIyID0gYWVbIDQgXSwgYTIzID0gYWVbIDcgXTtcclxuXHRcdHZhciBhMzEgPSBhZVsgMiBdLCBhMzIgPSBhZVsgNSBdLCBhMzMgPSBhZVsgOCBdO1xyXG5cclxuXHRcdHZhciBiMTEgPSBiZVsgMCBdLCBiMTIgPSBiZVsgMyBdLCBiMTMgPSBiZVsgNiBdO1xyXG5cdFx0dmFyIGIyMSA9IGJlWyAxIF0sIGIyMiA9IGJlWyA0IF0sIGIyMyA9IGJlWyA3IF07XHJcblx0XHR2YXIgYjMxID0gYmVbIDIgXSwgYjMyID0gYmVbIDUgXSwgYjMzID0gYmVbIDggXTtcclxuXHJcblx0XHR0ZVsgMCBdID0gYTExICogYjExICsgYTEyICogYjIxICsgYTEzICogYjMxO1xyXG5cdFx0dGVbIDMgXSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMjtcclxuXHRcdHRlWyA2IF0gPSBhMTEgKiBiMTMgKyBhMTIgKiBiMjMgKyBhMTMgKiBiMzM7XHJcblxyXG5cdFx0dGVbIDEgXSA9IGEyMSAqIGIxMSArIGEyMiAqIGIyMSArIGEyMyAqIGIzMTtcclxuXHRcdHRlWyA0IF0gPSBhMjEgKiBiMTIgKyBhMjIgKiBiMjIgKyBhMjMgKiBiMzI7XHJcblx0XHR0ZVsgNyBdID0gYTIxICogYjEzICsgYTIyICogYjIzICsgYTIzICogYjMzO1xyXG5cclxuXHRcdHRlWyAyIF0gPSBhMzEgKiBiMTEgKyBhMzIgKiBiMjEgKyBhMzMgKiBiMzE7XHJcblx0XHR0ZVsgNSBdID0gYTMxICogYjEyICsgYTMyICogYjIyICsgYTMzICogYjMyO1xyXG5cdFx0dGVbIDggXSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRlWyAwIF0gKj0gczsgdGVbIDMgXSAqPSBzOyB0ZVsgNiBdICo9IHM7XHJcblx0XHR0ZVsgMSBdICo9IHM7IHRlWyA0IF0gKj0gczsgdGVbIDcgXSAqPSBzO1xyXG5cdFx0dGVbIDIgXSAqPSBzOyB0ZVsgNSBdICo9IHM7IHRlWyA4IF0gKj0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZGV0ZXJtaW5hbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHZhciBhID0gdGVbIDAgXSwgYiA9IHRlWyAxIF0sIGMgPSB0ZVsgMiBdLFxyXG5cdFx0XHRkID0gdGVbIDMgXSwgZSA9IHRlWyA0IF0sIGYgPSB0ZVsgNSBdLFxyXG5cdFx0XHRnID0gdGVbIDYgXSwgaCA9IHRlWyA3IF0sIGkgPSB0ZVsgOCBdO1xyXG5cclxuXHRcdHJldHVybiBhICogZSAqIGkgLSBhICogZiAqIGggLSBiICogZCAqIGkgKyBiICogZiAqIGcgKyBjICogZCAqIGggLSBjICogZSAqIGc7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEludmVyc2U6IGZ1bmN0aW9uICggbWF0cml4LCB0aHJvd09uRGVnZW5lcmF0ZSApIHtcclxuXHJcblx0XHRpZiAoIG1hdHJpeCAmJiBtYXRyaXguaXNNYXRyaXg0ICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggXCJDT09MLk1hdHJpeDM6IC5nZXRJbnZlcnNlKCkgbm8gbG9uZ2VyIHRha2VzIGEgTWF0cml4NCBhcmd1bWVudC5cIiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbWUgPSBtYXRyaXguZWxlbWVudHMsXHJcblx0XHRcdHRlID0gdGhpcy5lbGVtZW50cyxcclxuXHJcblx0XHRcdG4xMSA9IG1lWyAwIF0sIG4yMSA9IG1lWyAxIF0sIG4zMSA9IG1lWyAyIF0sXHJcblx0XHRcdG4xMiA9IG1lWyAzIF0sIG4yMiA9IG1lWyA0IF0sIG4zMiA9IG1lWyA1IF0sXHJcblx0XHRcdG4xMyA9IG1lWyA2IF0sIG4yMyA9IG1lWyA3IF0sIG4zMyA9IG1lWyA4IF0sXHJcblxyXG5cdFx0XHR0MTEgPSBuMzMgKiBuMjIgLSBuMzIgKiBuMjMsXHJcblx0XHRcdHQxMiA9IG4zMiAqIG4xMyAtIG4zMyAqIG4xMixcclxuXHRcdFx0dDEzID0gbjIzICogbjEyIC0gbjIyICogbjEzLFxyXG5cclxuXHRcdFx0ZGV0ID0gbjExICogdDExICsgbjIxICogdDEyICsgbjMxICogdDEzO1xyXG5cclxuXHRcdGlmICggZGV0ID09PSAwICkge1xyXG5cclxuXHRcdFx0dmFyIG1zZyA9IFwiQ09PTC5NYXRyaXgzOiAuZ2V0SW52ZXJzZSgpIGNhbid0IGludmVydCBtYXRyaXgsIGRldGVybWluYW50IGlzIDBcIjtcclxuXHJcblx0XHRcdGlmICggdGhyb3dPbkRlZ2VuZXJhdGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oIG1zZyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuaWRlbnRpdHkoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGRldEludiA9IDEgLyBkZXQ7XHJcblxyXG5cdFx0dGVbIDAgXSA9IHQxMSAqIGRldEludjtcclxuXHRcdHRlWyAxIF0gPSAoIG4zMSAqIG4yMyAtIG4zMyAqIG4yMSApICogZGV0SW52O1xyXG5cdFx0dGVbIDIgXSA9ICggbjMyICogbjIxIC0gbjMxICogbjIyICkgKiBkZXRJbnY7XHJcblxyXG5cdFx0dGVbIDMgXSA9IHQxMiAqIGRldEludjtcclxuXHRcdHRlWyA0IF0gPSAoIG4zMyAqIG4xMSAtIG4zMSAqIG4xMyApICogZGV0SW52O1xyXG5cdFx0dGVbIDUgXSA9ICggbjMxICogbjEyIC0gbjMyICogbjExICkgKiBkZXRJbnY7XHJcblxyXG5cdFx0dGVbIDYgXSA9IHQxMyAqIGRldEludjtcclxuXHRcdHRlWyA3IF0gPSAoIG4yMSAqIG4xMyAtIG4yMyAqIG4xMSApICogZGV0SW52O1xyXG5cdFx0dGVbIDggXSA9ICggbjIyICogbjExIC0gbjIxICogbjEyICkgKiBkZXRJbnY7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRyYW5zcG9zZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB0bXAsIG0gPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRtcCA9IG1bIDEgXTsgbVsgMSBdID0gbVsgMyBdOyBtWyAzIF0gPSB0bXA7XHJcblx0XHR0bXAgPSBtWyAyIF07IG1bIDIgXSA9IG1bIDYgXTsgbVsgNiBdID0gdG1wO1xyXG5cdFx0dG1wID0gbVsgNSBdOyBtWyA1IF0gPSBtWyA3IF07IG1bIDcgXSA9IHRtcDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0Tm9ybWFsTWF0cml4OiBmdW5jdGlvbiAoIG1hdHJpeDQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeDQoIG1hdHJpeDQgKS5nZXRJbnZlcnNlKCB0aGlzICkudHJhbnNwb3NlKCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRyYW5zcG9zZUludG9BcnJheTogZnVuY3Rpb24gKCByICkge1xyXG5cclxuXHRcdHZhciBtID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHRyWyAwIF0gPSBtWyAwIF07XHJcblx0XHRyWyAxIF0gPSBtWyAzIF07XHJcblx0XHRyWyAyIF0gPSBtWyA2IF07XHJcblx0XHRyWyAzIF0gPSBtWyAxIF07XHJcblx0XHRyWyA0IF0gPSBtWyA0IF07XHJcblx0XHRyWyA1IF0gPSBtWyA3IF07XHJcblx0XHRyWyA2IF0gPSBtWyAyIF07XHJcblx0XHRyWyA3IF0gPSBtWyA1IF07XHJcblx0XHRyWyA4IF0gPSBtWyA4IF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFV2VHJhbnNmb3JtOiBmdW5jdGlvbiAoIHR4LCB0eSwgc3gsIHN5LCByb3RhdGlvbiwgY3gsIGN5ICkge1xyXG5cclxuXHRcdHZhciBjID0gTWF0aC5jb3MoIHJvdGF0aW9uICk7XHJcblx0XHR2YXIgcyA9IE1hdGguc2luKCByb3RhdGlvbiApO1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cdFx0XHRzeCAqIGMsIHN4ICogcywgLSBzeCAqICggYyAqIGN4ICsgcyAqIGN5ICkgKyBjeCArIHR4LFxyXG5cdFx0XHQtIHN5ICogcywgc3kgKiBjLCAtIHN5ICogKCAtIHMgKiBjeCArIGMgKiBjeSApICsgY3kgKyB0eSxcclxuXHRcdFx0MCwgMCwgMVxyXG5cdFx0KTtcclxuXHJcblx0fSxcclxuXHJcblx0c2NhbGU6IGZ1bmN0aW9uICggc3gsIHN5ICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dGVbIDAgXSAqPSBzeDsgdGVbIDMgXSAqPSBzeDsgdGVbIDYgXSAqPSBzeDtcclxuXHRcdHRlWyAxIF0gKj0gc3k7IHRlWyA0IF0gKj0gc3k7IHRlWyA3IF0gKj0gc3k7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdGF0ZTogZnVuY3Rpb24gKCB0aGV0YSApIHtcclxuXHJcblx0XHR2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApO1xyXG5cdFx0dmFyIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHZhciBhMTEgPSB0ZVsgMCBdLCBhMTIgPSB0ZVsgMyBdLCBhMTMgPSB0ZVsgNiBdO1xyXG5cdFx0dmFyIGEyMSA9IHRlWyAxIF0sIGEyMiA9IHRlWyA0IF0sIGEyMyA9IHRlWyA3IF07XHJcblxyXG5cdFx0dGVbIDAgXSA9IGMgKiBhMTEgKyBzICogYTIxO1xyXG5cdFx0dGVbIDMgXSA9IGMgKiBhMTIgKyBzICogYTIyO1xyXG5cdFx0dGVbIDYgXSA9IGMgKiBhMTMgKyBzICogYTIzO1xyXG5cclxuXHRcdHRlWyAxIF0gPSAtIHMgKiBhMTEgKyBjICogYTIxO1xyXG5cdFx0dGVbIDQgXSA9IC0gcyAqIGExMiArIGMgKiBhMjI7XHJcblx0XHR0ZVsgNyBdID0gLSBzICogYTEzICsgYyAqIGEyMztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIHR4LCB0eSApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRlWyAwIF0gKz0gdHggKiB0ZVsgMiBdOyB0ZVsgMyBdICs9IHR4ICogdGVbIDUgXTsgdGVbIDYgXSArPSB0eCAqIHRlWyA4IF07XHJcblx0XHR0ZVsgMSBdICs9IHR5ICogdGVbIDIgXTsgdGVbIDQgXSArPSB0eSAqIHRlWyA1IF07IHRlWyA3IF0gKz0gdHkgKiB0ZVsgOCBdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggbWF0cml4ICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHR2YXIgbWUgPSBtYXRyaXguZWxlbWVudHM7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgOTsgaSArKyApIHtcclxuXHJcblx0XHRcdGlmICggdGVbIGkgXSAhPT0gbWVbIGkgXSApIHJldHVybiBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDk7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmVsZW1lbnRzWyBpIF0gPSBhcnJheVsgaSArIG9mZnNldCBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XHJcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRlWyAwIF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGVbIDEgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0ZVsgMiBdO1xyXG5cclxuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0ZVsgMyBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgNSBdID0gdGVbIDUgXTtcclxuXHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgNiBdID0gdGVbIDYgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyA3IF0gPSB0ZVsgNyBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDggXSA9IHRlWyA4IF07XHJcblxyXG5cdFx0cmV0dXJuIGFycmF5O1xyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcblxyXG5cclxuZXhwb3J0IHsgTWF0cml4MyB9O1xyXG4iLCIvKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5mdW5jdGlvbiBMYXllcnMoKSB7XHJcblxyXG5cdHRoaXMubWFzayA9IDEgfCAwO1xyXG5cclxufVxyXG5cclxuT2JqZWN0LmFzc2lnbiggTGF5ZXJzLnByb3RvdHlwZSwge1xyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggY2hhbm5lbCApIHtcclxuXHJcblx0XHR0aGlzLm1hc2sgPSAxIDw8IGNoYW5uZWwgfCAwO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlbmFibGU6IGZ1bmN0aW9uICggY2hhbm5lbCApIHtcclxuXHJcblx0XHR0aGlzLm1hc2sgfD0gMSA8PCBjaGFubmVsIHwgMDtcclxuXHJcblx0fSxcclxuXHJcblx0dG9nZ2xlOiBmdW5jdGlvbiAoIGNoYW5uZWwgKSB7XHJcblxyXG5cdFx0dGhpcy5tYXNrIF49IDEgPDwgY2hhbm5lbCB8IDA7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICggY2hhbm5lbCApIHtcclxuXHJcblx0XHR0aGlzLm1hc2sgJj0gfiAoIDEgPDwgY2hhbm5lbCB8IDAgKTtcclxuXHJcblx0fSxcclxuXHJcblx0dGVzdDogZnVuY3Rpb24gKCBsYXllcnMgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggdGhpcy5tYXNrICYgbGF5ZXJzLm1hc2sgKSAhPT0gMDtcclxuXHJcblx0fVxyXG5cclxufSApO1xyXG5cclxuXHJcbmV4cG9ydCB7IExheWVycyB9O1xyXG4iLCJpbXBvcnQge1F1YXRlcm5pb259IGZyb20gJy4uL21hdGgvUXVhdGVybmlvbi5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5pbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi4vbWF0aC9NYXRyaXg0LmpzJztcclxuaW1wb3J0IHsgRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnLi9FdmVudERpc3BhdGNoZXIuanMnO1xyXG5pbXBvcnQgIHtFdWxlcn0gIGZyb20gJy4uL21hdGgvRXVsZXIuanMnO1xyXG5pbXBvcnQgeyBMYXllcnMgfSBmcm9tICcuL0xheWVycy5qcyc7XHJcbmltcG9ydCB7IE1hdHJpeDMgfSBmcm9tICcuLi9tYXRoL01hdHJpeDMuanMnO1xyXG5pbXBvcnQgIHtfTWF0aH0gIGZyb20gJy4uL21hdGgvTWF0aC5qcyc7XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqIEBhdXRob3IgZWxlcGhhbnRhdHdvcmsgLyB3d3cuZWxlcGhhbnRhdHdvcmsuY2hcclxuICovXHJcblxyXG52YXIgb2JqZWN0M0RJZCA9IDA7XHJcblxyXG5mdW5jdGlvbiBPYmplY3QzRCgpIHtcclxuXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBvYmplY3QzRElkICsrIH0gKTtcclxuXHJcblx0dGhpcy51dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG5cdHRoaXMubmFtZSA9ICcnO1xyXG5cdHRoaXMudHlwZSA9ICdPYmplY3QzRCc7XHJcblxyXG5cdHRoaXMucGFyZW50ID0gbnVsbDtcclxuXHR0aGlzLmNoaWxkcmVuID0gW107XHJcblxyXG5cdHRoaXMudXAgPSBPYmplY3QzRC5EZWZhdWx0VXAuY2xvbmUoKTtcclxuXHJcblx0dmFyIHBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcclxuXHR2YXIgcm90YXRpb24gPSBuZXcgRXVsZXIoKTtcclxuXHR2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcblx0dmFyIHNjYWxlID0gbmV3IFZlY3RvcjMoIDEsIDEsIDEgKTtcclxuXHJcblx0ZnVuY3Rpb24gb25Sb3RhdGlvbkNoYW5nZSgpIHtcclxuXHJcblx0XHRxdWF0ZXJuaW9uLnNldEZyb21FdWxlciggcm90YXRpb24sIGZhbHNlICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gb25RdWF0ZXJuaW9uQ2hhbmdlKCkge1xyXG5cclxuXHRcdHJvdGF0aW9uLnNldEZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLCB1bmRlZmluZWQsIGZhbHNlICk7XHJcblxyXG5cdH1cclxuXHJcblx0cm90YXRpb24ub25DaGFuZ2UoIG9uUm90YXRpb25DaGFuZ2UgKTtcclxuXHRxdWF0ZXJuaW9uLm9uQ2hhbmdlKCBvblF1YXRlcm5pb25DaGFuZ2UgKTtcclxuXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcclxuXHRcdHBvc2l0aW9uOiB7XHJcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0dmFsdWU6IHBvc2l0aW9uXHJcblx0XHR9LFxyXG5cdFx0cm90YXRpb246IHtcclxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHR2YWx1ZTogcm90YXRpb25cclxuXHRcdH0sXHJcblx0XHRxdWF0ZXJuaW9uOiB7XHJcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0dmFsdWU6IHF1YXRlcm5pb25cclxuXHRcdH0sXHJcblx0XHRzY2FsZToge1xyXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdHZhbHVlOiBzY2FsZVxyXG5cdFx0fSxcclxuXHRcdG1vZGVsVmlld01hdHJpeDoge1xyXG5cdFx0XHR2YWx1ZTogbmV3IE1hdHJpeDQoKVxyXG5cdFx0fSxcclxuXHRcdG5vcm1hbE1hdHJpeDoge1xyXG5cdFx0XHR2YWx1ZTogbmV3IE1hdHJpeDMoKVxyXG5cdFx0fVxyXG5cdH0gKTtcclxuXHJcblx0dGhpcy5tYXRyaXggPSBuZXcgTWF0cml4NCgpO1xyXG5cdHRoaXMubWF0cml4V29ybGQgPSBuZXcgTWF0cml4NCgpO1xyXG5cclxuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBPYmplY3QzRC5EZWZhdWx0TWF0cml4QXV0b1VwZGF0ZTtcclxuXHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5sYXllcnMgPSBuZXcgTGF5ZXJzKCk7XHJcblx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5jYXN0U2hhZG93ID0gZmFsc2U7XHJcblx0dGhpcy5yZWNlaXZlU2hhZG93ID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHRydWU7XHJcblx0dGhpcy5yZW5kZXJPcmRlciA9IDA7XHJcblxyXG5cdHRoaXMudXNlckRhdGEgPSB7fTtcclxuXHJcbn1cclxuXHJcbk9iamVjdDNELkRlZmF1bHRVcCA9IG5ldyBWZWN0b3IzKCAwLCAxLCAwICk7XHJcbk9iamVjdDNELkRlZmF1bHRNYXRyaXhBdXRvVXBkYXRlID0gdHJ1ZTtcclxuXHJcbk9iamVjdDNELnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgKSwge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogT2JqZWN0M0QsXHJcblxyXG5cdGlzT2JqZWN0M0Q6IHRydWUsXHJcblxyXG5cdG9uQmVmb3JlUmVuZGVyOiBmdW5jdGlvbiAoKSB7fSxcclxuXHRvbkFmdGVyUmVuZGVyOiBmdW5jdGlvbiAoKSB7fSxcclxuXHJcblx0YXBwbHlNYXRyaXg6IGZ1bmN0aW9uICggbWF0cml4ICkge1xyXG5cclxuXHRcdHRoaXMubWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeCwgdGhpcy5tYXRyaXggKTtcclxuXHJcblx0XHR0aGlzLm1hdHJpeC5kZWNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhcHBseVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcclxuXHJcblx0XHR0aGlzLnF1YXRlcm5pb24ucHJlbXVsdGlwbHkoIHEgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0Um90YXRpb25Gcm9tQXhpc0FuZ2xlOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xyXG5cclxuXHRcdC8vIGFzc3VtZXMgYXhpcyBpcyBub3JtYWxpemVkXHJcblxyXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFJvdGF0aW9uRnJvbUV1bGVyOiBmdW5jdGlvbiAoIGV1bGVyICkge1xyXG5cclxuXHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIGV1bGVyLCB0cnVlICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFJvdGF0aW9uRnJvbU1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXHJcblxyXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XHJcblxyXG5cdFx0Ly8gYXNzdW1lcyBxIGlzIG5vcm1hbGl6ZWRcclxuXHJcblx0XHR0aGlzLnF1YXRlcm5pb24uY29weSggcSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyb3RhdGVPbkF4aXM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyByb3RhdGUgb2JqZWN0IG9uIGF4aXMgaW4gb2JqZWN0IHNwYWNlXHJcblx0XHQvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxyXG5cclxuXHRcdHZhciBxMSA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZU9uQXhpcyggYXhpcywgYW5nbGUgKSB7XHJcblxyXG5cdFx0XHRxMS5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xyXG5cclxuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLm11bHRpcGx5KCBxMSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRyb3RhdGVPbldvcmxkQXhpczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHJvdGF0ZSBvYmplY3Qgb24gYXhpcyBpbiB3b3JsZCBzcGFjZVxyXG5cdFx0Ly8gYXhpcyBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcclxuXHRcdC8vIG1ldGhvZCBhc3N1bWVzIG5vIHJvdGF0ZWQgcGFyZW50XHJcblxyXG5cdFx0dmFyIHExID0gbmV3IFF1YXRlcm5pb24oKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlT25Xb3JsZEF4aXMoIGF4aXMsIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0cTEuc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcclxuXHJcblx0XHRcdHRoaXMucXVhdGVybmlvbi5wcmVtdWx0aXBseSggcTEgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0cm90YXRlWDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCAxLCAwLCAwICk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVgoIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMyggMCwgMSwgMCApO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVZKCBhbmdsZSApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyggdjEsIGFuZ2xlICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRyb3RhdGVaOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoIDAsIDAsIDEgKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWiggYW5nbGUgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIHYxLCBhbmdsZSApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0dHJhbnNsYXRlT25BeGlzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gdHJhbnNsYXRlIG9iamVjdCBieSBkaXN0YW5jZSBhbG9uZyBheGlzIGluIG9iamVjdCBzcGFjZVxyXG5cdFx0Ly8gYXhpcyBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiB0cmFuc2xhdGVPbkF4aXMoIGF4aXMsIGRpc3RhbmNlICkge1xyXG5cclxuXHRcdFx0djEuY29weSggYXhpcyApLmFwcGx5UXVhdGVybmlvbiggdGhpcy5xdWF0ZXJuaW9uICk7XHJcblxyXG5cdFx0XHR0aGlzLnBvc2l0aW9uLmFkZCggdjEubXVsdGlwbHlTY2FsYXIoIGRpc3RhbmNlICkgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0dHJhbnNsYXRlWDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCAxLCAwLCAwICk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZVgoIGRpc3RhbmNlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHRyYW5zbGF0ZVk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMyggMCwgMSwgMCApO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiB0cmFuc2xhdGVZKCBkaXN0YW5jZSApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggdjEsIGRpc3RhbmNlICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHR0cmFuc2xhdGVaOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoIDAsIDAsIDEgKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gdHJhbnNsYXRlWiggZGlzdGFuY2UgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIHYxLCBkaXN0YW5jZSApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0bG9jYWxUb1dvcmxkOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcblx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHR3b3JsZFRvTG9jYWw6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgbTEgPSBuZXcgTWF0cml4NCgpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiB3b3JsZFRvTG9jYWwoIHZlY3RvciApIHtcclxuXHJcblx0XHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtMS5nZXRJbnZlcnNlKCB0aGlzLm1hdHJpeFdvcmxkICkgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGxvb2tBdDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIFRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgb2JqZWN0cyBoYXZpbmcgbm9uLXVuaWZvcm1seS1zY2FsZWQgcGFyZW50KHMpXHJcblxyXG5cdFx0dmFyIHExID0gbmV3IFF1YXRlcm5pb24oKTtcclxuXHRcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XHJcblx0XHR2YXIgdGFyZ2V0ID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHZhciBwb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGxvb2tBdCggeCwgeSwgeiApIHtcclxuXHJcblx0XHRcdGlmICggeC5pc1ZlY3RvcjMgKSB7XHJcblxyXG5cdFx0XHRcdHRhcmdldC5jb3B5KCB4ICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0YXJnZXQuc2V0KCB4LCB5LCB6ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcblxyXG5cdFx0XHR0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xyXG5cclxuXHRcdFx0cG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuaXNDYW1lcmEgfHwgdGhpcy5pc0xpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRtMS5sb29rQXQoIHBvc2l0aW9uLCB0YXJnZXQsIHRoaXMudXAgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdG0xLmxvb2tBdCggdGFyZ2V0LCBwb3NpdGlvbiwgdGhpcy51cCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbTEgKTtcclxuXHJcblx0XHRcdGlmICggcGFyZW50ICkge1xyXG5cclxuXHRcdFx0XHRtMS5leHRyYWN0Um90YXRpb24oIHBhcmVudC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdHExLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbTEgKTtcclxuXHRcdFx0XHR0aGlzLnF1YXRlcm5pb24ucHJlbXVsdGlwbHkoIHExLmludmVyc2UoKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0YWRkOiBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5hZGQoIGFyZ3VtZW50c1sgaSBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBvYmplY3QgPT09IHRoaXMgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCBcIkNPT0wuT2JqZWN0M0QuYWRkOiBvYmplY3QgY2FuJ3QgYmUgYWRkZWQgYXMgYSBjaGlsZCBvZiBpdHNlbGYuXCIsIG9iamVjdCApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCAoIG9iamVjdCAmJiBvYmplY3QuaXNPYmplY3QzRCApICkge1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QucGFyZW50ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRvYmplY3QucGFyZW50LnJlbW92ZSggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRvYmplY3QucGFyZW50ID0gdGhpcztcclxuXHRcdFx0b2JqZWN0LmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2FkZGVkJyB9ICk7XHJcblxyXG5cdFx0XHR0aGlzLmNoaWxkcmVuLnB1c2goIG9iamVjdCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCBcIkNPT0wuT2JqZWN0M0QuYWRkOiBvYmplY3Qgbm90IGFuIGluc3RhbmNlIG9mIENPT0wuT2JqZWN0M0QuXCIsIG9iamVjdCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0cmVtb3ZlOiBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5yZW1vdmUoIGFyZ3VtZW50c1sgaSBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKCBvYmplY3QgKTtcclxuXHJcblx0XHRpZiAoIGluZGV4ICE9PSAtIDEgKSB7XHJcblxyXG5cdFx0XHRvYmplY3QucGFyZW50ID0gbnVsbDtcclxuXHJcblx0XHRcdG9iamVjdC5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdyZW1vdmVkJyB9ICk7XHJcblxyXG5cdFx0XHR0aGlzLmNoaWxkcmVuLnNwbGljZSggaW5kZXgsIDEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldE9iamVjdEJ5SWQ6IGZ1bmN0aW9uICggaWQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ2lkJywgaWQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0T2JqZWN0QnlOYW1lOiBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ25hbWUnLCBuYW1lICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldE9iamVjdEJ5UHJvcGVydHk6IGZ1bmN0aW9uICggbmFtZSwgdmFsdWUgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzWyBuYW1lIF0gPT09IHZhbHVlICkgcmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlblsgaSBdO1xyXG5cdFx0XHR2YXIgb2JqZWN0ID0gY2hpbGQuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKTtcclxuXHJcblx0XHRcdGlmICggb2JqZWN0ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBvYmplY3Q7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldFdvcmxkUG9zaXRpb246IGZ1bmN0aW9uICggdGFyZ2V0ICkge1xyXG5cclxuXHRcdGlmICggdGFyZ2V0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdDT09MLk9iamVjdDNEOiAuZ2V0V29ybGRQb3NpdGlvbigpIHRhcmdldCBpcyBub3cgcmVxdWlyZWQnICk7XHJcblx0XHRcdHRhcmdldCA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcclxuXHJcblx0XHRyZXR1cm4gdGFyZ2V0LnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRXb3JsZFF1YXRlcm5pb246IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgcG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0dmFyIHNjYWxlID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0V29ybGRRdWF0ZXJuaW9uKCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRhcmdldCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdDT09MLk9iamVjdDNEOiAuZ2V0V29ybGRRdWF0ZXJuaW9uKCkgdGFyZ2V0IGlzIG5vdyByZXF1aXJlZCcgKTtcclxuXHRcdFx0XHR0YXJnZXQgPSBuZXcgUXVhdGVybmlvbigpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xyXG5cclxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHBvc2l0aW9uLCB0YXJnZXQsIHNjYWxlICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGFyZ2V0O1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Z2V0V29ybGRTY2FsZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBwb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHR2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGdldFdvcmxkU2NhbGUoIHRhcmdldCApIHtcclxuXHJcblx0XHRcdGlmICggdGFyZ2V0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ0NPT0wuT2JqZWN0M0Q6IC5nZXRXb3JsZFNjYWxlKCkgdGFyZ2V0IGlzIG5vdyByZXF1aXJlZCcgKTtcclxuXHRcdFx0XHR0YXJnZXQgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xyXG5cclxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCB0YXJnZXQgKTtcclxuXHJcblx0XHRcdHJldHVybiB0YXJnZXQ7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRnZXRXb3JsZERpcmVjdGlvbjogZnVuY3Rpb24gKCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0aWYgKCB0YXJnZXQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ0NPT0wuT2JqZWN0M0Q6IC5nZXRXb3JsZERpcmVjdGlvbigpIHRhcmdldCBpcyBub3cgcmVxdWlyZWQnICk7XHJcblx0XHRcdHRhcmdldCA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcclxuXHJcblx0XHR2YXIgZSA9IHRoaXMubWF0cml4V29ybGQuZWxlbWVudHM7XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldC5zZXQoIGVbIDggXSwgZVsgOSBdLCBlWyAxMCBdICkubm9ybWFsaXplKCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJheWNhc3Q6IGZ1bmN0aW9uICgpIHt9LFxyXG5cclxuXHR0cmF2ZXJzZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcclxuXHJcblx0XHRjYWxsYmFjayggdGhpcyApO1xyXG5cclxuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGNoaWxkcmVuWyBpIF0udHJhdmVyc2UoIGNhbGxiYWNrICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHR0cmF2ZXJzZVZpc2libGU6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuXHRcdGNhbGxiYWNrKCB0aGlzICk7XHJcblxyXG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y2hpbGRyZW5bIGkgXS50cmF2ZXJzZVZpc2libGUoIGNhbGxiYWNrICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHR0cmF2ZXJzZUFuY2VzdG9yczogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcclxuXHJcblx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcblxyXG5cdFx0aWYgKCBwYXJlbnQgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRjYWxsYmFjayggcGFyZW50ICk7XHJcblxyXG5cdFx0XHRwYXJlbnQudHJhdmVyc2VBbmNlc3RvcnMoIGNhbGxiYWNrICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHR1cGRhdGVNYXRyaXg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLm1hdHJpeC5jb21wb3NlKCB0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIHRoaXMuc2NhbGUgKTtcclxuXHJcblx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHR1cGRhdGVNYXRyaXhXb3JsZDogZnVuY3Rpb24gKCBmb3JjZSApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMubWF0cml4QXV0b1VwZGF0ZSApIHRoaXMudXBkYXRlTWF0cml4KCk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgfHwgZm9yY2UgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMucGFyZW50ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHRoaXMubWF0cml4ICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXMoIHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLCB0aGlzLm1hdHJpeCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0XHRmb3JjZSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHVwZGF0ZSBjaGlsZHJlblxyXG5cclxuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGNoaWxkcmVuWyBpIF0udXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHR1cGRhdGVXb3JsZE1hdHJpeDogZnVuY3Rpb24gKCB1cGRhdGVQYXJlbnRzLCB1cGRhdGVDaGlsZHJlbiApIHtcclxuXHJcblx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcblxyXG5cdFx0aWYgKCB1cGRhdGVQYXJlbnRzID09PSB0cnVlICYmIHBhcmVudCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHBhcmVudC51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgKSB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xyXG5cclxuXHRcdGlmICggdGhpcy5wYXJlbnQgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHRoaXMubWF0cml4ICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyggdGhpcy5wYXJlbnQubWF0cml4V29ybGQsIHRoaXMubWF0cml4ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHVwZGF0ZSBjaGlsZHJlblxyXG5cclxuXHRcdGlmICggdXBkYXRlQ2hpbGRyZW4gPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Y2hpbGRyZW5bIGkgXS51cGRhdGVXb3JsZE1hdHJpeCggZmFsc2UsIHRydWUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xyXG5cclxuXHRcdC8vIG1ldGEgaXMgYSBzdHJpbmcgd2hlbiBjYWxsZWQgZnJvbSBKU09OLnN0cmluZ2lmeVxyXG5cdFx0dmFyIGlzUm9vdE9iamVjdCA9ICggbWV0YSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBtZXRhID09PSAnc3RyaW5nJyApO1xyXG5cclxuXHRcdHZhciBvdXRwdXQgPSB7fTtcclxuXHJcblx0XHQvLyBtZXRhIGlzIGEgaGFzaCB1c2VkIHRvIGNvbGxlY3QgZ2VvbWV0cmllcywgbWF0ZXJpYWxzLlxyXG5cdFx0Ly8gbm90IHByb3ZpZGluZyBpdCBpbXBsaWVzIHRoYXQgdGhpcyBpcyB0aGUgcm9vdCBvYmplY3RcclxuXHRcdC8vIGJlaW5nIHNlcmlhbGl6ZWQuXHJcblx0XHRpZiAoIGlzUm9vdE9iamVjdCApIHtcclxuXHJcblx0XHRcdC8vIGluaXRpYWxpemUgbWV0YSBvYmpcclxuXHRcdFx0bWV0YSA9IHtcclxuXHRcdFx0XHRnZW9tZXRyaWVzOiB7fSxcclxuXHRcdFx0XHRtYXRlcmlhbHM6IHt9LFxyXG5cdFx0XHRcdHRleHR1cmVzOiB7fSxcclxuXHRcdFx0XHRpbWFnZXM6IHt9LFxyXG5cdFx0XHRcdHNoYXBlczoge31cclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdG91dHB1dC5tZXRhZGF0YSA9IHtcclxuXHRcdFx0XHR2ZXJzaW9uOiA0LjUsXHJcblx0XHRcdFx0dHlwZTogJ09iamVjdCcsXHJcblx0XHRcdFx0Z2VuZXJhdG9yOiAnT2JqZWN0M0QudG9KU09OJ1xyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBzdGFuZGFyZCBPYmplY3QzRCBzZXJpYWxpemF0aW9uXHJcblxyXG5cdFx0dmFyIG9iamVjdCA9IHt9O1xyXG5cclxuXHRcdG9iamVjdC51dWlkID0gdGhpcy51dWlkO1xyXG5cdFx0b2JqZWN0LnR5cGUgPSB0aGlzLnR5cGU7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm5hbWUgIT09ICcnICkgb2JqZWN0Lm5hbWUgPSB0aGlzLm5hbWU7XHJcblx0XHRpZiAoIHRoaXMuY2FzdFNoYWRvdyA9PT0gdHJ1ZSApIG9iamVjdC5jYXN0U2hhZG93ID0gdHJ1ZTtcclxuXHRcdGlmICggdGhpcy5yZWNlaXZlU2hhZG93ID09PSB0cnVlICkgb2JqZWN0LnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xyXG5cdFx0aWYgKCB0aGlzLnZpc2libGUgPT09IGZhbHNlICkgb2JqZWN0LnZpc2libGUgPSBmYWxzZTtcclxuXHRcdGlmICggdGhpcy5mcnVzdHVtQ3VsbGVkID09PSBmYWxzZSApIG9iamVjdC5mcnVzdHVtQ3VsbGVkID0gZmFsc2U7XHJcblx0XHRpZiAoIHRoaXMucmVuZGVyT3JkZXIgIT09IDAgKSBvYmplY3QucmVuZGVyT3JkZXIgPSB0aGlzLnJlbmRlck9yZGVyO1xyXG5cdFx0aWYgKCBKU09OLnN0cmluZ2lmeSggdGhpcy51c2VyRGF0YSApICE9PSAne30nICkgb2JqZWN0LnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YTtcclxuXHJcblx0XHRvYmplY3QubGF5ZXJzID0gdGhpcy5sYXllcnMubWFzaztcclxuXHRcdG9iamVjdC5tYXRyaXggPSB0aGlzLm1hdHJpeC50b0FycmF5KCk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPT09IGZhbHNlICkgb2JqZWN0Lm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGZ1bmN0aW9uIHNlcmlhbGl6ZSggbGlicmFyeSwgZWxlbWVudCApIHtcclxuXHJcblx0XHRcdGlmICggbGlicmFyeVsgZWxlbWVudC51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0bGlicmFyeVsgZWxlbWVudC51dWlkIF0gPSBlbGVtZW50LnRvSlNPTiggbWV0YSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGVsZW1lbnQudXVpZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLmlzTWVzaCB8fCB0aGlzLmlzTGluZSB8fCB0aGlzLmlzUG9pbnRzICkge1xyXG5cclxuXHRcdFx0b2JqZWN0Lmdlb21ldHJ5ID0gc2VyaWFsaXplKCBtZXRhLmdlb21ldHJpZXMsIHRoaXMuZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRcdHZhciBwYXJhbWV0ZXJzID0gdGhpcy5nZW9tZXRyeS5wYXJhbWV0ZXJzO1xyXG5cclxuXHRcdFx0aWYgKCBwYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgJiYgcGFyYW1ldGVycy5zaGFwZXMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dmFyIHNoYXBlcyA9IHBhcmFtZXRlcnMuc2hhcGVzO1xyXG5cclxuXHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHNoYXBlcyApICkge1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIHNoYXBlID0gc2hhcGVzWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0XHRzZXJpYWxpemUoIG1ldGEuc2hhcGVzLCBzaGFwZSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRzZXJpYWxpemUoIG1ldGEuc2hhcGVzLCBzaGFwZXMgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMubWF0ZXJpYWwgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdGhpcy5tYXRlcmlhbCApICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdXVpZHMgPSBbXTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5tYXRlcmlhbC5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHV1aWRzLnB1c2goIHNlcmlhbGl6ZSggbWV0YS5tYXRlcmlhbHMsIHRoaXMubWF0ZXJpYWxbIGkgXSApICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0b2JqZWN0Lm1hdGVyaWFsID0gdXVpZHM7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRvYmplY3QubWF0ZXJpYWwgPSBzZXJpYWxpemUoIG1ldGEubWF0ZXJpYWxzLCB0aGlzLm1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0aWYgKCB0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRvYmplY3QuY2hpbGRyZW4gPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRvYmplY3QuY2hpbGRyZW4ucHVzaCggdGhpcy5jaGlsZHJlblsgaSBdLnRvSlNPTiggbWV0YSApLm9iamVjdCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGlzUm9vdE9iamVjdCApIHtcclxuXHJcblx0XHRcdHZhciBnZW9tZXRyaWVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5nZW9tZXRyaWVzICk7XHJcblx0XHRcdHZhciBtYXRlcmlhbHMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLm1hdGVyaWFscyApO1xyXG5cdFx0XHR2YXIgdGV4dHVyZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLnRleHR1cmVzICk7XHJcblx0XHRcdHZhciBpbWFnZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLmltYWdlcyApO1xyXG5cdFx0XHR2YXIgc2hhcGVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5zaGFwZXMgKTtcclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cmllcy5sZW5ndGggPiAwICkgb3V0cHV0Lmdlb21ldHJpZXMgPSBnZW9tZXRyaWVzO1xyXG5cdFx0XHRpZiAoIG1hdGVyaWFscy5sZW5ndGggPiAwICkgb3V0cHV0Lm1hdGVyaWFscyA9IG1hdGVyaWFscztcclxuXHRcdFx0aWYgKCB0ZXh0dXJlcy5sZW5ndGggPiAwICkgb3V0cHV0LnRleHR1cmVzID0gdGV4dHVyZXM7XHJcblx0XHRcdGlmICggaW1hZ2VzLmxlbmd0aCA+IDAgKSBvdXRwdXQuaW1hZ2VzID0gaW1hZ2VzO1xyXG5cdFx0XHRpZiAoIHNoYXBlcy5sZW5ndGggPiAwICkgb3V0cHV0LnNoYXBlcyA9IHNoYXBlcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0b3V0cHV0Lm9iamVjdCA9IG9iamVjdDtcclxuXHJcblx0XHRyZXR1cm4gb3V0cHV0O1xyXG5cclxuXHRcdC8vIGV4dHJhY3QgZGF0YSBmcm9tIHRoZSBjYWNoZSBoYXNoXHJcblx0XHQvLyByZW1vdmUgbWV0YWRhdGEgb24gZWFjaCBpdGVtXHJcblx0XHQvLyBhbmQgcmV0dXJuIGFzIGFycmF5XHJcblx0XHRmdW5jdGlvbiBleHRyYWN0RnJvbUNhY2hlKCBjYWNoZSApIHtcclxuXHJcblx0XHRcdHZhciB2YWx1ZXMgPSBbXTtcclxuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBjYWNoZSApIHtcclxuXHJcblx0XHRcdFx0dmFyIGRhdGEgPSBjYWNoZVsga2V5IF07XHJcblx0XHRcdFx0ZGVsZXRlIGRhdGEubWV0YWRhdGE7XHJcblx0XHRcdFx0dmFsdWVzLnB1c2goIGRhdGEgKTtcclxuXHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHZhbHVlcztcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoIHJlY3Vyc2l2ZSApIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzLCByZWN1cnNpdmUgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcclxuXHJcblx0XHRpZiAoIHJlY3Vyc2l2ZSA9PT0gdW5kZWZpbmVkICkgcmVjdXJzaXZlID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcclxuXHJcblx0XHR0aGlzLnVwLmNvcHkoIHNvdXJjZS51cCApO1xyXG5cclxuXHRcdHRoaXMucG9zaXRpb24uY29weSggc291cmNlLnBvc2l0aW9uICk7XHJcblx0XHR0aGlzLnF1YXRlcm5pb24uY29weSggc291cmNlLnF1YXRlcm5pb24gKTtcclxuXHRcdHRoaXMuc2NhbGUuY29weSggc291cmNlLnNjYWxlICk7XHJcblxyXG5cdFx0dGhpcy5tYXRyaXguY29weSggc291cmNlLm1hdHJpeCApO1xyXG5cdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCBzb3VyY2UubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBzb3VyY2UubWF0cml4QXV0b1VwZGF0ZTtcclxuXHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlO1xyXG5cclxuXHRcdHRoaXMubGF5ZXJzLm1hc2sgPSBzb3VyY2UubGF5ZXJzLm1hc2s7XHJcblx0XHR0aGlzLnZpc2libGUgPSBzb3VyY2UudmlzaWJsZTtcclxuXHJcblx0XHR0aGlzLmNhc3RTaGFkb3cgPSBzb3VyY2UuY2FzdFNoYWRvdztcclxuXHRcdHRoaXMucmVjZWl2ZVNoYWRvdyA9IHNvdXJjZS5yZWNlaXZlU2hhZG93O1xyXG5cclxuXHRcdHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHNvdXJjZS5mcnVzdHVtQ3VsbGVkO1xyXG5cdFx0dGhpcy5yZW5kZXJPcmRlciA9IHNvdXJjZS5yZW5kZXJPcmRlcjtcclxuXHJcblx0XHR0aGlzLnVzZXJEYXRhID0gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIHNvdXJjZS51c2VyRGF0YSApICk7XHJcblxyXG5cdFx0aWYgKCByZWN1cnNpdmUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBzb3VyY2UuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgY2hpbGQgPSBzb3VyY2UuY2hpbGRyZW5bIGkgXTtcclxuXHRcdFx0XHR0aGlzLmFkZCggY2hpbGQuY2xvbmUoKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxufSApO1xyXG5cclxuXHJcbmV4cG9ydCB7IE9iamVjdDNEIH07XHJcbiIsImltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJy4vRXZlbnREaXNwYXRjaGVyLmpzJztcclxuaW1wb3J0IHsgRmFjZTMgfSBmcm9tICcuL0ZhY2UzLmpzJztcclxuaW1wb3J0IHsgTWF0cml4MyB9IGZyb20gJy4uL21hdGgvTWF0cml4My5qcyc7XHJcbmltcG9ydCB7IFNwaGVyZSB9IGZyb20gJy4uL21hdGgvU3BoZXJlLmpzJztcclxuaW1wb3J0IHsgQm94MyB9IGZyb20gJy4uL21hdGgvQm94My5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5pbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi4vbWF0aC9NYXRyaXg0LmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uL21hdGgvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vbWF0aC9Db2xvci5qcyc7XHJcbmltcG9ydCB7IE9iamVjdDNEIH0gZnJvbSAnLi9PYmplY3QzRC5qcyc7XHJcbmltcG9ydCB7IF9NYXRoIH0gZnJvbSAnLi4vbWF0aC9NYXRoLmpzJztcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGtpbGUgLyBodHRwOi8va2lsZS5zdHJhdmFnYW56YS5vcmcvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG4gKi9cclxuXHJcbnZhciBnZW9tZXRyeUlkID0gMDsgLy8gR2VvbWV0cnkgdXNlcyBldmVuIG51bWJlcnMgYXMgSWRcclxuXHJcbmZ1bmN0aW9uIEdlb21ldHJ5KCkge1xyXG5cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IGdlb21ldHJ5SWQgKz0gMiB9ICk7XHJcblxyXG5cdHRoaXMudXVpZCA9IF9NYXRoLmdlbmVyYXRlVVVJRCgpO1xyXG5cclxuXHR0aGlzLm5hbWUgPSAnJztcclxuXHR0aGlzLnR5cGUgPSAnR2VvbWV0cnknO1xyXG5cclxuXHR0aGlzLnZlcnRpY2VzID0gW107XHJcblx0dGhpcy5jb2xvcnMgPSBbXTtcclxuXHR0aGlzLmZhY2VzID0gW107XHJcblx0dGhpcy5mYWNlVmVydGV4VXZzID0gW1tdXTtcclxuXHJcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBbXTtcclxuXHR0aGlzLm1vcnBoTm9ybWFscyA9IFtdO1xyXG5cclxuXHR0aGlzLnNraW5XZWlnaHRzID0gW107XHJcblx0dGhpcy5za2luSW5kaWNlcyA9IFtdO1xyXG5cclxuXHR0aGlzLmxpbmVEaXN0YW5jZXMgPSBbXTtcclxuXHJcblx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XHJcblx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XHJcblxyXG5cdC8vIHVwZGF0ZSBmbGFnc1xyXG5cclxuXHR0aGlzLmVsZW1lbnRzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0dGhpcy51dnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMubGluZURpc3RhbmNlc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHR0aGlzLmdyb3Vwc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcbn1cclxuXHJcbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgKSwge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogR2VvbWV0cnksXHJcblxyXG5cdGlzR2VvbWV0cnk6IHRydWUsXHJcblxyXG5cdGFwcGx5TWF0cml4OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcclxuXHJcblx0XHR2YXIgbm9ybWFsTWF0cml4ID0gbmV3IE1hdHJpeDMoKS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHZlcnRleCA9IHRoaXMudmVydGljZXNbIGkgXTtcclxuXHRcdFx0dmVydGV4LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGZhY2UgPSB0aGlzLmZhY2VzWyBpIF07XHJcblx0XHRcdGZhY2Uubm9ybWFsLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlLnZlcnRleE5vcm1hbHNbIGogXS5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblx0XHR0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0cm90YXRlWDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeC1heGlzXHJcblxyXG5cdFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWCggYW5nbGUgKSB7XHJcblxyXG5cdFx0XHRtMS5tYWtlUm90YXRpb25YKCBhbmdsZSApO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0cm90YXRlWTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeS1heGlzXHJcblxyXG5cdFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWSggYW5nbGUgKSB7XHJcblxyXG5cdFx0XHRtMS5tYWtlUm90YXRpb25ZKCBhbmdsZSApO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0cm90YXRlWjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgei1heGlzXHJcblxyXG5cdFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWiggYW5nbGUgKSB7XHJcblxyXG5cdFx0XHRtMS5tYWtlUm90YXRpb25aKCBhbmdsZSApO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gdHJhbnNsYXRlIGdlb21ldHJ5XHJcblxyXG5cdFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gdHJhbnNsYXRlKCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdFx0bTEubWFrZVRyYW5zbGF0aW9uKCB4LCB5LCB6ICk7XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRzY2FsZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHNjYWxlIGdlb21ldHJ5XHJcblxyXG5cdFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gc2NhbGUoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0XHRtMS5tYWtlU2NhbGUoIHgsIHksIHogKTtcclxuXHJcblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGxvb2tBdDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBvYmogPSBuZXcgT2JqZWN0M0QoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gbG9va0F0KCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0XHRvYmoubG9va0F0KCB2ZWN0b3IgKTtcclxuXHJcblx0XHRcdG9iai51cGRhdGVNYXRyaXgoKTtcclxuXHJcblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG9iai5tYXRyaXggKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGZyb21CdWZmZXJHZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdHZhciBpbmRpY2VzID0gZ2VvbWV0cnkuaW5kZXggIT09IG51bGwgPyBnZW9tZXRyeS5pbmRleC5hcnJheSA6IHVuZGVmaW5lZDtcclxuXHRcdHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcclxuXHJcblx0XHR2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcclxuXHRcdHZhciBub3JtYWxzID0gYXR0cmlidXRlcy5ub3JtYWwgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5IDogdW5kZWZpbmVkO1xyXG5cdFx0dmFyIGNvbG9ycyA9IGF0dHJpYnV0ZXMuY29sb3IgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMuY29sb3IuYXJyYXkgOiB1bmRlZmluZWQ7XHJcblx0XHR2YXIgdXZzID0gYXR0cmlidXRlcy51diAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy51di5hcnJheSA6IHVuZGVmaW5lZDtcclxuXHRcdHZhciB1dnMyID0gYXR0cmlidXRlcy51djIgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMudXYyLmFycmF5IDogdW5kZWZpbmVkO1xyXG5cclxuXHRcdGlmICggdXZzMiAhPT0gdW5kZWZpbmVkICkgdGhpcy5mYWNlVmVydGV4VXZzWyAxIF0gPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGogPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSArPSAzLCBqICs9IDIgKSB7XHJcblxyXG5cdFx0XHRzY29wZS52ZXJ0aWNlcy5wdXNoKCBuZXcgVmVjdG9yMygpLmZyb21BcnJheSggcG9zaXRpb25zLCBpICkgKTtcclxuXHJcblx0XHRcdGlmICggY29sb3JzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHNjb3BlLmNvbG9ycy5wdXNoKCBuZXcgQ29sb3IoKS5mcm9tQXJyYXkoIGNvbG9ycywgaSApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGFkZEZhY2UoIGEsIGIsIGMsIG1hdGVyaWFsSW5kZXggKSB7XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4Q29sb3JzID0gKCBjb2xvcnMgPT09IHVuZGVmaW5lZCApID8gW10gOiBbXHJcblx0XHRcdFx0c2NvcGUuY29sb3JzWyBhIF0uY2xvbmUoKSxcclxuXHRcdFx0XHRzY29wZS5jb2xvcnNbIGIgXS5jbG9uZSgpLFxyXG5cdFx0XHRcdHNjb3BlLmNvbG9yc1sgYyBdLmNsb25lKCkgXTtcclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXhOb3JtYWxzID0gKCBub3JtYWxzID09PSB1bmRlZmluZWQgKSA/IFtdIDogW1xyXG5cdFx0XHRcdG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KCBub3JtYWxzLCBhICogMyApLFxyXG5cdFx0XHRcdG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KCBub3JtYWxzLCBiICogMyApLFxyXG5cdFx0XHRcdG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KCBub3JtYWxzLCBjICogMyApXHJcblx0XHRcdF07XHJcblxyXG5cdFx0XHR2YXIgZmFjZSA9IG5ldyBGYWNlMyggYSwgYiwgYywgdmVydGV4Tm9ybWFscywgdmVydGV4Q29sb3JzLCBtYXRlcmlhbEluZGV4ICk7XHJcblxyXG5cdFx0XHRzY29wZS5mYWNlcy5wdXNoKCBmYWNlICk7XHJcblxyXG5cdFx0XHRpZiAoIHV2cyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggW1xyXG5cdFx0XHRcdFx0bmV3IFZlY3RvcjIoKS5mcm9tQXJyYXkoIHV2cywgYSAqIDIgKSxcclxuXHRcdFx0XHRcdG5ldyBWZWN0b3IyKCkuZnJvbUFycmF5KCB1dnMsIGIgKiAyICksXHJcblx0XHRcdFx0XHRuZXcgVmVjdG9yMigpLmZyb21BcnJheSggdXZzLCBjICogMiApXHJcblx0XHRcdFx0XSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB1dnMyICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDEgXS5wdXNoKCBbXHJcblx0XHRcdFx0XHRuZXcgVmVjdG9yMigpLmZyb21BcnJheSggdXZzMiwgYSAqIDIgKSxcclxuXHRcdFx0XHRcdG5ldyBWZWN0b3IyKCkuZnJvbUFycmF5KCB1dnMyLCBiICogMiApLFxyXG5cdFx0XHRcdFx0bmV3IFZlY3RvcjIoKS5mcm9tQXJyYXkoIHV2czIsIGMgKiAyIClcclxuXHRcdFx0XHRdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XHJcblxyXG5cdFx0aWYgKCBncm91cHMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xyXG5cclxuXHRcdFx0XHR2YXIgc3RhcnQgPSBncm91cC5zdGFydDtcclxuXHRcdFx0XHR2YXIgY291bnQgPSBncm91cC5jb3VudDtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGogPSBzdGFydCwgamwgPSBzdGFydCArIGNvdW50OyBqIDwgamw7IGogKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGluZGljZXMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGFkZEZhY2UoIGluZGljZXNbIGogXSwgaW5kaWNlc1sgaiArIDEgXSwgaW5kaWNlc1sgaiArIDIgXSwgZ3JvdXAubWF0ZXJpYWxJbmRleCApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRhZGRGYWNlKCBqLCBqICsgMSwgaiArIDIsIGdyb3VwLm1hdGVyaWFsSW5kZXggKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0aWYgKCBpbmRpY2VzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0YWRkRmFjZSggaW5kaWNlc1sgaSBdLCBpbmRpY2VzWyBpICsgMSBdLCBpbmRpY2VzWyBpICsgMiBdICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGggLyAzOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0YWRkRmFjZSggaSwgaSArIDEsIGkgKyAyICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94LmNsb25lKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNlbnRlcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBvZmZzZXQgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiBjZW50ZXIoKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xyXG5cclxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveC5nZXRDZW50ZXIoIG9mZnNldCApLm5lZ2F0ZSgpO1xyXG5cclxuXHRcdFx0dGhpcy50cmFuc2xhdGUoIG9mZnNldC54LCBvZmZzZXQueSwgb2Zmc2V0LnogKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcclxuXHJcblx0XHR2YXIgY2VudGVyID0gdGhpcy5ib3VuZGluZ1NwaGVyZS5jZW50ZXI7XHJcblx0XHR2YXIgcmFkaXVzID0gdGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXM7XHJcblxyXG5cdFx0dmFyIHMgPSByYWRpdXMgPT09IDAgPyAxIDogMS4wIC8gcmFkaXVzO1xyXG5cclxuXHRcdHZhciBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xyXG5cdFx0bWF0cml4LnNldChcclxuXHRcdFx0cywgMCwgMCwgLSBzICogY2VudGVyLngsXHJcblx0XHRcdDAsIHMsIDAsIC0gcyAqIGNlbnRlci55LFxyXG5cdFx0XHQwLCAwLCBzLCAtIHMgKiBjZW50ZXIueixcclxuXHRcdFx0MCwgMCwgMCwgMVxyXG5cdFx0KTtcclxuXHJcblx0XHR0aGlzLmFwcGx5TWF0cml4KCBtYXRyaXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29tcHV0ZUZhY2VOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGNiID0gbmV3IFZlY3RvcjMoKSwgYWIgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdGZvciAoIHZhciBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XHJcblxyXG5cdFx0XHR2YXIgdkEgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmEgXTtcclxuXHRcdFx0dmFyIHZCID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5iIF07XHJcblx0XHRcdHZhciB2QyA9IHRoaXMudmVydGljZXNbIGZhY2UuYyBdO1xyXG5cclxuXHRcdFx0Y2Iuc3ViVmVjdG9ycyggdkMsIHZCICk7XHJcblx0XHRcdGFiLnN1YlZlY3RvcnMoIHZBLCB2QiApO1xyXG5cdFx0XHRjYi5jcm9zcyggYWIgKTtcclxuXHJcblx0XHRcdGNiLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0ZmFjZS5ub3JtYWwuY29weSggY2IgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbXB1dGVWZXJ0ZXhOb3JtYWxzOiBmdW5jdGlvbiAoIGFyZWFXZWlnaHRlZCApIHtcclxuXHJcblx0XHRpZiAoIGFyZWFXZWlnaHRlZCA9PT0gdW5kZWZpbmVkICkgYXJlYVdlaWdodGVkID0gdHJ1ZTtcclxuXHJcblx0XHR2YXIgdiwgdmwsIGYsIGZsLCBmYWNlLCB2ZXJ0aWNlcztcclxuXHJcblx0XHR2ZXJ0aWNlcyA9IG5ldyBBcnJheSggdGhpcy52ZXJ0aWNlcy5sZW5ndGggKTtcclxuXHJcblx0XHRmb3IgKCB2ID0gMCwgdmwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2ICsrICkge1xyXG5cclxuXHRcdFx0dmVydGljZXNbIHYgXSA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggYXJlYVdlaWdodGVkICkge1xyXG5cclxuXHRcdFx0Ly8gdmVydGV4IG5vcm1hbHMgd2VpZ2h0ZWQgYnkgdHJpYW5nbGUgYXJlYXNcclxuXHRcdFx0Ly8gaHR0cDovL3d3dy5pcXVpbGV6bGVzLm9yZy93d3cvYXJ0aWNsZXMvbm9ybWFscy9ub3JtYWxzLmh0bVxyXG5cclxuXHRcdFx0dmFyIHZBLCB2QiwgdkM7XHJcblx0XHRcdHZhciBjYiA9IG5ldyBWZWN0b3IzKCksIGFiID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XHJcblxyXG5cdFx0XHRcdHZBID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5hIF07XHJcblx0XHRcdFx0dkIgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmIgXTtcclxuXHRcdFx0XHR2QyA9IHRoaXMudmVydGljZXNbIGZhY2UuYyBdO1xyXG5cclxuXHRcdFx0XHRjYi5zdWJWZWN0b3JzKCB2QywgdkIgKTtcclxuXHRcdFx0XHRhYi5zdWJWZWN0b3JzKCB2QSwgdkIgKTtcclxuXHRcdFx0XHRjYi5jcm9zcyggYWIgKTtcclxuXHJcblx0XHRcdFx0dmVydGljZXNbIGZhY2UuYSBdLmFkZCggY2IgKTtcclxuXHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5iIF0uYWRkKCBjYiApO1xyXG5cdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmMgXS5hZGQoIGNiICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblxyXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cclxuXHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5hIF0uYWRkKCBmYWNlLm5vcm1hbCApO1xyXG5cdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmIgXS5hZGQoIGZhY2Uubm9ybWFsICk7XHJcblx0XHRcdFx0dmVydGljZXNbIGZhY2UuYyBdLmFkZCggZmFjZS5ub3JtYWwgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggdiA9IDAsIHZsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArKyApIHtcclxuXHJcblx0XHRcdHZlcnRpY2VzWyB2IF0ubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cclxuXHRcdFx0dmFyIHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XHJcblxyXG5cdFx0XHRpZiAoIHZlcnRleE5vcm1hbHMubGVuZ3RoID09PSAzICkge1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAwIF0uY29weSggdmVydGljZXNbIGZhY2UuYSBdICk7XHJcblx0XHRcdFx0dmVydGV4Tm9ybWFsc1sgMSBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmIgXSApO1xyXG5cdFx0XHRcdHZlcnRleE5vcm1hbHNbIDIgXS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5jIF0gKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHZlcnRleE5vcm1hbHNbIDAgXSA9IHZlcnRpY2VzWyBmYWNlLmEgXS5jbG9uZSgpO1xyXG5cdFx0XHRcdHZlcnRleE5vcm1hbHNbIDEgXSA9IHZlcnRpY2VzWyBmYWNlLmIgXS5jbG9uZSgpO1xyXG5cdFx0XHRcdHZlcnRleE5vcm1hbHNbIDIgXSA9IHZlcnRpY2VzWyBmYWNlLmMgXS5jbG9uZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuZmFjZXMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Y29tcHV0ZUZsYXRWZXJ0ZXhOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGYsIGZsLCBmYWNlO1xyXG5cclxuXHRcdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblxyXG5cdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcclxuXHJcblx0XHRcdGlmICggdmVydGV4Tm9ybWFscy5sZW5ndGggPT09IDMgKSB7XHJcblxyXG5cdFx0XHRcdHZlcnRleE5vcm1hbHNbIDAgXS5jb3B5KCBmYWNlLm5vcm1hbCApO1xyXG5cdFx0XHRcdHZlcnRleE5vcm1hbHNbIDEgXS5jb3B5KCBmYWNlLm5vcm1hbCApO1xyXG5cdFx0XHRcdHZlcnRleE5vcm1hbHNbIDIgXS5jb3B5KCBmYWNlLm5vcm1hbCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dmVydGV4Tm9ybWFsc1sgMCBdID0gZmFjZS5ub3JtYWwuY2xvbmUoKTtcclxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAxIF0gPSBmYWNlLm5vcm1hbC5jbG9uZSgpO1xyXG5cdFx0XHRcdHZlcnRleE5vcm1hbHNbIDIgXSA9IGZhY2Uubm9ybWFsLmNsb25lKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5mYWNlcy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wdXRlTW9ycGhOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGksIGlsLCBmLCBmbCwgZmFjZTtcclxuXHJcblx0XHQvLyBzYXZlIG9yaWdpbmFsIG5vcm1hbHNcclxuXHRcdC8vIC0gY3JlYXRlIHRlbXAgdmFyaWFibGVzIG9uIGZpcnN0IGFjY2Vzc1xyXG5cdFx0Ly8gICBvdGhlcndpc2UganVzdCBjb3B5IChmb3IgZmFzdGVyIHJlcGVhdGVkIGNhbGxzKVxyXG5cclxuXHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cclxuXHRcdFx0aWYgKCAhIGZhY2UuX19vcmlnaW5hbEZhY2VOb3JtYWwgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UuX19vcmlnaW5hbEZhY2VOb3JtYWwgPSBmYWNlLm5vcm1hbC5jbG9uZSgpO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0ZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbC5jb3B5KCBmYWNlLm5vcm1hbCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCAhIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHMgKSBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggISBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzWyBpIF0gKSB7XHJcblxyXG5cdFx0XHRcdFx0ZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFsc1sgaSBdID0gZmFjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0uY2xvbmUoKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzWyBpIF0uY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyB1c2UgdGVtcCBnZW9tZXRyeSB0byBjb21wdXRlIGZhY2UgYW5kIHZlcnRleCBub3JtYWxzIGZvciBlYWNoIG1vcnBoXHJcblxyXG5cdFx0dmFyIHRtcEdlbyA9IG5ldyBHZW9tZXRyeSgpO1xyXG5cdFx0dG1wR2VvLmZhY2VzID0gdGhpcy5mYWNlcztcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdC8vIGNyZWF0ZSBvbiBmaXJzdCBhY2Nlc3NcclxuXHJcblx0XHRcdGlmICggISB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLm1vcnBoTm9ybWFsc1sgaSBdID0ge307XHJcblx0XHRcdFx0dGhpcy5tb3JwaE5vcm1hbHNbIGkgXS5mYWNlTm9ybWFscyA9IFtdO1xyXG5cdFx0XHRcdHRoaXMubW9ycGhOb3JtYWxzWyBpIF0udmVydGV4Tm9ybWFscyA9IFtdO1xyXG5cclxuXHRcdFx0XHR2YXIgZHN0Tm9ybWFsc0ZhY2UgPSB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLmZhY2VOb3JtYWxzO1xyXG5cdFx0XHRcdHZhciBkc3ROb3JtYWxzVmVydGV4ID0gdGhpcy5tb3JwaE5vcm1hbHNbIGkgXS52ZXJ0ZXhOb3JtYWxzO1xyXG5cclxuXHRcdFx0XHR2YXIgZmFjZU5vcm1hbCwgdmVydGV4Tm9ybWFscztcclxuXHJcblx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRmYWNlTm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdFx0XHRcdHZlcnRleE5vcm1hbHMgPSB7IGE6IG5ldyBWZWN0b3IzKCksIGI6IG5ldyBWZWN0b3IzKCksIGM6IG5ldyBWZWN0b3IzKCkgfTtcclxuXHJcblx0XHRcdFx0XHRkc3ROb3JtYWxzRmFjZS5wdXNoKCBmYWNlTm9ybWFsICk7XHJcblx0XHRcdFx0XHRkc3ROb3JtYWxzVmVydGV4LnB1c2goIHZlcnRleE5vcm1hbHMgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIG1vcnBoTm9ybWFscyA9IHRoaXMubW9ycGhOb3JtYWxzWyBpIF07XHJcblxyXG5cdFx0XHQvLyBzZXQgdmVydGljZXMgdG8gbW9ycGggdGFyZ2V0XHJcblxyXG5cdFx0XHR0bXBHZW8udmVydGljZXMgPSB0aGlzLm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzO1xyXG5cclxuXHRcdFx0Ly8gY29tcHV0ZSBtb3JwaCBub3JtYWxzXHJcblxyXG5cdFx0XHR0bXBHZW8uY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblx0XHRcdHRtcEdlby5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xyXG5cclxuXHRcdFx0Ly8gc3RvcmUgbW9ycGggbm9ybWFsc1xyXG5cclxuXHRcdFx0dmFyIGZhY2VOb3JtYWwsIHZlcnRleE5vcm1hbHM7XHJcblxyXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cclxuXHRcdFx0XHRmYWNlTm9ybWFsID0gbW9ycGhOb3JtYWxzLmZhY2VOb3JtYWxzWyBmIF07XHJcblx0XHRcdFx0dmVydGV4Tm9ybWFscyA9IG1vcnBoTm9ybWFscy52ZXJ0ZXhOb3JtYWxzWyBmIF07XHJcblxyXG5cdFx0XHRcdGZhY2VOb3JtYWwuY29weSggZmFjZS5ub3JtYWwgKTtcclxuXHJcblx0XHRcdFx0dmVydGV4Tm9ybWFscy5hLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgMCBdICk7XHJcblx0XHRcdFx0dmVydGV4Tm9ybWFscy5iLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgMSBdICk7XHJcblx0XHRcdFx0dmVydGV4Tm9ybWFscy5jLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgMiBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHJlc3RvcmUgb3JpZ2luYWwgbm9ybWFsc1xyXG5cclxuXHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cclxuXHRcdFx0ZmFjZS5ub3JtYWwgPSBmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsO1xyXG5cdFx0XHRmYWNlLnZlcnRleE5vcm1hbHMgPSBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Y29tcHV0ZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IG5ldyBCb3gzKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYm91bmRpbmdCb3guc2V0RnJvbVBvaW50cyggdGhpcy52ZXJ0aWNlcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wdXRlQm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlLnNldEZyb21Qb2ludHMoIHRoaXMudmVydGljZXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bWVyZ2U6IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdHJpeCwgbWF0ZXJpYWxJbmRleE9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoICEgKCBnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0dlb21ldHJ5ICkgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnQ09PTC5HZW9tZXRyeS5tZXJnZSgpOiBnZW9tZXRyeSBub3QgYW4gaW5zdGFuY2Ugb2YgQ09PTC5HZW9tZXRyeS4nLCBnZW9tZXRyeSApO1xyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBub3JtYWxNYXRyaXgsXHJcblx0XHRcdHZlcnRleE9mZnNldCA9IHRoaXMudmVydGljZXMubGVuZ3RoLFxyXG5cdFx0XHR2ZXJ0aWNlczEgPSB0aGlzLnZlcnRpY2VzLFxyXG5cdFx0XHR2ZXJ0aWNlczIgPSBnZW9tZXRyeS52ZXJ0aWNlcyxcclxuXHRcdFx0ZmFjZXMxID0gdGhpcy5mYWNlcyxcclxuXHRcdFx0ZmFjZXMyID0gZ2VvbWV0cnkuZmFjZXMsXHJcblx0XHRcdHV2czEgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXSxcclxuXHRcdFx0dXZzMiA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIDAgXSxcclxuXHRcdFx0Y29sb3JzMSA9IHRoaXMuY29sb3JzLFxyXG5cdFx0XHRjb2xvcnMyID0gZ2VvbWV0cnkuY29sb3JzO1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWxJbmRleE9mZnNldCA9PT0gdW5kZWZpbmVkICkgbWF0ZXJpYWxJbmRleE9mZnNldCA9IDA7XHJcblxyXG5cdFx0aWYgKCBtYXRyaXggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdG5vcm1hbE1hdHJpeCA9IG5ldyBNYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdmVydGljZXNcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmVydGljZXMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHZlcnRleCA9IHZlcnRpY2VzMlsgaSBdO1xyXG5cclxuXHRcdFx0dmFyIHZlcnRleENvcHkgPSB2ZXJ0ZXguY2xvbmUoKTtcclxuXHJcblx0XHRcdGlmICggbWF0cml4ICE9PSB1bmRlZmluZWQgKSB2ZXJ0ZXhDb3B5LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XHJcblxyXG5cdFx0XHR2ZXJ0aWNlczEucHVzaCggdmVydGV4Q29weSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBjb2xvcnNcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gY29sb3JzMi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGNvbG9yczEucHVzaCggY29sb3JzMlsgaSBdLmNsb25lKCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZmFjZXNcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSBmYWNlczIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgZmFjZSA9IGZhY2VzMlsgaSBdLCBmYWNlQ29weSwgbm9ybWFsLCBjb2xvcixcclxuXHRcdFx0XHRmYWNlVmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscyxcclxuXHRcdFx0XHRmYWNlVmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XHJcblxyXG5cdFx0XHRmYWNlQ29weSA9IG5ldyBGYWNlMyggZmFjZS5hICsgdmVydGV4T2Zmc2V0LCBmYWNlLmIgKyB2ZXJ0ZXhPZmZzZXQsIGZhY2UuYyArIHZlcnRleE9mZnNldCApO1xyXG5cdFx0XHRmYWNlQ29weS5ub3JtYWwuY29weSggZmFjZS5ub3JtYWwgKTtcclxuXHJcblx0XHRcdGlmICggbm9ybWFsTWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2VDb3B5Lm5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2VWZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRub3JtYWwgPSBmYWNlVmVydGV4Tm9ybWFsc1sgaiBdLmNsb25lKCk7XHJcblxyXG5cdFx0XHRcdGlmICggbm9ybWFsTWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0bm9ybWFsLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0ZmFjZUNvcHkudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZhY2VDb3B5LmNvbG9yLmNvcHkoIGZhY2UuY29sb3IgKTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlVmVydGV4Q29sb3JzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRjb2xvciA9IGZhY2VWZXJ0ZXhDb2xvcnNbIGogXTtcclxuXHRcdFx0XHRmYWNlQ29weS52ZXJ0ZXhDb2xvcnMucHVzaCggY29sb3IuY2xvbmUoKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZmFjZUNvcHkubWF0ZXJpYWxJbmRleCA9IGZhY2UubWF0ZXJpYWxJbmRleCArIG1hdGVyaWFsSW5kZXhPZmZzZXQ7XHJcblxyXG5cdFx0XHRmYWNlczEucHVzaCggZmFjZUNvcHkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdXZzXHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gdXZzMi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciB1diA9IHV2czJbIGkgXSwgdXZDb3B5ID0gW107XHJcblxyXG5cdFx0XHRpZiAoIHV2ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IHV2Lmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHR1dkNvcHkucHVzaCggdXZbIGogXS5jbG9uZSgpICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR1dnMxLnB1c2goIHV2Q29weSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0bWVyZ2VNZXNoOiBmdW5jdGlvbiAoIG1lc2ggKSB7XHJcblxyXG5cdFx0aWYgKCAhICggbWVzaCAmJiBtZXNoLmlzTWVzaCApICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ0NPT0wuR2VvbWV0cnkubWVyZ2VNZXNoKCk6IG1lc2ggbm90IGFuIGluc3RhbmNlIG9mIENPT0wuTWVzaC4nLCBtZXNoICk7XHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtZXNoLm1hdHJpeEF1dG9VcGRhdGUgKSBtZXNoLnVwZGF0ZU1hdHJpeCgpO1xyXG5cclxuXHRcdHRoaXMubWVyZ2UoIG1lc2guZ2VvbWV0cnksIG1lc2gubWF0cml4ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8qXHJcblx0ICogQ2hlY2tzIGZvciBkdXBsaWNhdGUgdmVydGljZXMgd2l0aCBoYXNobWFwLlxyXG5cdCAqIER1cGxpY2F0ZWQgdmVydGljZXMgYXJlIHJlbW92ZWRcclxuXHQgKiBhbmQgZmFjZXMnIHZlcnRpY2VzIGFyZSB1cGRhdGVkLlxyXG5cdCAqL1xyXG5cclxuXHRtZXJnZVZlcnRpY2VzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHZlcnRpY2VzTWFwID0ge307IC8vIEhhc2htYXAgZm9yIGxvb2tpbmcgdXAgdmVydGljZXMgYnkgcG9zaXRpb24gY29vcmRpbmF0ZXMgKGFuZCBtYWtpbmcgc3VyZSB0aGV5IGFyZSB1bmlxdWUpXHJcblx0XHR2YXIgdW5pcXVlID0gW10sIGNoYW5nZXMgPSBbXTtcclxuXHJcblx0XHR2YXIgdiwga2V5O1xyXG5cdFx0dmFyIHByZWNpc2lvblBvaW50cyA9IDQ7IC8vIG51bWJlciBvZiBkZWNpbWFsIHBvaW50cywgZS5nLiA0IGZvciBlcHNpbG9uIG9mIDAuMDAwMVxyXG5cdFx0dmFyIHByZWNpc2lvbiA9IE1hdGgucG93KCAxMCwgcHJlY2lzaW9uUG9pbnRzICk7XHJcblx0XHR2YXIgaSwgaWwsIGZhY2U7XHJcblx0XHR2YXIgaW5kaWNlcywgaiwgamw7XHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHYgPSB0aGlzLnZlcnRpY2VzWyBpIF07XHJcblx0XHRcdGtleSA9IE1hdGgucm91bmQoIHYueCAqIHByZWNpc2lvbiApICsgJ18nICsgTWF0aC5yb3VuZCggdi55ICogcHJlY2lzaW9uICkgKyAnXycgKyBNYXRoLnJvdW5kKCB2LnogKiBwcmVjaXNpb24gKTtcclxuXHJcblx0XHRcdGlmICggdmVydGljZXNNYXBbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHZlcnRpY2VzTWFwWyBrZXkgXSA9IGk7XHJcblx0XHRcdFx0dW5pcXVlLnB1c2goIHRoaXMudmVydGljZXNbIGkgXSApO1xyXG5cdFx0XHRcdGNoYW5nZXNbIGkgXSA9IHVuaXF1ZS5sZW5ndGggLSAxO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnRHVwbGljYXRlIHZlcnRleCBmb3VuZC4gJywgaSwgJyBjb3VsZCBiZSB1c2luZyAnLCB2ZXJ0aWNlc01hcFtrZXldKTtcclxuXHRcdFx0XHRjaGFuZ2VzWyBpIF0gPSBjaGFuZ2VzWyB2ZXJ0aWNlc01hcFsga2V5IF0gXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHRcdC8vIGlmIGZhY2VzIGFyZSBjb21wbGV0ZWx5IGRlZ2VuZXJhdGUgYWZ0ZXIgbWVyZ2luZyB2ZXJ0aWNlcywgd2VcclxuXHRcdC8vIGhhdmUgdG8gcmVtb3ZlIHRoZW0gZnJvbSB0aGUgZ2VvbWV0cnkuXHJcblx0XHR2YXIgZmFjZUluZGljZXNUb1JlbW92ZSA9IFtdO1xyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgaSBdO1xyXG5cclxuXHRcdFx0ZmFjZS5hID0gY2hhbmdlc1sgZmFjZS5hIF07XHJcblx0XHRcdGZhY2UuYiA9IGNoYW5nZXNbIGZhY2UuYiBdO1xyXG5cdFx0XHRmYWNlLmMgPSBjaGFuZ2VzWyBmYWNlLmMgXTtcclxuXHJcblx0XHRcdGluZGljZXMgPSBbIGZhY2UuYSwgZmFjZS5iLCBmYWNlLmMgXTtcclxuXHJcblx0XHRcdC8vIGlmIGFueSBkdXBsaWNhdGUgdmVydGljZXMgYXJlIGZvdW5kIGluIGEgRmFjZTNcclxuXHRcdFx0Ly8gd2UgaGF2ZSB0byByZW1vdmUgdGhlIGZhY2UgYXMgbm90aGluZyBjYW4gYmUgc2F2ZWRcclxuXHRcdFx0Zm9yICggdmFyIG4gPSAwOyBuIDwgMzsgbiArKyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBpbmRpY2VzWyBuIF0gPT09IGluZGljZXNbICggbiArIDEgKSAlIDMgXSApIHtcclxuXHJcblx0XHRcdFx0XHRmYWNlSW5kaWNlc1RvUmVtb3ZlLnB1c2goIGkgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIGkgPSBmYWNlSW5kaWNlc1RvUmVtb3ZlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtLSApIHtcclxuXHJcblx0XHRcdHZhciBpZHggPSBmYWNlSW5kaWNlc1RvUmVtb3ZlWyBpIF07XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VzLnNwbGljZSggaWR4LCAxICk7XHJcblxyXG5cdFx0XHRmb3IgKCBqID0gMCwgamwgPSB0aGlzLmZhY2VWZXJ0ZXhVdnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgaiBdLnNwbGljZSggaWR4LCAxICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFVzZSB1bmlxdWUgc2V0IG9mIHZlcnRpY2VzXHJcblxyXG5cdFx0dmFyIGRpZmYgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIHVuaXF1ZS5sZW5ndGg7XHJcblx0XHR0aGlzLnZlcnRpY2VzID0gdW5pcXVlO1xyXG5cdFx0cmV0dXJuIGRpZmY7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICggcG9pbnRzICkge1xyXG5cclxuXHRcdHRoaXMudmVydGljZXMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBwb2ludCA9IHBvaW50c1sgaSBdO1xyXG5cdFx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIG5ldyBWZWN0b3IzKCBwb2ludC54LCBwb2ludC55LCBwb2ludC56IHx8IDAgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c29ydEZhY2VzQnlNYXRlcmlhbEluZGV4OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGZhY2VzID0gdGhpcy5mYWNlcztcclxuXHRcdHZhciBsZW5ndGggPSBmYWNlcy5sZW5ndGg7XHJcblxyXG5cdFx0Ly8gdGFnIGZhY2VzXHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0ZmFjZXNbIGkgXS5faWQgPSBpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBzb3J0IGZhY2VzXHJcblxyXG5cdFx0ZnVuY3Rpb24gbWF0ZXJpYWxJbmRleFNvcnQoIGEsIGIgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYS5tYXRlcmlhbEluZGV4IC0gYi5tYXRlcmlhbEluZGV4O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmYWNlcy5zb3J0KCBtYXRlcmlhbEluZGV4U29ydCApO1xyXG5cclxuXHRcdC8vIHNvcnQgdXZzXHJcblxyXG5cdFx0dmFyIHV2czEgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXTtcclxuXHRcdHZhciB1dnMyID0gdGhpcy5mYWNlVmVydGV4VXZzWyAxIF07XHJcblxyXG5cdFx0dmFyIG5ld1V2czEsIG5ld1V2czI7XHJcblxyXG5cdFx0aWYgKCB1dnMxICYmIHV2czEubGVuZ3RoID09PSBsZW5ndGggKSBuZXdVdnMxID0gW107XHJcblx0XHRpZiAoIHV2czIgJiYgdXZzMi5sZW5ndGggPT09IGxlbmd0aCApIG5ld1V2czIgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgaWQgPSBmYWNlc1sgaSBdLl9pZDtcclxuXHJcblx0XHRcdGlmICggbmV3VXZzMSApIG5ld1V2czEucHVzaCggdXZzMVsgaWQgXSApO1xyXG5cdFx0XHRpZiAoIG5ld1V2czIgKSBuZXdVdnMyLnB1c2goIHV2czJbIGlkIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBuZXdVdnMxICkgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0gPSBuZXdVdnMxO1xyXG5cdFx0aWYgKCBuZXdVdnMyICkgdGhpcy5mYWNlVmVydGV4VXZzWyAxIF0gPSBuZXdVdnMyO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0pTT046IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0bWV0YWRhdGE6IHtcclxuXHRcdFx0XHR2ZXJzaW9uOiA0LjUsXHJcblx0XHRcdFx0dHlwZTogJ0dlb21ldHJ5JyxcclxuXHRcdFx0XHRnZW5lcmF0b3I6ICdHZW9tZXRyeS50b0pTT04nXHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gc3RhbmRhcmQgR2VvbWV0cnkgc2VyaWFsaXphdGlvblxyXG5cclxuXHRcdGRhdGEudXVpZCA9IHRoaXMudXVpZDtcclxuXHRcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcclxuXHRcdGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcclxuXHJcblx0XHRpZiAoIHRoaXMucGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIga2V5IGluIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggcGFyYW1ldGVyc1sga2V5IF0gIT09IHVuZGVmaW5lZCApIGRhdGFbIGtleSBdID0gcGFyYW1ldGVyc1sga2V5IF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHZlcnRpY2VzID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xyXG5cdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBmYWNlcyA9IFtdO1xyXG5cdFx0dmFyIG5vcm1hbHMgPSBbXTtcclxuXHRcdHZhciBub3JtYWxzSGFzaCA9IHt9O1xyXG5cdFx0dmFyIGNvbG9ycyA9IFtdO1xyXG5cdFx0dmFyIGNvbG9yc0hhc2ggPSB7fTtcclxuXHRcdHZhciB1dnMgPSBbXTtcclxuXHRcdHZhciB1dnNIYXNoID0ge307XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5mYWNlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgZmFjZSA9IHRoaXMuZmFjZXNbIGkgXTtcclxuXHJcblx0XHRcdHZhciBoYXNNYXRlcmlhbCA9IHRydWU7XHJcblx0XHRcdHZhciBoYXNGYWNlVXYgPSBmYWxzZTsgLy8gZGVwcmVjYXRlZFxyXG5cdFx0XHR2YXIgaGFzRmFjZVZlcnRleFV2ID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF1bIGkgXSAhPT0gdW5kZWZpbmVkO1xyXG5cdFx0XHR2YXIgaGFzRmFjZU5vcm1hbCA9IGZhY2Uubm9ybWFsLmxlbmd0aCgpID4gMDtcclxuXHRcdFx0dmFyIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoID4gMDtcclxuXHRcdFx0dmFyIGhhc0ZhY2VDb2xvciA9IGZhY2UuY29sb3IuciAhPT0gMSB8fCBmYWNlLmNvbG9yLmcgIT09IDEgfHwgZmFjZS5jb2xvci5iICE9PSAxO1xyXG5cdFx0XHR2YXIgaGFzRmFjZVZlcnRleENvbG9yID0gZmFjZS52ZXJ0ZXhDb2xvcnMubGVuZ3RoID4gMDtcclxuXHJcblx0XHRcdHZhciBmYWNlVHlwZSA9IDA7XHJcblxyXG5cdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDAsIDAgKTsgLy8gaXNRdWFkXHJcblx0XHRcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgMSwgaGFzTWF0ZXJpYWwgKTtcclxuXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAyLCBoYXNGYWNlVXYgKTtcclxuXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAzLCBoYXNGYWNlVmVydGV4VXYgKTtcclxuXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA0LCBoYXNGYWNlTm9ybWFsICk7XHJcblx0XHRcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNSwgaGFzRmFjZVZlcnRleE5vcm1hbCApO1xyXG5cdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDYsIGhhc0ZhY2VDb2xvciApO1xyXG5cdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDcsIGhhc0ZhY2VWZXJ0ZXhDb2xvciApO1xyXG5cclxuXHRcdFx0ZmFjZXMucHVzaCggZmFjZVR5cGUgKTtcclxuXHRcdFx0ZmFjZXMucHVzaCggZmFjZS5hLCBmYWNlLmIsIGZhY2UuYyApO1xyXG5cdFx0XHRmYWNlcy5wdXNoKCBmYWNlLm1hdGVyaWFsSW5kZXggKTtcclxuXHJcblx0XHRcdGlmICggaGFzRmFjZVZlcnRleFV2ICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZmFjZVZlcnRleFV2cyA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdWyBpIF07XHJcblxyXG5cdFx0XHRcdGZhY2VzLnB1c2goXHJcblx0XHRcdFx0XHRnZXRVdkluZGV4KCBmYWNlVmVydGV4VXZzWyAwIF0gKSxcclxuXHRcdFx0XHRcdGdldFV2SW5kZXgoIGZhY2VWZXJ0ZXhVdnNbIDEgXSApLFxyXG5cdFx0XHRcdFx0Z2V0VXZJbmRleCggZmFjZVZlcnRleFV2c1sgMiBdIClcclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBoYXNGYWNlTm9ybWFsICkge1xyXG5cclxuXHRcdFx0XHRmYWNlcy5wdXNoKCBnZXROb3JtYWxJbmRleCggZmFjZS5ub3JtYWwgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4Tm9ybWFsICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcclxuXHJcblx0XHRcdFx0ZmFjZXMucHVzaChcclxuXHRcdFx0XHRcdGdldE5vcm1hbEluZGV4KCB2ZXJ0ZXhOb3JtYWxzWyAwIF0gKSxcclxuXHRcdFx0XHRcdGdldE5vcm1hbEluZGV4KCB2ZXJ0ZXhOb3JtYWxzWyAxIF0gKSxcclxuXHRcdFx0XHRcdGdldE5vcm1hbEluZGV4KCB2ZXJ0ZXhOb3JtYWxzWyAyIF0gKVxyXG5cdFx0XHRcdCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGhhc0ZhY2VDb2xvciApIHtcclxuXHJcblx0XHRcdFx0ZmFjZXMucHVzaCggZ2V0Q29sb3JJbmRleCggZmFjZS5jb2xvciApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhDb2xvciApIHtcclxuXHJcblx0XHRcdFx0dmFyIHZlcnRleENvbG9ycyA9IGZhY2UudmVydGV4Q29sb3JzO1xyXG5cclxuXHRcdFx0XHRmYWNlcy5wdXNoKFxyXG5cdFx0XHRcdFx0Z2V0Q29sb3JJbmRleCggdmVydGV4Q29sb3JzWyAwIF0gKSxcclxuXHRcdFx0XHRcdGdldENvbG9ySW5kZXgoIHZlcnRleENvbG9yc1sgMSBdICksXHJcblx0XHRcdFx0XHRnZXRDb2xvckluZGV4KCB2ZXJ0ZXhDb2xvcnNbIDIgXSApXHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gc2V0Qml0KCB2YWx1ZSwgcG9zaXRpb24sIGVuYWJsZWQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gZW5hYmxlZCA/IHZhbHVlIHwgKCAxIDw8IHBvc2l0aW9uICkgOiB2YWx1ZSAmICggfiAoIDEgPDwgcG9zaXRpb24gKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZXROb3JtYWxJbmRleCggbm9ybWFsICkge1xyXG5cclxuXHRcdFx0dmFyIGhhc2ggPSBub3JtYWwueC50b1N0cmluZygpICsgbm9ybWFsLnkudG9TdHJpbmcoKSArIG5vcm1hbC56LnRvU3RyaW5nKCk7XHJcblxyXG5cdFx0XHRpZiAoIG5vcm1hbHNIYXNoWyBoYXNoIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG5vcm1hbHNIYXNoWyBoYXNoIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRub3JtYWxzSGFzaFsgaGFzaCBdID0gbm9ybWFscy5sZW5ndGggLyAzO1xyXG5cdFx0XHRub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcclxuXHJcblx0XHRcdHJldHVybiBub3JtYWxzSGFzaFsgaGFzaCBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZXRDb2xvckluZGV4KCBjb2xvciApIHtcclxuXHJcblx0XHRcdHZhciBoYXNoID0gY29sb3Iuci50b1N0cmluZygpICsgY29sb3IuZy50b1N0cmluZygpICsgY29sb3IuYi50b1N0cmluZygpO1xyXG5cclxuXHRcdFx0aWYgKCBjb2xvcnNIYXNoWyBoYXNoIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGNvbG9yc0hhc2hbIGhhc2ggXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbG9yc0hhc2hbIGhhc2ggXSA9IGNvbG9ycy5sZW5ndGg7XHJcblx0XHRcdGNvbG9ycy5wdXNoKCBjb2xvci5nZXRIZXgoKSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIGNvbG9yc0hhc2hbIGhhc2ggXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2V0VXZJbmRleCggdXYgKSB7XHJcblxyXG5cdFx0XHR2YXIgaGFzaCA9IHV2LngudG9TdHJpbmcoKSArIHV2LnkudG9TdHJpbmcoKTtcclxuXHJcblx0XHRcdGlmICggdXZzSGFzaFsgaGFzaCBdICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiB1dnNIYXNoWyBoYXNoIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR1dnNIYXNoWyBoYXNoIF0gPSB1dnMubGVuZ3RoIC8gMjtcclxuXHRcdFx0dXZzLnB1c2goIHV2LngsIHV2LnkgKTtcclxuXHJcblx0XHRcdHJldHVybiB1dnNIYXNoWyBoYXNoIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGRhdGEuZGF0YSA9IHt9O1xyXG5cclxuXHRcdGRhdGEuZGF0YS52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xyXG5cdFx0ZGF0YS5kYXRhLm5vcm1hbHMgPSBub3JtYWxzO1xyXG5cdFx0aWYgKCBjb2xvcnMubGVuZ3RoID4gMCApIGRhdGEuZGF0YS5jb2xvcnMgPSBjb2xvcnM7XHJcblx0XHRpZiAoIHV2cy5sZW5ndGggPiAwICkgZGF0YS5kYXRhLnV2cyA9IFsgdXZzIF07IC8vIHRlbXBvcmFsIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcclxuXHRcdGRhdGEuZGF0YS5mYWNlcyA9IGZhY2VzO1xyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8qXHJcblx0XHQgLy8gSGFuZGxlIHByaW1pdGl2ZXNcclxuXHJcblx0XHQgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XHJcblxyXG5cdFx0IGlmICggcGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdCB2YXIgdmFsdWVzID0gW107XHJcblxyXG5cdFx0IGZvciAoIHZhciBrZXkgaW4gcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHQgdmFsdWVzLnB1c2goIHBhcmFtZXRlcnNbIGtleSBdICk7XHJcblxyXG5cdFx0IH1cclxuXHJcblx0XHQgdmFyIGdlb21ldHJ5ID0gT2JqZWN0LmNyZWF0ZSggdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgKTtcclxuXHRcdCB0aGlzLmNvbnN0cnVjdG9yLmFwcGx5KCBnZW9tZXRyeSwgdmFsdWVzICk7XHJcblx0XHQgcmV0dXJuIGdlb21ldHJ5O1xyXG5cclxuXHRcdCB9XHJcblxyXG5cdFx0IHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHRcdCAqL1xyXG5cclxuXHRcdHJldHVybiBuZXcgR2VvbWV0cnkoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdHZhciBpLCBpbCwgaiwgamwsIGssIGtsO1xyXG5cclxuXHRcdC8vIHJlc2V0XHJcblxyXG5cdFx0dGhpcy52ZXJ0aWNlcyA9IFtdO1xyXG5cdFx0dGhpcy5jb2xvcnMgPSBbXTtcclxuXHRcdHRoaXMuZmFjZXMgPSBbXTtcclxuXHRcdHRoaXMuZmFjZVZlcnRleFV2cyA9IFtbXV07XHJcblx0XHR0aGlzLm1vcnBoVGFyZ2V0cyA9IFtdO1xyXG5cdFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBbXTtcclxuXHRcdHRoaXMuc2tpbldlaWdodHMgPSBbXTtcclxuXHRcdHRoaXMuc2tpbkluZGljZXMgPSBbXTtcclxuXHRcdHRoaXMubGluZURpc3RhbmNlcyA9IFtdO1xyXG5cdFx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XHJcblx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcclxuXHJcblx0XHQvLyBuYW1lXHJcblxyXG5cdFx0dGhpcy5uYW1lID0gc291cmNlLm5hbWU7XHJcblxyXG5cdFx0Ly8gdmVydGljZXNcclxuXHJcblx0XHR2YXIgdmVydGljZXMgPSBzb3VyY2UudmVydGljZXM7XHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRpY2VzWyBpIF0uY2xvbmUoKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBjb2xvcnNcclxuXHJcblx0XHR2YXIgY29sb3JzID0gc291cmNlLmNvbG9ycztcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSBjb2xvcnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNvbG9ycy5wdXNoKCBjb2xvcnNbIGkgXS5jbG9uZSgpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGZhY2VzXHJcblxyXG5cdFx0dmFyIGZhY2VzID0gc291cmNlLmZhY2VzO1xyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBmYWNlc1sgaSBdLmNsb25lKCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZmFjZSB2ZXJ0ZXggdXZzXHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gc291cmNlLmZhY2VWZXJ0ZXhVdnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgZmFjZVZlcnRleFV2cyA9IHNvdXJjZS5mYWNlVmVydGV4VXZzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuZmFjZVZlcnRleFV2c1sgaSBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgaSBdID0gW107XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCBqID0gMCwgamwgPSBmYWNlVmVydGV4VXZzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdXZzID0gZmFjZVZlcnRleFV2c1sgaiBdLCB1dnNDb3B5ID0gW107XHJcblxyXG5cdFx0XHRcdGZvciAoIGsgPSAwLCBrbCA9IHV2cy5sZW5ndGg7IGsgPCBrbDsgayArKyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgdXYgPSB1dnNbIGsgXTtcclxuXHJcblx0XHRcdFx0XHR1dnNDb3B5LnB1c2goIHV2LmNsb25lKCkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIGkgXS5wdXNoKCB1dnNDb3B5ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG1vcnBoIHRhcmdldHNcclxuXHJcblx0XHR2YXIgbW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSBtb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgbW9ycGhUYXJnZXQgPSB7fTtcclxuXHRcdFx0bW9ycGhUYXJnZXQubmFtZSA9IG1vcnBoVGFyZ2V0c1sgaSBdLm5hbWU7XHJcblxyXG5cdFx0XHQvLyB2ZXJ0aWNlc1xyXG5cclxuXHRcdFx0aWYgKCBtb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRtb3JwaFRhcmdldC52ZXJ0aWNlcyA9IFtdO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBqID0gMCwgamwgPSBtb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRtb3JwaFRhcmdldC52ZXJ0aWNlcy5wdXNoKCBtb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlc1sgaiBdLmNsb25lKCkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gbm9ybWFsc1xyXG5cclxuXHRcdFx0aWYgKCBtb3JwaFRhcmdldHNbIGkgXS5ub3JtYWxzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdG1vcnBoVGFyZ2V0Lm5vcm1hbHMgPSBbXTtcclxuXHJcblx0XHRcdFx0Zm9yICggaiA9IDAsIGpsID0gbW9ycGhUYXJnZXRzWyBpIF0ubm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRtb3JwaFRhcmdldC5ub3JtYWxzLnB1c2goIG1vcnBoVGFyZ2V0c1sgaSBdLm5vcm1hbHNbIGogXS5jbG9uZSgpICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMubW9ycGhUYXJnZXRzLnB1c2goIG1vcnBoVGFyZ2V0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG1vcnBoIG5vcm1hbHNcclxuXHJcblx0XHR2YXIgbW9ycGhOb3JtYWxzID0gc291cmNlLm1vcnBoTm9ybWFscztcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSBtb3JwaE5vcm1hbHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgbW9ycGhOb3JtYWwgPSB7fTtcclxuXHJcblx0XHRcdC8vIHZlcnRleCBub3JtYWxzXHJcblxyXG5cdFx0XHRpZiAoIG1vcnBoTm9ybWFsc1sgaSBdLnZlcnRleE5vcm1hbHMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0bW9ycGhOb3JtYWwudmVydGV4Tm9ybWFscyA9IFtdO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBqID0gMCwgamwgPSBtb3JwaE5vcm1hbHNbIGkgXS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBzcmNWZXJ0ZXhOb3JtYWwgPSBtb3JwaE5vcm1hbHNbIGkgXS52ZXJ0ZXhOb3JtYWxzWyBqIF07XHJcblx0XHRcdFx0XHR2YXIgZGVzdFZlcnRleE5vcm1hbCA9IHt9O1xyXG5cclxuXHRcdFx0XHRcdGRlc3RWZXJ0ZXhOb3JtYWwuYSA9IHNyY1ZlcnRleE5vcm1hbC5hLmNsb25lKCk7XHJcblx0XHRcdFx0XHRkZXN0VmVydGV4Tm9ybWFsLmIgPSBzcmNWZXJ0ZXhOb3JtYWwuYi5jbG9uZSgpO1xyXG5cdFx0XHRcdFx0ZGVzdFZlcnRleE5vcm1hbC5jID0gc3JjVmVydGV4Tm9ybWFsLmMuY2xvbmUoKTtcclxuXHJcblx0XHRcdFx0XHRtb3JwaE5vcm1hbC52ZXJ0ZXhOb3JtYWxzLnB1c2goIGRlc3RWZXJ0ZXhOb3JtYWwgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZmFjZSBub3JtYWxzXHJcblxyXG5cdFx0XHRpZiAoIG1vcnBoTm9ybWFsc1sgaSBdLmZhY2VOb3JtYWxzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdG1vcnBoTm9ybWFsLmZhY2VOb3JtYWxzID0gW107XHJcblxyXG5cdFx0XHRcdGZvciAoIGogPSAwLCBqbCA9IG1vcnBoTm9ybWFsc1sgaSBdLmZhY2VOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdG1vcnBoTm9ybWFsLmZhY2VOb3JtYWxzLnB1c2goIG1vcnBoTm9ybWFsc1sgaSBdLmZhY2VOb3JtYWxzWyBqIF0uY2xvbmUoKSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLm1vcnBoTm9ybWFscy5wdXNoKCBtb3JwaE5vcm1hbCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBza2luIHdlaWdodHNcclxuXHJcblx0XHR2YXIgc2tpbldlaWdodHMgPSBzb3VyY2Uuc2tpbldlaWdodHM7XHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gc2tpbldlaWdodHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnNraW5XZWlnaHRzLnB1c2goIHNraW5XZWlnaHRzWyBpIF0uY2xvbmUoKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBza2luIGluZGljZXNcclxuXHJcblx0XHR2YXIgc2tpbkluZGljZXMgPSBzb3VyY2Uuc2tpbkluZGljZXM7XHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gc2tpbkluZGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnNraW5JbmRpY2VzLnB1c2goIHNraW5JbmRpY2VzWyBpIF0uY2xvbmUoKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBsaW5lIGRpc3RhbmNlc1xyXG5cclxuXHRcdHZhciBsaW5lRGlzdGFuY2VzID0gc291cmNlLmxpbmVEaXN0YW5jZXM7XHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gbGluZURpc3RhbmNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMubGluZURpc3RhbmNlcy5wdXNoKCBsaW5lRGlzdGFuY2VzWyBpIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYm91bmRpbmcgYm94XHJcblxyXG5cdFx0dmFyIGJvdW5kaW5nQm94ID0gc291cmNlLmJvdW5kaW5nQm94O1xyXG5cclxuXHRcdGlmICggYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gYm91bmRpbmdCb3guY2xvbmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYm91bmRpbmcgc3BoZXJlXHJcblxyXG5cdFx0dmFyIGJvdW5kaW5nU3BoZXJlID0gc291cmNlLmJvdW5kaW5nU3BoZXJlO1xyXG5cclxuXHRcdGlmICggYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdXBkYXRlIGZsYWdzXHJcblxyXG5cdFx0dGhpcy5lbGVtZW50c05lZWRVcGRhdGUgPSBzb3VyY2UuZWxlbWVudHNOZWVkVXBkYXRlO1xyXG5cdFx0dGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSBzb3VyY2UudmVydGljZXNOZWVkVXBkYXRlO1xyXG5cdFx0dGhpcy51dnNOZWVkVXBkYXRlID0gc291cmNlLnV2c05lZWRVcGRhdGU7XHJcblx0XHR0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gc291cmNlLm5vcm1hbHNOZWVkVXBkYXRlO1xyXG5cdFx0dGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gc291cmNlLmNvbG9yc05lZWRVcGRhdGU7XHJcblx0XHR0aGlzLmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlID0gc291cmNlLmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlO1xyXG5cdFx0dGhpcy5ncm91cHNOZWVkVXBkYXRlID0gc291cmNlLmdyb3Vwc05lZWRVcGRhdGU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcclxuXHJcblx0fVxyXG5cclxufSApO1xyXG5cclxuXHJcbmV4cG9ydCB7IEdlb21ldHJ5IH07XHJcbiIsImltcG9ydCB7IFZlY3RvcjQgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjQuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uL21hdGgvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vbWF0aC9Db2xvci5qcyc7XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5mdW5jdGlvbiBCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcclxuXHJcblx0aWYgKCBBcnJheS5pc0FycmF5KCBhcnJheSApICkge1xyXG5cclxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdDT09MLkJ1ZmZlckF0dHJpYnV0ZTogYXJyYXkgc2hvdWxkIGJlIGEgVHlwZWQgQXJyYXkuJyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMubmFtZSA9ICcnO1xyXG5cclxuXHR0aGlzLmFycmF5ID0gYXJyYXk7XHJcblx0dGhpcy5pdGVtU2l6ZSA9IGl0ZW1TaXplO1xyXG5cdHRoaXMuY291bnQgPSBhcnJheSAhPT0gdW5kZWZpbmVkID8gYXJyYXkubGVuZ3RoIC8gaXRlbVNpemUgOiAwO1xyXG5cdHRoaXMubm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQgPT09IHRydWU7XHJcblxyXG5cdHRoaXMuZHluYW1pYyA9IGZhbHNlO1xyXG5cdHRoaXMudXBkYXRlUmFuZ2UgPSB7IG9mZnNldDogMCwgY291bnQ6IC0gMSB9O1xyXG5cclxuXHR0aGlzLnZlcnNpb24gPSAwO1xyXG5cclxufVxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLCAnbmVlZHNVcGRhdGUnLCB7XHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy52ZXJzaW9uICsrO1xyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcblxyXG5PYmplY3QuYXNzaWduKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLCB7XHJcblxyXG5cdGlzQnVmZmVyQXR0cmlidXRlOiB0cnVlLFxyXG5cclxuXHRvblVwbG9hZENhbGxiYWNrOiBmdW5jdGlvbiAoKSB7fSxcclxuXHJcblx0c2V0QXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XHJcblxyXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBhcnJheSApICkge1xyXG5cclxuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ0NPT0wuQnVmZmVyQXR0cmlidXRlOiBhcnJheSBzaG91bGQgYmUgYSBUeXBlZCBBcnJheS4nICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY291bnQgPSBhcnJheSAhPT0gdW5kZWZpbmVkID8gYXJyYXkubGVuZ3RoIC8gdGhpcy5pdGVtU2l6ZSA6IDA7XHJcblx0XHR0aGlzLmFycmF5ID0gYXJyYXk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldER5bmFtaWM6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5keW5hbWljID0gdmFsdWU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xyXG5cdFx0dGhpcy5hcnJheSA9IG5ldyBzb3VyY2UuYXJyYXkuY29uc3RydWN0b3IoIHNvdXJjZS5hcnJheSApO1xyXG5cdFx0dGhpcy5pdGVtU2l6ZSA9IHNvdXJjZS5pdGVtU2l6ZTtcclxuXHRcdHRoaXMuY291bnQgPSBzb3VyY2UuY291bnQ7XHJcblx0XHR0aGlzLm5vcm1hbGl6ZWQgPSBzb3VyY2Uubm9ybWFsaXplZDtcclxuXHJcblx0XHR0aGlzLmR5bmFtaWMgPSBzb3VyY2UuZHluYW1pYztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weUF0OiBmdW5jdGlvbiAoIGluZGV4MSwgYXR0cmlidXRlLCBpbmRleDIgKSB7XHJcblxyXG5cdFx0aW5kZXgxICo9IHRoaXMuaXRlbVNpemU7XHJcblx0XHRpbmRleDIgKj0gYXR0cmlidXRlLml0ZW1TaXplO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuaXRlbVNpemU7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dGhpcy5hcnJheVsgaW5kZXgxICsgaSBdID0gYXR0cmlidXRlLmFycmF5WyBpbmRleDIgKyBpIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5QXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XHJcblxyXG5cdFx0dGhpcy5hcnJheS5zZXQoIGFycmF5ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHlDb2xvcnNBcnJheTogZnVuY3Rpb24gKCBjb2xvcnMgKSB7XHJcblxyXG5cdFx0dmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjb2xvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBjb2xvciA9IGNvbG9yc1sgaSBdO1xyXG5cclxuXHRcdFx0aWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdDT09MLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5Q29sb3JzQXJyYXkoKTogY29sb3IgaXMgdW5kZWZpbmVkJywgaSApO1xyXG5cdFx0XHRcdGNvbG9yID0gbmV3IENvbG9yKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBjb2xvci5yO1xyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBjb2xvci5nO1xyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBjb2xvci5iO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weVZlY3RvcjJzQXJyYXk6IGZ1bmN0aW9uICggdmVjdG9ycyApIHtcclxuXHJcblx0XHR2YXIgYXJyYXkgPSB0aGlzLmFycmF5LCBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHZlY3RvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciB2ZWN0b3IgPSB2ZWN0b3JzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIHZlY3RvciA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdDT09MLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5VmVjdG9yMnNBcnJheSgpOiB2ZWN0b3IgaXMgdW5kZWZpbmVkJywgaSApO1xyXG5cdFx0XHRcdHZlY3RvciA9IG5ldyBWZWN0b3IyKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueDtcclxuXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5VmVjdG9yM3NBcnJheTogZnVuY3Rpb24gKCB2ZWN0b3JzICkge1xyXG5cclxuXHRcdHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdmVjdG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHZlY3RvciA9IHZlY3RvcnNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggdmVjdG9yID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ0NPT0wuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWQnLCBpICk7XHJcblx0XHRcdFx0dmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci54O1xyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueTtcclxuXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLno7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5VmVjdG9yNHNBcnJheTogZnVuY3Rpb24gKCB2ZWN0b3JzICkge1xyXG5cclxuXHRcdHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdmVjdG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHZlY3RvciA9IHZlY3RvcnNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggdmVjdG9yID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ0NPT0wuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3I0c0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWQnLCBpICk7XHJcblx0XHRcdFx0dmVjdG9yID0gbmV3IFZlY3RvcjQoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci54O1xyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueTtcclxuXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLno7XHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci53O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlLCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0dGhpcy5hcnJheS5zZXQoIHZhbHVlLCBvZmZzZXQgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0WDogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplIF07XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFg6IGZ1bmN0aW9uICggaW5kZXgsIHggKSB7XHJcblxyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplIF0gPSB4O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRZOiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAxIF07XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFk6IGZ1bmN0aW9uICggaW5kZXgsIHkgKSB7XHJcblxyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMSBdID0geTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0WjogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMiBdO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRaOiBmdW5jdGlvbiAoIGluZGV4LCB6ICkge1xyXG5cclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDIgXSA9IHo7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldFc6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDMgXTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0VzogZnVuY3Rpb24gKCBpbmRleCwgdyApIHtcclxuXHJcblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAzIF0gPSB3O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRYWTogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSApIHtcclxuXHJcblx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xyXG5cclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WFlaOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XHJcblxyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRYWVpXOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5LCB6LCB3ICkge1xyXG5cclxuXHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XHJcblxyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAzIF0gPSB3O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRvblVwbG9hZDogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcclxuXHJcblx0XHR0aGlzLm9uVXBsb2FkQ2FsbGJhY2sgPSBjYWxsYmFjaztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuYXJyYXksIHRoaXMuaXRlbVNpemUgKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuXHJcbi8vXHJcblxyXG5mdW5jdGlvbiBJbnQ4QnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XHJcblxyXG5cdEJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBuZXcgSW50OEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xyXG5cclxufVxyXG5cclxuSW50OEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XHJcbkludDhCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW50OEJ1ZmZlckF0dHJpYnV0ZTtcclxuXHJcblxyXG5mdW5jdGlvbiBVaW50OEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xyXG5cclxuXHRCdWZmZXJBdHRyaWJ1dGUuY2FsbCggdGhpcywgbmV3IFVpbnQ4QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XHJcblxyXG59XHJcblxyXG5VaW50OEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XHJcblVpbnQ4QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFVpbnQ4QnVmZmVyQXR0cmlidXRlO1xyXG5cclxuXHJcbmZ1bmN0aW9uIFVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xyXG5cclxuXHRCdWZmZXJBdHRyaWJ1dGUuY2FsbCggdGhpcywgbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xyXG5cclxufVxyXG5cclxuVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKTtcclxuVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZTtcclxuXHJcblxyXG5mdW5jdGlvbiBJbnQxNkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xyXG5cclxuXHRCdWZmZXJBdHRyaWJ1dGUuY2FsbCggdGhpcywgbmV3IEludDE2QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XHJcblxyXG59XHJcblxyXG5JbnQxNkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XHJcbkludDE2QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEludDE2QnVmZmVyQXR0cmlidXRlO1xyXG5cclxuXHJcbmZ1bmN0aW9uIFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xyXG5cclxuXHRCdWZmZXJBdHRyaWJ1dGUuY2FsbCggdGhpcywgbmV3IFVpbnQxNkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xyXG5cclxufVxyXG5cclxuVWludDE2QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKTtcclxuVWludDE2QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZTtcclxuXHJcblxyXG5mdW5jdGlvbiBJbnQzMkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xyXG5cclxuXHRCdWZmZXJBdHRyaWJ1dGUuY2FsbCggdGhpcywgbmV3IEludDMyQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XHJcblxyXG59XHJcblxyXG5JbnQzMkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XHJcbkludDMyQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEludDMyQnVmZmVyQXR0cmlidXRlO1xyXG5cclxuXHJcbmZ1bmN0aW9uIFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xyXG5cclxuXHRCdWZmZXJBdHRyaWJ1dGUuY2FsbCggdGhpcywgbmV3IFVpbnQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xyXG5cclxufVxyXG5cclxuVWludDMyQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKTtcclxuVWludDMyQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZTtcclxuXHJcblxyXG5mdW5jdGlvbiBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XHJcblxyXG5cdEJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBuZXcgRmxvYXQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xyXG5cclxufVxyXG5cclxuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XHJcbkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZTtcclxuXHJcblxyXG5mdW5jdGlvbiBGbG9hdDY0QnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XHJcblxyXG5cdEJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBuZXcgRmxvYXQ2NEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xyXG5cclxufVxyXG5cclxuRmxvYXQ2NEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XHJcbkZsb2F0NjRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRmxvYXQ2NEJ1ZmZlckF0dHJpYnV0ZTtcclxuXHJcbi8vXHJcblxyXG5leHBvcnQge1xyXG5cdEZsb2F0NjRCdWZmZXJBdHRyaWJ1dGUsXHJcblx0RmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSxcclxuXHRVaW50MzJCdWZmZXJBdHRyaWJ1dGUsXHJcblx0SW50MzJCdWZmZXJBdHRyaWJ1dGUsXHJcblx0VWludDE2QnVmZmVyQXR0cmlidXRlLFxyXG5cdEludDE2QnVmZmVyQXR0cmlidXRlLFxyXG5cdFVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZSxcclxuXHRVaW50OEJ1ZmZlckF0dHJpYnV0ZSxcclxuXHRJbnQ4QnVmZmVyQXR0cmlidXRlLFxyXG5cdEJ1ZmZlckF0dHJpYnV0ZVxyXG59O1xyXG4iLCIvKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IyLmpzJztcclxuXHJcbmZ1bmN0aW9uIERpcmVjdEdlb21ldHJ5KCkge1xyXG5cclxuXHR0aGlzLnZlcnRpY2VzID0gW107XHJcblx0dGhpcy5ub3JtYWxzID0gW107XHJcblx0dGhpcy5jb2xvcnMgPSBbXTtcclxuXHR0aGlzLnV2cyA9IFtdO1xyXG5cdHRoaXMudXZzMiA9IFtdO1xyXG5cclxuXHR0aGlzLmdyb3VwcyA9IFtdO1xyXG5cclxuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHt9O1xyXG5cclxuXHR0aGlzLnNraW5XZWlnaHRzID0gW107XHJcblx0dGhpcy5za2luSW5kaWNlcyA9IFtdO1xyXG5cclxuXHQvLyB0aGlzLmxpbmVEaXN0YW5jZXMgPSBbXTtcclxuXHJcblx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XHJcblx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XHJcblxyXG5cdC8vIHVwZGF0ZSBmbGFnc1xyXG5cclxuXHR0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHR0aGlzLmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHR0aGlzLnV2c05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHR0aGlzLmdyb3Vwc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcbn1cclxuXHJcbk9iamVjdC5hc3NpZ24oIERpcmVjdEdlb21ldHJ5LnByb3RvdHlwZSwge1xyXG5cclxuXHRjb21wdXRlR3JvdXBzOiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xyXG5cclxuXHRcdHZhciBncm91cDtcclxuXHRcdHZhciBncm91cHMgPSBbXTtcclxuXHRcdHZhciBtYXRlcmlhbEluZGV4ID0gdW5kZWZpbmVkO1xyXG5cclxuXHRcdHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGZhY2VzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcclxuXHJcblx0XHRcdC8vIG1hdGVyaWFsc1xyXG5cclxuXHRcdFx0aWYgKCBmYWNlLm1hdGVyaWFsSW5kZXggIT09IG1hdGVyaWFsSW5kZXggKSB7XHJcblxyXG5cdFx0XHRcdG1hdGVyaWFsSW5kZXggPSBmYWNlLm1hdGVyaWFsSW5kZXg7XHJcblxyXG5cdFx0XHRcdGlmICggZ3JvdXAgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRncm91cC5jb3VudCA9ICggaSAqIDMgKSAtIGdyb3VwLnN0YXJ0O1xyXG5cdFx0XHRcdFx0Z3JvdXBzLnB1c2goIGdyb3VwICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Z3JvdXAgPSB7XHJcblx0XHRcdFx0XHRzdGFydDogaSAqIDMsXHJcblx0XHRcdFx0XHRtYXRlcmlhbEluZGV4OiBtYXRlcmlhbEluZGV4XHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBncm91cCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Z3JvdXAuY291bnQgPSAoIGkgKiAzICkgLSBncm91cC5zdGFydDtcclxuXHRcdFx0Z3JvdXBzLnB1c2goIGdyb3VwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZ3JvdXBzID0gZ3JvdXBzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmcm9tR2VvbWV0cnk6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0dmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XHJcblx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcclxuXHRcdHZhciBmYWNlVmVydGV4VXZzID0gZ2VvbWV0cnkuZmFjZVZlcnRleFV2cztcclxuXHJcblx0XHR2YXIgaGFzRmFjZVZlcnRleFV2ID0gZmFjZVZlcnRleFV2c1sgMCBdICYmIGZhY2VWZXJ0ZXhVdnNbIDAgXS5sZW5ndGggPiAwO1xyXG5cdFx0dmFyIGhhc0ZhY2VWZXJ0ZXhVdjIgPSBmYWNlVmVydGV4VXZzWyAxIF0gJiYgZmFjZVZlcnRleFV2c1sgMSBdLmxlbmd0aCA+IDA7XHJcblxyXG5cdFx0Ly8gbW9ycGhzXHJcblxyXG5cdFx0dmFyIG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cztcclxuXHRcdHZhciBtb3JwaFRhcmdldHNMZW5ndGggPSBtb3JwaFRhcmdldHMubGVuZ3RoO1xyXG5cclxuXHRcdHZhciBtb3JwaFRhcmdldHNQb3NpdGlvbjtcclxuXHJcblx0XHRpZiAoIG1vcnBoVGFyZ2V0c0xlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRtb3JwaFRhcmdldHNQb3NpdGlvbiA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbW9ycGhUYXJnZXRzTGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRtb3JwaFRhcmdldHNQb3NpdGlvblsgaSBdID0ge1xyXG5cdFx0XHRcdFx0bmFtZTogbW9ycGhUYXJnZXRzWyBpIF0ubmFtZSxcclxuXHRcdFx0XHQgXHRkYXRhOiBbXVxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLm1vcnBoVGFyZ2V0cy5wb3NpdGlvbiA9IG1vcnBoVGFyZ2V0c1Bvc2l0aW9uO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbW9ycGhOb3JtYWxzID0gZ2VvbWV0cnkubW9ycGhOb3JtYWxzO1xyXG5cdFx0dmFyIG1vcnBoTm9ybWFsc0xlbmd0aCA9IG1vcnBoTm9ybWFscy5sZW5ndGg7XHJcblxyXG5cdFx0dmFyIG1vcnBoVGFyZ2V0c05vcm1hbDtcclxuXHJcblx0XHRpZiAoIG1vcnBoTm9ybWFsc0xlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRtb3JwaFRhcmdldHNOb3JtYWwgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG1vcnBoTm9ybWFsc0xlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0bW9ycGhUYXJnZXRzTm9ybWFsWyBpIF0gPSB7XHJcblx0XHRcdFx0XHRuYW1lOiBtb3JwaE5vcm1hbHNbIGkgXS5uYW1lLFxyXG5cdFx0XHRcdCBcdGRhdGE6IFtdXHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMubW9ycGhUYXJnZXRzLm5vcm1hbCA9IG1vcnBoVGFyZ2V0c05vcm1hbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2tpbnNcclxuXHJcblx0XHR2YXIgc2tpbkluZGljZXMgPSBnZW9tZXRyeS5za2luSW5kaWNlcztcclxuXHRcdHZhciBza2luV2VpZ2h0cyA9IGdlb21ldHJ5LnNraW5XZWlnaHRzO1xyXG5cclxuXHRcdHZhciBoYXNTa2luSW5kaWNlcyA9IHNraW5JbmRpY2VzLmxlbmd0aCA9PT0gdmVydGljZXMubGVuZ3RoO1xyXG5cdFx0dmFyIGhhc1NraW5XZWlnaHRzID0gc2tpbldlaWdodHMubGVuZ3RoID09PSB2ZXJ0aWNlcy5sZW5ndGg7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRpZiAoIHZlcnRpY2VzLmxlbmd0aCA+IDAgJiYgZmFjZXMubGVuZ3RoID09PSAwICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ0NPT0wuRGlyZWN0R2VvbWV0cnk6IEZhY2VsZXNzIGdlb21ldHJpZXMgYXJlIG5vdCBzdXBwb3J0ZWQuJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBmYWNlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XHJcblxyXG5cdFx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRpY2VzWyBmYWNlLmEgXSwgdmVydGljZXNbIGZhY2UuYiBdLCB2ZXJ0aWNlc1sgZmFjZS5jIF0gKTtcclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXhOb3JtYWxzID0gZmFjZS52ZXJ0ZXhOb3JtYWxzO1xyXG5cclxuXHRcdFx0aWYgKCB2ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA9PT0gMyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5ub3JtYWxzLnB1c2goIHZlcnRleE5vcm1hbHNbIDAgXSwgdmVydGV4Tm9ybWFsc1sgMSBdLCB2ZXJ0ZXhOb3JtYWxzWyAyIF0gKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHZhciBub3JtYWwgPSBmYWNlLm5vcm1hbDtcclxuXHJcblx0XHRcdFx0dGhpcy5ub3JtYWxzLnB1c2goIG5vcm1hbCwgbm9ybWFsLCBub3JtYWwgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXhDb2xvcnMgPSBmYWNlLnZlcnRleENvbG9ycztcclxuXHJcblx0XHRcdGlmICggdmVydGV4Q29sb3JzLmxlbmd0aCA9PT0gMyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5jb2xvcnMucHVzaCggdmVydGV4Q29sb3JzWyAwIF0sIHZlcnRleENvbG9yc1sgMSBdLCB2ZXJ0ZXhDb2xvcnNbIDIgXSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dmFyIGNvbG9yID0gZmFjZS5jb2xvcjtcclxuXHJcblx0XHRcdFx0dGhpcy5jb2xvcnMucHVzaCggY29sb3IsIGNvbG9yLCBjb2xvciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4VXYgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB2ZXJ0ZXhVdnMgPSBmYWNlVmVydGV4VXZzWyAwIF1bIGkgXTtcclxuXHJcblx0XHRcdFx0aWYgKCB2ZXJ0ZXhVdnMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLnV2cy5wdXNoKCB2ZXJ0ZXhVdnNbIDAgXSwgdmVydGV4VXZzWyAxIF0sIHZlcnRleFV2c1sgMiBdICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5EaXJlY3RHZW9tZXRyeS5mcm9tR2VvbWV0cnkoKTogVW5kZWZpbmVkIHZlcnRleFV2ICcsIGkgKTtcclxuXHJcblx0XHRcdFx0XHR0aGlzLnV2cy5wdXNoKCBuZXcgVmVjdG9yMigpLCBuZXcgVmVjdG9yMigpLCBuZXcgVmVjdG9yMigpICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggaGFzRmFjZVZlcnRleFV2MiA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0dmFyIHZlcnRleFV2cyA9IGZhY2VWZXJ0ZXhVdnNbIDEgXVsgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIHZlcnRleFV2cyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMudXZzMi5wdXNoKCB2ZXJ0ZXhVdnNbIDAgXSwgdmVydGV4VXZzWyAxIF0sIHZlcnRleFV2c1sgMiBdICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5EaXJlY3RHZW9tZXRyeS5mcm9tR2VvbWV0cnkoKTogVW5kZWZpbmVkIHZlcnRleFV2MiAnLCBpICk7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy51dnMyLnB1c2goIG5ldyBWZWN0b3IyKCksIG5ldyBWZWN0b3IyKCksIG5ldyBWZWN0b3IyKCkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gbW9ycGhzXHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBtb3JwaFRhcmdldHNMZW5ndGg7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBtb3JwaFRhcmdldCA9IG1vcnBoVGFyZ2V0c1sgaiBdLnZlcnRpY2VzO1xyXG5cclxuXHRcdFx0XHRtb3JwaFRhcmdldHNQb3NpdGlvblsgaiBdLmRhdGEucHVzaCggbW9ycGhUYXJnZXRbIGZhY2UuYSBdLCBtb3JwaFRhcmdldFsgZmFjZS5iIF0sIG1vcnBoVGFyZ2V0WyBmYWNlLmMgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgbW9ycGhOb3JtYWxzTGVuZ3RoOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgbW9ycGhOb3JtYWwgPSBtb3JwaE5vcm1hbHNbIGogXS52ZXJ0ZXhOb3JtYWxzWyBpIF07XHJcblxyXG5cdFx0XHRcdG1vcnBoVGFyZ2V0c05vcm1hbFsgaiBdLmRhdGEucHVzaCggbW9ycGhOb3JtYWwuYSwgbW9ycGhOb3JtYWwuYiwgbW9ycGhOb3JtYWwuYyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gc2tpbnNcclxuXHJcblx0XHRcdGlmICggaGFzU2tpbkluZGljZXMgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuc2tpbkluZGljZXMucHVzaCggc2tpbkluZGljZXNbIGZhY2UuYSBdLCBza2luSW5kaWNlc1sgZmFjZS5iIF0sIHNraW5JbmRpY2VzWyBmYWNlLmMgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBoYXNTa2luV2VpZ2h0cyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5za2luV2VpZ2h0cy5wdXNoKCBza2luV2VpZ2h0c1sgZmFjZS5hIF0sIHNraW5XZWlnaHRzWyBmYWNlLmIgXSwgc2tpbldlaWdodHNbIGZhY2UuYyBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY29tcHV0ZUdyb3VwcyggZ2VvbWV0cnkgKTtcclxuXHJcblx0XHR0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZTtcclxuXHRcdHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZTtcclxuXHRcdHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGU7XHJcblx0XHR0aGlzLnV2c05lZWRVcGRhdGUgPSBnZW9tZXRyeS51dnNOZWVkVXBkYXRlO1xyXG5cdFx0dGhpcy5ncm91cHNOZWVkVXBkYXRlID0gZ2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxufSApO1xyXG5cclxuXHJcbmV4cG9ydCB7IERpcmVjdEdlb21ldHJ5IH07XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGFycmF5TWluKCBhcnJheSApIHtcclxuXHJcblx0aWYgKCBhcnJheS5sZW5ndGggPT09IDAgKSByZXR1cm4gSW5maW5pdHk7XHJcblxyXG5cdHZhciBtaW4gPSBhcnJheVsgMCBdO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDEsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyArKyBpICkge1xyXG5cclxuXHRcdGlmICggYXJyYXlbIGkgXSA8IG1pbiApIG1pbiA9IGFycmF5WyBpIF07XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG1pbjtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFycmF5TWF4KCBhcnJheSApIHtcclxuXHJcblx0aWYgKCBhcnJheS5sZW5ndGggPT09IDAgKSByZXR1cm4gLSBJbmZpbml0eTtcclxuXHJcblx0dmFyIG1heCA9IGFycmF5WyAwIF07XHJcblxyXG5cdGZvciAoIHZhciBpID0gMSwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7ICsrIGkgKSB7XHJcblxyXG5cdFx0aWYgKCBhcnJheVsgaSBdID4gbWF4ICkgbWF4ID0gYXJyYXlbIGkgXTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbWF4O1xyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgYXJyYXlNaW4sIGFycmF5TWF4IH07XHJcbiIsImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5pbXBvcnQgeyBCb3gzIH0gZnJvbSAnLi4vbWF0aC9Cb3gzLmpzJztcclxuaW1wb3J0IHsgRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnLi9FdmVudERpc3BhdGNoZXIuanMnO1xyXG5pbXBvcnQgeyBCdWZmZXJBdHRyaWJ1dGUsIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUsIFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSwgVWludDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi9CdWZmZXJBdHRyaWJ1dGUuanMnO1xyXG5pbXBvcnQgeyBTcGhlcmUgfSBmcm9tICcuLi9tYXRoL1NwaGVyZS5qcyc7XHJcbmltcG9ydCB7IERpcmVjdEdlb21ldHJ5IH0gZnJvbSAnLi9EaXJlY3RHZW9tZXRyeS5qcyc7XHJcbmltcG9ydCB7IE9iamVjdDNEIH0gZnJvbSAnLi9PYmplY3QzRC5qcyc7XHJcbmltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuLi9tYXRoL01hdHJpeDQuanMnO1xyXG5pbXBvcnQgeyBNYXRyaXgzIH0gZnJvbSAnLi4vbWF0aC9NYXRyaXgzLmpzJztcclxuaW1wb3J0IHtfTWF0aH0gZnJvbSAnLi4vbWF0aC9NYXRoLmpzJztcclxuaW1wb3J0IHsgYXJyYXlNYXggfSBmcm9tICcuL3V0aWxzLmpzJztcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcbnZhciBidWZmZXJHZW9tZXRyeUlkID0gMTsgLy8gQnVmZmVyR2VvbWV0cnkgdXNlcyBvZGQgbnVtYmVycyBhcyBJZFxyXG5cclxuZnVuY3Rpb24gQnVmZmVyR2VvbWV0cnkoKSB7XHJcblxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogYnVmZmVyR2VvbWV0cnlJZCArPSAyIH0gKTtcclxuXHJcblx0dGhpcy51dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG5cdHRoaXMubmFtZSA9ICcnO1xyXG5cdHRoaXMudHlwZSA9ICdCdWZmZXJHZW9tZXRyeSc7XHJcblxyXG5cdHRoaXMuaW5kZXggPSBudWxsO1xyXG5cdHRoaXMuYXR0cmlidXRlcyA9IHt9O1xyXG5cclxuXHR0aGlzLm1vcnBoQXR0cmlidXRlcyA9IHt9O1xyXG5cclxuXHR0aGlzLmdyb3VwcyA9IFtdO1xyXG5cclxuXHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcclxuXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcclxuXHJcblx0dGhpcy5kcmF3UmFuZ2UgPSB7IHN0YXJ0OiAwLCBjb3VudDogSW5maW5pdHkgfTtcclxuXHJcblx0dGhpcy51c2VyRGF0YSA9IHt9O1xyXG5cclxufVxyXG5cclxuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSApLCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBCdWZmZXJHZW9tZXRyeSxcclxuXHJcblx0aXNCdWZmZXJHZW9tZXRyeTogdHJ1ZSxcclxuXHJcblx0Z2V0SW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5pbmRleDtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0SW5kZXg6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBpbmRleCApICkge1xyXG5cclxuXHRcdFx0dGhpcy5pbmRleCA9IG5ldyAoIGFycmF5TWF4KCBpbmRleCApID4gNjU1MzUgPyBVaW50MzJCdWZmZXJBdHRyaWJ1dGUgOiBVaW50MTZCdWZmZXJBdHRyaWJ1dGUgKSggaW5kZXgsIDEgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5pbmRleCA9IGluZGV4O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0YWRkQXR0cmlidXRlOiBmdW5jdGlvbiAoIG5hbWUsIGF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRpZiAoICEgKCBhdHRyaWJ1dGUgJiYgYXR0cmlidXRlLmlzQnVmZmVyQXR0cmlidXRlICkgJiYgISAoIGF0dHJpYnV0ZSAmJiBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnQ09PTC5CdWZmZXJHZW9tZXRyeTogLmFkZEF0dHJpYnV0ZSgpIG5vdyBleHBlY3RzICggbmFtZSwgYXR0cmlidXRlICkuJyApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkQXR0cmlidXRlKCBuYW1lLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBhcmd1bWVudHNbIDEgXSwgYXJndW1lbnRzWyAyIF0gKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG5hbWUgPT09ICdpbmRleCcgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdDT09MLkJ1ZmZlckdlb21ldHJ5LmFkZEF0dHJpYnV0ZTogVXNlIC5zZXRJbmRleCgpIGZvciBpbmRleCBhdHRyaWJ1dGUuJyApO1xyXG5cdFx0XHR0aGlzLnNldEluZGV4KCBhdHRyaWJ1dGUgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXSA9IGF0dHJpYnV0ZTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0QXR0cmlidXRlOiBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyZW1vdmVBdHRyaWJ1dGU6IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcblx0XHRkZWxldGUgdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZEdyb3VwOiBmdW5jdGlvbiAoIHN0YXJ0LCBjb3VudCwgbWF0ZXJpYWxJbmRleCApIHtcclxuXHJcblx0XHR0aGlzLmdyb3Vwcy5wdXNoKCB7XHJcblxyXG5cdFx0XHRzdGFydDogc3RhcnQsXHJcblx0XHRcdGNvdW50OiBjb3VudCxcclxuXHRcdFx0bWF0ZXJpYWxJbmRleDogbWF0ZXJpYWxJbmRleCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWxJbmRleCA6IDBcclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsZWFyR3JvdXBzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5ncm91cHMgPSBbXTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RHJhd1JhbmdlOiBmdW5jdGlvbiAoIHN0YXJ0LCBjb3VudCApIHtcclxuXHJcblx0XHR0aGlzLmRyYXdSYW5nZS5zdGFydCA9IHN0YXJ0O1xyXG5cdFx0dGhpcy5kcmF3UmFuZ2UuY291bnQgPSBjb3VudDtcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlNYXRyaXg6IGZ1bmN0aW9uICggbWF0cml4ICkge1xyXG5cclxuXHRcdHZhciBwb3NpdGlvbiA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuXHJcblx0XHRpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRtYXRyaXguYXBwbHlUb0J1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24gKTtcclxuXHRcdFx0cG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbm9ybWFsID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtcclxuXHJcblx0XHRpZiAoIG5vcm1hbCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBNYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcclxuXHJcblx0XHRcdG5vcm1hbE1hdHJpeC5hcHBseVRvQnVmZmVyQXR0cmlidXRlKCBub3JtYWwgKTtcclxuXHRcdFx0bm9ybWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdGF0ZVg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHgtYXhpc1xyXG5cclxuXHRcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVgoIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0bTEubWFrZVJvdGF0aW9uWCggYW5nbGUgKTtcclxuXHJcblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHktYXhpc1xyXG5cclxuXHRcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVkoIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0bTEubWFrZVJvdGF0aW9uWSggYW5nbGUgKTtcclxuXHJcblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHJvdGF0ZVo6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHotYXhpc1xyXG5cclxuXHRcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVooIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0bTEubWFrZVJvdGF0aW9uWiggYW5nbGUgKTtcclxuXHJcblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHRyYW5zbGF0ZSBnZW9tZXRyeVxyXG5cclxuXHRcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZSggeCwgeSwgeiApIHtcclxuXHJcblx0XHRcdG0xLm1ha2VUcmFuc2xhdGlvbiggeCwgeSwgeiApO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0c2NhbGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyBzY2FsZSBnZW9tZXRyeVxyXG5cclxuXHRcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHNjYWxlKCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdFx0bTEubWFrZVNjYWxlKCB4LCB5LCB6ICk7XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRsb29rQXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgb2JqID0gbmV3IE9iamVjdDNEKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGxvb2tBdCggdmVjdG9yICkge1xyXG5cclxuXHRcdFx0b2JqLmxvb2tBdCggdmVjdG9yICk7XHJcblxyXG5cdFx0XHRvYmoudXBkYXRlTWF0cml4KCk7XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBvYmoubWF0cml4ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRjZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgb2Zmc2V0ID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gY2VudGVyKCkge1xyXG5cclxuXHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcclxuXHJcblx0XHRcdHRoaXMuYm91bmRpbmdCb3guZ2V0Q2VudGVyKCBvZmZzZXQgKS5uZWdhdGUoKTtcclxuXHJcblx0XHRcdHRoaXMudHJhbnNsYXRlKCBvZmZzZXQueCwgb2Zmc2V0LnksIG9mZnNldC56ICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHNldEZyb21PYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRcdC8vIGNvbnNvbGUubG9nKCAnQ09PTC5CdWZmZXJHZW9tZXRyeS5zZXRGcm9tT2JqZWN0KCkuIENvbnZlcnRpbmcnLCBvYmplY3QsIHRoaXMgKTtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XHJcblxyXG5cdFx0aWYgKCBvYmplY3QuaXNQb2ludHMgfHwgb2JqZWN0LmlzTGluZSApIHtcclxuXHJcblx0XHRcdHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICogMywgMyApO1xyXG5cdFx0XHR2YXIgY29sb3JzID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGdlb21ldHJ5LmNvbG9ycy5sZW5ndGggKiAzLCAzICk7XHJcblxyXG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25zLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcyApICk7XHJcblx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnY29sb3InLCBjb2xvcnMuY29weUNvbG9yc0FycmF5KCBnZW9tZXRyeS5jb2xvcnMgKSApO1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzICYmIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMubGVuZ3RoID09PSBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHRcdHZhciBsaW5lRGlzdGFuY2VzID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMubGVuZ3RoLCAxICk7XHJcblxyXG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnbGluZURpc3RhbmNlJywgbGluZURpc3RhbmNlcy5jb3B5QXJyYXkoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gZ2VvbWV0cnkuYm91bmRpbmdCb3guY2xvbmUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNNZXNoICkge1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0dlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmZyb21HZW9tZXRyeSggZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICggcG9pbnRzICkge1xyXG5cclxuXHRcdHZhciBwb3NpdGlvbiA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHBvaW50ID0gcG9pbnRzWyBpIF07XHJcblx0XHRcdHBvc2l0aW9uLnB1c2goIHBvaW50LngsIHBvaW50LnksIHBvaW50LnogfHwgMCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCAzICkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dXBkYXRlRnJvbU9iamVjdDogZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuXHRcdGlmICggb2JqZWN0LmlzTWVzaCApIHtcclxuXHJcblx0XHRcdHZhciBkaXJlY3QgPSBnZW9tZXRyeS5fX2RpcmVjdEdlb21ldHJ5O1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeS5lbGVtZW50c05lZWRVcGRhdGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdGRpcmVjdCA9IHVuZGVmaW5lZDtcclxuXHRcdFx0XHRnZW9tZXRyeS5lbGVtZW50c05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggZGlyZWN0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzLmZyb21HZW9tZXRyeSggZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGRpcmVjdC52ZXJ0aWNlc05lZWRVcGRhdGUgPSBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGU7XHJcblx0XHRcdGRpcmVjdC5ub3JtYWxzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlO1xyXG5cdFx0XHRkaXJlY3QuY29sb3JzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGU7XHJcblx0XHRcdGRpcmVjdC51dnNOZWVkVXBkYXRlID0gZ2VvbWV0cnkudXZzTmVlZFVwZGF0ZTtcclxuXHRcdFx0ZGlyZWN0Lmdyb3Vwc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlO1xyXG5cclxuXHRcdFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0XHRcdGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0XHRcdGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHRcdFx0Z2VvbWV0cnkudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHRnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0XHRnZW9tZXRyeSA9IGRpcmVjdDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGF0dHJpYnV0ZTtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuXHJcblx0XHRcdGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGF0dHJpYnV0ZS5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkudmVydGljZXMgKTtcclxuXHRcdFx0XHRhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsO1xyXG5cclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0YXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS5ub3JtYWxzICk7XHJcblx0XHRcdFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy5jb2xvcjtcclxuXHJcblx0XHRcdGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGF0dHJpYnV0ZS5jb3B5Q29sb3JzQXJyYXkoIGdlb21ldHJ5LmNvbG9ycyApO1xyXG5cdFx0XHRcdGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkudXZzTmVlZFVwZGF0ZSApIHtcclxuXHJcblx0XHRcdGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy51djtcclxuXHJcblx0XHRcdGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGF0dHJpYnV0ZS5jb3B5VmVjdG9yMnNBcnJheSggZ2VvbWV0cnkudXZzICk7XHJcblx0XHRcdFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGdlb21ldHJ5LnV2c05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZSApIHtcclxuXHJcblx0XHRcdGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy5saW5lRGlzdGFuY2U7XHJcblxyXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRhdHRyaWJ1dGUuY29weUFycmF5KCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzICk7XHJcblx0XHRcdFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGdlb21ldHJ5LmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZSApIHtcclxuXHJcblx0XHRcdGdlb21ldHJ5LmNvbXB1dGVHcm91cHMoIG9iamVjdC5nZW9tZXRyeSApO1xyXG5cdFx0XHR0aGlzLmdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcclxuXHJcblx0XHRcdGdlb21ldHJ5Lmdyb3Vwc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21HZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHRnZW9tZXRyeS5fX2RpcmVjdEdlb21ldHJ5ID0gbmV3IERpcmVjdEdlb21ldHJ5KCkuZnJvbUdlb21ldHJ5KCBnZW9tZXRyeSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmZyb21EaXJlY3RHZW9tZXRyeSggZ2VvbWV0cnkuX19kaXJlY3RHZW9tZXRyeSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmcm9tRGlyZWN0R2VvbWV0cnk6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0dmFyIHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCAqIDMgKTtcclxuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIDMgKS5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkudmVydGljZXMgKSApO1xyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkubm9ybWFscy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0dmFyIG5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS5ub3JtYWxzLmxlbmd0aCAqIDMgKTtcclxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5Lm5vcm1hbHMgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmNvbG9ycy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0dmFyIGNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LmNvbG9ycy5sZW5ndGggKiAzICk7XHJcblx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKS5jb3B5Q29sb3JzQXJyYXkoIGdlb21ldHJ5LmNvbG9ycyApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkudXZzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHR2YXIgdXZzID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudXZzLmxlbmd0aCAqIDIgKTtcclxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApLmNvcHlWZWN0b3Iyc0FycmF5KCBnZW9tZXRyeS51dnMgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LnV2czIubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdHZhciB1dnMyID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudXZzMi5sZW5ndGggKiAyICk7XHJcblx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYyJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggdXZzMiwgMiApLmNvcHlWZWN0b3Iyc0FycmF5KCBnZW9tZXRyeS51dnMyICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZ3JvdXBzXHJcblxyXG5cdFx0dGhpcy5ncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XHJcblxyXG5cdFx0Ly8gbW9ycGhzXHJcblxyXG5cdFx0Zm9yICggdmFyIG5hbWUgaW4gZ2VvbWV0cnkubW9ycGhUYXJnZXRzICkge1xyXG5cclxuXHRcdFx0dmFyIGFycmF5ID0gW107XHJcblx0XHRcdHZhciBtb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIG5hbWUgXTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgbW9ycGhUYXJnZXQgPSBtb3JwaFRhcmdldHNbIGkgXTtcclxuXHJcblx0XHRcdFx0dmFyIGF0dHJpYnV0ZSA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBtb3JwaFRhcmdldC5kYXRhLmxlbmd0aCAqIDMsIDMgKTtcclxuXHRcdFx0XHRhdHRyaWJ1dGUubmFtZSA9IG1vcnBoVGFyZ2V0Lm5hbWU7XHJcblxyXG5cdFx0XHRcdGFycmF5LnB1c2goIGF0dHJpYnV0ZS5jb3B5VmVjdG9yM3NBcnJheSggbW9ycGhUYXJnZXQuZGF0YSApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLm1vcnBoQXR0cmlidXRlc1sgbmFtZSBdID0gYXJyYXk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHNraW5uaW5nXHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0dmFyIHNraW5JbmRpY2VzID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCAqIDQsIDQgKTtcclxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdza2luSW5kZXgnLCBza2luSW5kaWNlcy5jb3B5VmVjdG9yNHNBcnJheSggZ2VvbWV0cnkuc2tpbkluZGljZXMgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHR2YXIgc2tpbldlaWdodHMgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoICogNCwgNCApO1xyXG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3NraW5XZWlnaHQnLCBza2luV2VpZ2h0cy5jb3B5VmVjdG9yNHNBcnJheSggZ2VvbWV0cnkuc2tpbldlaWdodHMgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBnZW9tZXRyeS5ib3VuZGluZ0JveC5jbG9uZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29tcHV0ZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IG5ldyBCb3gzKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwb3NpdGlvbiA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuXHJcblx0XHRpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94LnNldEZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMuYm91bmRpbmdCb3gubWFrZUVtcHR5KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnggKSB8fCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueSApIHx8IGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi56ICkgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnQ09PTC5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3g6IENvbXB1dGVkIG1pbi9tYXggaGF2ZSBOYU4gdmFsdWVzLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsIHRoaXMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbXB1dGVCb3VuZGluZ1NwaGVyZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBib3ggPSBuZXcgQm94MygpO1xyXG5cdFx0dmFyIHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpIHtcclxuXHJcblx0XHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBTcGhlcmUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBwb3NpdGlvbiA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuXHJcblx0XHRcdGlmICggcG9zaXRpb24gKSB7XHJcblxyXG5cdFx0XHRcdHZhciBjZW50ZXIgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlcjtcclxuXHJcblx0XHRcdFx0Ym94LnNldEZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uICk7XHJcblx0XHRcdFx0Ym94LmdldENlbnRlciggY2VudGVyICk7XHJcblxyXG5cdFx0XHRcdC8vIGhvcGluZyB0byBmaW5kIGEgYm91bmRpbmdTcGhlcmUgd2l0aCBhIHJhZGl1cyBzbWFsbGVyIHRoYW4gdGhlXHJcblx0XHRcdFx0Ly8gYm91bmRpbmdTcGhlcmUgb2YgdGhlIGJvdW5kaW5nQm94OiBzcXJ0KDMpIHNtYWxsZXIgaW4gdGhlIGJlc3QgY2FzZVxyXG5cclxuXHRcdFx0XHR2YXIgbWF4UmFkaXVzU3EgPSAwO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb24uY291bnQ7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHR2ZWN0b3IueCA9IHBvc2l0aW9uLmdldFgoIGkgKTtcclxuXHRcdFx0XHRcdHZlY3Rvci55ID0gcG9zaXRpb24uZ2V0WSggaSApO1xyXG5cdFx0XHRcdFx0dmVjdG9yLnogPSBwb3NpdGlvbi5nZXRaKCBpICk7XHJcblx0XHRcdFx0XHRtYXhSYWRpdXNTcSA9IE1hdGgubWF4KCBtYXhSYWRpdXNTcSwgY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCB2ZWN0b3IgKSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzID0gTWF0aC5zcXJ0KCBtYXhSYWRpdXNTcSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGlzTmFOKCB0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cyApICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdDT09MLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpOiBDb21wdXRlZCByYWRpdXMgaXMgTmFOLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsIHRoaXMgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Y29tcHV0ZUZhY2VOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcclxuXHJcblx0fSxcclxuXHJcblx0Y29tcHV0ZVZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xyXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0aWYgKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICkge1xyXG5cclxuXHRcdFx0dmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblxyXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZXMubm9ybWFsID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggcG9zaXRpb25zLmxlbmd0aCApLCAzICkgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIHJlc2V0IGV4aXN0aW5nIG5vcm1hbHMgdG8gemVyb1xyXG5cclxuXHRcdFx0XHR2YXIgYXJyYXkgPSBhdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGFycmF5WyBpIF0gPSAwO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgbm9ybWFscyA9IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xyXG5cclxuXHRcdFx0dmFyIHZBLCB2QiwgdkM7XHJcblx0XHRcdHZhciBwQSA9IG5ldyBWZWN0b3IzKCksIHBCID0gbmV3IFZlY3RvcjMoKSwgcEMgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0XHR2YXIgY2IgPSBuZXcgVmVjdG9yMygpLCBhYiA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHQvLyBpbmRleGVkIGVsZW1lbnRzXHJcblxyXG5cdFx0XHRpZiAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0XHR2YXIgaW5kaWNlcyA9IGluZGV4LmFycmF5O1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gaW5kZXguY291bnQ7IGkgPCBpbDsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0XHRcdHZBID0gaW5kaWNlc1sgaSArIDAgXSAqIDM7XHJcblx0XHRcdFx0XHR2QiA9IGluZGljZXNbIGkgKyAxIF0gKiAzO1xyXG5cdFx0XHRcdFx0dkMgPSBpbmRpY2VzWyBpICsgMiBdICogMztcclxuXHJcblx0XHRcdFx0XHRwQS5mcm9tQXJyYXkoIHBvc2l0aW9ucywgdkEgKTtcclxuXHRcdFx0XHRcdHBCLmZyb21BcnJheSggcG9zaXRpb25zLCB2QiApO1xyXG5cdFx0XHRcdFx0cEMuZnJvbUFycmF5KCBwb3NpdGlvbnMsIHZDICk7XHJcblxyXG5cdFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggcEMsIHBCICk7XHJcblx0XHRcdFx0XHRhYi5zdWJWZWN0b3JzKCBwQSwgcEIgKTtcclxuXHRcdFx0XHRcdGNiLmNyb3NzKCBhYiApO1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbHNbIHZBIF0gKz0gY2IueDtcclxuXHRcdFx0XHRcdG5vcm1hbHNbIHZBICsgMSBdICs9IGNiLnk7XHJcblx0XHRcdFx0XHRub3JtYWxzWyB2QSArIDIgXSArPSBjYi56O1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbHNbIHZCIF0gKz0gY2IueDtcclxuXHRcdFx0XHRcdG5vcm1hbHNbIHZCICsgMSBdICs9IGNiLnk7XHJcblx0XHRcdFx0XHRub3JtYWxzWyB2QiArIDIgXSArPSBjYi56O1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbHNbIHZDIF0gKz0gY2IueDtcclxuXHRcdFx0XHRcdG5vcm1hbHNbIHZDICsgMSBdICs9IGNiLnk7XHJcblx0XHRcdFx0XHRub3JtYWxzWyB2QyArIDIgXSArPSBjYi56O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyBub24taW5kZXhlZCBlbGVtZW50cyAodW5jb25uZWN0ZWQgdHJpYW5nbGUgc291cClcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArPSA5ICkge1xyXG5cclxuXHRcdFx0XHRcdHBBLmZyb21BcnJheSggcG9zaXRpb25zLCBpICk7XHJcblx0XHRcdFx0XHRwQi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSArIDMgKTtcclxuXHRcdFx0XHRcdHBDLmZyb21BcnJheSggcG9zaXRpb25zLCBpICsgNiApO1xyXG5cclxuXHRcdFx0XHRcdGNiLnN1YlZlY3RvcnMoIHBDLCBwQiApO1xyXG5cdFx0XHRcdFx0YWIuc3ViVmVjdG9ycyggcEEsIHBCICk7XHJcblx0XHRcdFx0XHRjYi5jcm9zcyggYWIgKTtcclxuXHJcblx0XHRcdFx0XHRub3JtYWxzWyBpIF0gPSBjYi54O1xyXG5cdFx0XHRcdFx0bm9ybWFsc1sgaSArIDEgXSA9IGNiLnk7XHJcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgMiBdID0gY2IuejtcclxuXHJcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgMyBdID0gY2IueDtcclxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyA0IF0gPSBjYi55O1xyXG5cdFx0XHRcdFx0bm9ybWFsc1sgaSArIDUgXSA9IGNiLno7XHJcblxyXG5cdFx0XHRcdFx0bm9ybWFsc1sgaSArIDYgXSA9IGNiLng7XHJcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgNyBdID0gY2IueTtcclxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyA4IF0gPSBjYi56O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLm5vcm1hbGl6ZU5vcm1hbHMoKTtcclxuXHJcblx0XHRcdGF0dHJpYnV0ZXMubm9ybWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdG1lcmdlOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCAhICggZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ0NPT0wuQnVmZmVyR2VvbWV0cnkubWVyZ2UoKTogZ2VvbWV0cnkgbm90IGFuIGluc3RhbmNlIG9mIENPT0wuQnVmZmVyR2VvbWV0cnkuJywgZ2VvbWV0cnkgKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0b2Zmc2V0ID0gMDtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybihcclxuXHRcdFx0XHQnQ09PTC5CdWZmZXJHZW9tZXRyeS5tZXJnZSgpOiBPdmVyd3JpdGluZyBvcmlnaW5hbCBnZW9tZXRyeSwgc3RhcnRpbmcgYXQgb2Zmc2V0PTAuICdcclxuXHRcdFx0XHQrICdVc2UgQnVmZmVyR2VvbWV0cnlVdGlscy5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmb3IgbG9zc2xlc3MgbWVyZ2UuJ1xyXG5cdFx0XHQpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcclxuXHJcblx0XHRmb3IgKCB2YXIga2V5IGluIGF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmF0dHJpYnV0ZXNbIGtleSBdID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdHZhciBhdHRyaWJ1dGUxID0gYXR0cmlidXRlc1sga2V5IF07XHJcblx0XHRcdHZhciBhdHRyaWJ1dGVBcnJheTEgPSBhdHRyaWJ1dGUxLmFycmF5O1xyXG5cclxuXHRcdFx0dmFyIGF0dHJpYnV0ZTIgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBrZXkgXTtcclxuXHRcdFx0dmFyIGF0dHJpYnV0ZUFycmF5MiA9IGF0dHJpYnV0ZTIuYXJyYXk7XHJcblxyXG5cdFx0XHR2YXIgYXR0cmlidXRlU2l6ZSA9IGF0dHJpYnV0ZTIuaXRlbVNpemU7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGogPSBhdHRyaWJ1dGVTaXplICogb2Zmc2V0OyBpIDwgYXR0cmlidXRlQXJyYXkyLmxlbmd0aDsgaSArKywgaiArKyApIHtcclxuXHJcblx0XHRcdFx0YXR0cmlidXRlQXJyYXkxWyBqIF0gPSBhdHRyaWJ1dGVBcnJheTJbIGkgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5vcm1hbGl6ZU5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gbm9ybWFsaXplTm9ybWFscygpIHtcclxuXHJcblx0XHRcdHZhciBub3JtYWxzID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBub3JtYWxzLmNvdW50OyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZlY3Rvci54ID0gbm9ybWFscy5nZXRYKCBpICk7XHJcblx0XHRcdFx0dmVjdG9yLnkgPSBub3JtYWxzLmdldFkoIGkgKTtcclxuXHRcdFx0XHR2ZWN0b3IueiA9IG5vcm1hbHMuZ2V0WiggaSApO1xyXG5cclxuXHRcdFx0XHR2ZWN0b3Iubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHRcdG5vcm1hbHMuc2V0WFlaKCBpLCB2ZWN0b3IueCwgdmVjdG9yLnksIHZlY3Rvci56ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHR0b05vbkluZGV4ZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuaW5kZXggPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdDT09MLkJ1ZmZlckdlb21ldHJ5LnRvTm9uSW5kZXhlZCgpOiBHZW9tZXRyeSBpcyBhbHJlYWR5IG5vbi1pbmRleGVkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBnZW9tZXRyeTIgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcclxuXHJcblx0XHR2YXIgaW5kaWNlcyA9IHRoaXMuaW5kZXguYXJyYXk7XHJcblx0XHR2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcclxuXHJcblx0XHRmb3IgKCB2YXIgbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0dmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIG5hbWUgXTtcclxuXHJcblx0XHRcdHZhciBhcnJheSA9IGF0dHJpYnV0ZS5hcnJheTtcclxuXHRcdFx0dmFyIGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xyXG5cclxuXHRcdFx0dmFyIGFycmF5MiA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvciggaW5kaWNlcy5sZW5ndGggKiBpdGVtU2l6ZSApO1xyXG5cclxuXHRcdFx0dmFyIGluZGV4ID0gMCwgaW5kZXgyID0gMDtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0aW5kZXggPSBpbmRpY2VzWyBpIF0gKiBpdGVtU2l6ZTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgaXRlbVNpemU7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0YXJyYXkyWyBpbmRleDIgKysgXSA9IGFycmF5WyBpbmRleCArKyBdO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRnZW9tZXRyeTIuYWRkQXR0cmlidXRlKCBuYW1lLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBhcnJheTIsIGl0ZW1TaXplICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGdyb3VwID0gZ3JvdXBzWyBpIF07XHJcblx0XHRcdGdlb21ldHJ5Mi5hZGRHcm91cCggZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50LCBncm91cC5tYXRlcmlhbEluZGV4ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBnZW9tZXRyeTI7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvSlNPTjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRtZXRhZGF0YToge1xyXG5cdFx0XHRcdHZlcnNpb246IDQuNSxcclxuXHRcdFx0XHR0eXBlOiAnQnVmZmVyR2VvbWV0cnknLFxyXG5cdFx0XHRcdGdlbmVyYXRvcjogJ0J1ZmZlckdlb21ldHJ5LnRvSlNPTidcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBzdGFuZGFyZCBCdWZmZXJHZW9tZXRyeSBzZXJpYWxpemF0aW9uXHJcblxyXG5cdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xyXG5cdFx0ZGF0YS50eXBlID0gdGhpcy50eXBlO1xyXG5cdFx0aWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xyXG5cdFx0aWYgKCBPYmplY3Qua2V5cyggdGhpcy51c2VyRGF0YSApLmxlbmd0aCA+IDAgKSBkYXRhLnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YTtcclxuXHJcblx0XHRpZiAoIHRoaXMucGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIga2V5IGluIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggcGFyYW1ldGVyc1sga2V5IF0gIT09IHVuZGVmaW5lZCApIGRhdGFbIGtleSBdID0gcGFyYW1ldGVyc1sga2V5IF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZGF0YS5kYXRhID0geyBhdHRyaWJ1dGVzOiB7fSB9O1xyXG5cclxuXHRcdHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XHJcblxyXG5cdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHZhciBhcnJheSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBpbmRleC5hcnJheSApO1xyXG5cclxuXHRcdFx0ZGF0YS5kYXRhLmluZGV4ID0ge1xyXG5cdFx0XHRcdHR5cGU6IGluZGV4LmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXHJcblx0XHRcdFx0YXJyYXk6IGFycmF5XHJcblx0XHRcdH07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xyXG5cclxuXHRcdGZvciAoIHZhciBrZXkgaW4gYXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcclxuXHJcblx0XHRcdHZhciBhcnJheSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhdHRyaWJ1dGUuYXJyYXkgKTtcclxuXHJcblx0XHRcdGRhdGEuZGF0YS5hdHRyaWJ1dGVzWyBrZXkgXSA9IHtcclxuXHRcdFx0XHRpdGVtU2l6ZTogYXR0cmlidXRlLml0ZW1TaXplLFxyXG5cdFx0XHRcdHR5cGU6IGF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLFxyXG5cdFx0XHRcdGFycmF5OiBhcnJheSxcclxuXHRcdFx0XHRub3JtYWxpemVkOiBhdHRyaWJ1dGUubm9ybWFsaXplZFxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZ3JvdXBzID0gdGhpcy5ncm91cHM7XHJcblxyXG5cdFx0aWYgKCBncm91cHMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdGRhdGEuZGF0YS5ncm91cHMgPSBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSggZ3JvdXBzICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGJvdW5kaW5nU3BoZXJlID0gdGhpcy5ib3VuZGluZ1NwaGVyZTtcclxuXHJcblx0XHRpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0ZGF0YS5kYXRhLmJvdW5kaW5nU3BoZXJlID0ge1xyXG5cdFx0XHRcdGNlbnRlcjogYm91bmRpbmdTcGhlcmUuY2VudGVyLnRvQXJyYXkoKSxcclxuXHRcdFx0XHRyYWRpdXM6IGJvdW5kaW5nU3BoZXJlLnJhZGl1c1xyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvKlxyXG5cdFx0IC8vIEhhbmRsZSBwcmltaXRpdmVzXHJcblxyXG5cdFx0IHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xyXG5cclxuXHRcdCBpZiAoIHBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHQgdmFyIHZhbHVlcyA9IFtdO1xyXG5cclxuXHRcdCBmb3IgKCB2YXIga2V5IGluIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFx0IHZhbHVlcy5wdXNoKCBwYXJhbWV0ZXJzWyBrZXkgXSApO1xyXG5cclxuXHRcdCB9XHJcblxyXG5cdFx0IHZhciBnZW9tZXRyeSA9IE9iamVjdC5jcmVhdGUoIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlICk7XHJcblx0XHQgdGhpcy5jb25zdHJ1Y3Rvci5hcHBseSggZ2VvbWV0cnksIHZhbHVlcyApO1xyXG5cdFx0IHJldHVybiBnZW9tZXRyeTtcclxuXHJcblx0XHQgfVxyXG5cclxuXHRcdCByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblx0XHQgKi9cclxuXHJcblx0XHRyZXR1cm4gbmV3IEJ1ZmZlckdlb21ldHJ5KCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0XHR2YXIgbmFtZSwgaSwgbDtcclxuXHJcblx0XHQvLyByZXNldFxyXG5cclxuXHRcdHRoaXMuaW5kZXggPSBudWxsO1xyXG5cdFx0dGhpcy5hdHRyaWJ1dGVzID0ge307XHJcblx0XHR0aGlzLm1vcnBoQXR0cmlidXRlcyA9IHt9O1xyXG5cdFx0dGhpcy5ncm91cHMgPSBbXTtcclxuXHRcdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xyXG5cdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XHJcblxyXG5cdFx0Ly8gbmFtZVxyXG5cclxuXHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xyXG5cclxuXHRcdC8vIGluZGV4XHJcblxyXG5cdFx0dmFyIGluZGV4ID0gc291cmNlLmluZGV4O1xyXG5cclxuXHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnNldEluZGV4KCBpbmRleC5jbG9uZSgpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGF0dHJpYnV0ZXNcclxuXHJcblx0XHR2YXIgYXR0cmlidXRlcyA9IHNvdXJjZS5hdHRyaWJ1dGVzO1xyXG5cclxuXHRcdGZvciAoIG5hbWUgaW4gYXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XHJcblx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCBuYW1lLCBhdHRyaWJ1dGUuY2xvbmUoKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBtb3JwaCBhdHRyaWJ1dGVzXHJcblxyXG5cdFx0dmFyIG1vcnBoQXR0cmlidXRlcyA9IHNvdXJjZS5tb3JwaEF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0Zm9yICggbmFtZSBpbiBtb3JwaEF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHR2YXIgYXJyYXkgPSBbXTtcclxuXHRcdFx0dmFyIG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF07IC8vIG1vcnBoQXR0cmlidXRlOiBhcnJheSBvZiBGbG9hdDMyQnVmZmVyQXR0cmlidXRlc1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBtb3JwaEF0dHJpYnV0ZS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRhcnJheS5wdXNoKCBtb3JwaEF0dHJpYnV0ZVsgaSBdLmNsb25lKCkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMubW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF0gPSBhcnJheTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZ3JvdXBzXHJcblxyXG5cdFx0dmFyIGdyb3VwcyA9IHNvdXJjZS5ncm91cHM7XHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGwgPSBncm91cHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xyXG5cdFx0XHR0aGlzLmFkZEdyb3VwKCBncm91cC5zdGFydCwgZ3JvdXAuY291bnQsIGdyb3VwLm1hdGVyaWFsSW5kZXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYm91bmRpbmcgYm94XHJcblxyXG5cdFx0dmFyIGJvdW5kaW5nQm94ID0gc291cmNlLmJvdW5kaW5nQm94O1xyXG5cclxuXHRcdGlmICggYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gYm91bmRpbmdCb3guY2xvbmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYm91bmRpbmcgc3BoZXJlXHJcblxyXG5cdFx0dmFyIGJvdW5kaW5nU3BoZXJlID0gc291cmNlLmJvdW5kaW5nU3BoZXJlO1xyXG5cclxuXHRcdGlmICggYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZHJhdyByYW5nZVxyXG5cclxuXHRcdHRoaXMuZHJhd1JhbmdlLnN0YXJ0ID0gc291cmNlLmRyYXdSYW5nZS5zdGFydDtcclxuXHRcdHRoaXMuZHJhd1JhbmdlLmNvdW50ID0gc291cmNlLmRyYXdSYW5nZS5jb3VudDtcclxuXHJcblx0XHQvLyB1c2VyIGRhdGFcclxuXHJcblx0XHR0aGlzLnVzZXJEYXRhID0gc291cmNlLnVzZXJEYXRhO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuXHJcblxyXG5leHBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9O1xyXG4iLCIvKipcclxuICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcclxuICogUG9ydCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvZWFyY3V0ICh2Mi4xLjIpXHJcbiAqL1xyXG5cclxudmFyIEVhcmN1dCA9IHtcclxuXHJcblx0dHJpYW5ndWxhdGU6IGZ1bmN0aW9uICggZGF0YSwgaG9sZUluZGljZXMsIGRpbSApIHtcclxuXHJcblx0XHRkaW0gPSBkaW0gfHwgMjtcclxuXHJcblx0XHR2YXIgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGgsXHJcblx0XHRcdG91dGVyTGVuID0gaGFzSG9sZXMgPyBob2xlSW5kaWNlc1sgMCBdICogZGltIDogZGF0YS5sZW5ndGgsXHJcblx0XHRcdG91dGVyTm9kZSA9IGxpbmtlZExpc3QoIGRhdGEsIDAsIG91dGVyTGVuLCBkaW0sIHRydWUgKSxcclxuXHRcdFx0dHJpYW5nbGVzID0gW107XHJcblxyXG5cdFx0aWYgKCAhIG91dGVyTm9kZSApIHJldHVybiB0cmlhbmdsZXM7XHJcblxyXG5cdFx0dmFyIG1pblgsIG1pblksIG1heFgsIG1heFksIHgsIHksIGludlNpemU7XHJcblxyXG5cdFx0aWYgKCBoYXNIb2xlcyApIG91dGVyTm9kZSA9IGVsaW1pbmF0ZUhvbGVzKCBkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0gKTtcclxuXHJcblx0XHQvLyBpZiB0aGUgc2hhcGUgaXMgbm90IHRvbyBzaW1wbGUsIHdlJ2xsIHVzZSB6LW9yZGVyIGN1cnZlIGhhc2ggbGF0ZXI7IGNhbGN1bGF0ZSBwb2x5Z29uIGJib3hcclxuXHJcblx0XHRpZiAoIGRhdGEubGVuZ3RoID4gODAgKiBkaW0gKSB7XHJcblxyXG5cdFx0XHRtaW5YID0gbWF4WCA9IGRhdGFbIDAgXTtcclxuXHRcdFx0bWluWSA9IG1heFkgPSBkYXRhWyAxIF07XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IGRpbTsgaSA8IG91dGVyTGVuOyBpICs9IGRpbSApIHtcclxuXHJcblx0XHRcdFx0eCA9IGRhdGFbIGkgXTtcclxuXHRcdFx0XHR5ID0gZGF0YVsgaSArIDEgXTtcclxuXHRcdFx0XHRpZiAoIHggPCBtaW5YICkgbWluWCA9IHg7XHJcblx0XHRcdFx0aWYgKCB5IDwgbWluWSApIG1pblkgPSB5O1xyXG5cdFx0XHRcdGlmICggeCA+IG1heFggKSBtYXhYID0geDtcclxuXHRcdFx0XHRpZiAoIHkgPiBtYXhZICkgbWF4WSA9IHk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBtaW5YLCBtaW5ZIGFuZCBpbnZTaXplIGFyZSBsYXRlciB1c2VkIHRvIHRyYW5zZm9ybSBjb29yZHMgaW50byBpbnRlZ2VycyBmb3Igei1vcmRlciBjYWxjdWxhdGlvblxyXG5cclxuXHRcdFx0aW52U2l6ZSA9IE1hdGgubWF4KCBtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkgKTtcclxuXHRcdFx0aW52U2l6ZSA9IGludlNpemUgIT09IDAgPyAxIC8gaW52U2l6ZSA6IDA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGVhcmN1dExpbmtlZCggb3V0ZXJOb2RlLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSApO1xyXG5cclxuXHRcdHJldHVybiB0cmlhbmdsZXM7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBjcmVhdGUgYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QgZnJvbSBwb2x5Z29uIHBvaW50cyBpbiB0aGUgc3BlY2lmaWVkIHdpbmRpbmcgb3JkZXJcclxuXHJcbmZ1bmN0aW9uIGxpbmtlZExpc3QoIGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgY2xvY2t3aXNlICkge1xyXG5cclxuXHR2YXIgaSwgbGFzdDtcclxuXHJcblx0aWYgKCBjbG9ja3dpc2UgPT09ICggc2lnbmVkQXJlYSggZGF0YSwgc3RhcnQsIGVuZCwgZGltICkgPiAwICkgKSB7XHJcblxyXG5cdFx0Zm9yICggaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IGRpbSApIGxhc3QgPSBpbnNlcnROb2RlKCBpLCBkYXRhWyBpIF0sIGRhdGFbIGkgKyAxIF0sIGxhc3QgKTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRmb3IgKCBpID0gZW5kIC0gZGltOyBpID49IHN0YXJ0OyBpIC09IGRpbSApIGxhc3QgPSBpbnNlcnROb2RlKCBpLCBkYXRhWyBpIF0sIGRhdGFbIGkgKyAxIF0sIGxhc3QgKTtcclxuXHJcblx0fVxyXG5cclxuXHRpZiAoIGxhc3QgJiYgZXF1YWxzKCBsYXN0LCBsYXN0Lm5leHQgKSApIHtcclxuXHJcblx0XHRyZW1vdmVOb2RlKCBsYXN0ICk7XHJcblx0XHRsYXN0ID0gbGFzdC5uZXh0O1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBsYXN0O1xyXG5cclxufVxyXG5cclxuLy8gZWxpbWluYXRlIGNvbGluZWFyIG9yIGR1cGxpY2F0ZSBwb2ludHNcclxuXHJcbmZ1bmN0aW9uIGZpbHRlclBvaW50cyggc3RhcnQsIGVuZCApIHtcclxuXHJcblx0aWYgKCAhIHN0YXJ0ICkgcmV0dXJuIHN0YXJ0O1xyXG5cdGlmICggISBlbmQgKSBlbmQgPSBzdGFydDtcclxuXHJcblx0dmFyIHAgPSBzdGFydCwgYWdhaW47XHJcblxyXG5cdGRvIHtcclxuXHJcblx0XHRhZ2FpbiA9IGZhbHNlO1xyXG5cclxuXHRcdGlmICggISBwLnN0ZWluZXIgJiYgKCBlcXVhbHMoIHAsIHAubmV4dCApIHx8IGFyZWEoIHAucHJldiwgcCwgcC5uZXh0ICkgPT09IDAgKSApIHtcclxuXHJcblx0XHRcdHJlbW92ZU5vZGUoIHAgKTtcclxuXHRcdFx0cCA9IGVuZCA9IHAucHJldjtcclxuXHRcdFx0aWYgKCBwID09PSBwLm5leHQgKSBicmVhaztcclxuXHRcdFx0YWdhaW4gPSB0cnVlO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRwID0gcC5uZXh0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSB3aGlsZSAoIGFnYWluIHx8IHAgIT09IGVuZCApO1xyXG5cclxuXHRyZXR1cm4gZW5kO1xyXG5cclxufVxyXG5cclxuLy8gbWFpbiBlYXIgc2xpY2luZyBsb29wIHdoaWNoIHRyaWFuZ3VsYXRlcyBhIHBvbHlnb24gKGdpdmVuIGFzIGEgbGlua2VkIGxpc3QpXHJcblxyXG5mdW5jdGlvbiBlYXJjdXRMaW5rZWQoIGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIHBhc3MgKSB7XHJcblxyXG5cdGlmICggISBlYXIgKSByZXR1cm47XHJcblxyXG5cdC8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcclxuXHJcblx0aWYgKCAhIHBhc3MgJiYgaW52U2l6ZSApIGluZGV4Q3VydmUoIGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSApO1xyXG5cclxuXHR2YXIgc3RvcCA9IGVhciwgcHJldiwgbmV4dDtcclxuXHJcblx0Ly8gaXRlcmF0ZSB0aHJvdWdoIGVhcnMsIHNsaWNpbmcgdGhlbSBvbmUgYnkgb25lXHJcblxyXG5cdHdoaWxlICggZWFyLnByZXYgIT09IGVhci5uZXh0ICkge1xyXG5cclxuXHRcdHByZXYgPSBlYXIucHJldjtcclxuXHRcdG5leHQgPSBlYXIubmV4dDtcclxuXHJcblx0XHRpZiAoIGludlNpemUgPyBpc0Vhckhhc2hlZCggZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplICkgOiBpc0VhciggZWFyICkgKSB7XHJcblxyXG5cdFx0XHQvLyBjdXQgb2ZmIHRoZSB0cmlhbmdsZVxyXG5cdFx0XHR0cmlhbmdsZXMucHVzaCggcHJldi5pIC8gZGltICk7XHJcblx0XHRcdHRyaWFuZ2xlcy5wdXNoKCBlYXIuaSAvIGRpbSApO1xyXG5cdFx0XHR0cmlhbmdsZXMucHVzaCggbmV4dC5pIC8gZGltICk7XHJcblxyXG5cdFx0XHRyZW1vdmVOb2RlKCBlYXIgKTtcclxuXHJcblx0XHRcdC8vIHNraXBwaW5nIHRoZSBuZXh0IHZlcnRpY2UgbGVhZHMgdG8gbGVzcyBzbGl2ZXIgdHJpYW5nbGVzXHJcblx0XHRcdGVhciA9IG5leHQubmV4dDtcclxuXHRcdFx0c3RvcCA9IG5leHQubmV4dDtcclxuXHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRlYXIgPSBuZXh0O1xyXG5cclxuXHRcdC8vIGlmIHdlIGxvb3BlZCB0aHJvdWdoIHRoZSB3aG9sZSByZW1haW5pbmcgcG9seWdvbiBhbmQgY2FuJ3QgZmluZCBhbnkgbW9yZSBlYXJzXHJcblxyXG5cdFx0aWYgKCBlYXIgPT09IHN0b3AgKSB7XHJcblxyXG5cdFx0XHQvLyB0cnkgZmlsdGVyaW5nIHBvaW50cyBhbmQgc2xpY2luZyBhZ2FpblxyXG5cclxuXHRcdFx0aWYgKCAhIHBhc3MgKSB7XHJcblxyXG5cdFx0XHRcdGVhcmN1dExpbmtlZCggZmlsdGVyUG9pbnRzKCBlYXIgKSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDEgKTtcclxuXHJcblx0XHRcdFx0Ly8gaWYgdGhpcyBkaWRuJ3Qgd29yaywgdHJ5IGN1cmluZyBhbGwgc21hbGwgc2VsZi1pbnRlcnNlY3Rpb25zIGxvY2FsbHlcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHBhc3MgPT09IDEgKSB7XHJcblxyXG5cdFx0XHRcdGVhciA9IGN1cmVMb2NhbEludGVyc2VjdGlvbnMoIGVhciwgdHJpYW5nbGVzLCBkaW0gKTtcclxuXHRcdFx0XHRlYXJjdXRMaW5rZWQoIGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDIgKTtcclxuXHJcblx0XHRcdFx0Ly8gYXMgYSBsYXN0IHJlc29ydCwgdHJ5IHNwbGl0dGluZyB0aGUgcmVtYWluaW5nIHBvbHlnb24gaW50byB0d29cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHBhc3MgPT09IDIgKSB7XHJcblxyXG5cdFx0XHRcdHNwbGl0RWFyY3V0KCBlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbi8vIGNoZWNrIHdoZXRoZXIgYSBwb2x5Z29uIG5vZGUgZm9ybXMgYSB2YWxpZCBlYXIgd2l0aCBhZGphY2VudCBub2Rlc1xyXG5cclxuZnVuY3Rpb24gaXNFYXIoIGVhciApIHtcclxuXHJcblx0dmFyIGEgPSBlYXIucHJldixcclxuXHRcdGIgPSBlYXIsXHJcblx0XHRjID0gZWFyLm5leHQ7XHJcblxyXG5cdGlmICggYXJlYSggYSwgYiwgYyApID49IDAgKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXHJcblxyXG5cdC8vIG5vdyBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZSBvdGhlciBwb2ludHMgaW5zaWRlIHRoZSBwb3RlbnRpYWwgZWFyXHJcblx0dmFyIHAgPSBlYXIubmV4dC5uZXh0O1xyXG5cclxuXHR3aGlsZSAoIHAgIT09IGVhci5wcmV2ICkge1xyXG5cclxuXHRcdGlmICggcG9pbnRJblRyaWFuZ2xlKCBhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSApICYmIGFyZWEoIHAucHJldiwgcCwgcC5uZXh0ICkgPj0gMCApIHtcclxuXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cCA9IHAubmV4dDtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdHJ1ZTtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRWFySGFzaGVkKCBlYXIsIG1pblgsIG1pblksIGludlNpemUgKSB7XHJcblxyXG5cdHZhciBhID0gZWFyLnByZXYsXHJcblx0XHRiID0gZWFyLFxyXG5cdFx0YyA9IGVhci5uZXh0O1xyXG5cclxuXHRpZiAoIGFyZWEoIGEsIGIsIGMgKSA+PSAwICkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxyXG5cclxuXHQvLyB0cmlhbmdsZSBiYm94OyBtaW4gJiBtYXggYXJlIGNhbGN1bGF0ZWQgbGlrZSB0aGlzIGZvciBzcGVlZFxyXG5cclxuXHR2YXIgbWluVFggPSBhLnggPCBiLnggPyAoIGEueCA8IGMueCA/IGEueCA6IGMueCApIDogKCBiLnggPCBjLnggPyBiLnggOiBjLnggKSxcclxuXHRcdG1pblRZID0gYS55IDwgYi55ID8gKCBhLnkgPCBjLnkgPyBhLnkgOiBjLnkgKSA6ICggYi55IDwgYy55ID8gYi55IDogYy55ICksXHJcblx0XHRtYXhUWCA9IGEueCA+IGIueCA/ICggYS54ID4gYy54ID8gYS54IDogYy54ICkgOiAoIGIueCA+IGMueCA/IGIueCA6IGMueCApLFxyXG5cdFx0bWF4VFkgPSBhLnkgPiBiLnkgPyAoIGEueSA+IGMueSA/IGEueSA6IGMueSApIDogKCBiLnkgPiBjLnkgPyBiLnkgOiBjLnkgKTtcclxuXHJcblx0Ly8gei1vcmRlciByYW5nZSBmb3IgdGhlIGN1cnJlbnQgdHJpYW5nbGUgYmJveDtcclxuXHJcblx0dmFyIG1pblogPSB6T3JkZXIoIG1pblRYLCBtaW5UWSwgbWluWCwgbWluWSwgaW52U2l6ZSApLFxyXG5cdFx0bWF4WiA9IHpPcmRlciggbWF4VFgsIG1heFRZLCBtaW5YLCBtaW5ZLCBpbnZTaXplICk7XHJcblxyXG5cdC8vIGZpcnN0IGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIGluIGluY3JlYXNpbmcgei1vcmRlclxyXG5cclxuXHR2YXIgcCA9IGVhci5uZXh0WjtcclxuXHJcblx0d2hpbGUgKCBwICYmIHAueiA8PSBtYXhaICkge1xyXG5cclxuXHRcdGlmICggcCAhPT0gZWFyLnByZXYgJiYgcCAhPT0gZWFyLm5leHQgJiZcclxuXHRcdFx0XHRwb2ludEluVHJpYW5nbGUoIGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55ICkgJiZcclxuXHRcdFx0XHRhcmVhKCBwLnByZXYsIHAsIHAubmV4dCApID49IDAgKSByZXR1cm4gZmFsc2U7XHJcblx0XHRwID0gcC5uZXh0WjtcclxuXHJcblx0fVxyXG5cclxuXHQvLyB0aGVuIGxvb2sgZm9yIHBvaW50cyBpbiBkZWNyZWFzaW5nIHotb3JkZXJcclxuXHJcblx0cCA9IGVhci5wcmV2WjtcclxuXHJcblx0d2hpbGUgKCBwICYmIHAueiA+PSBtaW5aICkge1xyXG5cclxuXHRcdGlmICggcCAhPT0gZWFyLnByZXYgJiYgcCAhPT0gZWFyLm5leHQgJiZcclxuXHRcdFx0XHRwb2ludEluVHJpYW5nbGUoIGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55ICkgJiZcclxuXHRcdFx0XHRhcmVhKCBwLnByZXYsIHAsIHAubmV4dCApID49IDAgKSByZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0cCA9IHAucHJldlo7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRydWU7XHJcblxyXG59XHJcblxyXG4vLyBnbyB0aHJvdWdoIGFsbCBwb2x5Z29uIG5vZGVzIGFuZCBjdXJlIHNtYWxsIGxvY2FsIHNlbGYtaW50ZXJzZWN0aW9uc1xyXG5cclxuZnVuY3Rpb24gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyggc3RhcnQsIHRyaWFuZ2xlcywgZGltICkge1xyXG5cclxuXHR2YXIgcCA9IHN0YXJ0O1xyXG5cclxuXHRkbyB7XHJcblxyXG5cdFx0dmFyIGEgPSBwLnByZXYsIGIgPSBwLm5leHQubmV4dDtcclxuXHJcblx0XHRpZiAoICEgZXF1YWxzKCBhLCBiICkgJiYgaW50ZXJzZWN0cyggYSwgcCwgcC5uZXh0LCBiICkgJiYgbG9jYWxseUluc2lkZSggYSwgYiApICYmIGxvY2FsbHlJbnNpZGUoIGIsIGEgKSApIHtcclxuXHJcblx0XHRcdHRyaWFuZ2xlcy5wdXNoKCBhLmkgLyBkaW0gKTtcclxuXHRcdFx0dHJpYW5nbGVzLnB1c2goIHAuaSAvIGRpbSApO1xyXG5cdFx0XHR0cmlhbmdsZXMucHVzaCggYi5pIC8gZGltICk7XHJcblxyXG5cdFx0XHQvLyByZW1vdmUgdHdvIG5vZGVzIGludm9sdmVkXHJcblxyXG5cdFx0XHRyZW1vdmVOb2RlKCBwICk7XHJcblx0XHRcdHJlbW92ZU5vZGUoIHAubmV4dCApO1xyXG5cclxuXHRcdFx0cCA9IHN0YXJ0ID0gYjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cCA9IHAubmV4dDtcclxuXHJcblx0fSB3aGlsZSAoIHAgIT09IHN0YXJ0ICk7XHJcblxyXG5cdHJldHVybiBwO1xyXG5cclxufVxyXG5cclxuLy8gdHJ5IHNwbGl0dGluZyBwb2x5Z29uIGludG8gdHdvIGFuZCB0cmlhbmd1bGF0ZSB0aGVtIGluZGVwZW5kZW50bHlcclxuXHJcbmZ1bmN0aW9uIHNwbGl0RWFyY3V0KCBzdGFydCwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUgKSB7XHJcblxyXG5cdC8vIGxvb2sgZm9yIGEgdmFsaWQgZGlhZ29uYWwgdGhhdCBkaXZpZGVzIHRoZSBwb2x5Z29uIGludG8gdHdvXHJcblxyXG5cdHZhciBhID0gc3RhcnQ7XHJcblxyXG5cdGRvIHtcclxuXHJcblx0XHR2YXIgYiA9IGEubmV4dC5uZXh0O1xyXG5cclxuXHRcdHdoaWxlICggYiAhPT0gYS5wcmV2ICkge1xyXG5cclxuXHRcdFx0aWYgKCBhLmkgIT09IGIuaSAmJiBpc1ZhbGlkRGlhZ29uYWwoIGEsIGIgKSApIHtcclxuXHJcblx0XHRcdFx0Ly8gc3BsaXQgdGhlIHBvbHlnb24gaW4gdHdvIGJ5IHRoZSBkaWFnb25hbFxyXG5cclxuXHRcdFx0XHR2YXIgYyA9IHNwbGl0UG9seWdvbiggYSwgYiApO1xyXG5cclxuXHRcdFx0XHQvLyBmaWx0ZXIgY29saW5lYXIgcG9pbnRzIGFyb3VuZCB0aGUgY3V0c1xyXG5cclxuXHRcdFx0XHRhID0gZmlsdGVyUG9pbnRzKCBhLCBhLm5leHQgKTtcclxuXHRcdFx0XHRjID0gZmlsdGVyUG9pbnRzKCBjLCBjLm5leHQgKTtcclxuXHJcblx0XHRcdFx0Ly8gcnVuIGVhcmN1dCBvbiBlYWNoIGhhbGZcclxuXHJcblx0XHRcdFx0ZWFyY3V0TGlua2VkKCBhLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSApO1xyXG5cdFx0XHRcdGVhcmN1dExpbmtlZCggYywgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUgKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRiID0gYi5uZXh0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRhID0gYS5uZXh0O1xyXG5cclxuXHR9IHdoaWxlICggYSAhPT0gc3RhcnQgKTtcclxuXHJcbn1cclxuXHJcbi8vIGxpbmsgZXZlcnkgaG9sZSBpbnRvIHRoZSBvdXRlciBsb29wLCBwcm9kdWNpbmcgYSBzaW5nbGUtcmluZyBwb2x5Z29uIHdpdGhvdXQgaG9sZXNcclxuXHJcbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGVzKCBkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0gKSB7XHJcblxyXG5cdHZhciBxdWV1ZSA9IFtdLCBpLCBsZW4sIHN0YXJ0LCBlbmQsIGxpc3Q7XHJcblxyXG5cdGZvciAoIGkgPSAwLCBsZW4gPSBob2xlSW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkgKysgKSB7XHJcblxyXG5cdFx0c3RhcnQgPSBob2xlSW5kaWNlc1sgaSBdICogZGltO1xyXG5cdFx0ZW5kID0gaSA8IGxlbiAtIDEgPyBob2xlSW5kaWNlc1sgaSArIDEgXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xyXG5cdFx0bGlzdCA9IGxpbmtlZExpc3QoIGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgZmFsc2UgKTtcclxuXHRcdGlmICggbGlzdCA9PT0gbGlzdC5uZXh0ICkgbGlzdC5zdGVpbmVyID0gdHJ1ZTtcclxuXHRcdHF1ZXVlLnB1c2goIGdldExlZnRtb3N0KCBsaXN0ICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRxdWV1ZS5zb3J0KCBjb21wYXJlWCApO1xyXG5cclxuXHQvLyBwcm9jZXNzIGhvbGVzIGZyb20gbGVmdCB0byByaWdodFxyXG5cclxuXHRmb3IgKCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRlbGltaW5hdGVIb2xlKCBxdWV1ZVsgaSBdLCBvdXRlck5vZGUgKTtcclxuXHRcdG91dGVyTm9kZSA9IGZpbHRlclBvaW50cyggb3V0ZXJOb2RlLCBvdXRlck5vZGUubmV4dCApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBvdXRlck5vZGU7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wYXJlWCggYSwgYiApIHtcclxuXHJcblx0cmV0dXJuIGEueCAtIGIueDtcclxuXHJcbn1cclxuXHJcbi8vIGZpbmQgYSBicmlkZ2UgYmV0d2VlbiB2ZXJ0aWNlcyB0aGF0IGNvbm5lY3RzIGhvbGUgd2l0aCBhbiBvdXRlciByaW5nIGFuZCBhbmQgbGluayBpdFxyXG5cclxuZnVuY3Rpb24gZWxpbWluYXRlSG9sZSggaG9sZSwgb3V0ZXJOb2RlICkge1xyXG5cclxuXHRvdXRlck5vZGUgPSBmaW5kSG9sZUJyaWRnZSggaG9sZSwgb3V0ZXJOb2RlICk7XHJcblxyXG5cdGlmICggb3V0ZXJOb2RlICkge1xyXG5cclxuXHRcdHZhciBiID0gc3BsaXRQb2x5Z29uKCBvdXRlck5vZGUsIGhvbGUgKTtcclxuXHJcblx0XHRmaWx0ZXJQb2ludHMoIGIsIGIubmV4dCApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG4vLyBEYXZpZCBFYmVybHkncyBhbGdvcml0aG0gZm9yIGZpbmRpbmcgYSBicmlkZ2UgYmV0d2VlbiBob2xlIGFuZCBvdXRlciBwb2x5Z29uXHJcblxyXG5mdW5jdGlvbiBmaW5kSG9sZUJyaWRnZSggaG9sZSwgb3V0ZXJOb2RlICkge1xyXG5cclxuXHR2YXIgcCA9IG91dGVyTm9kZSxcclxuXHRcdGh4ID0gaG9sZS54LFxyXG5cdFx0aHkgPSBob2xlLnksXHJcblx0XHRxeCA9IC0gSW5maW5pdHksXHJcblx0XHRtO1xyXG5cclxuXHQvLyBmaW5kIGEgc2VnbWVudCBpbnRlcnNlY3RlZCBieSBhIHJheSBmcm9tIHRoZSBob2xlJ3MgbGVmdG1vc3QgcG9pbnQgdG8gdGhlIGxlZnQ7XHJcblx0Ly8gc2VnbWVudCdzIGVuZHBvaW50IHdpdGggbGVzc2VyIHggd2lsbCBiZSBwb3RlbnRpYWwgY29ubmVjdGlvbiBwb2ludFxyXG5cclxuXHRkbyB7XHJcblxyXG5cdFx0aWYgKCBoeSA8PSBwLnkgJiYgaHkgPj0gcC5uZXh0LnkgJiYgcC5uZXh0LnkgIT09IHAueSApIHtcclxuXHJcblx0XHRcdHZhciB4ID0gcC54ICsgKCBoeSAtIHAueSApICogKCBwLm5leHQueCAtIHAueCApIC8gKCBwLm5leHQueSAtIHAueSApO1xyXG5cclxuXHRcdFx0aWYgKCB4IDw9IGh4ICYmIHggPiBxeCApIHtcclxuXHJcblx0XHRcdFx0cXggPSB4O1xyXG5cclxuXHRcdFx0XHRpZiAoIHggPT09IGh4ICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggaHkgPT09IHAueSApIHJldHVybiBwO1xyXG5cdFx0XHRcdFx0aWYgKCBoeSA9PT0gcC5uZXh0LnkgKSByZXR1cm4gcC5uZXh0O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdG0gPSBwLnggPCBwLm5leHQueCA/IHAgOiBwLm5leHQ7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHAgPSBwLm5leHQ7XHJcblxyXG5cdH0gd2hpbGUgKCBwICE9PSBvdXRlck5vZGUgKTtcclxuXHJcblx0aWYgKCAhIG0gKSByZXR1cm4gbnVsbDtcclxuXHJcblx0aWYgKCBoeCA9PT0gcXggKSByZXR1cm4gbS5wcmV2OyAvLyBob2xlIHRvdWNoZXMgb3V0ZXIgc2VnbWVudDsgcGljayBsb3dlciBlbmRwb2ludFxyXG5cclxuXHQvLyBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBvZiBob2xlIHBvaW50LCBzZWdtZW50IGludGVyc2VjdGlvbiBhbmQgZW5kcG9pbnQ7XHJcblx0Ly8gaWYgdGhlcmUgYXJlIG5vIHBvaW50cyBmb3VuZCwgd2UgaGF2ZSBhIHZhbGlkIGNvbm5lY3Rpb247XHJcblx0Ly8gb3RoZXJ3aXNlIGNob29zZSB0aGUgcG9pbnQgb2YgdGhlIG1pbmltdW0gYW5nbGUgd2l0aCB0aGUgcmF5IGFzIGNvbm5lY3Rpb24gcG9pbnRcclxuXHJcblx0dmFyIHN0b3AgPSBtLFxyXG5cdFx0bXggPSBtLngsXHJcblx0XHRteSA9IG0ueSxcclxuXHRcdHRhbk1pbiA9IEluZmluaXR5LFxyXG5cdFx0dGFuO1xyXG5cclxuXHRwID0gbS5uZXh0O1xyXG5cclxuXHR3aGlsZSAoIHAgIT09IHN0b3AgKSB7XHJcblxyXG5cdFx0aWYgKCBoeCA+PSBwLnggJiYgcC54ID49IG14ICYmIGh4ICE9PSBwLnggJiZcclxuXHRcdFx0XHRcdFx0cG9pbnRJblRyaWFuZ2xlKCBoeSA8IG15ID8gaHggOiBxeCwgaHksIG14LCBteSwgaHkgPCBteSA/IHF4IDogaHgsIGh5LCBwLngsIHAueSApICkge1xyXG5cclxuXHRcdFx0dGFuID0gTWF0aC5hYnMoIGh5IC0gcC55ICkgLyAoIGh4IC0gcC54ICk7IC8vIHRhbmdlbnRpYWxcclxuXHJcblx0XHRcdGlmICggKCB0YW4gPCB0YW5NaW4gfHwgKCB0YW4gPT09IHRhbk1pbiAmJiBwLnggPiBtLnggKSApICYmIGxvY2FsbHlJbnNpZGUoIHAsIGhvbGUgKSApIHtcclxuXHJcblx0XHRcdFx0bSA9IHA7XHJcblx0XHRcdFx0dGFuTWluID0gdGFuO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRwID0gcC5uZXh0O1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBtO1xyXG5cclxufVxyXG5cclxuLy8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxyXG5cclxuZnVuY3Rpb24gaW5kZXhDdXJ2ZSggc3RhcnQsIG1pblgsIG1pblksIGludlNpemUgKSB7XHJcblxyXG5cdHZhciBwID0gc3RhcnQ7XHJcblxyXG5cdGRvIHtcclxuXHJcblx0XHRpZiAoIHAueiA9PT0gbnVsbCApIHAueiA9IHpPcmRlciggcC54LCBwLnksIG1pblgsIG1pblksIGludlNpemUgKTtcclxuXHRcdHAucHJldlogPSBwLnByZXY7XHJcblx0XHRwLm5leHRaID0gcC5uZXh0O1xyXG5cdFx0cCA9IHAubmV4dDtcclxuXHJcblx0fSB3aGlsZSAoIHAgIT09IHN0YXJ0ICk7XHJcblxyXG5cdHAucHJldloubmV4dFogPSBudWxsO1xyXG5cdHAucHJldlogPSBudWxsO1xyXG5cclxuXHRzb3J0TGlua2VkKCBwICk7XHJcblxyXG59XHJcblxyXG4vLyBTaW1vbiBUYXRoYW0ncyBsaW5rZWQgbGlzdCBtZXJnZSBzb3J0IGFsZ29yaXRobVxyXG4vLyBodHRwOi8vd3d3LmNoaWFyay5ncmVlbmVuZC5vcmcudWsvfnNndGF0aGFtL2FsZ29yaXRobXMvbGlzdHNvcnQuaHRtbFxyXG5cclxuZnVuY3Rpb24gc29ydExpbmtlZCggbGlzdCApIHtcclxuXHJcblx0dmFyIGksIHAsIHEsIGUsIHRhaWwsIG51bU1lcmdlcywgcFNpemUsIHFTaXplLCBpblNpemUgPSAxO1xyXG5cclxuXHRkbyB7XHJcblxyXG5cdFx0cCA9IGxpc3Q7XHJcblx0XHRsaXN0ID0gbnVsbDtcclxuXHRcdHRhaWwgPSBudWxsO1xyXG5cdFx0bnVtTWVyZ2VzID0gMDtcclxuXHJcblx0XHR3aGlsZSAoIHAgKSB7XHJcblxyXG5cdFx0XHRudW1NZXJnZXMgKys7XHJcblx0XHRcdHEgPSBwO1xyXG5cdFx0XHRwU2l6ZSA9IDA7XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGluU2l6ZTsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0cFNpemUgKys7XHJcblx0XHRcdFx0cSA9IHEubmV4dFo7XHJcblx0XHRcdFx0aWYgKCAhIHEgKSBicmVhaztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHFTaXplID0gaW5TaXplO1xyXG5cclxuXHRcdFx0d2hpbGUgKCBwU2l6ZSA+IDAgfHwgKCBxU2l6ZSA+IDAgJiYgcSApICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHBTaXplICE9PSAwICYmICggcVNpemUgPT09IDAgfHwgISBxIHx8IHAueiA8PSBxLnogKSApIHtcclxuXHJcblx0XHRcdFx0XHRlID0gcDtcclxuXHRcdFx0XHRcdHAgPSBwLm5leHRaO1xyXG5cdFx0XHRcdFx0cFNpemUgLS07XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0ZSA9IHE7XHJcblx0XHRcdFx0XHRxID0gcS5uZXh0WjtcclxuXHRcdFx0XHRcdHFTaXplIC0tO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggdGFpbCApIHRhaWwubmV4dFogPSBlO1xyXG5cdFx0XHRcdGVsc2UgbGlzdCA9IGU7XHJcblxyXG5cdFx0XHRcdGUucHJldlogPSB0YWlsO1xyXG5cdFx0XHRcdHRhaWwgPSBlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cCA9IHE7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRhaWwubmV4dFogPSBudWxsO1xyXG5cdFx0aW5TaXplICo9IDI7XHJcblxyXG5cdH0gd2hpbGUgKCBudW1NZXJnZXMgPiAxICk7XHJcblxyXG5cdHJldHVybiBsaXN0O1xyXG5cclxufVxyXG5cclxuLy8gei1vcmRlciBvZiBhIHBvaW50IGdpdmVuIGNvb3JkcyBhbmQgaW52ZXJzZSBvZiB0aGUgbG9uZ2VyIHNpZGUgb2YgZGF0YSBiYm94XHJcblxyXG5mdW5jdGlvbiB6T3JkZXIoIHgsIHksIG1pblgsIG1pblksIGludlNpemUgKSB7XHJcblxyXG5cdC8vIGNvb3JkcyBhcmUgdHJhbnNmb3JtZWQgaW50byBub24tbmVnYXRpdmUgMTUtYml0IGludGVnZXIgcmFuZ2VcclxuXHJcblx0eCA9IDMyNzY3ICogKCB4IC0gbWluWCApICogaW52U2l6ZTtcclxuXHR5ID0gMzI3NjcgKiAoIHkgLSBtaW5ZICkgKiBpbnZTaXplO1xyXG5cclxuXHR4ID0gKCB4IHwgKCB4IDw8IDggKSApICYgMHgwMEZGMDBGRjtcclxuXHR4ID0gKCB4IHwgKCB4IDw8IDQgKSApICYgMHgwRjBGMEYwRjtcclxuXHR4ID0gKCB4IHwgKCB4IDw8IDIgKSApICYgMHgzMzMzMzMzMztcclxuXHR4ID0gKCB4IHwgKCB4IDw8IDEgKSApICYgMHg1NTU1NTU1NTtcclxuXHJcblx0eSA9ICggeSB8ICggeSA8PCA4ICkgKSAmIDB4MDBGRjAwRkY7XHJcblx0eSA9ICggeSB8ICggeSA8PCA0ICkgKSAmIDB4MEYwRjBGMEY7XHJcblx0eSA9ICggeSB8ICggeSA8PCAyICkgKSAmIDB4MzMzMzMzMzM7XHJcblx0eSA9ICggeSB8ICggeSA8PCAxICkgKSAmIDB4NTU1NTU1NTU7XHJcblxyXG5cdHJldHVybiB4IHwgKCB5IDw8IDEgKTtcclxuXHJcbn1cclxuXHJcbi8vIGZpbmQgdGhlIGxlZnRtb3N0IG5vZGUgb2YgYSBwb2x5Z29uIHJpbmdcclxuXHJcbmZ1bmN0aW9uIGdldExlZnRtb3N0KCBzdGFydCApIHtcclxuXHJcblx0dmFyIHAgPSBzdGFydCwgbGVmdG1vc3QgPSBzdGFydDtcclxuXHJcblx0ZG8ge1xyXG5cclxuXHRcdGlmICggcC54IDwgbGVmdG1vc3QueCApIGxlZnRtb3N0ID0gcDtcclxuXHRcdHAgPSBwLm5leHQ7XHJcblxyXG5cdH0gd2hpbGUgKCBwICE9PSBzdGFydCApO1xyXG5cclxuXHRyZXR1cm4gbGVmdG1vc3Q7XHJcblxyXG59XHJcblxyXG4vLyBjaGVjayBpZiBhIHBvaW50IGxpZXMgd2l0aGluIGEgY29udmV4IHRyaWFuZ2xlXHJcblxyXG5mdW5jdGlvbiBwb2ludEluVHJpYW5nbGUoIGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHB4LCBweSApIHtcclxuXHJcblx0cmV0dXJuICggY3ggLSBweCApICogKCBheSAtIHB5ICkgLSAoIGF4IC0gcHggKSAqICggY3kgLSBweSApID49IDAgJiZcclxuXHQgKCBheCAtIHB4ICkgKiAoIGJ5IC0gcHkgKSAtICggYnggLSBweCApICogKCBheSAtIHB5ICkgPj0gMCAmJlxyXG5cdCAoIGJ4IC0gcHggKSAqICggY3kgLSBweSApIC0gKCBjeCAtIHB4ICkgKiAoIGJ5IC0gcHkgKSA+PSAwO1xyXG5cclxufVxyXG5cclxuLy8gY2hlY2sgaWYgYSBkaWFnb25hbCBiZXR3ZWVuIHR3byBwb2x5Z29uIG5vZGVzIGlzIHZhbGlkIChsaWVzIGluIHBvbHlnb24gaW50ZXJpb3IpXHJcblxyXG5mdW5jdGlvbiBpc1ZhbGlkRGlhZ29uYWwoIGEsIGIgKSB7XHJcblxyXG5cdHJldHVybiBhLm5leHQuaSAhPT0gYi5pICYmIGEucHJldi5pICE9PSBiLmkgJiYgISBpbnRlcnNlY3RzUG9seWdvbiggYSwgYiApICYmXHJcblx0XHRsb2NhbGx5SW5zaWRlKCBhLCBiICkgJiYgbG9jYWxseUluc2lkZSggYiwgYSApICYmIG1pZGRsZUluc2lkZSggYSwgYiApO1xyXG5cclxufVxyXG5cclxuLy8gc2lnbmVkIGFyZWEgb2YgYSB0cmlhbmdsZVxyXG5cclxuZnVuY3Rpb24gYXJlYSggcCwgcSwgciApIHtcclxuXHJcblx0cmV0dXJuICggcS55IC0gcC55ICkgKiAoIHIueCAtIHEueCApIC0gKCBxLnggLSBwLnggKSAqICggci55IC0gcS55ICk7XHJcblxyXG59XHJcblxyXG4vLyBjaGVjayBpZiB0d28gcG9pbnRzIGFyZSBlcXVhbFxyXG5cclxuZnVuY3Rpb24gZXF1YWxzKCBwMSwgcDIgKSB7XHJcblxyXG5cdHJldHVybiBwMS54ID09PSBwMi54ICYmIHAxLnkgPT09IHAyLnk7XHJcblxyXG59XHJcblxyXG4vLyBjaGVjayBpZiB0d28gc2VnbWVudHMgaW50ZXJzZWN0XHJcblxyXG5mdW5jdGlvbiBpbnRlcnNlY3RzKCBwMSwgcTEsIHAyLCBxMiApIHtcclxuXHJcblx0aWYgKCAoIGVxdWFscyggcDEsIHExICkgJiYgZXF1YWxzKCBwMiwgcTIgKSApIHx8XHJcblx0XHRcdCggZXF1YWxzKCBwMSwgcTIgKSAmJiBlcXVhbHMoIHAyLCBxMSApICkgKSByZXR1cm4gdHJ1ZTtcclxuXHJcblx0cmV0dXJuIGFyZWEoIHAxLCBxMSwgcDIgKSA+IDAgIT09IGFyZWEoIHAxLCBxMSwgcTIgKSA+IDAgJiZcclxuXHRcdFx0XHQgYXJlYSggcDIsIHEyLCBwMSApID4gMCAhPT0gYXJlYSggcDIsIHEyLCBxMSApID4gMDtcclxuXHJcbn1cclxuXHJcbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpbnRlcnNlY3RzIGFueSBwb2x5Z29uIHNlZ21lbnRzXHJcblxyXG5mdW5jdGlvbiBpbnRlcnNlY3RzUG9seWdvbiggYSwgYiApIHtcclxuXHJcblx0dmFyIHAgPSBhO1xyXG5cclxuXHRkbyB7XHJcblxyXG5cdFx0aWYgKCBwLmkgIT09IGEuaSAmJiBwLm5leHQuaSAhPT0gYS5pICYmIHAuaSAhPT0gYi5pICYmIHAubmV4dC5pICE9PSBiLmkgJiZcclxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0cyggcCwgcC5uZXh0LCBhLCBiICkgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cCA9IHAubmV4dDtcclxuXHJcblx0fSB3aGlsZSAoIHAgIT09IGEgKTtcclxuXHJcblx0cmV0dXJuIGZhbHNlO1xyXG5cclxufVxyXG5cclxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGxvY2FsbHkgaW5zaWRlIHRoZSBwb2x5Z29uXHJcblxyXG5mdW5jdGlvbiBsb2NhbGx5SW5zaWRlKCBhLCBiICkge1xyXG5cclxuXHRyZXR1cm4gYXJlYSggYS5wcmV2LCBhLCBhLm5leHQgKSA8IDAgP1xyXG5cdFx0YXJlYSggYSwgYiwgYS5uZXh0ICkgPj0gMCAmJiBhcmVhKCBhLCBhLnByZXYsIGIgKSA+PSAwIDpcclxuXHRcdGFyZWEoIGEsIGIsIGEucHJldiApIDwgMCB8fCBhcmVhKCBhLCBhLm5leHQsIGIgKSA8IDA7XHJcblxyXG59XHJcblxyXG4vLyBjaGVjayBpZiB0aGUgbWlkZGxlIHBvaW50IG9mIGEgcG9seWdvbiBkaWFnb25hbCBpcyBpbnNpZGUgdGhlIHBvbHlnb25cclxuXHJcbmZ1bmN0aW9uIG1pZGRsZUluc2lkZSggYSwgYiApIHtcclxuXHJcblx0dmFyIHAgPSBhLFxyXG5cdFx0aW5zaWRlID0gZmFsc2UsXHJcblx0XHRweCA9ICggYS54ICsgYi54ICkgLyAyLFxyXG5cdFx0cHkgPSAoIGEueSArIGIueSApIC8gMjtcclxuXHJcblx0ZG8ge1xyXG5cclxuXHRcdGlmICggKCAoIHAueSA+IHB5ICkgIT09ICggcC5uZXh0LnkgPiBweSApICkgJiYgcC5uZXh0LnkgIT09IHAueSAmJlxyXG5cdFx0XHRcdFx0XHQoIHB4IDwgKCBwLm5leHQueCAtIHAueCApICogKCBweSAtIHAueSApIC8gKCBwLm5leHQueSAtIHAueSApICsgcC54ICkgKSB7XHJcblxyXG5cdFx0XHRpbnNpZGUgPSAhIGluc2lkZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cCA9IHAubmV4dDtcclxuXHJcblx0fSB3aGlsZSAoIHAgIT09IGEgKTtcclxuXHJcblx0cmV0dXJuIGluc2lkZTtcclxuXHJcbn1cclxuXHJcbi8vIGxpbmsgdHdvIHBvbHlnb24gdmVydGljZXMgd2l0aCBhIGJyaWRnZTsgaWYgdGhlIHZlcnRpY2VzIGJlbG9uZyB0byB0aGUgc2FtZSByaW5nLCBpdCBzcGxpdHMgcG9seWdvbiBpbnRvIHR3bztcclxuLy8gaWYgb25lIGJlbG9uZ3MgdG8gdGhlIG91dGVyIHJpbmcgYW5kIGFub3RoZXIgdG8gYSBob2xlLCBpdCBtZXJnZXMgaXQgaW50byBhIHNpbmdsZSByaW5nXHJcblxyXG5mdW5jdGlvbiBzcGxpdFBvbHlnb24oIGEsIGIgKSB7XHJcblxyXG5cdHZhciBhMiA9IG5ldyBOb2RlKCBhLmksIGEueCwgYS55ICksXHJcblx0XHRiMiA9IG5ldyBOb2RlKCBiLmksIGIueCwgYi55ICksXHJcblx0XHRhbiA9IGEubmV4dCxcclxuXHRcdGJwID0gYi5wcmV2O1xyXG5cclxuXHRhLm5leHQgPSBiO1xyXG5cdGIucHJldiA9IGE7XHJcblxyXG5cdGEyLm5leHQgPSBhbjtcclxuXHRhbi5wcmV2ID0gYTI7XHJcblxyXG5cdGIyLm5leHQgPSBhMjtcclxuXHRhMi5wcmV2ID0gYjI7XHJcblxyXG5cdGJwLm5leHQgPSBiMjtcclxuXHRiMi5wcmV2ID0gYnA7XHJcblxyXG5cdHJldHVybiBiMjtcclxuXHJcbn1cclxuXHJcbi8vIGNyZWF0ZSBhIG5vZGUgYW5kIG9wdGlvbmFsbHkgbGluayBpdCB3aXRoIHByZXZpb3VzIG9uZSAoaW4gYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QpXHJcblxyXG5mdW5jdGlvbiBpbnNlcnROb2RlKCBpLCB4LCB5LCBsYXN0ICkge1xyXG5cclxuXHR2YXIgcCA9IG5ldyBOb2RlKCBpLCB4LCB5ICk7XHJcblxyXG5cdGlmICggISBsYXN0ICkge1xyXG5cclxuXHRcdHAucHJldiA9IHA7XHJcblx0XHRwLm5leHQgPSBwO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdHAubmV4dCA9IGxhc3QubmV4dDtcclxuXHRcdHAucHJldiA9IGxhc3Q7XHJcblx0XHRsYXN0Lm5leHQucHJldiA9IHA7XHJcblx0XHRsYXN0Lm5leHQgPSBwO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBwO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlTm9kZSggcCApIHtcclxuXHJcblx0cC5uZXh0LnByZXYgPSBwLnByZXY7XHJcblx0cC5wcmV2Lm5leHQgPSBwLm5leHQ7XHJcblxyXG5cdGlmICggcC5wcmV2WiApIHAucHJldloubmV4dFogPSBwLm5leHRaO1xyXG5cdGlmICggcC5uZXh0WiApIHAubmV4dFoucHJldlogPSBwLnByZXZaO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gTm9kZSggaSwgeCwgeSApIHtcclxuXHJcblx0Ly8gdmVydGljZSBpbmRleCBpbiBjb29yZGluYXRlcyBhcnJheVxyXG5cdHRoaXMuaSA9IGk7XHJcblxyXG5cdC8vIHZlcnRleCBjb29yZGluYXRlc1xyXG5cdHRoaXMueCA9IHg7XHJcblx0dGhpcy55ID0geTtcclxuXHJcblx0Ly8gcHJldmlvdXMgYW5kIG5leHQgdmVydGljZSBub2RlcyBpbiBhIHBvbHlnb24gcmluZ1xyXG5cdHRoaXMucHJldiA9IG51bGw7XHJcblx0dGhpcy5uZXh0ID0gbnVsbDtcclxuXHJcblx0Ly8gei1vcmRlciBjdXJ2ZSB2YWx1ZVxyXG5cdHRoaXMueiA9IG51bGw7XHJcblxyXG5cdC8vIHByZXZpb3VzIGFuZCBuZXh0IG5vZGVzIGluIHotb3JkZXJcclxuXHR0aGlzLnByZXZaID0gbnVsbDtcclxuXHR0aGlzLm5leHRaID0gbnVsbDtcclxuXHJcblx0Ly8gaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhIHN0ZWluZXIgcG9pbnRcclxuXHR0aGlzLnN0ZWluZXIgPSBmYWxzZTtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNpZ25lZEFyZWEoIGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSApIHtcclxuXHJcblx0dmFyIHN1bSA9IDA7XHJcblxyXG5cdGZvciAoIHZhciBpID0gc3RhcnQsIGogPSBlbmQgLSBkaW07IGkgPCBlbmQ7IGkgKz0gZGltICkge1xyXG5cclxuXHRcdHN1bSArPSAoIGRhdGFbIGogXSAtIGRhdGFbIGkgXSApICogKCBkYXRhWyBpICsgMSBdICsgZGF0YVsgaiArIDEgXSApO1xyXG5cdFx0aiA9IGk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHN1bTtcclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IEVhcmN1dCB9O1xyXG4iLCIvKipcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKi9cclxuXHJcbmltcG9ydCB7IEVhcmN1dCB9IGZyb20gJy4vRWFyY3V0LmpzJztcclxuXHJcbnZhciBTaGFwZVV0aWxzID0ge1xyXG5cclxuXHQvLyBjYWxjdWxhdGUgYXJlYSBvZiB0aGUgY29udG91ciBwb2x5Z29uXHJcblxyXG5cdGFyZWE6IGZ1bmN0aW9uICggY29udG91ciApIHtcclxuXHJcblx0XHR2YXIgbiA9IGNvbnRvdXIubGVuZ3RoO1xyXG5cdFx0dmFyIGEgPSAwLjA7XHJcblxyXG5cdFx0Zm9yICggdmFyIHAgPSBuIC0gMSwgcSA9IDA7IHEgPCBuOyBwID0gcSArKyApIHtcclxuXHJcblx0XHRcdGEgKz0gY29udG91clsgcCBdLnggKiBjb250b3VyWyBxIF0ueSAtIGNvbnRvdXJbIHEgXS54ICogY29udG91clsgcCBdLnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBhICogMC41O1xyXG5cclxuXHR9LFxyXG5cclxuXHRpc0Nsb2NrV2lzZTogZnVuY3Rpb24gKCBwdHMgKSB7XHJcblxyXG5cdFx0cmV0dXJuIFNoYXBlVXRpbHMuYXJlYSggcHRzICkgPCAwO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0cmlhbmd1bGF0ZVNoYXBlOiBmdW5jdGlvbiAoIGNvbnRvdXIsIGhvbGVzICkge1xyXG5cclxuXHRcdHZhciB2ZXJ0aWNlcyA9IFtdOyAvLyBmbGF0IGFycmF5IG9mIHZlcnRpY2VzIGxpa2UgWyB4MCx5MCwgeDEseTEsIHgyLHkyLCAuLi4gXVxyXG5cdFx0dmFyIGhvbGVJbmRpY2VzID0gW107IC8vIGFycmF5IG9mIGhvbGUgaW5kaWNlc1xyXG5cdFx0dmFyIGZhY2VzID0gW107IC8vIGZpbmFsIGFycmF5IG9mIHZlcnRleCBpbmRpY2VzIGxpa2UgWyBbIGEsYixkIF0sIFsgYixjLGQgXSBdXHJcblxyXG5cdFx0cmVtb3ZlRHVwRW5kUHRzKCBjb250b3VyICk7XHJcblx0XHRhZGRDb250b3VyKCB2ZXJ0aWNlcywgY29udG91ciApO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0dmFyIGhvbGVJbmRleCA9IGNvbnRvdXIubGVuZ3RoO1xyXG5cclxuXHRcdGhvbGVzLmZvckVhY2goIHJlbW92ZUR1cEVuZFB0cyApO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGhvbGVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdGhvbGVJbmRpY2VzLnB1c2goIGhvbGVJbmRleCApO1xyXG5cdFx0XHRob2xlSW5kZXggKz0gaG9sZXNbIGkgXS5sZW5ndGg7XHJcblx0XHRcdGFkZENvbnRvdXIoIHZlcnRpY2VzLCBob2xlc1sgaSBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0dmFyIHRyaWFuZ2xlcyA9IEVhcmN1dC50cmlhbmd1bGF0ZSggdmVydGljZXMsIGhvbGVJbmRpY2VzICk7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0cmlhbmdsZXMubGVuZ3RoOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHRmYWNlcy5wdXNoKCB0cmlhbmdsZXMuc2xpY2UoIGksIGkgKyAzICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhY2VzO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuZnVuY3Rpb24gcmVtb3ZlRHVwRW5kUHRzKCBwb2ludHMgKSB7XHJcblxyXG5cdHZhciBsID0gcG9pbnRzLmxlbmd0aDtcclxuXHJcblx0aWYgKCBsID4gMiAmJiBwb2ludHNbIGwgLSAxIF0uZXF1YWxzKCBwb2ludHNbIDAgXSApICkge1xyXG5cclxuXHRcdHBvaW50cy5wb3AoKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gYWRkQ29udG91ciggdmVydGljZXMsIGNvbnRvdXIgKSB7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IGNvbnRvdXIubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdHZlcnRpY2VzLnB1c2goIGNvbnRvdXJbIGkgXS54ICk7XHJcblx0XHR2ZXJ0aWNlcy5wdXNoKCBjb250b3VyWyBpIF0ueSApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBTaGFwZVV0aWxzIH07XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqXHJcbiAqIENyZWF0ZXMgZXh0cnVkZWQgZ2VvbWV0cnkgZnJvbSBhIHBhdGggc2hhcGUuXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqXHJcbiAqICBjdXJ2ZVNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmVzXHJcbiAqICBzdGVwczogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgZm9yIHotc2lkZSBleHRydXNpb25zIC8gdXNlZCBmb3Igc3ViZGl2aWRpbmcgc2VnbWVudHMgb2YgZXh0cnVkZSBzcGxpbmUgdG9vXHJcbiAqICBkZXB0aDogPGZsb2F0PiwgLy8gRGVwdGggdG8gZXh0cnVkZSB0aGUgc2hhcGVcclxuICpcclxuICogIGJldmVsRW5hYmxlZDogPGJvb2w+LCAvLyB0dXJuIG9uIGJldmVsXHJcbiAqICBiZXZlbFRoaWNrbmVzczogPGZsb2F0PiwgLy8gaG93IGRlZXAgaW50byB0aGUgb3JpZ2luYWwgc2hhcGUgYmV2ZWwgZ29lc1xyXG4gKiAgYmV2ZWxTaXplOiA8ZmxvYXQ+LCAvLyBob3cgZmFyIGZyb20gc2hhcGUgb3V0bGluZSBpcyBiZXZlbFxyXG4gKiAgYmV2ZWxTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBiZXZlbCBsYXllcnNcclxuICpcclxuICogIGV4dHJ1ZGVQYXRoOiA8Q09PTC5DdXJ2ZT4gLy8gY3VydmUgdG8gZXh0cnVkZSBzaGFwZSBhbG9uZ1xyXG4gKlxyXG4gKiAgVVZHZW5lcmF0b3I6IDxPYmplY3Q+IC8vIG9iamVjdCB0aGF0IHByb3ZpZGVzIFVWIGdlbmVyYXRvciBmdW5jdGlvbnNcclxuICpcclxuICogfVxyXG4gKi9cclxuXHJcbmltcG9ydCB7IEdlb21ldHJ5IH0gZnJvbSAnLi9HZW9tZXRyeS5qcyc7XHJcbmltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH0gZnJvbSAnLi9CdWZmZXJHZW9tZXRyeS5qcyc7XHJcbmltcG9ydCB7IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcclxuaW1wb3J0IHsgU2hhcGVVdGlscyB9IGZyb20gJy4uL2V4dHJhcy9TaGFwZVV0aWxzLmpzJztcclxuXHJcbi8vIEV4dHJ1ZGVHZW9tZXRyeVxyXG5cclxuZnVuY3Rpb24gRXh0cnVkZUdlb21ldHJ5KCBzaGFwZXMsIG9wdGlvbnMgKSB7XHJcblxyXG5cdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ0V4dHJ1ZGVHZW9tZXRyeSc7XHJcblxyXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdHNoYXBlczogc2hhcGVzLFxyXG5cdFx0b3B0aW9uczogb3B0aW9uc1xyXG5cdH07XHJcblxyXG5cdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgRXh0cnVkZUJ1ZmZlckdlb21ldHJ5KCBzaGFwZXMsIG9wdGlvbnMgKSApO1xyXG5cdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xyXG5cclxufVxyXG5cclxuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRXh0cnVkZUdlb21ldHJ5O1xyXG5cclxuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBkYXRhID0gR2VvbWV0cnkucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHZhciBzaGFwZXMgPSB0aGlzLnBhcmFtZXRlcnMuc2hhcGVzO1xyXG5cdHZhciBvcHRpb25zID0gdGhpcy5wYXJhbWV0ZXJzLm9wdGlvbnM7XHJcblxyXG5cdHJldHVybiB0b0pTT04oIHNoYXBlcywgb3B0aW9ucywgZGF0YSApO1xyXG5cclxufTtcclxuXHJcbi8vIEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeVxyXG5cclxuZnVuY3Rpb24gRXh0cnVkZUJ1ZmZlckdlb21ldHJ5KCBzaGFwZXMsIG9wdGlvbnMgKSB7XHJcblxyXG5cdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ0V4dHJ1ZGVCdWZmZXJHZW9tZXRyeSc7XHJcblxyXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdHNoYXBlczogc2hhcGVzLFxyXG5cdFx0b3B0aW9uczogb3B0aW9uc1xyXG5cdH07XHJcblxyXG5cdHNoYXBlcyA9IEFycmF5LmlzQXJyYXkoIHNoYXBlcyApID8gc2hhcGVzIDogWyBzaGFwZXMgXTtcclxuXHJcblx0dmFyIHNjb3BlID0gdGhpcztcclxuXHJcblx0dmFyIHZlcnRpY2VzQXJyYXkgPSBbXTtcclxuXHR2YXIgdXZBcnJheSA9IFtdO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzaGFwZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHR2YXIgc2hhcGUgPSBzaGFwZXNbIGkgXTtcclxuXHRcdGFkZFNoYXBlKCBzaGFwZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIGJ1aWxkIGdlb21ldHJ5XHJcblxyXG5cdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXNBcnJheSwgMyApICk7XHJcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dkFycmF5LCAyICkgKTtcclxuXHJcblx0dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xyXG5cclxuXHQvLyBmdW5jdGlvbnNcclxuXHJcblx0ZnVuY3Rpb24gYWRkU2hhcGUoIHNoYXBlICkge1xyXG5cclxuXHRcdHZhciBwbGFjZWhvbGRlciA9IFtdO1xyXG5cclxuXHRcdC8vIG9wdGlvbnNcclxuXHJcblx0XHR2YXIgY3VydmVTZWdtZW50cyA9IG9wdGlvbnMuY3VydmVTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzIDogMTI7XHJcblx0XHR2YXIgc3RlcHMgPSBvcHRpb25zLnN0ZXBzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0ZXBzIDogMTtcclxuXHRcdHZhciBkZXB0aCA9IG9wdGlvbnMuZGVwdGggIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGVwdGggOiAxMDA7XHJcblxyXG5cdFx0dmFyIGJldmVsRW5hYmxlZCA9IG9wdGlvbnMuYmV2ZWxFbmFibGVkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsRW5hYmxlZCA6IHRydWU7XHJcblx0XHR2YXIgYmV2ZWxUaGlja25lc3MgPSBvcHRpb25zLmJldmVsVGhpY2tuZXNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsVGhpY2tuZXNzIDogNjtcclxuXHRcdHZhciBiZXZlbFNpemUgPSBvcHRpb25zLmJldmVsU2l6ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFNpemUgOiBiZXZlbFRoaWNrbmVzcyAtIDI7XHJcblx0XHR2YXIgYmV2ZWxTZWdtZW50cyA9IG9wdGlvbnMuYmV2ZWxTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFNlZ21lbnRzIDogMztcclxuXHJcblx0XHR2YXIgZXh0cnVkZVBhdGggPSBvcHRpb25zLmV4dHJ1ZGVQYXRoO1xyXG5cclxuXHRcdHZhciB1dmdlbiA9IG9wdGlvbnMuVVZHZW5lcmF0b3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuVVZHZW5lcmF0b3IgOiBXb3JsZFVWR2VuZXJhdG9yO1xyXG5cclxuXHRcdC8vIGRlcHJlY2F0ZWQgb3B0aW9uc1xyXG5cclxuXHRcdGlmICggb3B0aW9ucy5hbW91bnQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ0NPT0wuRXh0cnVkZUJ1ZmZlckdlb21ldHJ5OiBhbW91bnQgaGFzIGJlZW4gcmVuYW1lZCB0byBkZXB0aC4nICk7XHJcblx0XHRcdGRlcHRoID0gb3B0aW9ucy5hbW91bnQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0dmFyIGV4dHJ1ZGVQdHMsIGV4dHJ1ZGVCeVBhdGggPSBmYWxzZTtcclxuXHRcdHZhciBzcGxpbmVUdWJlLCBiaW5vcm1hbCwgbm9ybWFsLCBwb3NpdGlvbjI7XHJcblxyXG5cdFx0aWYgKCBleHRydWRlUGF0aCApIHtcclxuXHJcblx0XHRcdGV4dHJ1ZGVQdHMgPSBleHRydWRlUGF0aC5nZXRTcGFjZWRQb2ludHMoIHN0ZXBzICk7XHJcblxyXG5cdFx0XHRleHRydWRlQnlQYXRoID0gdHJ1ZTtcclxuXHRcdFx0YmV2ZWxFbmFibGVkID0gZmFsc2U7IC8vIGJldmVscyBub3Qgc3VwcG9ydGVkIGZvciBwYXRoIGV4dHJ1c2lvblxyXG5cclxuXHRcdFx0Ly8gU0VUVVAgVE5CIHZhcmlhYmxlc1xyXG5cclxuXHRcdFx0Ly8gVE9ETzEgLSBoYXZlIGEgLmlzQ2xvc2VkIGluIHNwbGluZT9cclxuXHJcblx0XHRcdHNwbGluZVR1YmUgPSBleHRydWRlUGF0aC5jb21wdXRlRnJlbmV0RnJhbWVzKCBzdGVwcywgZmFsc2UgKTtcclxuXHJcblx0XHRcdC8vIGNvbnNvbGUubG9nKHNwbGluZVR1YmUsICdzcGxpbmVUdWJlJywgc3BsaW5lVHViZS5ub3JtYWxzLmxlbmd0aCwgJ3N0ZXBzJywgc3RlcHMsICdleHRydWRlUHRzJywgZXh0cnVkZVB0cy5sZW5ndGgpO1xyXG5cclxuXHRcdFx0Ymlub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0XHRub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0XHRwb3NpdGlvbjIgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBTYWZlZ3VhcmRzIGlmIGJldmVscyBhcmUgbm90IGVuYWJsZWRcclxuXHJcblx0XHRpZiAoICEgYmV2ZWxFbmFibGVkICkge1xyXG5cclxuXHRcdFx0YmV2ZWxTZWdtZW50cyA9IDA7XHJcblx0XHRcdGJldmVsVGhpY2tuZXNzID0gMDtcclxuXHRcdFx0YmV2ZWxTaXplID0gMDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVmFyaWFibGVzIGluaXRpYWxpemF0aW9uXHJcblxyXG5cdFx0dmFyIGFob2xlLCBoLCBobDsgLy8gbG9vcGluZyBvZiBob2xlc1xyXG5cclxuXHRcdHZhciBzaGFwZVBvaW50cyA9IHNoYXBlLmV4dHJhY3RQb2ludHMoIGN1cnZlU2VnbWVudHMgKTtcclxuXHJcblx0XHR2YXIgdmVydGljZXMgPSBzaGFwZVBvaW50cy5zaGFwZTtcclxuXHRcdHZhciBob2xlcyA9IHNoYXBlUG9pbnRzLmhvbGVzO1xyXG5cclxuXHRcdHZhciByZXZlcnNlID0gISBTaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKCB2ZXJ0aWNlcyApO1xyXG5cclxuXHRcdGlmICggcmV2ZXJzZSApIHtcclxuXHJcblx0XHRcdHZlcnRpY2VzID0gdmVydGljZXMucmV2ZXJzZSgpO1xyXG5cclxuXHRcdFx0Ly8gTWF5YmUgd2Ugc2hvdWxkIGFsc28gY2hlY2sgaWYgaG9sZXMgYXJlIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24sIGp1c3QgdG8gYmUgc2FmZSAuLi5cclxuXHJcblx0XHRcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xyXG5cclxuXHRcdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XHJcblxyXG5cdFx0XHRcdGlmICggU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggYWhvbGUgKSApIHtcclxuXHJcblx0XHRcdFx0XHRob2xlc1sgaCBdID0gYWhvbGUucmV2ZXJzZSgpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHJcblx0XHR2YXIgZmFjZXMgPSBTaGFwZVV0aWxzLnRyaWFuZ3VsYXRlU2hhcGUoIHZlcnRpY2VzLCBob2xlcyApO1xyXG5cclxuXHRcdC8qIFZlcnRpY2VzICovXHJcblxyXG5cdFx0dmFyIGNvbnRvdXIgPSB2ZXJ0aWNlczsgLy8gdmVydGljZXMgaGFzIGFsbCBwb2ludHMgYnV0IGNvbnRvdXIgaGFzIG9ubHkgcG9pbnRzIG9mIGNpcmN1bWZlcmVuY2VcclxuXHJcblx0XHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcclxuXHJcblx0XHRcdGFob2xlID0gaG9sZXNbIGggXTtcclxuXHJcblx0XHRcdHZlcnRpY2VzID0gdmVydGljZXMuY29uY2F0KCBhaG9sZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblxyXG5cdFx0ZnVuY3Rpb24gc2NhbGVQdDIoIHB0LCB2ZWMsIHNpemUgKSB7XHJcblxyXG5cdFx0XHRpZiAoICEgdmVjICkgY29uc29sZS5lcnJvciggXCJDT09MLkV4dHJ1ZGVHZW9tZXRyeTogdmVjIGRvZXMgbm90IGV4aXN0XCIgKTtcclxuXHJcblx0XHRcdHJldHVybiB2ZWMuY2xvbmUoKS5tdWx0aXBseVNjYWxhciggc2l6ZSApLmFkZCggcHQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGIsIGJzLCB0LCB6LFxyXG5cdFx0XHR2ZXJ0LCB2bGVuID0gdmVydGljZXMubGVuZ3RoLFxyXG5cdFx0XHRmYWNlLCBmbGVuID0gZmFjZXMubGVuZ3RoO1xyXG5cclxuXHJcblx0XHQvLyBGaW5kIGRpcmVjdGlvbnMgZm9yIHBvaW50IG1vdmVtZW50XHJcblxyXG5cclxuXHRcdGZ1bmN0aW9uIGdldEJldmVsVmVjKCBpblB0LCBpblByZXYsIGluTmV4dCApIHtcclxuXHJcblx0XHRcdC8vIGNvbXB1dGVzIGZvciBpblB0IHRoZSBjb3JyZXNwb25kaW5nIHBvaW50IGluUHQnIG9uIGEgbmV3IGNvbnRvdXJcclxuXHRcdFx0Ly8gICBzaGlmdGVkIGJ5IDEgdW5pdCAobGVuZ3RoIG9mIG5vcm1hbGl6ZWQgdmVjdG9yKSB0byB0aGUgbGVmdFxyXG5cdFx0XHQvLyBpZiB3ZSB3YWxrIGFsb25nIGNvbnRvdXIgY2xvY2t3aXNlLCB0aGlzIG5ldyBjb250b3VyIGlzIG91dHNpZGUgdGhlIG9sZCBvbmVcclxuXHRcdFx0Ly9cclxuXHRcdFx0Ly8gaW5QdCcgaXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIGxpbmVzIHBhcmFsbGVsIHRvIHRoZSB0d29cclxuXHRcdFx0Ly8gIGFkamFjZW50IGVkZ2VzIG9mIGluUHQgYXQgYSBkaXN0YW5jZSBvZiAxIHVuaXQgb24gdGhlIGxlZnQgc2lkZS5cclxuXHJcblx0XHRcdHZhciB2X3RyYW5zX3gsIHZfdHJhbnNfeSwgc2hyaW5rX2J5OyAvLyByZXN1bHRpbmcgdHJhbnNsYXRpb24gdmVjdG9yIGZvciBpblB0XHJcblxyXG5cdFx0XHQvLyBnb29kIHJlYWRpbmcgZm9yIGdlb21ldHJ5IGFsZ29yaXRobXMgKGhlcmU6IGxpbmUtbGluZSBpbnRlcnNlY3Rpb24pXHJcblx0XHRcdC8vIGh0dHA6Ly9nZW9tYWxnb3JpdGhtcy5jb20vYTA1LV9pbnRlcnNlY3QtMS5odG1sXHJcblxyXG5cdFx0XHR2YXIgdl9wcmV2X3ggPSBpblB0LnggLSBpblByZXYueCxcclxuXHRcdFx0XHR2X3ByZXZfeSA9IGluUHQueSAtIGluUHJldi55O1xyXG5cdFx0XHR2YXIgdl9uZXh0X3ggPSBpbk5leHQueCAtIGluUHQueCxcclxuXHRcdFx0XHR2X25leHRfeSA9IGluTmV4dC55IC0gaW5QdC55O1xyXG5cclxuXHRcdFx0dmFyIHZfcHJldl9sZW5zcSA9ICggdl9wcmV2X3ggKiB2X3ByZXZfeCArIHZfcHJldl95ICogdl9wcmV2X3kgKTtcclxuXHJcblx0XHRcdC8vIGNoZWNrIGZvciBjb2xsaW5lYXIgZWRnZXNcclxuXHRcdFx0dmFyIGNvbGxpbmVhcjAgPSAoIHZfcHJldl94ICogdl9uZXh0X3kgLSB2X3ByZXZfeSAqIHZfbmV4dF94ICk7XHJcblxyXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBjb2xsaW5lYXIwICkgPiBOdW1iZXIuRVBTSUxPTiApIHtcclxuXHJcblx0XHRcdFx0Ly8gbm90IGNvbGxpbmVhclxyXG5cclxuXHRcdFx0XHQvLyBsZW5ndGggb2YgdmVjdG9ycyBmb3Igbm9ybWFsaXppbmdcclxuXHJcblx0XHRcdFx0dmFyIHZfcHJldl9sZW4gPSBNYXRoLnNxcnQoIHZfcHJldl9sZW5zcSApO1xyXG5cdFx0XHRcdHZhciB2X25leHRfbGVuID0gTWF0aC5zcXJ0KCB2X25leHRfeCAqIHZfbmV4dF94ICsgdl9uZXh0X3kgKiB2X25leHRfeSApO1xyXG5cclxuXHRcdFx0XHQvLyBzaGlmdCBhZGphY2VudCBwb2ludHMgYnkgdW5pdCB2ZWN0b3JzIHRvIHRoZSBsZWZ0XHJcblxyXG5cdFx0XHRcdHZhciBwdFByZXZTaGlmdF94ID0gKCBpblByZXYueCAtIHZfcHJldl95IC8gdl9wcmV2X2xlbiApO1xyXG5cdFx0XHRcdHZhciBwdFByZXZTaGlmdF95ID0gKCBpblByZXYueSArIHZfcHJldl94IC8gdl9wcmV2X2xlbiApO1xyXG5cclxuXHRcdFx0XHR2YXIgcHROZXh0U2hpZnRfeCA9ICggaW5OZXh0LnggLSB2X25leHRfeSAvIHZfbmV4dF9sZW4gKTtcclxuXHRcdFx0XHR2YXIgcHROZXh0U2hpZnRfeSA9ICggaW5OZXh0LnkgKyB2X25leHRfeCAvIHZfbmV4dF9sZW4gKTtcclxuXHJcblx0XHRcdFx0Ly8gc2NhbGluZyBmYWN0b3IgZm9yIHZfcHJldiB0byBpbnRlcnNlY3Rpb24gcG9pbnRcclxuXHJcblx0XHRcdFx0dmFyIHNmID0gKCAoIHB0TmV4dFNoaWZ0X3ggLSBwdFByZXZTaGlmdF94ICkgKiB2X25leHRfeSAtXHJcblx0XHRcdFx0XHRcdCggcHROZXh0U2hpZnRfeSAtIHB0UHJldlNoaWZ0X3kgKSAqIHZfbmV4dF94ICkgL1xyXG5cdFx0XHRcdFx0KCB2X3ByZXZfeCAqIHZfbmV4dF95IC0gdl9wcmV2X3kgKiB2X25leHRfeCApO1xyXG5cclxuXHRcdFx0XHQvLyB2ZWN0b3IgZnJvbSBpblB0IHRvIGludGVyc2VjdGlvbiBwb2ludFxyXG5cclxuXHRcdFx0XHR2X3RyYW5zX3ggPSAoIHB0UHJldlNoaWZ0X3ggKyB2X3ByZXZfeCAqIHNmIC0gaW5QdC54ICk7XHJcblx0XHRcdFx0dl90cmFuc195ID0gKCBwdFByZXZTaGlmdF95ICsgdl9wcmV2X3kgKiBzZiAtIGluUHQueSApO1xyXG5cclxuXHRcdFx0XHQvLyBEb24ndCBub3JtYWxpemUhLCBvdGhlcndpc2Ugc2hhcnAgY29ybmVycyBiZWNvbWUgdWdseVxyXG5cdFx0XHRcdC8vICBidXQgcHJldmVudCBjcmF6eSBzcGlrZXNcclxuXHRcdFx0XHR2YXIgdl90cmFuc19sZW5zcSA9ICggdl90cmFuc194ICogdl90cmFuc194ICsgdl90cmFuc195ICogdl90cmFuc195ICk7XHJcblx0XHRcdFx0aWYgKCB2X3RyYW5zX2xlbnNxIDw9IDIgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBWZWN0b3IyKCB2X3RyYW5zX3gsIHZfdHJhbnNfeSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHNocmlua19ieSA9IE1hdGguc3FydCggdl90cmFuc19sZW5zcSAvIDIgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gaGFuZGxlIHNwZWNpYWwgY2FzZSBvZiBjb2xsaW5lYXIgZWRnZXNcclxuXHJcblx0XHRcdFx0dmFyIGRpcmVjdGlvbl9lcSA9IGZhbHNlOyAvLyBhc3N1bWVzOiBvcHBvc2l0ZVxyXG5cdFx0XHRcdGlmICggdl9wcmV2X3ggPiBOdW1iZXIuRVBTSUxPTiApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHZfbmV4dF94ID4gTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRkaXJlY3Rpb25fZXEgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHZfcHJldl94IDwgLSBOdW1iZXIuRVBTSUxPTiApIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggdl9uZXh0X3ggPCAtIE51bWJlci5FUFNJTE9OICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRkaXJlY3Rpb25fZXEgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIE1hdGguc2lnbiggdl9wcmV2X3kgKSA9PT0gTWF0aC5zaWduKCB2X25leHRfeSApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRkaXJlY3Rpb25fZXEgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIGRpcmVjdGlvbl9lcSApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIldhcm5pbmc6IGxpbmVzIGFyZSBhIHN0cmFpZ2h0IHNlcXVlbmNlXCIpO1xyXG5cdFx0XHRcdFx0dl90cmFuc194ID0gLSB2X3ByZXZfeTtcclxuXHRcdFx0XHRcdHZfdHJhbnNfeSA9IHZfcHJldl94O1xyXG5cdFx0XHRcdFx0c2hyaW5rX2J5ID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIldhcm5pbmc6IGxpbmVzIGFyZSBhIHN0cmFpZ2h0IHNwaWtlXCIpO1xyXG5cdFx0XHRcdFx0dl90cmFuc194ID0gdl9wcmV2X3g7XHJcblx0XHRcdFx0XHR2X3RyYW5zX3kgPSB2X3ByZXZfeTtcclxuXHRcdFx0XHRcdHNocmlua19ieSA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxIC8gMiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gbmV3IFZlY3RvcjIoIHZfdHJhbnNfeCAvIHNocmlua19ieSwgdl90cmFuc195IC8gc2hyaW5rX2J5ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHJcblx0XHR2YXIgY29udG91ck1vdmVtZW50cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBjb250b3VyLmxlbmd0aCwgaiA9IGlsIC0gMSwgayA9IGkgKyAxOyBpIDwgaWw7IGkgKyssIGogKyssIGsgKysgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGogPT09IGlsICkgaiA9IDA7XHJcblx0XHRcdGlmICggayA9PT0gaWwgKSBrID0gMDtcclxuXHJcblx0XHRcdC8vICAoaiktLS0oaSktLS0oaylcclxuXHRcdFx0Ly8gY29uc29sZS5sb2coJ2ksaixrJywgaSwgaiAsIGspXHJcblxyXG5cdFx0XHRjb250b3VyTW92ZW1lbnRzWyBpIF0gPSBnZXRCZXZlbFZlYyggY29udG91clsgaSBdLCBjb250b3VyWyBqIF0sIGNvbnRvdXJbIGsgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaG9sZXNNb3ZlbWVudHMgPSBbXSxcclxuXHRcdFx0b25lSG9sZU1vdmVtZW50cywgdmVydGljZXNNb3ZlbWVudHMgPSBjb250b3VyTW92ZW1lbnRzLmNvbmNhdCgpO1xyXG5cclxuXHRcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xyXG5cclxuXHRcdFx0YWhvbGUgPSBob2xlc1sgaCBdO1xyXG5cclxuXHRcdFx0b25lSG9sZU1vdmVtZW50cyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoLCBqID0gaWwgLSAxLCBrID0gaSArIDE7IGkgPCBpbDsgaSArKywgaiArKywgayArKyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBqID09PSBpbCApIGogPSAwO1xyXG5cdFx0XHRcdGlmICggayA9PT0gaWwgKSBrID0gMDtcclxuXHJcblx0XHRcdFx0Ly8gIChqKS0tLShpKS0tLShrKVxyXG5cdFx0XHRcdG9uZUhvbGVNb3ZlbWVudHNbIGkgXSA9IGdldEJldmVsVmVjKCBhaG9sZVsgaSBdLCBhaG9sZVsgaiBdLCBhaG9sZVsgayBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRob2xlc01vdmVtZW50cy5wdXNoKCBvbmVIb2xlTW92ZW1lbnRzICk7XHJcblx0XHRcdHZlcnRpY2VzTW92ZW1lbnRzID0gdmVydGljZXNNb3ZlbWVudHMuY29uY2F0KCBvbmVIb2xlTW92ZW1lbnRzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHJcblx0XHQvLyBMb29wIGJldmVsU2VnbWVudHMsIDEgZm9yIHRoZSBmcm9udCwgMSBmb3IgdGhlIGJhY2tcclxuXHJcblx0XHRmb3IgKCBiID0gMDsgYiA8IGJldmVsU2VnbWVudHM7IGIgKysgKSB7XHJcblxyXG5cdFx0XHQvL2ZvciAoIGIgPSBiZXZlbFNlZ21lbnRzOyBiID4gMDsgYiAtLSApIHtcclxuXHJcblx0XHRcdHQgPSBiIC8gYmV2ZWxTZWdtZW50cztcclxuXHRcdFx0eiA9IGJldmVsVGhpY2tuZXNzICogTWF0aC5jb3MoIHQgKiBNYXRoLlBJIC8gMiApO1xyXG5cdFx0XHRicyA9IGJldmVsU2l6ZSAqIE1hdGguc2luKCB0ICogTWF0aC5QSSAvIDIgKTtcclxuXHJcblx0XHRcdC8vIGNvbnRyYWN0IHNoYXBlXHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBjb250b3VyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2ZXJ0ID0gc2NhbGVQdDIoIGNvbnRvdXJbIGkgXSwgY29udG91ck1vdmVtZW50c1sgaSBdLCBicyApO1xyXG5cclxuXHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgLSB6ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBleHBhbmQgaG9sZXNcclxuXHJcblx0XHRcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xyXG5cclxuXHRcdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XHJcblx0XHRcdFx0b25lSG9sZU1vdmVtZW50cyA9IGhvbGVzTW92ZW1lbnRzWyBoIF07XHJcblxyXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZlcnQgPSBzY2FsZVB0MiggYWhvbGVbIGkgXSwgb25lSG9sZU1vdmVtZW50c1sgaSBdLCBicyApO1xyXG5cclxuXHRcdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAtIHogKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRicyA9IGJldmVsU2l6ZTtcclxuXHJcblx0XHQvLyBCYWNrIGZhY2luZyB2ZXJ0aWNlc1xyXG5cclxuXHRcdGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcclxuXHJcblx0XHRcdHZlcnQgPSBiZXZlbEVuYWJsZWQgPyBzY2FsZVB0MiggdmVydGljZXNbIGkgXSwgdmVydGljZXNNb3ZlbWVudHNbIGkgXSwgYnMgKSA6IHZlcnRpY2VzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcclxuXHJcblx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksIDAgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIHYoIHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1sgMCBdLnksIGV4dHJ1ZGVQdHNbIDAgXS54ICk7XHJcblxyXG5cdFx0XHRcdG5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLm5vcm1hbHNbIDAgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnggKTtcclxuXHRcdFx0XHRiaW5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLmJpbm9ybWFsc1sgMCBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueSApO1xyXG5cclxuXHRcdFx0XHRwb3NpdGlvbjIuY29weSggZXh0cnVkZVB0c1sgMCBdICkuYWRkKCBub3JtYWwgKS5hZGQoIGJpbm9ybWFsICk7XHJcblxyXG5cdFx0XHRcdHYoIHBvc2l0aW9uMi54LCBwb3NpdGlvbjIueSwgcG9zaXRpb24yLnogKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQWRkIHN0ZXBwZWQgdmVydGljZXMuLi5cclxuXHRcdC8vIEluY2x1ZGluZyBmcm9udCBmYWNpbmcgdmVydGljZXNcclxuXHJcblx0XHR2YXIgcztcclxuXHJcblx0XHRmb3IgKCBzID0gMTsgcyA8PSBzdGVwczsgcyArKyApIHtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmVydCA9IGJldmVsRW5hYmxlZCA/IHNjYWxlUHQyKCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc01vdmVtZW50c1sgaSBdLCBicyApIDogdmVydGljZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0aWYgKCAhIGV4dHJ1ZGVCeVBhdGggKSB7XHJcblxyXG5cdFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksIGRlcHRoIC8gc3RlcHMgKiBzICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gdiggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyBzIC0gMSBdLnksIGV4dHJ1ZGVQdHNbIHMgLSAxIF0ueCApO1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLm5vcm1hbHNbIHMgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnggKTtcclxuXHRcdFx0XHRcdGJpbm9ybWFsLmNvcHkoIHNwbGluZVR1YmUuYmlub3JtYWxzWyBzIF0gKS5tdWx0aXBseVNjYWxhciggdmVydC55ICk7XHJcblxyXG5cdFx0XHRcdFx0cG9zaXRpb24yLmNvcHkoIGV4dHJ1ZGVQdHNbIHMgXSApLmFkZCggbm9ybWFsICkuYWRkKCBiaW5vcm1hbCApO1xyXG5cclxuXHRcdFx0XHRcdHYoIHBvc2l0aW9uMi54LCBwb3NpdGlvbjIueSwgcG9zaXRpb24yLnogKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblxyXG5cdFx0Ly8gQWRkIGJldmVsIHNlZ21lbnRzIHBsYW5lc1xyXG5cclxuXHRcdC8vZm9yICggYiA9IDE7IGIgPD0gYmV2ZWxTZWdtZW50czsgYiArKyApIHtcclxuXHRcdGZvciAoIGIgPSBiZXZlbFNlZ21lbnRzIC0gMTsgYiA+PSAwOyBiIC0tICkge1xyXG5cclxuXHRcdFx0dCA9IGIgLyBiZXZlbFNlZ21lbnRzO1xyXG5cdFx0XHR6ID0gYmV2ZWxUaGlja25lc3MgKiBNYXRoLmNvcyggdCAqIE1hdGguUEkgLyAyICk7XHJcblx0XHRcdGJzID0gYmV2ZWxTaXplICogTWF0aC5zaW4oIHQgKiBNYXRoLlBJIC8gMiApO1xyXG5cclxuXHRcdFx0Ly8gY29udHJhY3Qgc2hhcGVcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZlcnQgPSBzY2FsZVB0MiggY29udG91clsgaSBdLCBjb250b3VyTW92ZW1lbnRzWyBpIF0sIGJzICk7XHJcblx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksIGRlcHRoICsgeiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZXhwYW5kIGhvbGVzXHJcblxyXG5cdFx0XHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcclxuXHJcblx0XHRcdFx0YWhvbGUgPSBob2xlc1sgaCBdO1xyXG5cdFx0XHRcdG9uZUhvbGVNb3ZlbWVudHMgPSBob2xlc01vdmVtZW50c1sgaCBdO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHR2ZXJ0ID0gc2NhbGVQdDIoIGFob2xlWyBpIF0sIG9uZUhvbGVNb3ZlbWVudHNbIGkgXSwgYnMgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCBkZXB0aCArIHogKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyBzdGVwcyAtIDEgXS55LCBleHRydWRlUHRzWyBzdGVwcyAtIDEgXS54ICsgeiApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvKiBGYWNlcyAqL1xyXG5cclxuXHRcdC8vIFRvcCBhbmQgYm90dG9tIGZhY2VzXHJcblxyXG5cdFx0YnVpbGRMaWRGYWNlcygpO1xyXG5cclxuXHRcdC8vIFNpZGVzIGZhY2VzXHJcblxyXG5cdFx0YnVpbGRTaWRlRmFjZXMoKTtcclxuXHJcblxyXG5cdFx0Ly8vLy8gIEludGVybmFsIGZ1bmN0aW9uc1xyXG5cclxuXHRcdGZ1bmN0aW9uIGJ1aWxkTGlkRmFjZXMoKSB7XHJcblxyXG5cdFx0XHR2YXIgc3RhcnQgPSB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDM7XHJcblxyXG5cdFx0XHRpZiAoIGJldmVsRW5hYmxlZCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGxheWVyID0gMDsgLy8gc3RlcHMgKyAxXHJcblx0XHRcdFx0dmFyIG9mZnNldCA9IHZsZW4gKiBsYXllcjtcclxuXHJcblx0XHRcdFx0Ly8gQm90dG9tIGZhY2VzXHJcblxyXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRmYWNlID0gZmFjZXNbIGkgXTtcclxuXHRcdFx0XHRcdGYzKCBmYWNlWyAyIF0gKyBvZmZzZXQsIGZhY2VbIDEgXSArIG9mZnNldCwgZmFjZVsgMCBdICsgb2Zmc2V0ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bGF5ZXIgPSBzdGVwcyArIGJldmVsU2VnbWVudHMgKiAyO1xyXG5cdFx0XHRcdG9mZnNldCA9IHZsZW4gKiBsYXllcjtcclxuXHJcblx0XHRcdFx0Ly8gVG9wIGZhY2VzXHJcblxyXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRmYWNlID0gZmFjZXNbIGkgXTtcclxuXHRcdFx0XHRcdGYzKCBmYWNlWyAwIF0gKyBvZmZzZXQsIGZhY2VbIDEgXSArIG9mZnNldCwgZmFjZVsgMiBdICsgb2Zmc2V0ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIEJvdHRvbSBmYWNlc1xyXG5cclxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZmFjZSA9IGZhY2VzWyBpIF07XHJcblx0XHRcdFx0XHRmMyggZmFjZVsgMiBdLCBmYWNlWyAxIF0sIGZhY2VbIDAgXSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIFRvcCBmYWNlc1xyXG5cclxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZmFjZSA9IGZhY2VzWyBpIF07XHJcblx0XHRcdFx0XHRmMyggZmFjZVsgMCBdICsgdmxlbiAqIHN0ZXBzLCBmYWNlWyAxIF0gKyB2bGVuICogc3RlcHMsIGZhY2VbIDIgXSArIHZsZW4gKiBzdGVwcyApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzY29wZS5hZGRHcm91cCggc3RhcnQsIHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMyAtIHN0YXJ0LCAwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIENyZWF0ZSBmYWNlcyBmb3IgdGhlIHotc2lkZXMgb2YgdGhlIHNoYXBlXHJcblxyXG5cdFx0ZnVuY3Rpb24gYnVpbGRTaWRlRmFjZXMoKSB7XHJcblxyXG5cdFx0XHR2YXIgc3RhcnQgPSB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDM7XHJcblx0XHRcdHZhciBsYXllcm9mZnNldCA9IDA7XHJcblx0XHRcdHNpZGV3YWxscyggY29udG91ciwgbGF5ZXJvZmZzZXQgKTtcclxuXHRcdFx0bGF5ZXJvZmZzZXQgKz0gY29udG91ci5sZW5ndGg7XHJcblxyXG5cdFx0XHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcclxuXHJcblx0XHRcdFx0YWhvbGUgPSBob2xlc1sgaCBdO1xyXG5cdFx0XHRcdHNpZGV3YWxscyggYWhvbGUsIGxheWVyb2Zmc2V0ICk7XHJcblxyXG5cdFx0XHRcdC8vLCB0cnVlXHJcblx0XHRcdFx0bGF5ZXJvZmZzZXQgKz0gYWhvbGUubGVuZ3RoO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdHNjb3BlLmFkZEdyb3VwKCBzdGFydCwgdmVydGljZXNBcnJheS5sZW5ndGggLyAzIC0gc3RhcnQsIDEgKTtcclxuXHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHNpZGV3YWxscyggY29udG91ciwgbGF5ZXJvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHR2YXIgaiwgaztcclxuXHRcdFx0aSA9IGNvbnRvdXIubGVuZ3RoO1xyXG5cclxuXHRcdFx0d2hpbGUgKCAtLSBpID49IDAgKSB7XHJcblxyXG5cdFx0XHRcdGogPSBpO1xyXG5cdFx0XHRcdGsgPSBpIC0gMTtcclxuXHRcdFx0XHRpZiAoIGsgPCAwICkgayA9IGNvbnRvdXIubGVuZ3RoIC0gMTtcclxuXHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnYicsIGksaiwgaS0xLCBrLHZlcnRpY2VzLmxlbmd0aCk7XHJcblxyXG5cdFx0XHRcdHZhciBzID0gMCxcclxuXHRcdFx0XHRcdHNsID0gc3RlcHMgKyBiZXZlbFNlZ21lbnRzICogMjtcclxuXHJcblx0XHRcdFx0Zm9yICggcyA9IDA7IHMgPCBzbDsgcyArKyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgc2xlbjEgPSB2bGVuICogcztcclxuXHRcdFx0XHRcdHZhciBzbGVuMiA9IHZsZW4gKiAoIHMgKyAxICk7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGEgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMSxcclxuXHRcdFx0XHRcdFx0YiA9IGxheWVyb2Zmc2V0ICsgayArIHNsZW4xLFxyXG5cdFx0XHRcdFx0XHRjID0gbGF5ZXJvZmZzZXQgKyBrICsgc2xlbjIsXHJcblx0XHRcdFx0XHRcdGQgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMjtcclxuXHJcblx0XHRcdFx0XHRmNCggYSwgYiwgYywgZCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHYoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0XHRwbGFjZWhvbGRlci5wdXNoKCB4ICk7XHJcblx0XHRcdHBsYWNlaG9sZGVyLnB1c2goIHkgKTtcclxuXHRcdFx0cGxhY2Vob2xkZXIucHVzaCggeiApO1xyXG5cclxuXHRcdH1cclxuXHJcblxyXG5cdFx0ZnVuY3Rpb24gZjMoIGEsIGIsIGMgKSB7XHJcblxyXG5cdFx0XHRhZGRWZXJ0ZXgoIGEgKTtcclxuXHRcdFx0YWRkVmVydGV4KCBiICk7XHJcblx0XHRcdGFkZFZlcnRleCggYyApO1xyXG5cclxuXHRcdFx0dmFyIG5leHRJbmRleCA9IHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMztcclxuXHRcdFx0dmFyIHV2cyA9IHV2Z2VuLmdlbmVyYXRlVG9wVVYoIHNjb3BlLCB2ZXJ0aWNlc0FycmF5LCBuZXh0SW5kZXggLSAzLCBuZXh0SW5kZXggLSAyLCBuZXh0SW5kZXggLSAxICk7XHJcblxyXG5cdFx0XHRhZGRVViggdXZzWyAwIF0gKTtcclxuXHRcdFx0YWRkVVYoIHV2c1sgMSBdICk7XHJcblx0XHRcdGFkZFVWKCB1dnNbIDIgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBmNCggYSwgYiwgYywgZCApIHtcclxuXHJcblx0XHRcdGFkZFZlcnRleCggYSApO1xyXG5cdFx0XHRhZGRWZXJ0ZXgoIGIgKTtcclxuXHRcdFx0YWRkVmVydGV4KCBkICk7XHJcblxyXG5cdFx0XHRhZGRWZXJ0ZXgoIGIgKTtcclxuXHRcdFx0YWRkVmVydGV4KCBjICk7XHJcblx0XHRcdGFkZFZlcnRleCggZCApO1xyXG5cclxuXHJcblx0XHRcdHZhciBuZXh0SW5kZXggPSB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDM7XHJcblx0XHRcdHZhciB1dnMgPSB1dmdlbi5nZW5lcmF0ZVNpZGVXYWxsVVYoIHNjb3BlLCB2ZXJ0aWNlc0FycmF5LCBuZXh0SW5kZXggLSA2LCBuZXh0SW5kZXggLSAzLCBuZXh0SW5kZXggLSAyLCBuZXh0SW5kZXggLSAxICk7XHJcblxyXG5cdFx0XHRhZGRVViggdXZzWyAwIF0gKTtcclxuXHRcdFx0YWRkVVYoIHV2c1sgMSBdICk7XHJcblx0XHRcdGFkZFVWKCB1dnNbIDMgXSApO1xyXG5cclxuXHRcdFx0YWRkVVYoIHV2c1sgMSBdICk7XHJcblx0XHRcdGFkZFVWKCB1dnNbIDIgXSApO1xyXG5cdFx0XHRhZGRVViggdXZzWyAzIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gYWRkVmVydGV4KCBpbmRleCApIHtcclxuXHJcblx0XHRcdHZlcnRpY2VzQXJyYXkucHVzaCggcGxhY2Vob2xkZXJbIGluZGV4ICogMyArIDAgXSApO1xyXG5cdFx0XHR2ZXJ0aWNlc0FycmF5LnB1c2goIHBsYWNlaG9sZGVyWyBpbmRleCAqIDMgKyAxIF0gKTtcclxuXHRcdFx0dmVydGljZXNBcnJheS5wdXNoKCBwbGFjZWhvbGRlclsgaW5kZXggKiAzICsgMiBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHJcblx0XHRmdW5jdGlvbiBhZGRVViggdmVjdG9yMiApIHtcclxuXHJcblx0XHRcdHV2QXJyYXkucHVzaCggdmVjdG9yMi54ICk7XHJcblx0XHRcdHV2QXJyYXkucHVzaCggdmVjdG9yMi55ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5FeHRydWRlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XHJcbkV4dHJ1ZGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFeHRydWRlQnVmZmVyR2VvbWV0cnk7XHJcblxyXG5FeHRydWRlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIGRhdGEgPSBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dmFyIHNoYXBlcyA9IHRoaXMucGFyYW1ldGVycy5zaGFwZXM7XHJcblx0dmFyIG9wdGlvbnMgPSB0aGlzLnBhcmFtZXRlcnMub3B0aW9ucztcclxuXHJcblx0cmV0dXJuIHRvSlNPTiggc2hhcGVzLCBvcHRpb25zLCBkYXRhICk7XHJcblxyXG59O1xyXG5cclxuLy9cclxuXHJcbnZhciBXb3JsZFVWR2VuZXJhdG9yID0ge1xyXG5cclxuXHRnZW5lcmF0ZVRvcFVWOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCB2ZXJ0aWNlcywgaW5kZXhBLCBpbmRleEIsIGluZGV4QyApIHtcclxuXHJcblx0XHR2YXIgYV94ID0gdmVydGljZXNbIGluZGV4QSAqIDMgXTtcclxuXHRcdHZhciBhX3kgPSB2ZXJ0aWNlc1sgaW5kZXhBICogMyArIDEgXTtcclxuXHRcdHZhciBiX3ggPSB2ZXJ0aWNlc1sgaW5kZXhCICogMyBdO1xyXG5cdFx0dmFyIGJfeSA9IHZlcnRpY2VzWyBpbmRleEIgKiAzICsgMSBdO1xyXG5cdFx0dmFyIGNfeCA9IHZlcnRpY2VzWyBpbmRleEMgKiAzIF07XHJcblx0XHR2YXIgY195ID0gdmVydGljZXNbIGluZGV4QyAqIDMgKyAxIF07XHJcblxyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0bmV3IFZlY3RvcjIoIGFfeCwgYV95ICksXHJcblx0XHRcdG5ldyBWZWN0b3IyKCBiX3gsIGJfeSApLFxyXG5cdFx0XHRuZXcgVmVjdG9yMiggY194LCBjX3kgKVxyXG5cdFx0XTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2VuZXJhdGVTaWRlV2FsbFVWOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCB2ZXJ0aWNlcywgaW5kZXhBLCBpbmRleEIsIGluZGV4QywgaW5kZXhEICkge1xyXG5cclxuXHRcdHZhciBhX3ggPSB2ZXJ0aWNlc1sgaW5kZXhBICogMyBdO1xyXG5cdFx0dmFyIGFfeSA9IHZlcnRpY2VzWyBpbmRleEEgKiAzICsgMSBdO1xyXG5cdFx0dmFyIGFfeiA9IHZlcnRpY2VzWyBpbmRleEEgKiAzICsgMiBdO1xyXG5cdFx0dmFyIGJfeCA9IHZlcnRpY2VzWyBpbmRleEIgKiAzIF07XHJcblx0XHR2YXIgYl95ID0gdmVydGljZXNbIGluZGV4QiAqIDMgKyAxIF07XHJcblx0XHR2YXIgYl96ID0gdmVydGljZXNbIGluZGV4QiAqIDMgKyAyIF07XHJcblx0XHR2YXIgY194ID0gdmVydGljZXNbIGluZGV4QyAqIDMgXTtcclxuXHRcdHZhciBjX3kgPSB2ZXJ0aWNlc1sgaW5kZXhDICogMyArIDEgXTtcclxuXHRcdHZhciBjX3ogPSB2ZXJ0aWNlc1sgaW5kZXhDICogMyArIDIgXTtcclxuXHRcdHZhciBkX3ggPSB2ZXJ0aWNlc1sgaW5kZXhEICogMyBdO1xyXG5cdFx0dmFyIGRfeSA9IHZlcnRpY2VzWyBpbmRleEQgKiAzICsgMSBdO1xyXG5cdFx0dmFyIGRfeiA9IHZlcnRpY2VzWyBpbmRleEQgKiAzICsgMiBdO1xyXG5cclxuXHRcdGlmICggTWF0aC5hYnMoIGFfeSAtIGJfeSApIDwgMC4wMSApIHtcclxuXHJcblx0XHRcdHJldHVybiBbXHJcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGFfeCwgMSAtIGFfeiApLFxyXG5cdFx0XHRcdG5ldyBWZWN0b3IyKCBiX3gsIDEgLSBiX3ogKSxcclxuXHRcdFx0XHRuZXcgVmVjdG9yMiggY194LCAxIC0gY196ICksXHJcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGRfeCwgMSAtIGRfeiApXHJcblx0XHRcdF07XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHJldHVybiBbXHJcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGFfeSwgMSAtIGFfeiApLFxyXG5cdFx0XHRcdG5ldyBWZWN0b3IyKCBiX3ksIDEgLSBiX3ogKSxcclxuXHRcdFx0XHRuZXcgVmVjdG9yMiggY195LCAxIC0gY196ICksXHJcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGRfeSwgMSAtIGRfeiApXHJcblx0XHRcdF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcbn07XHJcblxyXG5mdW5jdGlvbiB0b0pTT04oIHNoYXBlcywgb3B0aW9ucywgZGF0YSApIHtcclxuXHJcblx0Ly9cclxuXHJcblx0ZGF0YS5zaGFwZXMgPSBbXTtcclxuXHJcblx0aWYgKCBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSApIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzaGFwZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBzaGFwZSA9IHNoYXBlc1sgaSBdO1xyXG5cclxuXHRcdFx0ZGF0YS5zaGFwZXMucHVzaCggc2hhcGUudXVpZCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRkYXRhLnNoYXBlcy5wdXNoKCBzaGFwZXMudXVpZCApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vXHJcblxyXG5cdGlmICggb3B0aW9ucy5leHRydWRlUGF0aCAhPT0gdW5kZWZpbmVkICkgZGF0YS5vcHRpb25zLmV4dHJ1ZGVQYXRoID0gb3B0aW9ucy5leHRydWRlUGF0aC50b0pTT04oKTtcclxuXHJcblx0cmV0dXJuIGRhdGE7XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IHsgRXh0cnVkZUdlb21ldHJ5LCBFeHRydWRlQnVmZmVyR2VvbWV0cnkgfTtcclxuIiwiaW1wb3J0IHsgX01hdGggfSBmcm9tICcuLi8uLi9tYXRoL01hdGguanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IzLmpzJztcclxuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uLy4uL21hdGgvTWF0cml4NC5qcyc7XHJcblxyXG4vKipcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKiBFeHRlbnNpYmxlIGN1cnZlIG9iamVjdFxyXG4gKlxyXG4gKiBTb21lIGNvbW1vbiBvZiBjdXJ2ZSBtZXRob2RzOlxyXG4gKiAuZ2V0UG9pbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ICksIC5nZXRUYW5nZW50KCB0IClcclxuICogLmdldFBvaW50QXQoIHUsIG9wdGlvbmFsVGFyZ2V0ICksIC5nZXRUYW5nZW50QXQoIHUgKVxyXG4gKiAuZ2V0UG9pbnRzKCksIC5nZXRTcGFjZWRQb2ludHMoKVxyXG4gKiAuZ2V0TGVuZ3RoKClcclxuICogLnVwZGF0ZUFyY0xlbmd0aHMoKVxyXG4gKlxyXG4gKiBUaGlzIGZvbGxvd2luZyBjdXJ2ZXMgaW5oZXJpdCBmcm9tIENPT0wuQ3VydmU6XHJcbiAqXHJcbiAqIC0tIDJEIGN1cnZlcyAtLVxyXG4gKiBDT09MLkFyY0N1cnZlXHJcbiAqIENPT0wuQ3ViaWNCZXppZXJDdXJ2ZVxyXG4gKiBDT09MLkVsbGlwc2VDdXJ2ZVxyXG4gKiBDT09MLkxpbmVDdXJ2ZVxyXG4gKiBDT09MLlF1YWRyYXRpY0JlemllckN1cnZlXHJcbiAqIENPT0wuU3BsaW5lQ3VydmVcclxuICpcclxuICogLS0gM0QgY3VydmVzIC0tXHJcbiAqIENPT0wuQ2F0bXVsbFJvbUN1cnZlM1xyXG4gKiBDT09MLkN1YmljQmV6aWVyQ3VydmUzXHJcbiAqIENPT0wuTGluZUN1cnZlM1xyXG4gKiBDT09MLlF1YWRyYXRpY0JlemllckN1cnZlM1xyXG4gKlxyXG4gKiBBIHNlcmllcyBvZiBjdXJ2ZXMgY2FuIGJlIHJlcHJlc2VudGVkIGFzIGEgQ09PTC5DdXJ2ZVBhdGguXHJcbiAqXHJcbiAqKi9cclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0QWJzdHJhY3QgQ3VydmUgYmFzZSBjbGFzc1xyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5mdW5jdGlvbiBDdXJ2ZSgpIHtcclxuXHJcblx0dGhpcy50eXBlID0gJ0N1cnZlJztcclxuXHJcblx0dGhpcy5hcmNMZW5ndGhEaXZpc2lvbnMgPSAyMDA7XHJcblxyXG59XHJcblxyXG5PYmplY3QuYXNzaWduKCBDdXJ2ZS5wcm90b3R5cGUsIHtcclxuXHJcblx0Ly8gVmlydHVhbCBiYXNlIGNsYXNzIG1ldGhvZCB0byBvdmVyd3JpdGUgYW5kIGltcGxlbWVudCBpbiBzdWJjbGFzc2VzXHJcblx0Ly9cdC0gdCBbMCAuLiAxXVxyXG5cclxuXHRnZXRQb2ludDogZnVuY3Rpb24gKCAvKiB0LCBvcHRpb25hbFRhcmdldCAqLyApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdDT09MLkN1cnZlOiAuZ2V0UG9pbnQoKSBub3QgaW1wbGVtZW50ZWQuJyApO1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIEdldCBwb2ludCBhdCByZWxhdGl2ZSBwb3NpdGlvbiBpbiBjdXJ2ZSBhY2NvcmRpbmcgdG8gYXJjIGxlbmd0aFxyXG5cdC8vIC0gdSBbMCAuLiAxXVxyXG5cclxuXHRnZXRQb2ludEF0OiBmdW5jdGlvbiAoIHUsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciB0ID0gdGhpcy5nZXRVdG9UbWFwcGluZyggdSApO1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0UG9pbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIEdldCBzZXF1ZW5jZSBvZiBwb2ludHMgdXNpbmcgZ2V0UG9pbnQoIHQgKVxyXG5cclxuXHRnZXRQb2ludHM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xyXG5cclxuXHRcdGlmICggZGl2aXNpb25zID09PSB1bmRlZmluZWQgKSBkaXZpc2lvbnMgPSA1O1xyXG5cclxuXHRcdHZhciBwb2ludHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgZCA9IDA7IGQgPD0gZGl2aXNpb25zOyBkICsrICkge1xyXG5cclxuXHRcdFx0cG9pbnRzLnB1c2goIHRoaXMuZ2V0UG9pbnQoIGQgLyBkaXZpc2lvbnMgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcG9pbnRzO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBHZXQgc2VxdWVuY2Ugb2YgcG9pbnRzIHVzaW5nIGdldFBvaW50QXQoIHUgKVxyXG5cclxuXHRnZXRTcGFjZWRQb2ludHM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xyXG5cclxuXHRcdGlmICggZGl2aXNpb25zID09PSB1bmRlZmluZWQgKSBkaXZpc2lvbnMgPSA1O1xyXG5cclxuXHRcdHZhciBwb2ludHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgZCA9IDA7IGQgPD0gZGl2aXNpb25zOyBkICsrICkge1xyXG5cclxuXHRcdFx0cG9pbnRzLnB1c2goIHRoaXMuZ2V0UG9pbnRBdCggZCAvIGRpdmlzaW9ucyApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwb2ludHM7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIEdldCB0b3RhbCBjdXJ2ZSBhcmMgbGVuZ3RoXHJcblxyXG5cdGdldExlbmd0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBsZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzKCk7XHJcblx0XHRyZXR1cm4gbGVuZ3Roc1sgbGVuZ3Rocy5sZW5ndGggLSAxIF07XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIEdldCBsaXN0IG9mIGN1bXVsYXRpdmUgc2VnbWVudCBsZW5ndGhzXHJcblxyXG5cdGdldExlbmd0aHM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xyXG5cclxuXHRcdGlmICggZGl2aXNpb25zID09PSB1bmRlZmluZWQgKSBkaXZpc2lvbnMgPSB0aGlzLmFyY0xlbmd0aERpdmlzaW9ucztcclxuXHJcblx0XHRpZiAoIHRoaXMuY2FjaGVBcmNMZW5ndGhzICYmXHJcblx0XHRcdCggdGhpcy5jYWNoZUFyY0xlbmd0aHMubGVuZ3RoID09PSBkaXZpc2lvbnMgKyAxICkgJiZcclxuXHRcdFx0ISB0aGlzLm5lZWRzVXBkYXRlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuY2FjaGVBcmNMZW5ndGhzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0dmFyIGNhY2hlID0gW107XHJcblx0XHR2YXIgY3VycmVudCwgbGFzdCA9IHRoaXMuZ2V0UG9pbnQoIDAgKTtcclxuXHRcdHZhciBwLCBzdW0gPSAwO1xyXG5cclxuXHRcdGNhY2hlLnB1c2goIDAgKTtcclxuXHJcblx0XHRmb3IgKCBwID0gMTsgcCA8PSBkaXZpc2lvbnM7IHAgKysgKSB7XHJcblxyXG5cdFx0XHRjdXJyZW50ID0gdGhpcy5nZXRQb2ludCggcCAvIGRpdmlzaW9ucyApO1xyXG5cdFx0XHRzdW0gKz0gY3VycmVudC5kaXN0YW5jZVRvKCBsYXN0ICk7XHJcblx0XHRcdGNhY2hlLnB1c2goIHN1bSApO1xyXG5cdFx0XHRsYXN0ID0gY3VycmVudDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jYWNoZUFyY0xlbmd0aHMgPSBjYWNoZTtcclxuXHJcblx0XHRyZXR1cm4gY2FjaGU7IC8vIHsgc3VtczogY2FjaGUsIHN1bTogc3VtIH07IFN1bSBpcyBpbiB0aGUgbGFzdCBlbGVtZW50LlxyXG5cclxuXHR9LFxyXG5cclxuXHR1cGRhdGVBcmNMZW5ndGhzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblx0XHR0aGlzLmdldExlbmd0aHMoKTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gR2l2ZW4gdSAoIDAgLi4gMSApLCBnZXQgYSB0IHRvIGZpbmQgcC4gVGhpcyBnaXZlcyB5b3UgcG9pbnRzIHdoaWNoIGFyZSBlcXVpZGlzdGFudFxyXG5cclxuXHRnZXRVdG9UbWFwcGluZzogZnVuY3Rpb24gKCB1LCBkaXN0YW5jZSApIHtcclxuXHJcblx0XHR2YXIgYXJjTGVuZ3RocyA9IHRoaXMuZ2V0TGVuZ3RocygpO1xyXG5cclxuXHRcdHZhciBpID0gMCwgaWwgPSBhcmNMZW5ndGhzLmxlbmd0aDtcclxuXHJcblx0XHR2YXIgdGFyZ2V0QXJjTGVuZ3RoOyAvLyBUaGUgdGFyZ2V0ZWQgdSBkaXN0YW5jZSB2YWx1ZSB0byBnZXRcclxuXHJcblx0XHRpZiAoIGRpc3RhbmNlICkge1xyXG5cclxuXHRcdFx0dGFyZ2V0QXJjTGVuZ3RoID0gZGlzdGFuY2U7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRhcmdldEFyY0xlbmd0aCA9IHUgKiBhcmNMZW5ndGhzWyBpbCAtIDEgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYmluYXJ5IHNlYXJjaCBmb3IgdGhlIGluZGV4IHdpdGggbGFyZ2VzdCB2YWx1ZSBzbWFsbGVyIHRoYW4gdGFyZ2V0IHUgZGlzdGFuY2VcclxuXHJcblx0XHR2YXIgbG93ID0gMCwgaGlnaCA9IGlsIC0gMSwgY29tcGFyaXNvbjtcclxuXHJcblx0XHR3aGlsZSAoIGxvdyA8PSBoaWdoICkge1xyXG5cclxuXHRcdFx0aSA9IE1hdGguZmxvb3IoIGxvdyArICggaGlnaCAtIGxvdyApIC8gMiApOyAvLyBsZXNzIGxpa2VseSB0byBvdmVyZmxvdywgdGhvdWdoIHByb2JhYmx5IG5vdCBpc3N1ZSBoZXJlLCBKUyBkb2Vzbid0IHJlYWxseSBoYXZlIGludGVnZXJzLCBhbGwgbnVtYmVycyBhcmUgZmxvYXRzXHJcblxyXG5cdFx0XHRjb21wYXJpc29uID0gYXJjTGVuZ3Roc1sgaSBdIC0gdGFyZ2V0QXJjTGVuZ3RoO1xyXG5cclxuXHRcdFx0aWYgKCBjb21wYXJpc29uIDwgMCApIHtcclxuXHJcblx0XHRcdFx0bG93ID0gaSArIDE7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21wYXJpc29uID4gMCApIHtcclxuXHJcblx0XHRcdFx0aGlnaCA9IGkgLSAxO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0aGlnaCA9IGk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdC8vIERPTkVcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aSA9IGhpZ2g7XHJcblxyXG5cdFx0aWYgKCBhcmNMZW5ndGhzWyBpIF0gPT09IHRhcmdldEFyY0xlbmd0aCApIHtcclxuXHJcblx0XHRcdHJldHVybiBpIC8gKCBpbCAtIDEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gd2UgY291bGQgZ2V0IGZpbmVyIGdyYWluIGF0IGxlbmd0aHMsIG9yIHVzZSBzaW1wbGUgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcclxuXHJcblx0XHR2YXIgbGVuZ3RoQmVmb3JlID0gYXJjTGVuZ3Roc1sgaSBdO1xyXG5cdFx0dmFyIGxlbmd0aEFmdGVyID0gYXJjTGVuZ3Roc1sgaSArIDEgXTtcclxuXHJcblx0XHR2YXIgc2VnbWVudExlbmd0aCA9IGxlbmd0aEFmdGVyIC0gbGVuZ3RoQmVmb3JlO1xyXG5cclxuXHRcdC8vIGRldGVybWluZSB3aGVyZSB3ZSBhcmUgYmV0d2VlbiB0aGUgJ2JlZm9yZScgYW5kICdhZnRlcicgcG9pbnRzXHJcblxyXG5cdFx0dmFyIHNlZ21lbnRGcmFjdGlvbiA9ICggdGFyZ2V0QXJjTGVuZ3RoIC0gbGVuZ3RoQmVmb3JlICkgLyBzZWdtZW50TGVuZ3RoO1xyXG5cclxuXHRcdC8vIGFkZCB0aGF0IGZyYWN0aW9uYWwgYW1vdW50IHRvIHRcclxuXHJcblx0XHR2YXIgdCA9ICggaSArIHNlZ21lbnRGcmFjdGlvbiApIC8gKCBpbCAtIDEgKTtcclxuXHJcblx0XHRyZXR1cm4gdDtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gUmV0dXJucyBhIHVuaXQgdmVjdG9yIHRhbmdlbnQgYXQgdFxyXG5cdC8vIEluIGNhc2UgYW55IHN1YiBjdXJ2ZSBkb2VzIG5vdCBpbXBsZW1lbnQgaXRzIHRhbmdlbnQgZGVyaXZhdGlvbixcclxuXHQvLyAyIHBvaW50cyBhIHNtYWxsIGRlbHRhIGFwYXJ0IHdpbGwgYmUgdXNlZCB0byBmaW5kIGl0cyBncmFkaWVudFxyXG5cdC8vIHdoaWNoIHNlZW1zIHRvIGdpdmUgYSByZWFzb25hYmxlIGFwcHJveGltYXRpb25cclxuXHJcblx0Z2V0VGFuZ2VudDogZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHRcdHZhciBkZWx0YSA9IDAuMDAwMTtcclxuXHRcdHZhciB0MSA9IHQgLSBkZWx0YTtcclxuXHRcdHZhciB0MiA9IHQgKyBkZWx0YTtcclxuXHJcblx0XHQvLyBDYXBwaW5nIGluIGNhc2Ugb2YgZGFuZ2VyXHJcblxyXG5cdFx0aWYgKCB0MSA8IDAgKSB0MSA9IDA7XHJcblx0XHRpZiAoIHQyID4gMSApIHQyID0gMTtcclxuXHJcblx0XHR2YXIgcHQxID0gdGhpcy5nZXRQb2ludCggdDEgKTtcclxuXHRcdHZhciBwdDIgPSB0aGlzLmdldFBvaW50KCB0MiApO1xyXG5cclxuXHRcdHZhciB2ZWMgPSBwdDIuY2xvbmUoKS5zdWIoIHB0MSApO1xyXG5cdFx0cmV0dXJuIHZlYy5ub3JtYWxpemUoKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0VGFuZ2VudEF0OiBmdW5jdGlvbiAoIHUgKSB7XHJcblxyXG5cdFx0dmFyIHQgPSB0aGlzLmdldFV0b1RtYXBwaW5nKCB1ICk7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRUYW5nZW50KCB0ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbXB1dGVGcmVuZXRGcmFtZXM6IGZ1bmN0aW9uICggc2VnbWVudHMsIGNsb3NlZCApIHtcclxuXHJcblx0XHQvLyBzZWUgaHR0cDovL3d3dy5jcy5pbmRpYW5hLmVkdS9wdWIvdGVjaHJlcG9ydHMvVFI0MjUucGRmXHJcblxyXG5cdFx0dmFyIG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0dmFyIHRhbmdlbnRzID0gW107XHJcblx0XHR2YXIgbm9ybWFscyA9IFtdO1xyXG5cdFx0dmFyIGJpbm9ybWFscyA9IFtdO1xyXG5cclxuXHRcdHZhciB2ZWMgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0dmFyIG1hdCA9IG5ldyBNYXRyaXg0KCk7XHJcblxyXG5cdFx0dmFyIGksIHUsIHRoZXRhO1xyXG5cclxuXHRcdC8vIGNvbXB1dGUgdGhlIHRhbmdlbnQgdmVjdG9ycyBmb3IgZWFjaCBzZWdtZW50IG9uIHRoZSBjdXJ2ZVxyXG5cclxuXHRcdGZvciAoIGkgPSAwOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xyXG5cclxuXHRcdFx0dSA9IGkgLyBzZWdtZW50cztcclxuXHJcblx0XHRcdHRhbmdlbnRzWyBpIF0gPSB0aGlzLmdldFRhbmdlbnRBdCggdSApO1xyXG5cdFx0XHR0YW5nZW50c1sgaSBdLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBzZWxlY3QgYW4gaW5pdGlhbCBub3JtYWwgdmVjdG9yIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGZpcnN0IHRhbmdlbnQgdmVjdG9yLFxyXG5cdFx0Ly8gYW5kIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIG1pbmltdW0gdGFuZ2VudCB4eXogY29tcG9uZW50XHJcblxyXG5cdFx0bm9ybWFsc1sgMCBdID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdGJpbm9ybWFsc1sgMCBdID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHZhciBtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG5cdFx0dmFyIHR4ID0gTWF0aC5hYnMoIHRhbmdlbnRzWyAwIF0ueCApO1xyXG5cdFx0dmFyIHR5ID0gTWF0aC5hYnMoIHRhbmdlbnRzWyAwIF0ueSApO1xyXG5cdFx0dmFyIHR6ID0gTWF0aC5hYnMoIHRhbmdlbnRzWyAwIF0ueiApO1xyXG5cclxuXHRcdGlmICggdHggPD0gbWluICkge1xyXG5cclxuXHRcdFx0bWluID0gdHg7XHJcblx0XHRcdG5vcm1hbC5zZXQoIDEsIDAsIDAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0eSA8PSBtaW4gKSB7XHJcblxyXG5cdFx0XHRtaW4gPSB0eTtcclxuXHRcdFx0bm9ybWFsLnNldCggMCwgMSwgMCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHR6IDw9IG1pbiApIHtcclxuXHJcblx0XHRcdG5vcm1hbC5zZXQoIDAsIDAsIDEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmVjLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsICkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0bm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgdmVjICk7XHJcblx0XHRiaW5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbHNbIDAgXSApO1xyXG5cclxuXHJcblx0XHQvLyBjb21wdXRlIHRoZSBzbG93bHktdmFyeWluZyBub3JtYWwgYW5kIGJpbm9ybWFsIHZlY3RvcnMgZm9yIGVhY2ggc2VnbWVudCBvbiB0aGUgY3VydmVcclxuXHJcblx0XHRmb3IgKCBpID0gMTsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcclxuXHJcblx0XHRcdG5vcm1hbHNbIGkgXSA9IG5vcm1hbHNbIGkgLSAxIF0uY2xvbmUoKTtcclxuXHJcblx0XHRcdGJpbm9ybWFsc1sgaSBdID0gYmlub3JtYWxzWyBpIC0gMSBdLmNsb25lKCk7XHJcblxyXG5cdFx0XHR2ZWMuY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgaSAtIDEgXSwgdGFuZ2VudHNbIGkgXSApO1xyXG5cclxuXHRcdFx0aWYgKCB2ZWMubGVuZ3RoKCkgPiBOdW1iZXIuRVBTSUxPTiApIHtcclxuXHJcblx0XHRcdFx0dmVjLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0XHR0aGV0YSA9IE1hdGguYWNvcyggX01hdGguY2xhbXAoIHRhbmdlbnRzWyBpIC0gMSBdLmRvdCggdGFuZ2VudHNbIGkgXSApLCAtIDEsIDEgKSApOyAvLyBjbGFtcCBmb3IgZmxvYXRpbmcgcHQgZXJyb3JzXHJcblxyXG5cdFx0XHRcdG5vcm1hbHNbIGkgXS5hcHBseU1hdHJpeDQoIG1hdC5tYWtlUm90YXRpb25BeGlzKCB2ZWMsIHRoZXRhICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGJpbm9ybWFsc1sgaSBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgXSwgbm9ybWFsc1sgaSBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGlmIHRoZSBjdXJ2ZSBpcyBjbG9zZWQsIHBvc3Rwcm9jZXNzIHRoZSB2ZWN0b3JzIHNvIHRoZSBmaXJzdCBhbmQgbGFzdCBub3JtYWwgdmVjdG9ycyBhcmUgdGhlIHNhbWVcclxuXHJcblx0XHRpZiAoIGNsb3NlZCA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdHRoZXRhID0gTWF0aC5hY29zKCBfTWF0aC5jbGFtcCggbm9ybWFsc1sgMCBdLmRvdCggbm9ybWFsc1sgc2VnbWVudHMgXSApLCAtIDEsIDEgKSApO1xyXG5cdFx0XHR0aGV0YSAvPSBzZWdtZW50cztcclxuXHJcblx0XHRcdGlmICggdGFuZ2VudHNbIDAgXS5kb3QoIHZlYy5jcm9zc1ZlY3RvcnMoIG5vcm1hbHNbIDAgXSwgbm9ybWFsc1sgc2VnbWVudHMgXSApICkgPiAwICkge1xyXG5cclxuXHRcdFx0XHR0aGV0YSA9IC0gdGhldGE7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMTsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Ly8gdHdpc3QgYSBsaXR0bGUuLi5cclxuXHRcdFx0XHRub3JtYWxzWyBpIF0uYXBwbHlNYXRyaXg0KCBtYXQubWFrZVJvdGF0aW9uQXhpcyggdGFuZ2VudHNbIGkgXSwgdGhldGEgKiBpICkgKTtcclxuXHRcdFx0XHRiaW5vcm1hbHNbIGkgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIF0sIG5vcm1hbHNbIGkgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR0YW5nZW50czogdGFuZ2VudHMsXHJcblx0XHRcdG5vcm1hbHM6IG5vcm1hbHMsXHJcblx0XHRcdGJpbm9ybWFsczogYmlub3JtYWxzXHJcblx0XHR9O1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0dGhpcy5hcmNMZW5ndGhEaXZpc2lvbnMgPSBzb3VyY2UuYXJjTGVuZ3RoRGl2aXNpb25zO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0pTT046IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0bWV0YWRhdGE6IHtcclxuXHRcdFx0XHR2ZXJzaW9uOiA0LjUsXHJcblx0XHRcdFx0dHlwZTogJ0N1cnZlJyxcclxuXHRcdFx0XHRnZW5lcmF0b3I6ICdDdXJ2ZS50b0pTT04nXHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0ZGF0YS5hcmNMZW5ndGhEaXZpc2lvbnMgPSB0aGlzLmFyY0xlbmd0aERpdmlzaW9ucztcclxuXHRcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcclxuXHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0fSxcclxuXHJcblx0ZnJvbUpTT046IGZ1bmN0aW9uICgganNvbiApIHtcclxuXHJcblx0XHR0aGlzLmFyY0xlbmd0aERpdmlzaW9ucyA9IGpzb24uYXJjTGVuZ3RoRGl2aXNpb25zO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcblxyXG5cclxuZXhwb3J0IHsgQ3VydmUgfTtcclxuIiwiaW1wb3J0IHsgQ3VydmUgfSBmcm9tICcuLi9jb3JlL0N1cnZlLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMi5qcyc7XHJcblxyXG5cclxuZnVuY3Rpb24gRWxsaXBzZUN1cnZlKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApIHtcclxuXHJcblx0Q3VydmUuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnRWxsaXBzZUN1cnZlJztcclxuXHJcblx0dGhpcy5hWCA9IGFYIHx8IDA7XHJcblx0dGhpcy5hWSA9IGFZIHx8IDA7XHJcblxyXG5cdHRoaXMueFJhZGl1cyA9IHhSYWRpdXMgfHwgMTtcclxuXHR0aGlzLnlSYWRpdXMgPSB5UmFkaXVzIHx8IDE7XHJcblxyXG5cdHRoaXMuYVN0YXJ0QW5nbGUgPSBhU3RhcnRBbmdsZSB8fCAwO1xyXG5cdHRoaXMuYUVuZEFuZ2xlID0gYUVuZEFuZ2xlIHx8IDIgKiBNYXRoLlBJO1xyXG5cclxuXHR0aGlzLmFDbG9ja3dpc2UgPSBhQ2xvY2t3aXNlIHx8IGZhbHNlO1xyXG5cclxuXHR0aGlzLmFSb3RhdGlvbiA9IGFSb3RhdGlvbiB8fCAwO1xyXG5cclxufVxyXG5cclxuRWxsaXBzZUN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN1cnZlLnByb3RvdHlwZSApO1xyXG5FbGxpcHNlQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRWxsaXBzZUN1cnZlO1xyXG5cclxuRWxsaXBzZUN1cnZlLnByb3RvdHlwZS5pc0VsbGlwc2VDdXJ2ZSA9IHRydWU7XHJcblxyXG5FbGxpcHNlQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0dmFyIHBvaW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjIoKTtcclxuXHJcblx0dmFyIHR3b1BpID0gTWF0aC5QSSAqIDI7XHJcblx0dmFyIGRlbHRhQW5nbGUgPSB0aGlzLmFFbmRBbmdsZSAtIHRoaXMuYVN0YXJ0QW5nbGU7XHJcblx0dmFyIHNhbWVQb2ludHMgPSBNYXRoLmFicyggZGVsdGFBbmdsZSApIDwgTnVtYmVyLkVQU0lMT047XHJcblxyXG5cdC8vIGVuc3VyZXMgdGhhdCBkZWx0YUFuZ2xlIGlzIDAgLi4gMiBQSVxyXG5cdHdoaWxlICggZGVsdGFBbmdsZSA8IDAgKSBkZWx0YUFuZ2xlICs9IHR3b1BpO1xyXG5cdHdoaWxlICggZGVsdGFBbmdsZSA+IHR3b1BpICkgZGVsdGFBbmdsZSAtPSB0d29QaTtcclxuXHJcblx0aWYgKCBkZWx0YUFuZ2xlIDwgTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG5cdFx0aWYgKCBzYW1lUG9pbnRzICkge1xyXG5cclxuXHRcdFx0ZGVsdGFBbmdsZSA9IDA7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGRlbHRhQW5nbGUgPSB0d29QaTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0aWYgKCB0aGlzLmFDbG9ja3dpc2UgPT09IHRydWUgJiYgISBzYW1lUG9pbnRzICkge1xyXG5cclxuXHRcdGlmICggZGVsdGFBbmdsZSA9PT0gdHdvUGkgKSB7XHJcblxyXG5cdFx0XHRkZWx0YUFuZ2xlID0gLSB0d29QaTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0ZGVsdGFBbmdsZSA9IGRlbHRhQW5nbGUgLSB0d29QaTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIGFuZ2xlID0gdGhpcy5hU3RhcnRBbmdsZSArIHQgKiBkZWx0YUFuZ2xlO1xyXG5cdHZhciB4ID0gdGhpcy5hWCArIHRoaXMueFJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xyXG5cdHZhciB5ID0gdGhpcy5hWSArIHRoaXMueVJhZGl1cyAqIE1hdGguc2luKCBhbmdsZSApO1xyXG5cclxuXHRpZiAoIHRoaXMuYVJvdGF0aW9uICE9PSAwICkge1xyXG5cclxuXHRcdHZhciBjb3MgPSBNYXRoLmNvcyggdGhpcy5hUm90YXRpb24gKTtcclxuXHRcdHZhciBzaW4gPSBNYXRoLnNpbiggdGhpcy5hUm90YXRpb24gKTtcclxuXHJcblx0XHR2YXIgdHggPSB4IC0gdGhpcy5hWDtcclxuXHRcdHZhciB0eSA9IHkgLSB0aGlzLmFZO1xyXG5cclxuXHRcdC8vIFJvdGF0ZSB0aGUgcG9pbnQgYWJvdXQgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZS5cclxuXHRcdHggPSB0eCAqIGNvcyAtIHR5ICogc2luICsgdGhpcy5hWDtcclxuXHRcdHkgPSB0eCAqIHNpbiArIHR5ICogY29zICsgdGhpcy5hWTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcG9pbnQuc2V0KCB4LCB5ICk7XHJcblxyXG59O1xyXG5cclxuRWxsaXBzZUN1cnZlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdEN1cnZlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLmFYID0gc291cmNlLmFYO1xyXG5cdHRoaXMuYVkgPSBzb3VyY2UuYVk7XHJcblxyXG5cdHRoaXMueFJhZGl1cyA9IHNvdXJjZS54UmFkaXVzO1xyXG5cdHRoaXMueVJhZGl1cyA9IHNvdXJjZS55UmFkaXVzO1xyXG5cclxuXHR0aGlzLmFTdGFydEFuZ2xlID0gc291cmNlLmFTdGFydEFuZ2xlO1xyXG5cdHRoaXMuYUVuZEFuZ2xlID0gc291cmNlLmFFbmRBbmdsZTtcclxuXHJcblx0dGhpcy5hQ2xvY2t3aXNlID0gc291cmNlLmFDbG9ja3dpc2U7XHJcblxyXG5cdHRoaXMuYVJvdGF0aW9uID0gc291cmNlLmFSb3RhdGlvbjtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuXHJcbkVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgZGF0YSA9IEN1cnZlLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xyXG5cclxuXHRkYXRhLmFYID0gdGhpcy5hWDtcclxuXHRkYXRhLmFZID0gdGhpcy5hWTtcclxuXHJcblx0ZGF0YS54UmFkaXVzID0gdGhpcy54UmFkaXVzO1xyXG5cdGRhdGEueVJhZGl1cyA9IHRoaXMueVJhZGl1cztcclxuXHJcblx0ZGF0YS5hU3RhcnRBbmdsZSA9IHRoaXMuYVN0YXJ0QW5nbGU7XHJcblx0ZGF0YS5hRW5kQW5nbGUgPSB0aGlzLmFFbmRBbmdsZTtcclxuXHJcblx0ZGF0YS5hQ2xvY2t3aXNlID0gdGhpcy5hQ2xvY2t3aXNlO1xyXG5cclxuXHRkYXRhLmFSb3RhdGlvbiA9IHRoaXMuYVJvdGF0aW9uO1xyXG5cclxuXHRyZXR1cm4gZGF0YTtcclxuXHJcbn07XHJcblxyXG5FbGxpcHNlQ3VydmUucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24gKCBqc29uICkge1xyXG5cclxuXHRDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04uY2FsbCggdGhpcywganNvbiApO1xyXG5cclxuXHR0aGlzLmFYID0ganNvbi5hWDtcclxuXHR0aGlzLmFZID0ganNvbi5hWTtcclxuXHJcblx0dGhpcy54UmFkaXVzID0ganNvbi54UmFkaXVzO1xyXG5cdHRoaXMueVJhZGl1cyA9IGpzb24ueVJhZGl1cztcclxuXHJcblx0dGhpcy5hU3RhcnRBbmdsZSA9IGpzb24uYVN0YXJ0QW5nbGU7XHJcblx0dGhpcy5hRW5kQW5nbGUgPSBqc29uLmFFbmRBbmdsZTtcclxuXHJcblx0dGhpcy5hQ2xvY2t3aXNlID0ganNvbi5hQ2xvY2t3aXNlO1xyXG5cclxuXHR0aGlzLmFSb3RhdGlvbiA9IGpzb24uYVJvdGF0aW9uO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG5cclxuZXhwb3J0IHsgRWxsaXBzZUN1cnZlIH07XHJcbiIsImltcG9ydCB7IEVsbGlwc2VDdXJ2ZSB9IGZyb20gJy4vRWxsaXBzZUN1cnZlLmpzJztcclxuXHJcblxyXG5mdW5jdGlvbiBBcmNDdXJ2ZSggYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xyXG5cclxuXHRFbGxpcHNlQ3VydmUuY2FsbCggdGhpcywgYVgsIGFZLCBhUmFkaXVzLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdBcmNDdXJ2ZSc7XHJcblxyXG59XHJcblxyXG5BcmNDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFbGxpcHNlQ3VydmUucHJvdG90eXBlICk7XHJcbkFyY0N1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFyY0N1cnZlO1xyXG5cclxuQXJjQ3VydmUucHJvdG90eXBlLmlzQXJjQ3VydmUgPSB0cnVlO1xyXG5cclxuXHJcbmV4cG9ydCB7IEFyY0N1cnZlIH07XHJcbiIsImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5pbXBvcnQgeyBDdXJ2ZSB9IGZyb20gJy4uL2NvcmUvQ3VydmUuanMnO1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igeno4NSBodHRwczovL2dpdGh1Yi5jb20veno4NVxyXG4gKlxyXG4gKiBDZW50cmlwZXRhbCBDYXRtdWxsUm9tIEN1cnZlIC0gd2hpY2ggaXMgdXNlZnVsIGZvciBhdm9pZGluZ1xyXG4gKiBjdXNwcyBhbmQgc2VsZi1pbnRlcnNlY3Rpb25zIGluIG5vbi11bmlmb3JtIGNhdG11bGwgcm9tIGN1cnZlcy5cclxuICogaHR0cDovL3d3dy5jZW15dWtzZWwuY29tL3Jlc2VhcmNoL2NhdG11bGxyb21fcGFyYW0vY2F0bXVsbHJvbS5wZGZcclxuICpcclxuICogY3VydmUudHlwZSBhY2NlcHRzIGNlbnRyaXBldGFsKGRlZmF1bHQpLCBjaG9yZGFsIGFuZCBjYXRtdWxscm9tXHJcbiAqIGN1cnZlLnRlbnNpb24gaXMgdXNlZCBmb3IgY2F0bXVsbHJvbSB3aGljaCBkZWZhdWx0cyB0byAwLjVcclxuICovXHJcblxyXG5cclxuLypcclxuQmFzZWQgb24gYW4gb3B0aW1pemVkIGMrKyBzb2x1dGlvbiBpblxyXG4gLSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzk0ODk3MzYvY2F0bXVsbC1yb20tY3VydmUtd2l0aC1uby1jdXNwcy1hbmQtbm8tc2VsZi1pbnRlcnNlY3Rpb25zL1xyXG4gLSBodHRwOi8vaWRlb25lLmNvbS9Ob0ViVk1cclxuXHJcblRoaXMgQ3ViaWNQb2x5IGNsYXNzIGNvdWxkIGJlIHVzZWQgZm9yIHJldXNpbmcgc29tZSB2YXJpYWJsZXMgYW5kIGNhbGN1bGF0aW9ucyxcclxuYnV0IGZvciBDT09MLmpzIGN1cnZlIHVzZSwgaXQgY291bGQgYmUgcG9zc2libGUgaW5saW5lZCBhbmQgZmxhdHRlbiBpbnRvIGEgc2luZ2xlIGZ1bmN0aW9uIGNhbGxcclxud2hpY2ggY2FuIGJlIHBsYWNlZCBpbiBDdXJ2ZVV0aWxzLlxyXG4qL1xyXG5cclxuZnVuY3Rpb24gQ3ViaWNQb2x5KCkge1xyXG5cclxuXHR2YXIgYzAgPSAwLCBjMSA9IDAsIGMyID0gMCwgYzMgPSAwO1xyXG5cclxuXHQvKlxyXG5cdCAqIENvbXB1dGUgY29lZmZpY2llbnRzIGZvciBhIGN1YmljIHBvbHlub21pYWxcclxuXHQgKiAgIHAocykgPSBjMCArIGMxKnMgKyBjMipzXjIgKyBjMypzXjNcclxuXHQgKiBzdWNoIHRoYXRcclxuXHQgKiAgIHAoMCkgPSB4MCwgcCgxKSA9IHgxXHJcblx0ICogIGFuZFxyXG5cdCAqICAgcCcoMCkgPSB0MCwgcCcoMSkgPSB0MS5cclxuXHQgKi9cclxuXHRmdW5jdGlvbiBpbml0KCB4MCwgeDEsIHQwLCB0MSApIHtcclxuXHJcblx0XHRjMCA9IHgwO1xyXG5cdFx0YzEgPSB0MDtcclxuXHRcdGMyID0gLSAzICogeDAgKyAzICogeDEgLSAyICogdDAgLSB0MTtcclxuXHRcdGMzID0gMiAqIHgwIC0gMiAqIHgxICsgdDAgKyB0MTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cclxuXHRcdGluaXRDYXRtdWxsUm9tOiBmdW5jdGlvbiAoIHgwLCB4MSwgeDIsIHgzLCB0ZW5zaW9uICkge1xyXG5cclxuXHRcdFx0aW5pdCggeDEsIHgyLCB0ZW5zaW9uICogKCB4MiAtIHgwICksIHRlbnNpb24gKiAoIHgzIC0geDEgKSApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0aW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tOiBmdW5jdGlvbiAoIHgwLCB4MSwgeDIsIHgzLCBkdDAsIGR0MSwgZHQyICkge1xyXG5cclxuXHRcdFx0Ly8gY29tcHV0ZSB0YW5nZW50cyB3aGVuIHBhcmFtZXRlcml6ZWQgaW4gW3QxLHQyXVxyXG5cdFx0XHR2YXIgdDEgPSAoIHgxIC0geDAgKSAvIGR0MCAtICggeDIgLSB4MCApIC8gKCBkdDAgKyBkdDEgKSArICggeDIgLSB4MSApIC8gZHQxO1xyXG5cdFx0XHR2YXIgdDIgPSAoIHgyIC0geDEgKSAvIGR0MSAtICggeDMgLSB4MSApIC8gKCBkdDEgKyBkdDIgKSArICggeDMgLSB4MiApIC8gZHQyO1xyXG5cclxuXHRcdFx0Ly8gcmVzY2FsZSB0YW5nZW50cyBmb3IgcGFyYW1ldHJpemF0aW9uIGluIFswLDFdXHJcblx0XHRcdHQxICo9IGR0MTtcclxuXHRcdFx0dDIgKj0gZHQxO1xyXG5cclxuXHRcdFx0aW5pdCggeDEsIHgyLCB0MSwgdDIgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNhbGM6IGZ1bmN0aW9uICggdCApIHtcclxuXHJcblx0XHRcdHZhciB0MiA9IHQgKiB0O1xyXG5cdFx0XHR2YXIgdDMgPSB0MiAqIHQ7XHJcblx0XHRcdHJldHVybiBjMCArIGMxICogdCArIGMyICogdDIgKyBjMyAqIHQzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcbn1cclxuXHJcbi8vXHJcblxyXG52YXIgdG1wID0gbmV3IFZlY3RvcjMoKTtcclxudmFyIHB4ID0gbmV3IEN1YmljUG9seSgpLCBweSA9IG5ldyBDdWJpY1BvbHkoKSwgcHogPSBuZXcgQ3ViaWNQb2x5KCk7XHJcblxyXG5mdW5jdGlvbiBDYXRtdWxsUm9tQ3VydmUzKCBwb2ludHMsIGNsb3NlZCwgY3VydmVUeXBlLCB0ZW5zaW9uICkge1xyXG5cclxuXHRDdXJ2ZS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdDYXRtdWxsUm9tQ3VydmUzJztcclxuXHJcblx0dGhpcy5wb2ludHMgPSBwb2ludHMgfHwgW107XHJcblx0dGhpcy5jbG9zZWQgPSBjbG9zZWQgfHwgZmFsc2U7XHJcblx0dGhpcy5jdXJ2ZVR5cGUgPSBjdXJ2ZVR5cGUgfHwgJ2NlbnRyaXBldGFsJztcclxuXHR0aGlzLnRlbnNpb24gPSB0ZW5zaW9uIHx8IDAuNTtcclxuXHJcbn1cclxuXHJcbkNhdG11bGxSb21DdXJ2ZTMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XHJcbkNhdG11bGxSb21DdXJ2ZTMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2F0bXVsbFJvbUN1cnZlMztcclxuXHJcbkNhdG11bGxSb21DdXJ2ZTMucHJvdG90eXBlLmlzQ2F0bXVsbFJvbUN1cnZlMyA9IHRydWU7XHJcblxyXG5DYXRtdWxsUm9tQ3VydmUzLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdHZhciBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcclxuXHR2YXIgbCA9IHBvaW50cy5sZW5ndGg7XHJcblxyXG5cdHZhciBwID0gKCBsIC0gKCB0aGlzLmNsb3NlZCA/IDAgOiAxICkgKSAqIHQ7XHJcblx0dmFyIGludFBvaW50ID0gTWF0aC5mbG9vciggcCApO1xyXG5cdHZhciB3ZWlnaHQgPSBwIC0gaW50UG9pbnQ7XHJcblxyXG5cdGlmICggdGhpcy5jbG9zZWQgKSB7XHJcblxyXG5cdFx0aW50UG9pbnQgKz0gaW50UG9pbnQgPiAwID8gMCA6ICggTWF0aC5mbG9vciggTWF0aC5hYnMoIGludFBvaW50ICkgLyBsICkgKyAxICkgKiBsO1xyXG5cclxuXHR9IGVsc2UgaWYgKCB3ZWlnaHQgPT09IDAgJiYgaW50UG9pbnQgPT09IGwgLSAxICkge1xyXG5cclxuXHRcdGludFBvaW50ID0gbCAtIDI7XHJcblx0XHR3ZWlnaHQgPSAxO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBwMCwgcDEsIHAyLCBwMzsgLy8gNCBwb2ludHNcclxuXHJcblx0aWYgKCB0aGlzLmNsb3NlZCB8fCBpbnRQb2ludCA+IDAgKSB7XHJcblxyXG5cdFx0cDAgPSBwb2ludHNbICggaW50UG9pbnQgLSAxICkgJSBsIF07XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0Ly8gZXh0cmFwb2xhdGUgZmlyc3QgcG9pbnRcclxuXHRcdHRtcC5zdWJWZWN0b3JzKCBwb2ludHNbIDAgXSwgcG9pbnRzWyAxIF0gKS5hZGQoIHBvaW50c1sgMCBdICk7XHJcblx0XHRwMCA9IHRtcDtcclxuXHJcblx0fVxyXG5cclxuXHRwMSA9IHBvaW50c1sgaW50UG9pbnQgJSBsIF07XHJcblx0cDIgPSBwb2ludHNbICggaW50UG9pbnQgKyAxICkgJSBsIF07XHJcblxyXG5cdGlmICggdGhpcy5jbG9zZWQgfHwgaW50UG9pbnQgKyAyIDwgbCApIHtcclxuXHJcblx0XHRwMyA9IHBvaW50c1sgKCBpbnRQb2ludCArIDIgKSAlIGwgXTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHQvLyBleHRyYXBvbGF0ZSBsYXN0IHBvaW50XHJcblx0XHR0bXAuc3ViVmVjdG9ycyggcG9pbnRzWyBsIC0gMSBdLCBwb2ludHNbIGwgLSAyIF0gKS5hZGQoIHBvaW50c1sgbCAtIDEgXSApO1xyXG5cdFx0cDMgPSB0bXA7XHJcblxyXG5cdH1cclxuXHJcblx0aWYgKCB0aGlzLmN1cnZlVHlwZSA9PT0gJ2NlbnRyaXBldGFsJyB8fCB0aGlzLmN1cnZlVHlwZSA9PT0gJ2Nob3JkYWwnICkge1xyXG5cclxuXHRcdC8vIGluaXQgQ2VudHJpcGV0YWwgLyBDaG9yZGFsIENhdG11bGwtUm9tXHJcblx0XHR2YXIgcG93ID0gdGhpcy5jdXJ2ZVR5cGUgPT09ICdjaG9yZGFsJyA/IDAuNSA6IDAuMjU7XHJcblx0XHR2YXIgZHQwID0gTWF0aC5wb3coIHAwLmRpc3RhbmNlVG9TcXVhcmVkKCBwMSApLCBwb3cgKTtcclxuXHRcdHZhciBkdDEgPSBNYXRoLnBvdyggcDEuZGlzdGFuY2VUb1NxdWFyZWQoIHAyICksIHBvdyApO1xyXG5cdFx0dmFyIGR0MiA9IE1hdGgucG93KCBwMi5kaXN0YW5jZVRvU3F1YXJlZCggcDMgKSwgcG93ICk7XHJcblxyXG5cdFx0Ly8gc2FmZXR5IGNoZWNrIGZvciByZXBlYXRlZCBwb2ludHNcclxuXHRcdGlmICggZHQxIDwgMWUtNCApIGR0MSA9IDEuMDtcclxuXHRcdGlmICggZHQwIDwgMWUtNCApIGR0MCA9IGR0MTtcclxuXHRcdGlmICggZHQyIDwgMWUtNCApIGR0MiA9IGR0MTtcclxuXHJcblx0XHRweC5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oIHAwLngsIHAxLngsIHAyLngsIHAzLngsIGR0MCwgZHQxLCBkdDIgKTtcclxuXHRcdHB5LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSggcDAueSwgcDEueSwgcDIueSwgcDMueSwgZHQwLCBkdDEsIGR0MiApO1xyXG5cdFx0cHouaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tKCBwMC56LCBwMS56LCBwMi56LCBwMy56LCBkdDAsIGR0MSwgZHQyICk7XHJcblxyXG5cdH0gZWxzZSBpZiAoIHRoaXMuY3VydmVUeXBlID09PSAnY2F0bXVsbHJvbScgKSB7XHJcblxyXG5cdFx0cHguaW5pdENhdG11bGxSb20oIHAwLngsIHAxLngsIHAyLngsIHAzLngsIHRoaXMudGVuc2lvbiApO1xyXG5cdFx0cHkuaW5pdENhdG11bGxSb20oIHAwLnksIHAxLnksIHAyLnksIHAzLnksIHRoaXMudGVuc2lvbiApO1xyXG5cdFx0cHouaW5pdENhdG11bGxSb20oIHAwLnosIHAxLnosIHAyLnosIHAzLnosIHRoaXMudGVuc2lvbiApO1xyXG5cclxuXHR9XHJcblxyXG5cdHBvaW50LnNldChcclxuXHRcdHB4LmNhbGMoIHdlaWdodCApLFxyXG5cdFx0cHkuY2FsYyggd2VpZ2h0ICksXHJcblx0XHRwei5jYWxjKCB3ZWlnaHQgKVxyXG5cdCk7XHJcblxyXG5cdHJldHVybiBwb2ludDtcclxuXHJcbn07XHJcblxyXG5DYXRtdWxsUm9tQ3VydmUzLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdEN1cnZlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLnBvaW50cyA9IFtdO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzb3VyY2UucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIHBvaW50ID0gc291cmNlLnBvaW50c1sgaSBdO1xyXG5cclxuXHRcdHRoaXMucG9pbnRzLnB1c2goIHBvaW50LmNsb25lKCkgKTtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmNsb3NlZCA9IHNvdXJjZS5jbG9zZWQ7XHJcblx0dGhpcy5jdXJ2ZVR5cGUgPSBzb3VyY2UuY3VydmVUeXBlO1xyXG5cdHRoaXMudGVuc2lvbiA9IHNvdXJjZS50ZW5zaW9uO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG5DYXRtdWxsUm9tQ3VydmUzLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBkYXRhID0gQ3VydmUucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XHJcblxyXG5cdGRhdGEucG9pbnRzID0gW107XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIHBvaW50ID0gdGhpcy5wb2ludHNbIGkgXTtcclxuXHRcdGRhdGEucG9pbnRzLnB1c2goIHBvaW50LnRvQXJyYXkoKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGRhdGEuY2xvc2VkID0gdGhpcy5jbG9zZWQ7XHJcblx0ZGF0YS5jdXJ2ZVR5cGUgPSB0aGlzLmN1cnZlVHlwZTtcclxuXHRkYXRhLnRlbnNpb24gPSB0aGlzLnRlbnNpb247XHJcblxyXG5cdHJldHVybiBkYXRhO1xyXG5cclxufTtcclxuXHJcbkNhdG11bGxSb21DdXJ2ZTMucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24gKCBqc29uICkge1xyXG5cclxuXHRDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04uY2FsbCggdGhpcywganNvbiApO1xyXG5cclxuXHR0aGlzLnBvaW50cyA9IFtdO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLnBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdHZhciBwb2ludCA9IGpzb24ucG9pbnRzWyBpIF07XHJcblx0XHR0aGlzLnBvaW50cy5wdXNoKCBuZXcgVmVjdG9yMygpLmZyb21BcnJheSggcG9pbnQgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuY2xvc2VkID0ganNvbi5jbG9zZWQ7XHJcblx0dGhpcy5jdXJ2ZVR5cGUgPSBqc29uLmN1cnZlVHlwZTtcclxuXHR0aGlzLnRlbnNpb24gPSBqc29uLnRlbnNpb247XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcblxyXG5leHBvcnQgeyBDYXRtdWxsUm9tQ3VydmUzIH07XHJcbiIsIi8qKlxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqXHJcbiAqIEJlemllciBDdXJ2ZXMgZm9ybXVsYXMgb2J0YWluZWQgZnJvbVxyXG4gKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0LDqXppZXJfY3VydmVcclxuICovXHJcblxyXG5mdW5jdGlvbiBDYXRtdWxsUm9tKCB0LCBwMCwgcDEsIHAyLCBwMyApIHtcclxuXHJcblx0dmFyIHYwID0gKCBwMiAtIHAwICkgKiAwLjU7XHJcblx0dmFyIHYxID0gKCBwMyAtIHAxICkgKiAwLjU7XHJcblx0dmFyIHQyID0gdCAqIHQ7XHJcblx0dmFyIHQzID0gdCAqIHQyO1xyXG5cdHJldHVybiAoIDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEgKSAqIHQzICsgKCAtIDMgKiBwMSArIDMgKiBwMiAtIDIgKiB2MCAtIHYxICkgKiB0MiArIHYwICogdCArIHAxO1xyXG5cclxufVxyXG5cclxuLy9cclxuXHJcbmZ1bmN0aW9uIFF1YWRyYXRpY0JlemllclAwKCB0LCBwICkge1xyXG5cclxuXHR2YXIgayA9IDEgLSB0O1xyXG5cdHJldHVybiBrICogayAqIHA7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBRdWFkcmF0aWNCZXppZXJQMSggdCwgcCApIHtcclxuXHJcblx0cmV0dXJuIDIgKiAoIDEgLSB0ICkgKiB0ICogcDtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIFF1YWRyYXRpY0JlemllclAyKCB0LCBwICkge1xyXG5cclxuXHRyZXR1cm4gdCAqIHQgKiBwO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyKCB0LCBwMCwgcDEsIHAyICkge1xyXG5cclxuXHRyZXR1cm4gUXVhZHJhdGljQmV6aWVyUDAoIHQsIHAwICkgKyBRdWFkcmF0aWNCZXppZXJQMSggdCwgcDEgKSArXHJcblx0XHRRdWFkcmF0aWNCZXppZXJQMiggdCwgcDIgKTtcclxuXHJcbn1cclxuXHJcbi8vXHJcblxyXG5mdW5jdGlvbiBDdWJpY0JlemllclAwKCB0LCBwICkge1xyXG5cclxuXHR2YXIgayA9IDEgLSB0O1xyXG5cdHJldHVybiBrICogayAqIGsgKiBwO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gQ3ViaWNCZXppZXJQMSggdCwgcCApIHtcclxuXHJcblx0dmFyIGsgPSAxIC0gdDtcclxuXHRyZXR1cm4gMyAqIGsgKiBrICogdCAqIHA7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBDdWJpY0JlemllclAyKCB0LCBwICkge1xyXG5cclxuXHRyZXR1cm4gMyAqICggMSAtIHQgKSAqIHQgKiB0ICogcDtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIEN1YmljQmV6aWVyUDMoIHQsIHAgKSB7XHJcblxyXG5cdHJldHVybiB0ICogdCAqIHQgKiBwO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gQ3ViaWNCZXppZXIoIHQsIHAwLCBwMSwgcDIsIHAzICkge1xyXG5cclxuXHRyZXR1cm4gQ3ViaWNCZXppZXJQMCggdCwgcDAgKSArIEN1YmljQmV6aWVyUDEoIHQsIHAxICkgKyBDdWJpY0JlemllclAyKCB0LCBwMiApICtcclxuXHRcdEN1YmljQmV6aWVyUDMoIHQsIHAzICk7XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBDYXRtdWxsUm9tLCBRdWFkcmF0aWNCZXppZXIsIEN1YmljQmV6aWVyIH07XHJcbiIsImltcG9ydCB7IEN1cnZlIH0gZnJvbSAnLi4vY29yZS9DdXJ2ZS5qcyc7XHJcbmltcG9ydCB7IEN1YmljQmV6aWVyIH0gZnJvbSAnLi4vY29yZS9JbnRlcnBvbGF0aW9ucy5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjIuanMnO1xyXG5cclxuXHJcbmZ1bmN0aW9uIEN1YmljQmV6aWVyQ3VydmUoIHYwLCB2MSwgdjIsIHYzICkge1xyXG5cclxuXHRDdXJ2ZS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdDdWJpY0JlemllckN1cnZlJztcclxuXHJcblx0dGhpcy52MCA9IHYwIHx8IG5ldyBWZWN0b3IyKCk7XHJcblx0dGhpcy52MSA9IHYxIHx8IG5ldyBWZWN0b3IyKCk7XHJcblx0dGhpcy52MiA9IHYyIHx8IG5ldyBWZWN0b3IyKCk7XHJcblx0dGhpcy52MyA9IHYzIHx8IG5ldyBWZWN0b3IyKCk7XHJcblxyXG59XHJcblxyXG5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN1cnZlLnByb3RvdHlwZSApO1xyXG5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEN1YmljQmV6aWVyQ3VydmU7XHJcblxyXG5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5pc0N1YmljQmV6aWVyQ3VydmUgPSB0cnVlO1xyXG5cclxuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHR2YXIgcG9pbnQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMigpO1xyXG5cclxuXHR2YXIgdjAgPSB0aGlzLnYwLCB2MSA9IHRoaXMudjEsIHYyID0gdGhpcy52MiwgdjMgPSB0aGlzLnYzO1xyXG5cclxuXHRwb2ludC5zZXQoXHJcblx0XHRDdWJpY0JlemllciggdCwgdjAueCwgdjEueCwgdjIueCwgdjMueCApLFxyXG5cdFx0Q3ViaWNCZXppZXIoIHQsIHYwLnksIHYxLnksIHYyLnksIHYzLnkgKVxyXG5cdCk7XHJcblxyXG5cdHJldHVybiBwb2ludDtcclxuXHJcbn07XHJcblxyXG5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdEN1cnZlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLnYwLmNvcHkoIHNvdXJjZS52MCApO1xyXG5cdHRoaXMudjEuY29weSggc291cmNlLnYxICk7XHJcblx0dGhpcy52Mi5jb3B5KCBzb3VyY2UudjIgKTtcclxuXHR0aGlzLnYzLmNvcHkoIHNvdXJjZS52MyApO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBkYXRhID0gQ3VydmUucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XHJcblxyXG5cdGRhdGEudjAgPSB0aGlzLnYwLnRvQXJyYXkoKTtcclxuXHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XHJcblx0ZGF0YS52MiA9IHRoaXMudjIudG9BcnJheSgpO1xyXG5cdGRhdGEudjMgPSB0aGlzLnYzLnRvQXJyYXkoKTtcclxuXHJcblx0cmV0dXJuIGRhdGE7XHJcblxyXG59O1xyXG5cclxuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04gPSBmdW5jdGlvbiAoIGpzb24gKSB7XHJcblxyXG5cdEN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTi5jYWxsKCB0aGlzLCBqc29uICk7XHJcblxyXG5cdHRoaXMudjAuZnJvbUFycmF5KCBqc29uLnYwICk7XHJcblx0dGhpcy52MS5mcm9tQXJyYXkoIGpzb24udjEgKTtcclxuXHR0aGlzLnYyLmZyb21BcnJheSgganNvbi52MiApO1xyXG5cdHRoaXMudjMuZnJvbUFycmF5KCBqc29uLnYzICk7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcblxyXG5leHBvcnQgeyBDdWJpY0JlemllckN1cnZlIH07XHJcbiIsImltcG9ydCB7IEN1cnZlIH0gZnJvbSAnLi4vY29yZS9DdXJ2ZS5qcyc7XHJcbmltcG9ydCB7IEN1YmljQmV6aWVyIH0gZnJvbSAnLi4vY29yZS9JbnRlcnBvbGF0aW9ucy5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5cclxuXHJcbmZ1bmN0aW9uIEN1YmljQmV6aWVyQ3VydmUzKCB2MCwgdjEsIHYyLCB2MyApIHtcclxuXHJcblx0Q3VydmUuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnQ3ViaWNCZXppZXJDdXJ2ZTMnO1xyXG5cclxuXHR0aGlzLnYwID0gdjAgfHwgbmV3IFZlY3RvcjMoKTtcclxuXHR0aGlzLnYxID0gdjEgfHwgbmV3IFZlY3RvcjMoKTtcclxuXHR0aGlzLnYyID0gdjIgfHwgbmV3IFZlY3RvcjMoKTtcclxuXHR0aGlzLnYzID0gdjMgfHwgbmV3IFZlY3RvcjMoKTtcclxuXHJcbn1cclxuXHJcbkN1YmljQmV6aWVyQ3VydmUzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN1cnZlLnByb3RvdHlwZSApO1xyXG5DdWJpY0JlemllckN1cnZlMy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDdWJpY0JlemllckN1cnZlMztcclxuXHJcbkN1YmljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5pc0N1YmljQmV6aWVyQ3VydmUzID0gdHJ1ZTtcclxuXHJcbkN1YmljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdHZhciBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdHZhciB2MCA9IHRoaXMudjAsIHYxID0gdGhpcy52MSwgdjIgPSB0aGlzLnYyLCB2MyA9IHRoaXMudjM7XHJcblxyXG5cdHBvaW50LnNldChcclxuXHRcdEN1YmljQmV6aWVyKCB0LCB2MC54LCB2MS54LCB2Mi54LCB2My54ICksXHJcblx0XHRDdWJpY0JlemllciggdCwgdjAueSwgdjEueSwgdjIueSwgdjMueSApLFxyXG5cdFx0Q3ViaWNCZXppZXIoIHQsIHYwLnosIHYxLnosIHYyLnosIHYzLnogKVxyXG5cdCk7XHJcblxyXG5cdHJldHVybiBwb2ludDtcclxuXHJcbn07XHJcblxyXG5DdWJpY0JlemllckN1cnZlMy5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRDdXJ2ZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0dGhpcy52MC5jb3B5KCBzb3VyY2UudjAgKTtcclxuXHR0aGlzLnYxLmNvcHkoIHNvdXJjZS52MSApO1xyXG5cdHRoaXMudjIuY29weSggc291cmNlLnYyICk7XHJcblx0dGhpcy52My5jb3B5KCBzb3VyY2UudjMgKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuQ3ViaWNCZXppZXJDdXJ2ZTMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIGRhdGEgPSBDdXJ2ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0ZGF0YS52MCA9IHRoaXMudjAudG9BcnJheSgpO1xyXG5cdGRhdGEudjEgPSB0aGlzLnYxLnRvQXJyYXkoKTtcclxuXHRkYXRhLnYyID0gdGhpcy52Mi50b0FycmF5KCk7XHJcblx0ZGF0YS52MyA9IHRoaXMudjMudG9BcnJheSgpO1xyXG5cclxuXHRyZXR1cm4gZGF0YTtcclxuXHJcbn07XHJcblxyXG5DdWJpY0JlemllckN1cnZlMy5wcm90b3R5cGUuZnJvbUpTT04gPSBmdW5jdGlvbiAoIGpzb24gKSB7XHJcblxyXG5cdEN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTi5jYWxsKCB0aGlzLCBqc29uICk7XHJcblxyXG5cdHRoaXMudjAuZnJvbUFycmF5KCBqc29uLnYwICk7XHJcblx0dGhpcy52MS5mcm9tQXJyYXkoIGpzb24udjEgKTtcclxuXHR0aGlzLnYyLmZyb21BcnJheSgganNvbi52MiApO1xyXG5cdHRoaXMudjMuZnJvbUFycmF5KCBqc29uLnYzICk7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcblxyXG5leHBvcnQgeyBDdWJpY0JlemllckN1cnZlMyB9O1xyXG4iLCJpbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IyLmpzJztcclxuaW1wb3J0IHsgQ3VydmUgfSBmcm9tICcuLi9jb3JlL0N1cnZlLmpzJztcclxuXHJcblxyXG5mdW5jdGlvbiBMaW5lQ3VydmUoIHYxLCB2MiApIHtcclxuXHJcblx0Q3VydmUuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnTGluZUN1cnZlJztcclxuXHJcblx0dGhpcy52MSA9IHYxIHx8IG5ldyBWZWN0b3IyKCk7XHJcblx0dGhpcy52MiA9IHYyIHx8IG5ldyBWZWN0b3IyKCk7XHJcblxyXG59XHJcblxyXG5MaW5lQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XHJcbkxpbmVDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMaW5lQ3VydmU7XHJcblxyXG5MaW5lQ3VydmUucHJvdG90eXBlLmlzTGluZUN1cnZlID0gdHJ1ZTtcclxuXHJcbkxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHR2YXIgcG9pbnQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMigpO1xyXG5cclxuXHRpZiAoIHQgPT09IDEgKSB7XHJcblxyXG5cdFx0cG9pbnQuY29weSggdGhpcy52MiApO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdHBvaW50LmNvcHkoIHRoaXMudjIgKS5zdWIoIHRoaXMudjEgKTtcclxuXHRcdHBvaW50Lm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLnYxICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHBvaW50O1xyXG5cclxufTtcclxuXHJcbi8vIExpbmUgY3VydmUgaXMgbGluZWFyLCBzbyB3ZSBjYW4gb3ZlcndyaXRlIGRlZmF1bHQgZ2V0UG9pbnRBdFxyXG5cclxuTGluZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludEF0ID0gZnVuY3Rpb24gKCB1LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0cmV0dXJuIHRoaXMuZ2V0UG9pbnQoIHUsIG9wdGlvbmFsVGFyZ2V0ICk7XHJcblxyXG59O1xyXG5cclxuTGluZUN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24gKCAvKiB0ICovICkge1xyXG5cclxuXHR2YXIgdGFuZ2VudCA9IHRoaXMudjIuY2xvbmUoKS5zdWIoIHRoaXMudjEgKTtcclxuXHJcblx0cmV0dXJuIHRhbmdlbnQubm9ybWFsaXplKCk7XHJcblxyXG59O1xyXG5cclxuTGluZUN1cnZlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdEN1cnZlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHR0aGlzLnYxLmNvcHkoIHNvdXJjZS52MSApO1xyXG5cdHRoaXMudjIuY29weSggc291cmNlLnYyICk7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbkxpbmVDdXJ2ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgZGF0YSA9IEN1cnZlLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xyXG5cclxuXHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XHJcblx0ZGF0YS52MiA9IHRoaXMudjIudG9BcnJheSgpO1xyXG5cclxuXHRyZXR1cm4gZGF0YTtcclxuXHJcbn07XHJcblxyXG5MaW5lQ3VydmUucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24gKCBqc29uICkge1xyXG5cclxuXHRDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04uY2FsbCggdGhpcywganNvbiApO1xyXG5cclxuXHR0aGlzLnYxLmZyb21BcnJheSgganNvbi52MSApO1xyXG5cdHRoaXMudjIuZnJvbUFycmF5KCBqc29uLnYyICk7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcblxyXG5leHBvcnQgeyBMaW5lQ3VydmUgfTtcclxuIiwiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMy5qcyc7XHJcbmltcG9ydCB7IEN1cnZlIH0gZnJvbSAnLi4vY29yZS9DdXJ2ZS5qcyc7XHJcblxyXG5cclxuZnVuY3Rpb24gTGluZUN1cnZlMyggdjEsIHYyICkge1xyXG5cclxuXHRDdXJ2ZS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdMaW5lQ3VydmUzJztcclxuXHJcblx0dGhpcy52MSA9IHYxIHx8IG5ldyBWZWN0b3IzKCk7XHJcblx0dGhpcy52MiA9IHYyIHx8IG5ldyBWZWN0b3IzKCk7XHJcblxyXG59XHJcblxyXG5MaW5lQ3VydmUzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN1cnZlLnByb3RvdHlwZSApO1xyXG5MaW5lQ3VydmUzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpbmVDdXJ2ZTM7XHJcblxyXG5MaW5lQ3VydmUzLnByb3RvdHlwZS5pc0xpbmVDdXJ2ZTMgPSB0cnVlO1xyXG5cclxuTGluZUN1cnZlMy5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHR2YXIgcG9pbnQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRpZiAoIHQgPT09IDEgKSB7XHJcblxyXG5cdFx0cG9pbnQuY29weSggdGhpcy52MiApO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdHBvaW50LmNvcHkoIHRoaXMudjIgKS5zdWIoIHRoaXMudjEgKTtcclxuXHRcdHBvaW50Lm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLnYxICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHBvaW50O1xyXG5cclxufTtcclxuXHJcbi8vIExpbmUgY3VydmUgaXMgbGluZWFyLCBzbyB3ZSBjYW4gb3ZlcndyaXRlIGRlZmF1bHQgZ2V0UG9pbnRBdFxyXG5cclxuTGluZUN1cnZlMy5wcm90b3R5cGUuZ2V0UG9pbnRBdCA9IGZ1bmN0aW9uICggdSwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdHJldHVybiB0aGlzLmdldFBvaW50KCB1LCBvcHRpb25hbFRhcmdldCApO1xyXG5cclxufTtcclxuXHJcbkxpbmVDdXJ2ZTMucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0Q3VydmUucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdHRoaXMudjEuY29weSggc291cmNlLnYxICk7XHJcblx0dGhpcy52Mi5jb3B5KCBzb3VyY2UudjIgKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuTGluZUN1cnZlMy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgZGF0YSA9IEN1cnZlLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xyXG5cclxuXHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XHJcblx0ZGF0YS52MiA9IHRoaXMudjIudG9BcnJheSgpO1xyXG5cclxuXHRyZXR1cm4gZGF0YTtcclxuXHJcbn07XHJcblxyXG5MaW5lQ3VydmUzLnByb3RvdHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uICgganNvbiApIHtcclxuXHJcblx0Q3VydmUucHJvdG90eXBlLmZyb21KU09OLmNhbGwoIHRoaXMsIGpzb24gKTtcclxuXHJcblx0dGhpcy52MS5mcm9tQXJyYXkoIGpzb24udjEgKTtcclxuXHR0aGlzLnYyLmZyb21BcnJheSgganNvbi52MiApO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG5cclxuZXhwb3J0IHsgTGluZUN1cnZlMyB9O1xyXG4iLCJpbXBvcnQgeyBDdXJ2ZSB9IGZyb20gJy4uL2NvcmUvQ3VydmUuanMnO1xyXG5pbXBvcnQgeyBRdWFkcmF0aWNCZXppZXIgfSBmcm9tICcuLi9jb3JlL0ludGVycG9sYXRpb25zLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMi5qcyc7XHJcblxyXG5cclxuZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyQ3VydmUoIHYwLCB2MSwgdjIgKSB7XHJcblxyXG5cdEN1cnZlLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ1F1YWRyYXRpY0JlemllckN1cnZlJztcclxuXHJcblx0dGhpcy52MCA9IHYwIHx8IG5ldyBWZWN0b3IyKCk7XHJcblx0dGhpcy52MSA9IHYxIHx8IG5ldyBWZWN0b3IyKCk7XHJcblx0dGhpcy52MiA9IHYyIHx8IG5ldyBWZWN0b3IyKCk7XHJcblxyXG59XHJcblxyXG5RdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKTtcclxuUXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUXVhZHJhdGljQmV6aWVyQ3VydmU7XHJcblxyXG5RdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuaXNRdWFkcmF0aWNCZXppZXJDdXJ2ZSA9IHRydWU7XHJcblxyXG5RdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHR2YXIgcG9pbnQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMigpO1xyXG5cclxuXHR2YXIgdjAgPSB0aGlzLnYwLCB2MSA9IHRoaXMudjEsIHYyID0gdGhpcy52MjtcclxuXHJcblx0cG9pbnQuc2V0KFxyXG5cdFx0UXVhZHJhdGljQmV6aWVyKCB0LCB2MC54LCB2MS54LCB2Mi54ICksXHJcblx0XHRRdWFkcmF0aWNCZXppZXIoIHQsIHYwLnksIHYxLnksIHYyLnkgKVxyXG5cdCk7XHJcblxyXG5cdHJldHVybiBwb2ludDtcclxuXHJcbn07XHJcblxyXG5RdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRDdXJ2ZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0dGhpcy52MC5jb3B5KCBzb3VyY2UudjAgKTtcclxuXHR0aGlzLnYxLmNvcHkoIHNvdXJjZS52MSApO1xyXG5cdHRoaXMudjIuY29weSggc291cmNlLnYyICk7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcblF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBkYXRhID0gQ3VydmUucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XHJcblxyXG5cdGRhdGEudjAgPSB0aGlzLnYwLnRvQXJyYXkoKTtcclxuXHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XHJcblx0ZGF0YS52MiA9IHRoaXMudjIudG9BcnJheSgpO1xyXG5cclxuXHRyZXR1cm4gZGF0YTtcclxuXHJcbn07XHJcblxyXG5RdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04gPSBmdW5jdGlvbiAoIGpzb24gKSB7XHJcblxyXG5cdEN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTi5jYWxsKCB0aGlzLCBqc29uICk7XHJcblxyXG5cdHRoaXMudjAuZnJvbUFycmF5KCBqc29uLnYwICk7XHJcblx0dGhpcy52MS5mcm9tQXJyYXkoIGpzb24udjEgKTtcclxuXHR0aGlzLnYyLmZyb21BcnJheSgganNvbi52MiApO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG5cclxuZXhwb3J0IHsgUXVhZHJhdGljQmV6aWVyQ3VydmUgfTtcclxuIiwiaW1wb3J0IHsgQ3VydmUgfSBmcm9tICcuLi9jb3JlL0N1cnZlLmpzJztcclxuaW1wb3J0IHsgUXVhZHJhdGljQmV6aWVyIH0gZnJvbSAnLi4vY29yZS9JbnRlcnBvbGF0aW9ucy5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5cclxuXHJcbmZ1bmN0aW9uIFF1YWRyYXRpY0JlemllckN1cnZlMyggdjAsIHYxLCB2MiApIHtcclxuXHJcblx0Q3VydmUuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnR5cGUgPSAnUXVhZHJhdGljQmV6aWVyQ3VydmUzJztcclxuXHJcblx0dGhpcy52MCA9IHYwIHx8IG5ldyBWZWN0b3IzKCk7XHJcblx0dGhpcy52MSA9IHYxIHx8IG5ldyBWZWN0b3IzKCk7XHJcblx0dGhpcy52MiA9IHYyIHx8IG5ldyBWZWN0b3IzKCk7XHJcblxyXG59XHJcblxyXG5RdWFkcmF0aWNCZXppZXJDdXJ2ZTMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XHJcblF1YWRyYXRpY0JlemllckN1cnZlMy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBRdWFkcmF0aWNCZXppZXJDdXJ2ZTM7XHJcblxyXG5RdWFkcmF0aWNCZXppZXJDdXJ2ZTMucHJvdG90eXBlLmlzUXVhZHJhdGljQmV6aWVyQ3VydmUzID0gdHJ1ZTtcclxuXHJcblF1YWRyYXRpY0JlemllckN1cnZlMy5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHR2YXIgcG9pbnQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHR2YXIgdjAgPSB0aGlzLnYwLCB2MSA9IHRoaXMudjEsIHYyID0gdGhpcy52MjtcclxuXHJcblx0cG9pbnQuc2V0KFxyXG5cdFx0UXVhZHJhdGljQmV6aWVyKCB0LCB2MC54LCB2MS54LCB2Mi54ICksXHJcblx0XHRRdWFkcmF0aWNCZXppZXIoIHQsIHYwLnksIHYxLnksIHYyLnkgKSxcclxuXHRcdFF1YWRyYXRpY0JlemllciggdCwgdjAueiwgdjEueiwgdjIueiApXHJcblx0KTtcclxuXHJcblx0cmV0dXJuIHBvaW50O1xyXG5cclxufTtcclxuXHJcblF1YWRyYXRpY0JlemllckN1cnZlMy5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRDdXJ2ZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0dGhpcy52MC5jb3B5KCBzb3VyY2UudjAgKTtcclxuXHR0aGlzLnYxLmNvcHkoIHNvdXJjZS52MSApO1xyXG5cdHRoaXMudjIuY29weSggc291cmNlLnYyICk7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcblF1YWRyYXRpY0JlemllckN1cnZlMy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgZGF0YSA9IEN1cnZlLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xyXG5cclxuXHRkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XHJcblx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xyXG5cdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcclxuXHJcblx0cmV0dXJuIGRhdGE7XHJcblxyXG59O1xyXG5cclxuUXVhZHJhdGljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uICgganNvbiApIHtcclxuXHJcblx0Q3VydmUucHJvdG90eXBlLmZyb21KU09OLmNhbGwoIHRoaXMsIGpzb24gKTtcclxuXHJcblx0dGhpcy52MC5mcm9tQXJyYXkoIGpzb24udjAgKTtcclxuXHR0aGlzLnYxLmZyb21BcnJheSgganNvbi52MSApO1xyXG5cdHRoaXMudjIuZnJvbUFycmF5KCBqc29uLnYyICk7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcblxyXG5leHBvcnQgeyBRdWFkcmF0aWNCZXppZXJDdXJ2ZTMgfTtcclxuIiwiaW1wb3J0IHsgQ3VydmUgfSBmcm9tICcuLi9jb3JlL0N1cnZlLmpzJztcclxuaW1wb3J0IHsgQ2F0bXVsbFJvbSB9IGZyb20gJy4uL2NvcmUvSW50ZXJwb2xhdGlvbnMuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IyLmpzJztcclxuXHJcblxyXG5mdW5jdGlvbiBTcGxpbmVDdXJ2ZSggcG9pbnRzIC8qIGFycmF5IG9mIFZlY3RvcjIgKi8gKSB7XHJcblxyXG5cdEN1cnZlLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ1NwbGluZUN1cnZlJztcclxuXHJcblx0dGhpcy5wb2ludHMgPSBwb2ludHMgfHwgW107XHJcblxyXG59XHJcblxyXG5TcGxpbmVDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKTtcclxuU3BsaW5lQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3BsaW5lQ3VydmU7XHJcblxyXG5TcGxpbmVDdXJ2ZS5wcm90b3R5cGUuaXNTcGxpbmVDdXJ2ZSA9IHRydWU7XHJcblxyXG5TcGxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHR2YXIgcG9pbnQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMigpO1xyXG5cclxuXHR2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XHJcblx0dmFyIHAgPSAoIHBvaW50cy5sZW5ndGggLSAxICkgKiB0O1xyXG5cclxuXHR2YXIgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwICk7XHJcblx0dmFyIHdlaWdodCA9IHAgLSBpbnRQb2ludDtcclxuXHJcblx0dmFyIHAwID0gcG9pbnRzWyBpbnRQb2ludCA9PT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxIF07XHJcblx0dmFyIHAxID0gcG9pbnRzWyBpbnRQb2ludCBdO1xyXG5cdHZhciBwMiA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxIF07XHJcblx0dmFyIHAzID0gcG9pbnRzWyBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAzID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDIgXTtcclxuXHJcblx0cG9pbnQuc2V0KFxyXG5cdFx0Q2F0bXVsbFJvbSggd2VpZ2h0LCBwMC54LCBwMS54LCBwMi54LCBwMy54ICksXHJcblx0XHRDYXRtdWxsUm9tKCB3ZWlnaHQsIHAwLnksIHAxLnksIHAyLnksIHAzLnkgKVxyXG5cdCk7XHJcblxyXG5cdHJldHVybiBwb2ludDtcclxuXHJcbn07XHJcblxyXG5TcGxpbmVDdXJ2ZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRDdXJ2ZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0dGhpcy5wb2ludHMgPSBbXTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBsID0gc291cmNlLnBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdHZhciBwb2ludCA9IHNvdXJjZS5wb2ludHNbIGkgXTtcclxuXHJcblx0XHR0aGlzLnBvaW50cy5wdXNoKCBwb2ludC5jbG9uZSgpICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuU3BsaW5lQ3VydmUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIGRhdGEgPSBDdXJ2ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0ZGF0YS5wb2ludHMgPSBbXTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHR2YXIgcG9pbnQgPSB0aGlzLnBvaW50c1sgaSBdO1xyXG5cdFx0ZGF0YS5wb2ludHMucHVzaCggcG9pbnQudG9BcnJheSgpICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGRhdGE7XHJcblxyXG59O1xyXG5cclxuU3BsaW5lQ3VydmUucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24gKCBqc29uICkge1xyXG5cclxuXHRDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04uY2FsbCggdGhpcywganNvbiApO1xyXG5cclxuXHR0aGlzLnBvaW50cyA9IFtdO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLnBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdHZhciBwb2ludCA9IGpzb24ucG9pbnRzWyBpIF07XHJcblx0XHR0aGlzLnBvaW50cy5wdXNoKCBuZXcgVmVjdG9yMigpLmZyb21BcnJheSggcG9pbnQgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcblxyXG5leHBvcnQgeyBTcGxpbmVDdXJ2ZSB9O1xyXG4iLCJleHBvcnQgeyBBcmNDdXJ2ZSB9IGZyb20gJy4vQXJjQ3VydmUuanMnO1xyXG5leHBvcnQgeyBDYXRtdWxsUm9tQ3VydmUzIH0gZnJvbSAnLi9DYXRtdWxsUm9tQ3VydmUzLmpzJztcclxuZXhwb3J0IHsgQ3ViaWNCZXppZXJDdXJ2ZSB9IGZyb20gJy4vQ3ViaWNCZXppZXJDdXJ2ZS5qcyc7XHJcbmV4cG9ydCB7IEN1YmljQmV6aWVyQ3VydmUzIH0gZnJvbSAnLi9DdWJpY0JlemllckN1cnZlMy5qcyc7XHJcbmV4cG9ydCB7IEVsbGlwc2VDdXJ2ZSB9IGZyb20gJy4vRWxsaXBzZUN1cnZlLmpzJztcclxuZXhwb3J0IHsgTGluZUN1cnZlIH0gZnJvbSAnLi9MaW5lQ3VydmUuanMnO1xyXG5leHBvcnQgeyBMaW5lQ3VydmUzIH0gZnJvbSAnLi9MaW5lQ3VydmUzLmpzJztcclxuZXhwb3J0IHsgUXVhZHJhdGljQmV6aWVyQ3VydmUgfSBmcm9tICcuL1F1YWRyYXRpY0JlemllckN1cnZlLmpzJztcclxuZXhwb3J0IHsgUXVhZHJhdGljQmV6aWVyQ3VydmUzIH0gZnJvbSAnLi9RdWFkcmF0aWNCZXppZXJDdXJ2ZTMuanMnO1xyXG5leHBvcnQgeyBTcGxpbmVDdXJ2ZSB9IGZyb20gJy4vU3BsaW5lQ3VydmUuanMnO1xyXG4iLCJpbXBvcnQgeyBDdXJ2ZSB9IGZyb20gJy4vQ3VydmUuanMnO1xyXG5pbXBvcnQgKiBhcyBDdXJ2ZXMgZnJvbSAnLi4vY3VydmVzL0N1cnZlcy5qcyc7XHJcblxyXG4vKipcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKlxyXG4gKiovXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdEN1cnZlZCBQYXRoIC0gYSBjdXJ2ZSBwYXRoIGlzIHNpbXBseSBhIGFycmF5IG9mIGNvbm5lY3RlZFxyXG4gKiAgY3VydmVzLCBidXQgcmV0YWlucyB0aGUgYXBpIG9mIGEgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuZnVuY3Rpb24gQ3VydmVQYXRoKCkge1xyXG5cclxuXHRDdXJ2ZS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMudHlwZSA9ICdDdXJ2ZVBhdGgnO1xyXG5cclxuXHR0aGlzLmN1cnZlcyA9IFtdO1xyXG5cdHRoaXMuYXV0b0Nsb3NlID0gZmFsc2U7IC8vIEF1dG9tYXRpY2FsbHkgY2xvc2VzIHRoZSBwYXRoXHJcblxyXG59XHJcblxyXG5DdXJ2ZVBhdGgucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICksIHtcclxuXHJcblx0Y29uc3RydWN0b3I6IEN1cnZlUGF0aCxcclxuXHJcblx0YWRkOiBmdW5jdGlvbiAoIGN1cnZlICkge1xyXG5cclxuXHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb3NlUGF0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIEFkZCBhIGxpbmUgY3VydmUgaWYgc3RhcnQgYW5kIGVuZCBvZiBsaW5lcyBhcmUgbm90IGNvbm5lY3RlZFxyXG5cdFx0dmFyIHN0YXJ0UG9pbnQgPSB0aGlzLmN1cnZlc1sgMCBdLmdldFBvaW50KCAwICk7XHJcblx0XHR2YXIgZW5kUG9pbnQgPSB0aGlzLmN1cnZlc1sgdGhpcy5jdXJ2ZXMubGVuZ3RoIC0gMSBdLmdldFBvaW50KCAxICk7XHJcblxyXG5cdFx0aWYgKCAhIHN0YXJ0UG9pbnQuZXF1YWxzKCBlbmRQb2ludCApICkge1xyXG5cclxuXHRcdFx0dGhpcy5jdXJ2ZXMucHVzaCggbmV3IEN1cnZlc1sgJ0xpbmVDdXJ2ZScgXSggZW5kUG9pbnQsIHN0YXJ0UG9pbnQgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Ly8gVG8gZ2V0IGFjY3VyYXRlIHBvaW50IHdpdGggcmVmZXJlbmNlIHRvXHJcblx0Ly8gZW50aXJlIHBhdGggZGlzdGFuY2UgYXQgdGltZSB0LFxyXG5cdC8vIGZvbGxvd2luZyBoYXMgdG8gYmUgZG9uZTpcclxuXHJcblx0Ly8gMS4gTGVuZ3RoIG9mIGVhY2ggc3ViIHBhdGggaGF2ZSB0byBiZSBrbm93blxyXG5cdC8vIDIuIExvY2F0ZSBhbmQgaWRlbnRpZnkgdHlwZSBvZiBjdXJ2ZVxyXG5cdC8vIDMuIEdldCB0IGZvciB0aGUgY3VydmVcclxuXHQvLyA0LiBSZXR1cm4gY3VydmUuZ2V0UG9pbnRBdCh0JylcclxuXHJcblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uICggdCApIHtcclxuXHJcblx0XHR2YXIgZCA9IHQgKiB0aGlzLmdldExlbmd0aCgpO1xyXG5cdFx0dmFyIGN1cnZlTGVuZ3RocyA9IHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XHJcblx0XHR2YXIgaSA9IDA7XHJcblxyXG5cdFx0Ly8gVG8gdGhpbmsgYWJvdXQgYm91bmRhcmllcyBwb2ludHMuXHJcblxyXG5cdFx0d2hpbGUgKCBpIDwgY3VydmVMZW5ndGhzLmxlbmd0aCApIHtcclxuXHJcblx0XHRcdGlmICggY3VydmVMZW5ndGhzWyBpIF0gPj0gZCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGRpZmYgPSBjdXJ2ZUxlbmd0aHNbIGkgXSAtIGQ7XHJcblx0XHRcdFx0dmFyIGN1cnZlID0gdGhpcy5jdXJ2ZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0dmFyIHNlZ21lbnRMZW5ndGggPSBjdXJ2ZS5nZXRMZW5ndGgoKTtcclxuXHRcdFx0XHR2YXIgdSA9IHNlZ21lbnRMZW5ndGggPT09IDAgPyAwIDogMSAtIGRpZmYgLyBzZWdtZW50TGVuZ3RoO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gY3VydmUuZ2V0UG9pbnRBdCggdSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aSArKztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0Ly8gbG9vcCB3aGVyZSBzdW0gIT0gMCwgc3VtID4gZCAsIHN1bSsxIDxkXHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIFdlIGNhbm5vdCB1c2UgdGhlIGRlZmF1bHQgQ09PTC5DdXJ2ZSBnZXRQb2ludCgpIHdpdGggZ2V0TGVuZ3RoKCkgYmVjYXVzZSBpblxyXG5cdC8vIENPT0wuQ3VydmUsIGdldExlbmd0aCgpIGRlcGVuZHMgb24gZ2V0UG9pbnQoKSBidXQgaW4gQ09PTC5DdXJ2ZVBhdGhcclxuXHQvLyBnZXRQb2ludCgpIGRlcGVuZHMgb24gZ2V0TGVuZ3RoXHJcblxyXG5cdGdldExlbmd0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBsZW5zID0gdGhpcy5nZXRDdXJ2ZUxlbmd0aHMoKTtcclxuXHRcdHJldHVybiBsZW5zWyBsZW5zLmxlbmd0aCAtIDEgXTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gY2FjaGVMZW5ndGhzIG11c3QgYmUgcmVjYWxjdWxhdGVkLlxyXG5cdHVwZGF0ZUFyY0xlbmd0aHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHRcdHRoaXMuY2FjaGVMZW5ndGhzID0gbnVsbDtcclxuXHRcdHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIENvbXB1dGUgbGVuZ3RocyBhbmQgY2FjaGUgdGhlbVxyXG5cdC8vIFdlIGNhbm5vdCBvdmVyd3JpdGUgZ2V0TGVuZ3RocygpIGJlY2F1c2UgVXRvVCBtYXBwaW5nIHVzZXMgaXQuXHJcblxyXG5cdGdldEN1cnZlTGVuZ3RoczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIFdlIHVzZSBjYWNoZSB2YWx1ZXMgaWYgY3VydmVzIGFuZCBjYWNoZSBhcnJheSBhcmUgc2FtZSBsZW5ndGhcclxuXHJcblx0XHRpZiAoIHRoaXMuY2FjaGVMZW5ndGhzICYmIHRoaXMuY2FjaGVMZW5ndGhzLmxlbmd0aCA9PT0gdGhpcy5jdXJ2ZXMubGVuZ3RoICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuY2FjaGVMZW5ndGhzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBHZXQgbGVuZ3RoIG9mIHN1Yi1jdXJ2ZVxyXG5cdFx0Ly8gUHVzaCBzdW1zIGludG8gY2FjaGVkIGFycmF5XHJcblxyXG5cdFx0dmFyIGxlbmd0aHMgPSBbXSwgc3VtcyA9IDA7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHN1bXMgKz0gdGhpcy5jdXJ2ZXNbIGkgXS5nZXRMZW5ndGgoKTtcclxuXHRcdFx0bGVuZ3Rocy5wdXNoKCBzdW1zICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY2FjaGVMZW5ndGhzID0gbGVuZ3RocztcclxuXHJcblx0XHRyZXR1cm4gbGVuZ3RocztcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0U3BhY2VkUG9pbnRzOiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcclxuXHJcblx0XHRpZiAoIGRpdmlzaW9ucyA9PT0gdW5kZWZpbmVkICkgZGl2aXNpb25zID0gNDA7XHJcblxyXG5cdFx0dmFyIHBvaW50cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8PSBkaXZpc2lvbnM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRwb2ludHMucHVzaCggdGhpcy5nZXRQb2ludCggaSAvIGRpdmlzaW9ucyApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5hdXRvQ2xvc2UgKSB7XHJcblxyXG5cdFx0XHRwb2ludHMucHVzaCggcG9pbnRzWyAwIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHBvaW50cztcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0UG9pbnRzOiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcclxuXHJcblx0XHRkaXZpc2lvbnMgPSBkaXZpc2lvbnMgfHwgMTI7XHJcblxyXG5cdFx0dmFyIHBvaW50cyA9IFtdLCBsYXN0O1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgY3VydmVzID0gdGhpcy5jdXJ2ZXM7IGkgPCBjdXJ2ZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGN1cnZlID0gY3VydmVzWyBpIF07XHJcblx0XHRcdHZhciByZXNvbHV0aW9uID0gKCBjdXJ2ZSAmJiBjdXJ2ZS5pc0VsbGlwc2VDdXJ2ZSApID8gZGl2aXNpb25zICogMlxyXG5cdFx0XHRcdDogKCBjdXJ2ZSAmJiAoIGN1cnZlLmlzTGluZUN1cnZlIHx8IGN1cnZlLmlzTGluZUN1cnZlMyApICkgPyAxXHJcblx0XHRcdFx0XHQ6ICggY3VydmUgJiYgY3VydmUuaXNTcGxpbmVDdXJ2ZSApID8gZGl2aXNpb25zICogY3VydmUucG9pbnRzLmxlbmd0aFxyXG5cdFx0XHRcdFx0XHQ6IGRpdmlzaW9ucztcclxuXHJcblx0XHRcdHZhciBwdHMgPSBjdXJ2ZS5nZXRQb2ludHMoIHJlc29sdXRpb24gKTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IHB0cy5sZW5ndGg7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBwb2ludCA9IHB0c1sgaiBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGxhc3QgJiYgbGFzdC5lcXVhbHMoIHBvaW50ICkgKSBjb250aW51ZTsgLy8gZW5zdXJlcyBubyBjb25zZWN1dGl2ZSBwb2ludHMgYXJlIGR1cGxpY2F0ZXNcclxuXHJcblx0XHRcdFx0cG9pbnRzLnB1c2goIHBvaW50ICk7XHJcblx0XHRcdFx0bGFzdCA9IHBvaW50O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuYXV0b0Nsb3NlICYmIHBvaW50cy5sZW5ndGggPiAxICYmICEgcG9pbnRzWyBwb2ludHMubGVuZ3RoIC0gMSBdLmVxdWFscyggcG9pbnRzWyAwIF0gKSApIHtcclxuXHJcblx0XHRcdHBvaW50cy5wdXNoKCBwb2ludHNbIDAgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcG9pbnRzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0XHRDdXJ2ZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLmN1cnZlcyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHNvdXJjZS5jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBjdXJ2ZSA9IHNvdXJjZS5jdXJ2ZXNbIGkgXTtcclxuXHJcblx0XHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlLmNsb25lKCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5hdXRvQ2xvc2UgPSBzb3VyY2UuYXV0b0Nsb3NlO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0pTT046IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgZGF0YSA9IEN1cnZlLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdGRhdGEuYXV0b0Nsb3NlID0gdGhpcy5hdXRvQ2xvc2U7XHJcblx0XHRkYXRhLmN1cnZlcyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgY3VydmUgPSB0aGlzLmN1cnZlc1sgaSBdO1xyXG5cdFx0XHRkYXRhLmN1cnZlcy5wdXNoKCBjdXJ2ZS50b0pTT04oKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0fSxcclxuXHJcblx0ZnJvbUpTT046IGZ1bmN0aW9uICgganNvbiApIHtcclxuXHJcblx0XHRDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04uY2FsbCggdGhpcywganNvbiApO1xyXG5cclxuXHRcdHRoaXMuYXV0b0Nsb3NlID0ganNvbi5hdXRvQ2xvc2U7XHJcblx0XHR0aGlzLmN1cnZlcyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24uY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgY3VydmUgPSBqc29uLmN1cnZlc1sgaSBdO1xyXG5cdFx0XHR0aGlzLmN1cnZlcy5wdXNoKCBuZXcgQ3VydmVzWyBjdXJ2ZS50eXBlIF0oKS5mcm9tSlNPTiggY3VydmUgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxufSApO1xyXG5cclxuXHJcbmV4cG9ydCB7IEN1cnZlUGF0aCB9O1xyXG4iLCJpbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IyLmpzJztcclxuaW1wb3J0IHsgQ3VydmVQYXRoIH0gZnJvbSAnLi9DdXJ2ZVBhdGguanMnO1xyXG5pbXBvcnQgeyBFbGxpcHNlQ3VydmUgfSBmcm9tICcuLi9jdXJ2ZXMvRWxsaXBzZUN1cnZlLmpzJztcclxuaW1wb3J0IHsgU3BsaW5lQ3VydmUgfSBmcm9tICcuLi9jdXJ2ZXMvU3BsaW5lQ3VydmUuanMnO1xyXG5pbXBvcnQgeyBDdWJpY0JlemllckN1cnZlIH0gZnJvbSAnLi4vY3VydmVzL0N1YmljQmV6aWVyQ3VydmUuanMnO1xyXG5pbXBvcnQgeyBRdWFkcmF0aWNCZXppZXJDdXJ2ZSB9IGZyb20gJy4uL2N1cnZlcy9RdWFkcmF0aWNCZXppZXJDdXJ2ZS5qcyc7XHJcbmltcG9ydCB7IExpbmVDdXJ2ZSB9IGZyb20gJy4uL2N1cnZlcy9MaW5lQ3VydmUuanMnO1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICogQ3JlYXRlcyBmcmVlIGZvcm0gMmQgcGF0aCB1c2luZyBzZXJpZXMgb2YgcG9pbnRzLCBsaW5lcyBvciBjdXJ2ZXMuXHJcbiAqKi9cclxuXHJcbmZ1bmN0aW9uIFBhdGgoIHBvaW50cyApIHtcclxuXHJcblx0Q3VydmVQYXRoLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ1BhdGgnO1xyXG5cclxuXHR0aGlzLmN1cnJlbnRQb2ludCA9IG5ldyBWZWN0b3IyKCk7XHJcblxyXG5cdGlmICggcG9pbnRzICkge1xyXG5cclxuXHRcdHRoaXMuc2V0RnJvbVBvaW50cyggcG9pbnRzICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcblBhdGgucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggQ3VydmVQYXRoLnByb3RvdHlwZSApLCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBQYXRoLFxyXG5cclxuXHRzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoIHBvaW50cyApIHtcclxuXHJcblx0XHR0aGlzLm1vdmVUbyggcG9pbnRzWyAwIF0ueCwgcG9pbnRzWyAwIF0ueSApO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMSwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dGhpcy5saW5lVG8oIHBvaW50c1sgaSBdLngsIHBvaW50c1sgaSBdLnkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdG1vdmVUbzogZnVuY3Rpb24gKCB4LCB5ICkge1xyXG5cclxuXHRcdHRoaXMuY3VycmVudFBvaW50LnNldCggeCwgeSApOyAvLyBUT0RPIGNvbnNpZGVyIHJlZmVyZW5jaW5nIHZlY3RvcnMgaW5zdGVhZCBvZiBjb3B5aW5nP1xyXG5cclxuXHR9LFxyXG5cclxuXHRsaW5lVG86IGZ1bmN0aW9uICggeCwgeSApIHtcclxuXHJcblx0XHR2YXIgY3VydmUgPSBuZXcgTGluZUN1cnZlKCB0aGlzLmN1cnJlbnRQb2ludC5jbG9uZSgpLCBuZXcgVmVjdG9yMiggeCwgeSApICk7XHJcblx0XHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xyXG5cclxuXHRcdHRoaXMuY3VycmVudFBvaW50LnNldCggeCwgeSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbiAoIGFDUHgsIGFDUHksIGFYLCBhWSApIHtcclxuXHJcblx0XHR2YXIgY3VydmUgPSBuZXcgUXVhZHJhdGljQmV6aWVyQ3VydmUoXHJcblx0XHRcdHRoaXMuY3VycmVudFBvaW50LmNsb25lKCksXHJcblx0XHRcdG5ldyBWZWN0b3IyKCBhQ1B4LCBhQ1B5ICksXHJcblx0XHRcdG5ldyBWZWN0b3IyKCBhWCwgYVkgKVxyXG5cdFx0KTtcclxuXHJcblx0XHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xyXG5cclxuXHRcdHRoaXMuY3VycmVudFBvaW50LnNldCggYVgsIGFZICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGJlemllckN1cnZlVG86IGZ1bmN0aW9uICggYUNQMXgsIGFDUDF5LCBhQ1AyeCwgYUNQMnksIGFYLCBhWSApIHtcclxuXHJcblx0XHR2YXIgY3VydmUgPSBuZXcgQ3ViaWNCZXppZXJDdXJ2ZShcclxuXHRcdFx0dGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKSxcclxuXHRcdFx0bmV3IFZlY3RvcjIoIGFDUDF4LCBhQ1AxeSApLFxyXG5cdFx0XHRuZXcgVmVjdG9yMiggYUNQMngsIGFDUDJ5ICksXHJcblx0XHRcdG5ldyBWZWN0b3IyKCBhWCwgYVkgKVxyXG5cdFx0KTtcclxuXHJcblx0XHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xyXG5cclxuXHRcdHRoaXMuY3VycmVudFBvaW50LnNldCggYVgsIGFZICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNwbGluZVRocnU6IGZ1bmN0aW9uICggcHRzIC8qQXJyYXkgb2YgVmVjdG9yKi8gKSB7XHJcblxyXG5cdFx0dmFyIG5wdHMgPSBbIHRoaXMuY3VycmVudFBvaW50LmNsb25lKCkgXS5jb25jYXQoIHB0cyApO1xyXG5cclxuXHRcdHZhciBjdXJ2ZSA9IG5ldyBTcGxpbmVDdXJ2ZSggbnB0cyApO1xyXG5cdFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcclxuXHJcblx0XHR0aGlzLmN1cnJlbnRQb2ludC5jb3B5KCBwdHNbIHB0cy5sZW5ndGggLSAxIF0gKTtcclxuXHJcblx0fSxcclxuXHJcblx0YXJjOiBmdW5jdGlvbiAoIGFYLCBhWSwgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcclxuXHJcblx0XHR2YXIgeDAgPSB0aGlzLmN1cnJlbnRQb2ludC54O1xyXG5cdFx0dmFyIHkwID0gdGhpcy5jdXJyZW50UG9pbnQueTtcclxuXHJcblx0XHR0aGlzLmFic2FyYyggYVggKyB4MCwgYVkgKyB5MCwgYVJhZGl1cyxcclxuXHRcdFx0YVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhYnNhcmM6IGZ1bmN0aW9uICggYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xyXG5cclxuXHRcdHRoaXMuYWJzZWxsaXBzZSggYVgsIGFZLCBhUmFkaXVzLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVsbGlwc2U6IGZ1bmN0aW9uICggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKSB7XHJcblxyXG5cdFx0dmFyIHgwID0gdGhpcy5jdXJyZW50UG9pbnQueDtcclxuXHRcdHZhciB5MCA9IHRoaXMuY3VycmVudFBvaW50Lnk7XHJcblxyXG5cdFx0dGhpcy5hYnNlbGxpcHNlKCBhWCArIHgwLCBhWSArIHkwLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKTtcclxuXHJcblx0fSxcclxuXHJcblx0YWJzZWxsaXBzZTogZnVuY3Rpb24gKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApIHtcclxuXHJcblx0XHR2YXIgY3VydmUgPSBuZXcgRWxsaXBzZUN1cnZlKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApO1xyXG5cclxuXHRcdGlmICggdGhpcy5jdXJ2ZXMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdC8vIGlmIGEgcHJldmlvdXMgY3VydmUgaXMgcHJlc2VudCwgYXR0ZW1wdCB0byBqb2luXHJcblx0XHRcdHZhciBmaXJzdFBvaW50ID0gY3VydmUuZ2V0UG9pbnQoIDAgKTtcclxuXHJcblx0XHRcdGlmICggISBmaXJzdFBvaW50LmVxdWFscyggdGhpcy5jdXJyZW50UG9pbnQgKSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5saW5lVG8oIGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XHJcblxyXG5cdFx0dmFyIGxhc3RQb2ludCA9IGN1cnZlLmdldFBvaW50KCAxICk7XHJcblx0XHR0aGlzLmN1cnJlbnRQb2ludC5jb3B5KCBsYXN0UG9pbnQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0Q3VydmVQYXRoLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHRcdHRoaXMuY3VycmVudFBvaW50LmNvcHkoIHNvdXJjZS5jdXJyZW50UG9pbnQgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGRhdGEgPSBDdXJ2ZVBhdGgucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0ZGF0YS5jdXJyZW50UG9pbnQgPSB0aGlzLmN1cnJlbnRQb2ludC50b0FycmF5KCk7XHJcblxyXG5cdFx0cmV0dXJuIGRhdGE7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21KU09OOiBmdW5jdGlvbiAoIGpzb24gKSB7XHJcblxyXG5cdFx0Q3VydmVQYXRoLnByb3RvdHlwZS5mcm9tSlNPTi5jYWxsKCB0aGlzLCBqc29uICk7XHJcblxyXG5cdFx0dGhpcy5jdXJyZW50UG9pbnQuZnJvbUFycmF5KCBqc29uLmN1cnJlbnRQb2ludCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcblxyXG5cclxuZXhwb3J0IHsgUGF0aCB9O1xyXG4iLCJpbXBvcnQgeyBQYXRoIH0gZnJvbSAnLi9QYXRoLmpzJztcclxuaW1wb3J0IHsgX01hdGggfSBmcm9tICcuLi8uLi9tYXRoL01hdGguanMnO1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICogRGVmaW5lcyBhIDJkIHNoYXBlIHBsYW5lIHVzaW5nIHBhdGhzLlxyXG4gKiovXHJcblxyXG4vLyBTVEVQIDEgQ3JlYXRlIGEgcGF0aC5cclxuLy8gU1RFUCAyIFR1cm4gcGF0aCBpbnRvIHNoYXBlLlxyXG4vLyBTVEVQIDMgRXh0cnVkZUdlb21ldHJ5IHRha2VzIGluIFNoYXBlL1NoYXBlc1xyXG4vLyBTVEVQIDNhIC0gRXh0cmFjdCBwb2ludHMgZnJvbSBlYWNoIHNoYXBlLCB0dXJuIHRvIHZlcnRpY2VzXHJcbi8vIFNURVAgM2IgLSBUcmlhbmd1bGF0ZSBlYWNoIHNoYXBlLCBhZGQgZmFjZXMuXHJcblxyXG5mdW5jdGlvbiBTaGFwZSggcG9pbnRzICkge1xyXG5cclxuXHRQYXRoLmNhbGwoIHRoaXMsIHBvaW50cyApO1xyXG5cclxuXHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcblx0dGhpcy50eXBlID0gJ1NoYXBlJztcclxuXHJcblx0dGhpcy5ob2xlcyA9IFtdO1xyXG5cclxufVxyXG5cclxuU2hhcGUucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggUGF0aC5wcm90b3R5cGUgKSwge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogU2hhcGUsXHJcblxyXG5cdGdldFBvaW50c0hvbGVzOiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcclxuXHJcblx0XHR2YXIgaG9sZXNQdHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRob2xlc1B0c1sgaSBdID0gdGhpcy5ob2xlc1sgaSBdLmdldFBvaW50cyggZGl2aXNpb25zICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBob2xlc1B0cztcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gZ2V0IHBvaW50cyBvZiBzaGFwZSBhbmQgaG9sZXMgKGtleXBvaW50cyBiYXNlZCBvbiBzZWdtZW50cyBwYXJhbWV0ZXIpXHJcblxyXG5cdGV4dHJhY3RQb2ludHM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xyXG5cclxuXHRcdHJldHVybiB7XHJcblxyXG5cdFx0XHRzaGFwZTogdGhpcy5nZXRQb2ludHMoIGRpdmlzaW9ucyApLFxyXG5cdFx0XHRob2xlczogdGhpcy5nZXRQb2ludHNIb2xlcyggZGl2aXNpb25zIClcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0XHRQYXRoLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHRcdHRoaXMuaG9sZXMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzb3VyY2UuaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBob2xlID0gc291cmNlLmhvbGVzWyBpIF07XHJcblxyXG5cdFx0XHR0aGlzLmhvbGVzLnB1c2goIGhvbGUuY2xvbmUoKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGRhdGEgPSBQYXRoLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdGRhdGEudXVpZCA9IHRoaXMudXVpZDtcclxuXHRcdGRhdGEuaG9sZXMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgaG9sZSA9IHRoaXMuaG9sZXNbIGkgXTtcclxuXHRcdFx0ZGF0YS5ob2xlcy5wdXNoKCBob2xlLnRvSlNPTigpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmcm9tSlNPTjogZnVuY3Rpb24gKCBqc29uICkge1xyXG5cclxuXHRcdFBhdGgucHJvdG90eXBlLmZyb21KU09OLmNhbGwoIHRoaXMsIGpzb24gKTtcclxuXHJcblx0XHR0aGlzLnV1aWQgPSBqc29uLnV1aWQ7XHJcblx0XHR0aGlzLmhvbGVzID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5ob2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGhvbGUgPSBqc29uLmhvbGVzWyBpIF07XHJcblx0XHRcdHRoaXMuaG9sZXMucHVzaCggbmV3IFBhdGgoKS5mcm9tSlNPTiggaG9sZSApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcblxyXG5cclxuZXhwb3J0IHsgU2hhcGUgfTtcclxuIiwiaW1wb3J0IHtWZWN0b3IzfSBmcm9tIFwiLi4vbWF0aC9WZWN0b3IzXCI7XHJcbmltcG9ydCB7VmVjdG9yMn0gZnJvbSBcIi4uL21hdGgvVmVjdG9yMlwiO1xyXG5pbXBvcnQge1NwaGVyZX0gZnJvbSBcIi4uL21hdGgvU3BoZXJlXCI7XHJcbmltcG9ydCB7Qm94M30gZnJvbSBcIi4uL21hdGgvQm94M1wiO1xyXG5pbXBvcnQge0V4dHJ1ZGVCdWZmZXJHZW9tZXRyeX0gZnJvbSBcIi4uL2xvYWRlci9FeHRydWRlR2VvbWV0cnlcIjtcclxuaW1wb3J0IHtTaGFwZX0gZnJvbSBcIi4uL2V4dHJhcy9jb3JlL1NoYXBlXCI7XHJcblxyXG5jbGFzcyBUZXh0R2VvbWV0cnkge1xyXG4gICAgY29uc3RydWN0b3IocGFyYW0pIHtcclxuICAgICAgICBwYXJhbSA9IHBhcmFtIHx8IHt9O1xyXG5cclxuICAgICAgICB0aGlzLnRleHQgPSBwYXJhbS50ZXh0ID09IHVuZGVmaW5lZCA/ICcwJyA6IHBhcmFtLnRleHQ7XHJcblxyXG4gICAgICAgIGlmKHRoaXMudGV4dCA9PSAnMicpe1xyXG5cclxuICAgICAgICAgICAgdmFyIHB0cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAwLCAxMCApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNSwgMTAgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDUsIDQuNSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMSwgNC41ICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAxLCAxICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA1LCAxICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA1LCAwICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAwLCAwICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAwLCA1LjUgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDQsIDUuNSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNCwgOSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMCwgOSApICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBuZXcgU2hhcGUoIHB0cyApO1xyXG4gICAgICAgICAgICB2YXIgZXh0cnVkZVNldHRpbmdzID0ge1xyXG4gICAgICAgICAgICAgICAgZGVwdGg6IDMsXHJcbiAgICAgICAgICAgICAgICBzdGVwczogMSxcclxuICAgICAgICAgICAgICAgIGJldmVsRW5hYmxlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBiZXZlbFRoaWNrbmVzczogMixcclxuICAgICAgICAgICAgICAgIGJldmVsU2l6ZTogNCxcclxuICAgICAgICAgICAgICAgIGJldmVsU2VnbWVudHM6IDFcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGV4dHJ1ZGVHZW9tZXRyeSA9IG5ldyBFeHRydWRlQnVmZmVyR2VvbWV0cnkoIHNoYXBlLCBleHRydWRlU2V0dGluZ3MgKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBpbmRpY2VzID0gW107XHJcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPGV4dHJ1ZGVHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5Lmxlbmd0aC8zOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwYXJhbS52ZXJ0aWNlcyA9IGV4dHJ1ZGVHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xyXG4gICAgICAgICAgICBwYXJhbS5ub3JtYWwgPSBleHRydWRlR2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XHJcbiAgICAgICAgICAgIHBhcmFtLnV2ID0gZXh0cnVkZUdlb21ldHJ5LmF0dHJpYnV0ZXMudXYuYXJyYXk7XHJcbiAgICAgICAgICAgIHBhcmFtLmluZGljZXMgPSBpbmRpY2VzO1xyXG5cclxuXHJcbiAgICAgICAgfWVsc2UgaWYodGhpcy50ZXh0ID09ICcxJyl7XHJcblxyXG4gICAgICAgICAgICB2YXIgcHRzID0gW107XHJcblxyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDQuNSwgMCApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNC41LCAxMCApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNS41LCAxMCApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNS41LCAwICkgKTtcclxuXHJcblxyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBuZXcgU2hhcGUoIHB0cyApO1xyXG4gICAgICAgICAgICB2YXIgZXh0cnVkZVNldHRpbmdzID0ge1xyXG4gICAgICAgICAgICAgICAgZGVwdGg6IDMsXHJcbiAgICAgICAgICAgICAgICBzdGVwczogMSxcclxuICAgICAgICAgICAgICAgIGJldmVsRW5hYmxlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBiZXZlbFRoaWNrbmVzczogMixcclxuICAgICAgICAgICAgICAgIGJldmVsU2l6ZTogNCxcclxuICAgICAgICAgICAgICAgIGJldmVsU2VnbWVudHM6IDFcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGV4dHJ1ZGVHZW9tZXRyeSA9IG5ldyBFeHRydWRlQnVmZmVyR2VvbWV0cnkoIHNoYXBlLCBleHRydWRlU2V0dGluZ3MgKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBpbmRpY2VzID0gW107XHJcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPGV4dHJ1ZGVHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5Lmxlbmd0aC8zOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwYXJhbS52ZXJ0aWNlcyA9IGV4dHJ1ZGVHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xyXG4gICAgICAgICAgICBwYXJhbS5ub3JtYWwgPSBleHRydWRlR2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XHJcbiAgICAgICAgICAgIHBhcmFtLnV2ID0gZXh0cnVkZUdlb21ldHJ5LmF0dHJpYnV0ZXMudXYuYXJyYXk7XHJcbiAgICAgICAgICAgIHBhcmFtLmluZGljZXMgPSBpbmRpY2VzO1xyXG5cclxuXHJcbiAgICAgICAgfWVsc2UgaWYodGhpcy50ZXh0ID09ICczJyl7XHJcblxyXG4gICAgICAgICAgICB2YXIgcHRzID0gW107XHJcblxyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDAsIDAgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDAsIDEgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDQsIDEgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDQsIDQuNSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMCwgNC41ICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAwLCA1LjUgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDQsIDUuNSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNCwgOSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMCwgOSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMCwgMTAgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDUsIDEwICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA1LCAwICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA1LCAwICkgKTtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gbmV3IFNoYXBlKCBwdHMgKTtcclxuICAgICAgICAgICAgdmFyIGV4dHJ1ZGVTZXR0aW5ncyA9IHtcclxuICAgICAgICAgICAgICAgIGRlcHRoOiAzLFxyXG4gICAgICAgICAgICAgICAgc3RlcHM6IDEsXHJcbiAgICAgICAgICAgICAgICBiZXZlbEVuYWJsZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgYmV2ZWxUaGlja25lc3M6IDIsXHJcbiAgICAgICAgICAgICAgICBiZXZlbFNpemU6IDQsXHJcbiAgICAgICAgICAgICAgICBiZXZlbFNlZ21lbnRzOiAxXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBleHRydWRlR2VvbWV0cnkgPSBuZXcgRXh0cnVkZUJ1ZmZlckdlb21ldHJ5KCBzaGFwZSwgZXh0cnVkZVNldHRpbmdzICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgaW5kaWNlcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxleHRydWRlR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheS5sZW5ndGgvMzsgaSsrKXtcclxuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcGFyYW0udmVydGljZXMgPSBleHRydWRlR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcclxuICAgICAgICAgICAgcGFyYW0ubm9ybWFsID0gZXh0cnVkZUdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xyXG4gICAgICAgICAgICBwYXJhbS51diA9IGV4dHJ1ZGVHZW9tZXRyeS5hdHRyaWJ1dGVzLnV2LmFycmF5O1xyXG4gICAgICAgICAgICBwYXJhbS5pbmRpY2VzID0gaW5kaWNlcztcclxuXHJcblxyXG4gICAgICAgIH1lbHNlIGlmKHRoaXMudGV4dCA9PSAnNCcpe1xyXG5cclxuICAgICAgICAgICAgdmFyIHB0cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAwLCAxMCApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMSwgMTAgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDEsIDUuNSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNCwgNS41ICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA0LCAxMCApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNSwgMTAgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDUsIDAgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDQsIDAgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDQsIDQuNSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMCwgNC41ICkgKTtcclxuXHJcblxyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBuZXcgU2hhcGUoIHB0cyApO1xyXG4gICAgICAgICAgICB2YXIgZXh0cnVkZVNldHRpbmdzID0ge1xyXG4gICAgICAgICAgICAgICAgZGVwdGg6IDMsXHJcbiAgICAgICAgICAgICAgICBzdGVwczogMSxcclxuICAgICAgICAgICAgICAgIGJldmVsRW5hYmxlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBiZXZlbFRoaWNrbmVzczogMixcclxuICAgICAgICAgICAgICAgIGJldmVsU2l6ZTogNCxcclxuICAgICAgICAgICAgICAgIGJldmVsU2VnbWVudHM6IDFcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGV4dHJ1ZGVHZW9tZXRyeSA9IG5ldyBFeHRydWRlQnVmZmVyR2VvbWV0cnkoIHNoYXBlLCBleHRydWRlU2V0dGluZ3MgKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBpbmRpY2VzID0gW107XHJcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPGV4dHJ1ZGVHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5Lmxlbmd0aC8zOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwYXJhbS52ZXJ0aWNlcyA9IGV4dHJ1ZGVHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xyXG4gICAgICAgICAgICBwYXJhbS5ub3JtYWwgPSBleHRydWRlR2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XHJcbiAgICAgICAgICAgIHBhcmFtLnV2ID0gZXh0cnVkZUdlb21ldHJ5LmF0dHJpYnV0ZXMudXYuYXJyYXk7XHJcbiAgICAgICAgICAgIHBhcmFtLmluZGljZXMgPSBpbmRpY2VzO1xyXG5cclxuXHJcbiAgICAgICAgfWVsc2UgaWYodGhpcy50ZXh0ID09ICc1Jyl7XHJcblxyXG4gICAgICAgICAgICB2YXIgcHRzID0gW107XHJcblxyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDAsIDAgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDAsIDEgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDQsIDEgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDQsIDQuNSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMCwgNC41ICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAwLCAxMCApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNSwgMTAgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDUsIDkgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDEsIDkgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDEsIDUuNSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNSwgNS41ICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA1LCAwICkgKTtcclxuXHJcblxyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBuZXcgU2hhcGUoIHB0cyApO1xyXG4gICAgICAgICAgICB2YXIgZXh0cnVkZVNldHRpbmdzID0ge1xyXG4gICAgICAgICAgICAgICAgZGVwdGg6IDMsXHJcbiAgICAgICAgICAgICAgICBzdGVwczogMSxcclxuICAgICAgICAgICAgICAgIGJldmVsRW5hYmxlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBiZXZlbFRoaWNrbmVzczogMixcclxuICAgICAgICAgICAgICAgIGJldmVsU2l6ZTogNCxcclxuICAgICAgICAgICAgICAgIGJldmVsU2VnbWVudHM6IDFcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGV4dHJ1ZGVHZW9tZXRyeSA9IG5ldyBFeHRydWRlQnVmZmVyR2VvbWV0cnkoIHNoYXBlLCBleHRydWRlU2V0dGluZ3MgKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBpbmRpY2VzID0gW107XHJcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPGV4dHJ1ZGVHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5Lmxlbmd0aC8zOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwYXJhbS52ZXJ0aWNlcyA9IGV4dHJ1ZGVHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xyXG4gICAgICAgICAgICBwYXJhbS5ub3JtYWwgPSBleHRydWRlR2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XHJcbiAgICAgICAgICAgIHBhcmFtLnV2ID0gZXh0cnVkZUdlb21ldHJ5LmF0dHJpYnV0ZXMudXYuYXJyYXk7XHJcbiAgICAgICAgICAgIHBhcmFtLmluZGljZXMgPSBpbmRpY2VzO1xyXG4gICAgICAgIH1lbHNlIGlmKHRoaXMudGV4dCA9PSAnNicpe1xyXG5cclxuICAgICAgICAgICAgdmFyIHB0cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA1LCAxMCApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMCwgMTAgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDAsIDAgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDUsIDAgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDUsIDUuNSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMSwgNS41ICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAxLCA0LjUgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDQsIDQuNSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNCwgMSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMSwgMSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMSwgOSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNSwgOSApICk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IG5ldyBTaGFwZSggcHRzICk7XHJcbiAgICAgICAgICAgIHZhciBleHRydWRlU2V0dGluZ3MgPSB7XHJcbiAgICAgICAgICAgICAgICBkZXB0aDogMyxcclxuICAgICAgICAgICAgICAgIHN0ZXBzOiAxLFxyXG4gICAgICAgICAgICAgICAgYmV2ZWxFbmFibGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGJldmVsVGhpY2tuZXNzOiAyLFxyXG4gICAgICAgICAgICAgICAgYmV2ZWxTaXplOiA0LFxyXG4gICAgICAgICAgICAgICAgYmV2ZWxTZWdtZW50czogMVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgZXh0cnVkZUdlb21ldHJ5ID0gbmV3IEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeSggc2hhcGUsIGV4dHJ1ZGVTZXR0aW5ncyApO1xyXG5cclxuICAgICAgICAgICAgdmFyIGluZGljZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8ZXh0cnVkZUdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXkubGVuZ3RoLzM7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goaSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHBhcmFtLnZlcnRpY2VzID0gZXh0cnVkZUdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcbiAgICAgICAgICAgIHBhcmFtLm5vcm1hbCA9IGV4dHJ1ZGVHZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcclxuICAgICAgICAgICAgcGFyYW0udXYgPSBleHRydWRlR2VvbWV0cnkuYXR0cmlidXRlcy51di5hcnJheTtcclxuICAgICAgICAgICAgcGFyYW0uaW5kaWNlcyA9IGluZGljZXM7XHJcbiAgICAgICAgfWVsc2UgaWYodGhpcy50ZXh0ID09ICc3Jyl7XHJcblxyXG4gICAgICAgICAgICB2YXIgcHRzID0gW107XHJcblxyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDAsIDEwICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA1LCAxMCApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNSwgMCApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNCwgMCApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNCwgOSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMCwgOSApICk7XHJcblxyXG5cclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gbmV3IFNoYXBlKCBwdHMgKTtcclxuICAgICAgICAgICAgdmFyIGV4dHJ1ZGVTZXR0aW5ncyA9IHtcclxuICAgICAgICAgICAgICAgIGRlcHRoOiAzLFxyXG4gICAgICAgICAgICAgICAgc3RlcHM6IDEsXHJcbiAgICAgICAgICAgICAgICBiZXZlbEVuYWJsZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgYmV2ZWxUaGlja25lc3M6IDIsXHJcbiAgICAgICAgICAgICAgICBiZXZlbFNpemU6IDQsXHJcbiAgICAgICAgICAgICAgICBiZXZlbFNlZ21lbnRzOiAxXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBleHRydWRlR2VvbWV0cnkgPSBuZXcgRXh0cnVkZUJ1ZmZlckdlb21ldHJ5KCBzaGFwZSwgZXh0cnVkZVNldHRpbmdzICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgaW5kaWNlcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxleHRydWRlR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheS5sZW5ndGgvMzsgaSsrKXtcclxuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcGFyYW0udmVydGljZXMgPSBleHRydWRlR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcclxuICAgICAgICAgICAgcGFyYW0ubm9ybWFsID0gZXh0cnVkZUdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xyXG4gICAgICAgICAgICBwYXJhbS51diA9IGV4dHJ1ZGVHZW9tZXRyeS5hdHRyaWJ1dGVzLnV2LmFycmF5O1xyXG4gICAgICAgICAgICBwYXJhbS5pbmRpY2VzID0gaW5kaWNlcztcclxuICAgICAgICB9ZWxzZSBpZih0aGlzLnRleHQgPT0gJzgnKXtcclxuXHJcbiAgICAgICAgICAgIHZhciBwdHMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNSwgMTAgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDAsIDEwICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAwLCAwICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA1LCAwICkgKTtcclxuXHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNSwgOSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNCwgOSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNCwgNS41ICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAxLCA1LjUgKSApO1xyXG5cclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAxLCA0LjUgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDQsIDQuNSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNCwgMSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMSwgMSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMSwgOSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNSwgOSApICk7XHJcblxyXG5cclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gbmV3IFNoYXBlKCBwdHMgKTtcclxuICAgICAgICAgICAgdmFyIGV4dHJ1ZGVTZXR0aW5ncyA9IHtcclxuICAgICAgICAgICAgICAgIGRlcHRoOiAzLFxyXG4gICAgICAgICAgICAgICAgc3RlcHM6IDEsXHJcbiAgICAgICAgICAgICAgICBiZXZlbEVuYWJsZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgYmV2ZWxUaGlja25lc3M6IDIsXHJcbiAgICAgICAgICAgICAgICBiZXZlbFNpemU6IDQsXHJcbiAgICAgICAgICAgICAgICBiZXZlbFNlZ21lbnRzOiAxXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBleHRydWRlR2VvbWV0cnkgPSBuZXcgRXh0cnVkZUJ1ZmZlckdlb21ldHJ5KCBzaGFwZSwgZXh0cnVkZVNldHRpbmdzICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgaW5kaWNlcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxleHRydWRlR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheS5sZW5ndGgvMzsgaSsrKXtcclxuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcGFyYW0udmVydGljZXMgPSBleHRydWRlR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcclxuICAgICAgICAgICAgcGFyYW0ubm9ybWFsID0gZXh0cnVkZUdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xyXG4gICAgICAgICAgICBwYXJhbS51diA9IGV4dHJ1ZGVHZW9tZXRyeS5hdHRyaWJ1dGVzLnV2LmFycmF5O1xyXG4gICAgICAgICAgICBwYXJhbS5pbmRpY2VzID0gaW5kaWNlcztcclxuICAgICAgICB9ZWxzZSBpZih0aGlzLnRleHQgPT0gJzknKXtcclxuXHJcbiAgICAgICAgICAgIHZhciBwdHMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMCwgMTAgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDEsIDEwICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAxLCA1LjUgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDQsIDUuNSApICk7XHJcblxyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDQsIDkgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDEsIDkgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDEsIDEwICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA1LCAxMCApICk7XHJcblxyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDUsIDAgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDQsIDAgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDQsIDQuNSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMCwgNC41ICkgKTtcclxuXHJcblxyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBuZXcgU2hhcGUoIHB0cyApO1xyXG4gICAgICAgICAgICB2YXIgZXh0cnVkZVNldHRpbmdzID0ge1xyXG4gICAgICAgICAgICAgICAgZGVwdGg6IDMsXHJcbiAgICAgICAgICAgICAgICBzdGVwczogMSxcclxuICAgICAgICAgICAgICAgIGJldmVsRW5hYmxlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBiZXZlbFRoaWNrbmVzczogMixcclxuICAgICAgICAgICAgICAgIGJldmVsU2l6ZTogNCxcclxuICAgICAgICAgICAgICAgIGJldmVsU2VnbWVudHM6IDFcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGV4dHJ1ZGVHZW9tZXRyeSA9IG5ldyBFeHRydWRlQnVmZmVyR2VvbWV0cnkoIHNoYXBlLCBleHRydWRlU2V0dGluZ3MgKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBpbmRpY2VzID0gW107XHJcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPGV4dHJ1ZGVHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5Lmxlbmd0aC8zOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwYXJhbS52ZXJ0aWNlcyA9IGV4dHJ1ZGVHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xyXG4gICAgICAgICAgICBwYXJhbS5ub3JtYWwgPSBleHRydWRlR2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XHJcbiAgICAgICAgICAgIHBhcmFtLnV2ID0gZXh0cnVkZUdlb21ldHJ5LmF0dHJpYnV0ZXMudXYuYXJyYXk7XHJcbiAgICAgICAgICAgIHBhcmFtLmluZGljZXMgPSBpbmRpY2VzO1xyXG4gICAgICAgIH1lbHNlIGlmKHRoaXMudGV4dCA9PSAnMCcpe1xyXG5cclxuICAgICAgICAgICAgdmFyIHB0cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA1LCAxMCApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMCwgMTAgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDAsIDAgKSApO1xyXG4gICAgICAgICAgICBwdHMucHVzaCggbmV3IFZlY3RvcjIoIDUsIDAgKSApO1xyXG5cclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA1LCA5ICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA0LCA5ICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCA0LCAxICkgKTtcclxuICAgICAgICAgICAgcHRzLnB1c2goIG5ldyBWZWN0b3IyKCAxLCAxICkgKTtcclxuXHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggMSwgOSApICk7XHJcbiAgICAgICAgICAgIHB0cy5wdXNoKCBuZXcgVmVjdG9yMiggNSwgOSApICk7XHJcblxyXG5cclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gbmV3IFNoYXBlKCBwdHMgKTtcclxuICAgICAgICAgICAgdmFyIGV4dHJ1ZGVTZXR0aW5ncyA9IHtcclxuICAgICAgICAgICAgICAgIGRlcHRoOiAzLFxyXG4gICAgICAgICAgICAgICAgc3RlcHM6IDEsXHJcbiAgICAgICAgICAgICAgICBiZXZlbEVuYWJsZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgYmV2ZWxUaGlja25lc3M6IDIsXHJcbiAgICAgICAgICAgICAgICBiZXZlbFNpemU6IDQsXHJcbiAgICAgICAgICAgICAgICBiZXZlbFNlZ21lbnRzOiAxXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBleHRydWRlR2VvbWV0cnkgPSBuZXcgRXh0cnVkZUJ1ZmZlckdlb21ldHJ5KCBzaGFwZSwgZXh0cnVkZVNldHRpbmdzICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgaW5kaWNlcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxleHRydWRlR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheS5sZW5ndGgvMzsgaSsrKXtcclxuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcGFyYW0udmVydGljZXMgPSBleHRydWRlR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcclxuICAgICAgICAgICAgcGFyYW0ubm9ybWFsID0gZXh0cnVkZUdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xyXG4gICAgICAgICAgICBwYXJhbS51diA9IGV4dHJ1ZGVHZW9tZXRyeS5hdHRyaWJ1dGVzLnV2LmFycmF5O1xyXG4gICAgICAgICAgICBwYXJhbS5pbmRpY2VzID0gaW5kaWNlcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudXYgPSBwYXJhbS51diB8fCBuZXcgRmxvYXQzMkFycmF5KFsgICAvLyBWZXJ0ZXggY29vcmRpbmF0ZXNcclxuXHJcbiAgICAgICAgICAgIDEsMSwgMCwxLCAwLDAsIDEsMCwgIC8vIHYwLXYxLXYyLXYzIGZyb250XHJcbiAgICAgICAgICAgIDAsMSwgMCwwLCAxLDAsIDEsMSwgIC8vIHYwLXYzLXY0LXY1IHJpZ2h0XHJcbiAgICAgICAgICAgIDEsMCwgMSwxLCAwLDEsIDAsMCwgIC8vIHYwLXY1LXY2LXYxIHVwXHJcbiAgICAgICAgICAgIDEsMSwgMCwxLCAwLDAsIDEsMCwgIC8vIHYxLXY2LXY3LXYyIGxlZnRcclxuICAgICAgICAgICAgMCwxLCAxLDEsIDEsMCwgMCwwLCAgLy8gdjctdjQtdjMtdjIgZG93blxyXG4gICAgICAgICAgICAxLDAsIDAsMCwgMCwxLCAxLDEgICAvLyB2NC12Ny12Ni12NSBiYWNrXHJcblxyXG4gICAgICAgIF0pO1xyXG5cclxuICAgICAgICB0aGlzLnZlcnRpY2VzID0gcGFyYW0udmVydGljZXMgfHwgbmV3IEZsb2F0MzJBcnJheShbICAgLy8gVmVydGV4IGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICAgIDAuNSwgMC41LCAwLjUsICAtMC41LCAwLjUsIDAuNSwgIC0wLjUsLTAuNSwgMC41LCAgIDAuNSwtMC41LCAwLjUsICAvLyB2MC12MS12Mi12MyBmcm9udFxyXG4gICAgICAgICAgICAwLjUsIDAuNSwgMC41LCAgIDAuNSwtMC41LCAwLjUsICAgMC41LC0wLjUsLTAuNSwgICAwLjUsIDAuNSwtMC41LCAgLy8gdjAtdjMtdjQtdjUgcmlnaHRcclxuICAgICAgICAgICAgMC41LCAwLjUsIDAuNSwgICAwLjUsIDAuNSwtMC41LCAgLTAuNSwgMC41LC0wLjUsICAtMC41LCAwLjUsIDAuNSwgIC8vIHYwLXY1LXY2LXYxIHVwXHJcbiAgICAgICAgICAgIC0wLjUsIDAuNSwgMC41LCAgLTAuNSwgMC41LC0wLjUsICAtMC41LC0wLjUsLTAuNSwgIC0wLjUsLTAuNSwgMC41LCAgLy8gdjEtdjYtdjctdjIgbGVmdFxyXG4gICAgICAgICAgICAtMC41LC0wLjUsLTAuNSwgICAwLjUsLTAuNSwtMC41LCAgIDAuNSwtMC41LCAwLjUsICAtMC41LC0wLjUsIDAuNSwgIC8vIHY3LXY0LXYzLXYyIGRvd25cclxuICAgICAgICAgICAgMC41LC0wLjUsLTAuNSwgIC0wLjUsLTAuNSwtMC41LCAgLTAuNSwgMC41LC0wLjUsICAgMC41LCAwLjUsLTAuNSAgIC8vIHY0LXY3LXY2LXY1IGJhY2tcclxuICAgICAgICBdKTtcclxuXHJcbiAgICAgICAgdGhpcy5ub3JtYWwgPSBwYXJhbS5ub3JtYWwgfHwgdGhpcy52ZXJ0aWNlcztcclxuXHJcbiAgICAgICAgdGhpcy5pbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KHBhcmFtLmluZGljZXMpO1xyXG5cclxuICAgICAgICB0aGlzLm1vcnBoQXR0cmlidXRlcyA9IHBhcmFtLm1vcnBoQXR0cmlidXRlcztcclxuXHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBTcGhlcmUoKTtcclxuICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gbmV3IEJveDMoKTtcclxuICAgICAgICB0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xyXG5cclxuICAgICAgICAvLyB0aGlzLnVwZGF0ZU5vcm1hbCgpO1xyXG5cclxuICAgICAgICB0aGlzLnVwZGF0YUJ1ZmZlcigpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGFCdWZmZXIoKXtcclxuICAgICAgICB2YXIgYnVmZmVyID0gW107XHJcbiAgICAgICAgdmFyIHV2ID0gdGhpcy51djtcclxuICAgICAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xyXG4gICAgICAgIHZhciBub3JtYWwgPSB0aGlzLm5vcm1hbDtcclxuICAgICAgICBmb3IodmFyIGk9MDsgaTx2ZXJ0aWNlcy5sZW5ndGg7IGkrPTMpe1xyXG4gICAgICAgICAgICBidWZmZXIucHVzaCh2ZXJ0aWNlc1tpKzBdKTtcclxuICAgICAgICAgICAgYnVmZmVyLnB1c2godmVydGljZXNbaSsxXSk7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKHZlcnRpY2VzW2krMl0pO1xyXG5cclxuICAgICAgICAgICAgYnVmZmVyLnB1c2gobm9ybWFsW2krMF0pO1xyXG4gICAgICAgICAgICBidWZmZXIucHVzaChub3JtYWxbaSsxXSk7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKG5vcm1hbFtpKzJdKTtcclxuXHJcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKHV2W2kvMyoyKzBdKTtcclxuICAgICAgICAgICAgYnVmZmVyLnB1c2godXZbaS8zKjIrMV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcik7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlTm9ybWFsKCl7XHJcbiAgICAgICAgdmFyIG5vcm1hbCA9IFtdO1xyXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8dmVydGljZXMubGVuZ3RoOyBpKz0zKjQpe1xyXG4gICAgICAgICAgICB2YXIgbGluZTEgPSBuZXcgVmVjdG9yMygpLnN1YlZlY3RvcnMoXHJcbiAgICAgICAgICAgICAgICBuZXcgVmVjdG9yMyh2ZXJ0aWNlc1tpKzBdLCB2ZXJ0aWNlc1tpKzFdLCB2ZXJ0aWNlc1tpKzJdKSxcclxuICAgICAgICAgICAgICAgIG5ldyBWZWN0b3IzKHZlcnRpY2VzW2krM10sIHZlcnRpY2VzW2krNF0sIHZlcnRpY2VzW2krNV0pXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHZhciBsaW5lMiA9IG5ldyBWZWN0b3IzKCkuc3ViVmVjdG9ycyhcclxuICAgICAgICAgICAgICAgIG5ldyBWZWN0b3IzKHZlcnRpY2VzW2krM10sIHZlcnRpY2VzW2krNF0sIHZlcnRpY2VzW2krNV0pLFxyXG4gICAgICAgICAgICAgICAgbmV3IFZlY3RvcjModmVydGljZXNbaSs2XSwgdmVydGljZXNbaSs3XSwgdmVydGljZXNbaSs4XSksXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHZhciBjdXJfbm9ybWFsID0gbmV3IFZlY3RvcjMoKS5jcm9zc1ZlY3RvcnMoXHJcbiAgICAgICAgICAgICAgICBsaW5lMSxcclxuICAgICAgICAgICAgICAgIGxpbmUyXHJcbiAgICAgICAgICAgICkudG9BcnJheSgpO1xyXG4gICAgICAgICAgICBmb3IodmFyIGo9MCA7ajw0OyBqKyspe1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsLnB1c2goY3VyX25vcm1hbFswXSwgY3VyX25vcm1hbFsxXSwgY3VyX25vcm1hbFsyXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ub3JtYWwgPSBuZXcgRmxvYXQzMkFycmF5KG5vcm1hbCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGNvbXB1dGVCb3VuZGluZ0JveCAoKSB7XHJcbiAgICAgICAgdmFyIHZlcnRpY2VzVjMgPSBbXTtcclxuICAgICAgICBmb3IodmFyIGk9MDsgaTx0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSs9Myl7XHJcbiAgICAgICAgICAgIHZlcnRpY2VzVjMucHVzaChuZXcgVmVjdG9yMyh0aGlzLnZlcnRpY2VzW2ldLCB0aGlzLnZlcnRpY2VzW2krMV0sIHRoaXMudmVydGljZXNbaSsyXSkpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3guc2V0RnJvbVBvaW50cyh2ZXJ0aWNlc1YzKTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRleHRHZW9tZXRyeTtcclxuIiwiaW1wb3J0IFRleHR1cmUgZnJvbSBcIi4vVGV4dHVyZVwiO1xyXG5cclxuY2xhc3MgQ3ViZVRleHR1cmUgZXh0ZW5kcyBUZXh0dXJle1xyXG4gICAgY29uc3RydWN0b3IocGFyYW0pIHtcclxuICAgICAgICBzdXBlcihwYXJhbSk7XHJcblxyXG4gICAgICAgIHBhcmFtID0gcGFyYW0gfHwge307XHJcbiAgICAgICAgdGhpcy51cmxzID0gcGFyYW0udXJscztcclxuXHJcbiAgICAgICAgdGhpcy5pbWFnZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmltZ0xvYWRDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5pbWdSZWFkeSA9IGZhbHNlO1xyXG5cclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHVybHMgPSB0aGlzLnVybHM7XHJcbiAgICAgICAgZm9yKHZhciBpIGluIHVybHMpe1xyXG4gICAgICAgICAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICAgICAgdGhhdC5pbWFnZXMucHVzaChpbWFnZSk7XHJcbiAgICAgICAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuaW1nTG9hZENvdW50ICsrO1xyXG4gICAgICAgICAgICAgICAgaWYodGhhdC5pbWdMb2FkQ291bnQgPT0gNil7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5pbWdSZWFkeSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpbWFnZS5zcmMgPSB1cmxzW2ldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgY2xvbmUoKXtcclxuXHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDdWJlVGV4dHVyZTtcclxuIiwiXHJcbmltcG9ydCBSZW5kZXJlciBmcm9tICcuL2NvcmUvUmVuZGVyZXIuanMnO1xyXG5pbXBvcnQgTWVzaCBmcm9tIFwiLi9jb3JlL01lc2guanNcIjtcclxuaW1wb3J0IENhbWVyYSBmcm9tIFwiLi9jYW1lcmEvQ2FtZXJhLmpzXCI7XHJcbmltcG9ydCBDYW1lcmFDb250cm9sbGVyIGZyb20gXCIuL2NhbWVyYS9DYW1lcmFDb250cm9sbGVyLmpzXCI7XHJcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi9jb3JlL1NjZW5lLmpzXCI7XHJcbmltcG9ydCBNYXRlcmlhbCBmcm9tIFwiLi9tYXRlcmlhbC9NYXRlcmlhbFwiO1xyXG5pbXBvcnQgVGV4dHVyZSBmcm9tIFwiLi9tYXRlcmlhbC9UZXh0dXJlXCI7XHJcbmltcG9ydCBNZXNoQmFzaWNNYXRlcmlhbCBmcm9tIFwiLi9tYXRlcmlhbC9NZXNoQmFzaWNNYXRlcmlhbFwiO1xyXG5pbXBvcnQgTWVzaExhbWJlcnRNYXRlcmlhbCBmcm9tIFwiLi9tYXRlcmlhbC9NZXNoTGFtYmVydE1hdGVyaWFsXCI7XHJcbmltcG9ydCBBbWJpZW50TGlnaHQgZnJvbSBcIi4vbGlnaHQvQW1iaWVudExpZ2h0XCI7XHJcbmltcG9ydCBEaXJlY3Rpb25hbExpZ2h0IGZyb20gXCIuL2xpZ2h0L0RpcmVjdGlvbmFsTGlnaHRcIjtcclxuaW1wb3J0IE1lc2hTdGFuZGFyZE1hdGVyaWFsIGZyb20gXCIuL21hdGVyaWFsL01lc2hTdGFuZGFyZE1hdGVyaWFsXCI7XHJcbmltcG9ydCBHZW9tZXRyeSBmcm9tIFwiLi9jb3JlL0dlb21ldHJ5XCI7XHJcbmltcG9ydCBCb3hHZW9tZXRyeSBmcm9tIFwiLi9jb3JlL0JveEdlb21ldHJ5XCI7XHJcbmltcG9ydCBTcGhlcmVHZW9tZXRyeSBmcm9tIFwiLi9jb3JlL1NwaGVyZUdlb21ldHJ5XCI7XHJcblxyXG4vLyBpbXBvcnQgX0dMVEZMb2FkZXIgZnJvbSBcIi4vY29yZS9HTFRGTG9hZGVyXCI7XHJcbmltcG9ydCBHTFRGTG9hZGVyIGZyb20gXCIuL2NvcmUvR0xURkxvYWRlcjJcIjtcclxuXHJcbmltcG9ydCBPcnRob0NhbWVyYSBmcm9tIFwiLi9jYW1lcmEvT3J0aG9DYW1lcmFcIjtcclxuaW1wb3J0IEFuaW1hdGlvbiBmcm9tIFwiLi9hbmltYXRpb24vQW5pbWF0aW9uXCI7XHJcbmltcG9ydCB7UmF5Y2FzdGVyfSBmcm9tIFwiLi9jb3JlL1JheWNhc3RlclwiO1xyXG5cclxuaW1wb3J0IHtWZWN0b3IyfSBmcm9tIFwiLi9tYXRoL1ZlY3RvcjJcIjtcclxuaW1wb3J0IHtWZWN0b3IzfSBmcm9tIFwiLi9tYXRoL1ZlY3RvcjNcIjtcclxuaW1wb3J0IHtFeHRydWRlR2VvbWV0cnl9IGZyb20gXCIuL2xvYWRlci9FeHRydWRlR2VvbWV0cnlcIjtcclxuaW1wb3J0IHtFeHRydWRlQnVmZmVyR2VvbWV0cnl9IGZyb20gXCIuL2xvYWRlci9FeHRydWRlR2VvbWV0cnlcIjtcclxuaW1wb3J0IHtTaGFwZX0gZnJvbSBcIi4vZXh0cmFzL2NvcmUvU2hhcGUuanNcIjtcclxuaW1wb3J0IFRleHRHZW9tZXRyeSBmcm9tIFwiLi9jb3JlL1RleHRHZW9tZXRyeVwiO1xyXG5pbXBvcnQgQ3ViZVRleHR1cmUgZnJvbSBcIi4vbWF0ZXJpYWwvQ3ViZVRleHR1cmVcIjtcclxuXHJcblxyXG52YXIgQ09PTCA9IHdpbmRvdy5DT09MID0ge307XHJcblxyXG5DT09MLkxJTkVBUiA9IDk3Mjk7XHJcbkNPT0wuTkVBUkVTVCA9IDk3Mjg7XHJcblxyXG5DT09MLkNMQU1QX1RPX0VER0UgPSAzMzA3MTtcclxuQ09PTC5SRVBFQVQgPSAxMDQ5NztcclxuQ09PTC5NSVJST1JFRF9SRVBFQVQgPSAzMzY0ODtcclxuXHJcbkNPT0wuUmVuZGVyZXIgPSBSZW5kZXJlcjtcclxuQ09PTC5NZXNoID0gTWVzaDtcclxuQ09PTC5DYW1lcmEgPSBDYW1lcmE7XHJcbkNPT0wuT3J0aG9DYW1lcmEgPSBPcnRob0NhbWVyYTtcclxuQ09PTC5DYW1lcmFDb250cm9sbGVyID0gQ2FtZXJhQ29udHJvbGxlcjtcclxuQ09PTC5TY2VuZSA9IFNjZW5lO1xyXG5DT09MLk1hdGVyaWFsID0gTWF0ZXJpYWw7XHJcbkNPT0wuTWVzaEJhc2ljTWF0ZXJpYWwgPSBNZXNoQmFzaWNNYXRlcmlhbDtcclxuQ09PTC5NZXNoTGFtYmVydE1hdGVyaWFsID0gTWVzaExhbWJlcnRNYXRlcmlhbDtcclxuQ09PTC5NZXNoU3RhbmRhcmRNYXRlcmlhbCA9IE1lc2hTdGFuZGFyZE1hdGVyaWFsO1xyXG5cclxuQ09PTC5UZXh0dXJlID0gVGV4dHVyZTtcclxuQ09PTC5DdWJlVGV4dHVyZSA9IEN1YmVUZXh0dXJlO1xyXG5cclxuQ09PTC5BbWJpZW50TGlnaHQgPSBBbWJpZW50TGlnaHQ7XHJcbkNPT0wuRGlyZWN0aW9uYWxMaWdodCA9IERpcmVjdGlvbmFsTGlnaHQ7XHJcblxyXG5DT09MLkdlb21ldHJ5ID0gR2VvbWV0cnk7XHJcbkNPT0wuQm94R2VvbWV0cnkgPSBCb3hHZW9tZXRyeTtcclxuQ09PTC5TcGhlcmVHZW9tZXRyeSA9IFNwaGVyZUdlb21ldHJ5O1xyXG5cclxuLy8gQ09PTC5HTFRGTG9hZGVyID0gX0dMVEZMb2FkZXI7XHJcbkNPT0wuR0xURkxvYWRlcjIgPSBHTFRGTG9hZGVyO1xyXG5cclxuQ09PTC5BbmltYXRpb24gPSBBbmltYXRpb247XHJcblxyXG5DT09MLlJheWNhc3RlciA9IFJheWNhc3RlcjtcclxuXHJcbkNPT0wuVmVjdG9yMiA9IFZlY3RvcjI7XHJcbkNPT0wuVmVjdG9yMyA9IFZlY3RvcjM7XHJcblxyXG5DT09MLkV4dHJ1ZGVHZW9tZXRyeSA9IEV4dHJ1ZGVHZW9tZXRyeTtcclxuQ09PTC5FeHRydWRlQnVmZmVyR2VvbWV0cnkgPSBFeHRydWRlQnVmZmVyR2VvbWV0cnk7XHJcbkNPT0wuVGV4dEdlb21ldHJ5ID0gVGV4dEdlb21ldHJ5O1xyXG5DT09MLlNoYXBlID0gU2hhcGU7XHJcblxyXG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcm5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1bkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN3VCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdm1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3bEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM2VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcnFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1M0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWUE7OztBQzdhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDalJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3htQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6eUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdGVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n")}]);